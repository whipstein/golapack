package golapack

import (
	"bytes"
	"testing"
)

func TestDblasLevel1(t *testing.T) {
	var i, icase, incx, incy, j, k, ki, kn, kni, kpar, ksize, len, lenx, leny, mx, my, n, np1, off int
	var sfac float64 = 9.765625e-4
	var izero int = 0
	var ifive int = 5
	var inine int = 9

	{
		// Tests for Drotg and Drotmg
		var d12, sa, sb, sc, ss float64
		var da1 []float64 = []float64{0.3, 0.4, -0.3, -0.4, -0.3, 0.0, 0.0, 1.0}
		var datrue []float64 = []float64{0.5, 0.5, 0.5, -0.5, -0.5, 0.0, 1.0, 1.0}
		var db1 []float64 = []float64{0.4, 0.3, 0.4, 0.3, -0.4, 0.0, 1.0, 0.0}
		var dbtrue []float64 = []float64{0.0, 0.6, 0.0, -0.6, 0.0, 0.0, 1.0, 0.0}
		var dc1 []float64 = []float64{0.6, 0.8, -0.6, 0.8, 0.6, 1.0, 0.0, 1.0}
		var ds1 []float64 = []float64{0.8, 0.6, 0.8, -0.6, 0.8, 0.0, 1.0, 0.0}
		dtemp := make([]float64, 9+25)
		dab := make([]float64, 4*9)
		dtrue := make([]float64, 9*9)

		dab[0+0*4], dab[1+0*4], dab[2+0*4], dab[3+0*4], dab[0+1*4], dab[1+1*4], dab[2+1*4], dab[3+1*4], dab[0+2*4], dab[1+2*4], dab[2+2*4], dab[3+2*4], dab[0+3*4], dab[1+3*4], dab[2+3*4], dab[3+3*4], dab[0+4*4], dab[1+4*4], dab[2+4*4], dab[3+4*4], dab[0+5*4], dab[1+5*4], dab[2+5*4], dab[3+5*4], dab[0+6*4], dab[1+6*4], dab[2+6*4], dab[3+6*4], dab[0+7*4], dab[1+7*4], dab[2+7*4], dab[3+7*4], dab[0+8*4], dab[1+8*4], dab[2+8*4], dab[3+8*4] = 0.1, 0.3, 1.2, 0.2, 0.7, 0.2, 0.6, 4.2, 0.0, 0.0, 0.0, 0.0, 4.0, -1.0, 2.0, 4.0, 6e-10, 2e-2, 1e5, 10.0, 4e10, 2e-2, 1e-5, 10.0, 2e-10, 4e-2, 1e5, 10.0, 2e10, 4e-2, 1e-5, 10.0, 4.0, -2.0, 8.0, 4.0
		//    TRUE RESULTS FOR MODIFIED GIVENS
		dtrue[0+0*9], dtrue[1+0*9], dtrue[2+0*9], dtrue[3+0*9], dtrue[4+0*9], dtrue[5+0*9], dtrue[6+0*9], dtrue[7+0*9], dtrue[8+0*9], dtrue[0+1*9], dtrue[1+1*9], dtrue[2+1*9], dtrue[3+1*9], dtrue[4+1*9], dtrue[5+1*9], dtrue[6+1*9], dtrue[7+1*9], dtrue[8+1*9], dtrue[0+2*9], dtrue[1+2*9], dtrue[2+2*9], dtrue[3+2*9], dtrue[4+2*9], dtrue[5+2*9], dtrue[6+2*9], dtrue[7+2*9], dtrue[8+2*9], dtrue[0+3*9], dtrue[1+3*9], dtrue[2+3*9], dtrue[3+3*9], dtrue[4+3*9], dtrue[5+3*9], dtrue[6+3*9], dtrue[7+3*9], dtrue[8+3*9], dtrue[0+4*9], dtrue[1+4*9], dtrue[2+4*9], dtrue[3+4*9], dtrue[4+4*9], dtrue[5+4*9], dtrue[6+4*9], dtrue[7+4*9], dtrue[8+4*9], dtrue[0+5*9], dtrue[1+5*9], dtrue[2+5*9], dtrue[3+5*9], dtrue[4+5*9], dtrue[5+5*9], dtrue[6+5*9], dtrue[7+5*9], dtrue[8+5*9], dtrue[0+6*9], dtrue[1+6*9], dtrue[2+6*9], dtrue[3+6*9], dtrue[4+6*9], dtrue[5+6*9], dtrue[6+6*9], dtrue[7+6*9], dtrue[8+6*9], dtrue[0+7*9], dtrue[1+7*9], dtrue[2+7*9], dtrue[3+7*9], dtrue[4+7*9], dtrue[5+7*9], dtrue[6+7*9], dtrue[7+7*9], dtrue[8+7*9], dtrue[0+8*9], dtrue[1+8*9], dtrue[2+8*9], dtrue[3+8*9], dtrue[4+8*9], dtrue[5+8*9], dtrue[6+8*9], dtrue[7+8*9], dtrue[8+8*9] = 0., 0., 1.3, .2, 0., 0., 0., .5, 0., 0., 0., 4.5, 4.2, 1., .5, 0., 0., 0., 0., 0., 0., 0., -2., 0., 0., 0., 0., 0., 0., 0., 4., -1., 0., 0., 0., 0., 0., 15.e-3, 0., 10., -1., 0., -1.e-4, 0., 1., 0., 0., 6144.e-5, 10., -1., 4096., -1.e6, 0., 1., 0., 0., 15., 10., -1., 5.e-5, 0., 1., 0., 0., 0., 15., 10., -1.0, 5.e5, -4096., 1., 4096.e-6, 0., 0., 7., 4., 0., 0., -.5, -.25, 0.
		//                   4096 = 2 ** 12
		d12 = 4096.
		dtrue[0+0*9] = 12. / 130.
		dtrue[1+0*9] = 36. / 130.
		dtrue[6+0*9] = -1. / 6.
		dtrue[0+1*9] = 14. / 75.
		dtrue[1+1*9] = 49. / 75.
		dtrue[8+1*9] = 1. / 7.
		dtrue[0+4*9] = 45.e-11 * (d12 * d12)
		dtrue[2+4*9] = 4.e5 / (3. * d12)
		dtrue[5+4*9] = 1. / d12
		dtrue[7+4*9] = 1.e4 / (3. * d12)
		dtrue[0+5*9] = 4.e10 / (1.5 * d12 * d12)
		dtrue[1+5*9] = 2.e-2 / 1.5
		dtrue[7+5*9] = 5.e-7 * d12
		dtrue[0+6*9] = 4. / 150.
		dtrue[1+6*9] = (2.e-10 / 1.5) * (d12 * d12)
		dtrue[6+6*9] = -dtrue[5+4*9]
		dtrue[8+6*9] = 1.e4 / d12
		dtrue[0+7*9] = dtrue[0+6*9]
		dtrue[1+7*9] = 2.e10 / (1.5 * d12 * d12)
		dtrue[0+8*9] = 32. / 7.
		dtrue[1+8*9] = -16. / 7.
		//
		//     Compute true values which cannot be prestored
		//     in decimal notation
		//
		dbtrue[0] = 1.0 / 0.6
		dbtrue[2] = -1.0 / 0.6
		dbtrue[4] = 1.0 / 0.6

		n = 0
		for _, icase = range []int{3, 11} {
			for off = 0; off <= 25; off += 5 {
				for k = 1; k <= 8; k++ {
					if icase == 3 {
						if off != 0 {
							continue
						}
						if k > 8 {
							continue
						}
						n++
						sa = da1[k-1]
						sb = db1[k-1]
						Drotg(&sa, &sb, &sc, &ss)
						dcompare1(&sa, &(datrue[k-1]), &datrue, func() *int { y := k - 1; return &y }(), &sfac, t, []byte("Drotg"))
						dcompare1(&sb, &(dbtrue[k-1]), &dbtrue, func() *int { y := k - 1; return &y }(), &sfac, t, []byte("Drotg"))
						dcompare1(&sc, &(dc1[k-1]), &dc1, func() *int { y := k - 1; return &y }(), &sfac, t, []byte("Drotg"))
						dcompare1(&ss, &(ds1[k-1]), &ds1, func() *int { y := k - 1; return &y }(), &sfac, t, []byte("Drotg"))
					} else if icase == 11 {
						n++
						for i = 1; i <= 4; i++ {
							dtemp[i-1+off] = dab[i-1+(k-1)*4]
							dtemp[i+4-1+off] = 0.0
						}
						dtemp[8+off] = 0.0
						Drotmg(&(dtemp[0+off]), &(dtemp[1+off]), &(dtemp[2+off]), &(dtemp[3+off]), &dtemp, func() *int { y := 4 + off; return &y }())
						dcompare(&inine, &dtemp, &off, &dtrue, func() *int { y := 0 + (k-1)*9; return &y }(), &dtrue, func() *int { y := 0 + (k-1)*9; return &y }(), &sfac, t, []byte("Drotmg"))
					}
				}
			}
		}
	}
	{
		// Tests for Dnrm2, Dasum, Dscal and Idamax
		var dtrue1 []float64 = []float64{0.0, 0.3, 0.5, 0.7, 0.6}
		var dtrue3 []float64 = []float64{0.0, 0.3, 0.7, 1.1, 1.0}
		var sa []float64 = []float64{0.3, -1.0, 0.0, 1.0, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3}
		stemp := make([]float64, 1)
		strue := make([]float64, 8+25)
		sx := make([]float64, 8*25)
		var itrue2 []int = []int{0, 1, 2, 2, 3}
		dtrue5 := make([]float64, 8*5*2)
		dv := make([]float64, 8*5*2)

		dv[0+(0+(0)*5)*8], dv[1+(0+(0)*5)*8], dv[2+(0+(0)*5)*8], dv[3+(0+(0)*5)*8], dv[4+(0+(0)*5)*8], dv[5+(0+(0)*5)*8], dv[6+(0+(0)*5)*8], dv[7+(0+(0)*5)*8], dv[0+(1+(0)*5)*8], dv[1+(1+(0)*5)*8], dv[2+(1+(0)*5)*8], dv[3+(1+(0)*5)*8], dv[4+(1+(0)*5)*8], dv[5+(1+(0)*5)*8], dv[6+(1+(0)*5)*8], dv[7+(1+(0)*5)*8], dv[0+(2+(0)*5)*8], dv[1+(2+(0)*5)*8], dv[2+(2+(0)*5)*8], dv[3+(2+(0)*5)*8], dv[4+(2+(0)*5)*8], dv[5+(2+(0)*5)*8], dv[6+(2+(0)*5)*8], dv[7+(2+(0)*5)*8], dv[0+(3+(0)*5)*8], dv[1+(3+(0)*5)*8], dv[2+(3+(0)*5)*8], dv[3+(3+(0)*5)*8], dv[4+(3+(0)*5)*8], dv[5+(3+(0)*5)*8], dv[6+(3+(0)*5)*8], dv[7+(3+(0)*5)*8], dv[0+(4+(0)*5)*8], dv[1+(4+(0)*5)*8], dv[2+(4+(0)*5)*8], dv[3+(4+(0)*5)*8], dv[4+(4+(0)*5)*8], dv[5+(4+(0)*5)*8], dv[6+(4+(0)*5)*8], dv[7+(4+(0)*5)*8], dv[0+(0+(1)*5)*8], dv[1+(0+(1)*5)*8], dv[2+(0+(1)*5)*8], dv[3+(0+(1)*5)*8], dv[4+(0+(1)*5)*8], dv[5+(0+(1)*5)*8], dv[6+(0+(1)*5)*8], dv[7+(0+(1)*5)*8], dv[0+(1+(1)*5)*8], dv[1+(1+(1)*5)*8], dv[2+(1+(1)*5)*8], dv[3+(1+(1)*5)*8], dv[4+(1+(1)*5)*8], dv[5+(1+(1)*5)*8], dv[6+(1+(1)*5)*8], dv[7+(1+(1)*5)*8], dv[0+(2+(1)*5)*8], dv[1+(2+(1)*5)*8], dv[2+(2+(1)*5)*8], dv[3+(2+(1)*5)*8], dv[4+(2+(1)*5)*8], dv[5+(2+(1)*5)*8], dv[6+(2+(1)*5)*8], dv[7+(2+(1)*5)*8], dv[0+(3+(1)*5)*8], dv[1+(3+(1)*5)*8], dv[2+(3+(1)*5)*8], dv[3+(3+(1)*5)*8], dv[4+(3+(1)*5)*8], dv[5+(3+(1)*5)*8], dv[6+(3+(1)*5)*8], dv[7+(3+(1)*5)*8], dv[0+(4+(1)*5)*8], dv[1+(4+(1)*5)*8], dv[2+(4+(1)*5)*8], dv[3+(4+(1)*5)*8], dv[4+(4+(1)*5)*8], dv[5+(4+(1)*5)*8], dv[6+(4+(1)*5)*8], dv[7+(4+(1)*5)*8] = 0.1, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 0.3, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 0.3, -0.4, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 0.2, -0.6, 0.3, 5.0, 5.0, 5.0, 5.0, 5.0, 0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0, 0.1, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 0.3, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 0.3, 2.0, -0.4, 2.0, 2.0, 2.0, 2.0, 2.0, 0.2, 3.0, -0.6, 5.0, 0.3, 2.0, 2.0, 2.0, 0.1, 4.0, -0.3, 6.0, -0.5, 7.0, -0.1, 3.0
		dtrue5[0+(0+(0)*5)*8], dtrue5[1+(0+(0)*5)*8], dtrue5[2+(0+(0)*5)*8], dtrue5[3+(0+(0)*5)*8], dtrue5[4+(0+(0)*5)*8], dtrue5[5+(0+(0)*5)*8], dtrue5[6+(0+(0)*5)*8], dtrue5[7+(0+(0)*5)*8], dtrue5[0+(1+(0)*5)*8], dtrue5[1+(1+(0)*5)*8], dtrue5[2+(1+(0)*5)*8], dtrue5[3+(1+(0)*5)*8], dtrue5[4+(1+(0)*5)*8], dtrue5[5+(1+(0)*5)*8], dtrue5[6+(1+(0)*5)*8], dtrue5[7+(1+(0)*5)*8], dtrue5[0+(2+(0)*5)*8], dtrue5[1+(2+(0)*5)*8], dtrue5[2+(2+(0)*5)*8], dtrue5[3+(2+(0)*5)*8], dtrue5[4+(2+(0)*5)*8], dtrue5[5+(2+(0)*5)*8], dtrue5[6+(2+(0)*5)*8], dtrue5[7+(2+(0)*5)*8], dtrue5[0+(3+(0)*5)*8], dtrue5[1+(3+(0)*5)*8], dtrue5[2+(3+(0)*5)*8], dtrue5[3+(3+(0)*5)*8], dtrue5[4+(3+(0)*5)*8], dtrue5[5+(3+(0)*5)*8], dtrue5[6+(3+(0)*5)*8], dtrue5[7+(3+(0)*5)*8], dtrue5[0+(4+(0)*5)*8], dtrue5[1+(4+(0)*5)*8], dtrue5[2+(4+(0)*5)*8], dtrue5[3+(4+(0)*5)*8], dtrue5[4+(4+(0)*5)*8], dtrue5[5+(4+(0)*5)*8], dtrue5[6+(4+(0)*5)*8], dtrue5[7+(4+(0)*5)*8], dtrue5[0+(0+(1)*5)*8], dtrue5[1+(0+(1)*5)*8], dtrue5[2+(0+(1)*5)*8], dtrue5[3+(0+(1)*5)*8], dtrue5[4+(0+(1)*5)*8], dtrue5[5+(0+(1)*5)*8], dtrue5[6+(0+(1)*5)*8], dtrue5[7+(0+(1)*5)*8], dtrue5[0+(1+(1)*5)*8], dtrue5[1+(1+(1)*5)*8], dtrue5[2+(1+(1)*5)*8], dtrue5[3+(1+(1)*5)*8], dtrue5[4+(1+(1)*5)*8], dtrue5[5+(1+(1)*5)*8], dtrue5[6+(1+(1)*5)*8], dtrue5[7+(1+(1)*5)*8], dtrue5[0+(2+(1)*5)*8], dtrue5[1+(2+(1)*5)*8], dtrue5[2+(2+(1)*5)*8], dtrue5[3+(2+(1)*5)*8], dtrue5[4+(2+(1)*5)*8], dtrue5[5+(2+(1)*5)*8], dtrue5[6+(2+(1)*5)*8], dtrue5[7+(2+(1)*5)*8], dtrue5[0+(3+(1)*5)*8], dtrue5[1+(3+(1)*5)*8], dtrue5[2+(3+(1)*5)*8], dtrue5[3+(3+(1)*5)*8], dtrue5[4+(3+(1)*5)*8], dtrue5[5+(3+(1)*5)*8], dtrue5[6+(3+(1)*5)*8], dtrue5[7+(3+(1)*5)*8], dtrue5[0+(4+(1)*5)*8], dtrue5[1+(4+(1)*5)*8], dtrue5[2+(4+(1)*5)*8], dtrue5[3+(4+(1)*5)*8], dtrue5[4+(4+(1)*5)*8], dtrue5[5+(4+(1)*5)*8], dtrue5[6+(4+(1)*5)*8], dtrue5[7+(4+(1)*5)*8] = 0.10, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, -0.3, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 0.0, 0.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 0.20, -0.60, 0.30, 5.0, 5.0, 5.0, 5.0, 5.0, 0.03, -0.09, 0.15, -0.03, 6.0, 6.0, 6.0, 6.0, 0.10, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 0.09, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 0.09, 2.0, -0.12, 2.0, 2.0, 2.0, 2.0, 2.0, 0.06, 3.0, -0.18, 5.0, 0.09, 2.0, 2.0, 2.0, 0.03, 4.0, -0.09, 6.0, -0.15, 7.0, -0.03, 3.0

		n = 0
		for _, icase = range []int{7, 8, 9, 10} {
			for incx = 1; incx <= 2; incx++ {
				for np1 = 1; np1 <= 5; np1++ {
					n++
					len = 2 * maxint(np1-1, 1)
					for i = 1; i <= len; i++ {
						sx[i-1+off] = dv[i-1+(np1-1+(incx-1)*5)*8]
					}

					if icase == 7 {
						stemp[0] = dtrue1[np1-1]
						dcompare1(func() *float64 { y := Dnrm2(func() *int { y := np1 - 1; return &y }(), &sx, &off, &incx); return &y }(), &(stemp[0]), &stemp, &izero, &sfac, t, []byte("Dnrm2"))
					} else if icase == 8 {
						stemp[0] = dtrue3[np1-1]
						dcompare1(func() *float64 { y := Dasum(func() *int { y := np1 - 1; return &y }(), &sx, &off, &incx); return &y }(), &(stemp[0]), &stemp, &izero, &sfac, t, []byte("Dasum"))
					} else if icase == 9 {
						Dscal(func() *int { y := np1 - 1; return &y }(), &(sa[(incx-1)*5+np1-1]), &sx, &off, &incx)
						for i = 1; i <= len; i++ {
							strue[i-1] = dtrue5[i-1+(np1-1+(incx-1)*5)*8]
						}
						dcompare(&len, &sx, &off, &strue, &izero, &strue, &izero, &sfac, t, []byte("Dscal"))
					} else if icase == 10 {
						icompare1(func() *int { y := Idamax(func() *int { y := np1 - 1; return &y }(), &sx, &off, &incx); return &y }(), &(itrue2[np1-1]), t, []byte("Idamax"))
					}
				}
			}
		}
	}
	{
		// Tests for Ddot, Daxpy, Dcopy, Dswap, Drotm and Ddsdot
		var sa float64 = 0.3
		dtemp := make([]float64, 5)
		var dx1 []float64 = []float64{0.6, 0.1, -0.5, 0.8, 0.9, -0.3, -0.4}
		var dy1 []float64 = []float64{0.5, -0.9, 0.3, 0.7, -0.6, 0.2, 0.8}
		ssize := make([]float64, 7)
		var ssize1 []float64 = []float64{0.0, 0.3, 1.6, 3.2}
		var ssize1f []float32 = []float32{0.0, 0.3, 1.6, 3.2}
		stx := make([]float64, 7)
		sty := make([]float64, 7)
		sx := make([]float64, 7*25)
		sxf := make([]float32, 7*25)
		sy := make([]float64, 7*25)
		syf := make([]float32, 7*25)
		var incxs []int = []int{1, 2, -2, -1}
		var incys []int = []int{1, -2, 1, -2}
		var ns []int = []int{0, 1, 2, 4}
		dpar := make([]float64, 5*4)
		dt7 := make([]float64, 4*4)
		ssize2 := make([]float64, 14*2)
		dt10x := make([]float64, 7*4*4)
		dt10y := make([]float64, 7*4*4)
		st7 := make([]float32, 4*4)
		st7b := make([]float64, 4*4)
		dt8 := make([]float64, 7*4*4)
		lens := make([]int, 4*2)
		dt19x := make([]float64, 7*4*16)
		dt19y := make([]float64, 7*4*16)

		lens[0+(0)*4], lens[1+(0)*4], lens[2+(0)*4], lens[3+(0)*4], lens[0+(1)*4], lens[1+(1)*4], lens[2+(1)*4], lens[3+(1)*4] = 1, 1, 2, 4, 1, 1, 3, 7
		dt7[0+(0)*4], dt7[1+(0)*4], dt7[2+(0)*4], dt7[3+(0)*4], dt7[0+(1)*4], dt7[1+(1)*4], dt7[2+(1)*4], dt7[3+(1)*4], dt7[0+(2)*4], dt7[1+(2)*4], dt7[2+(2)*4], dt7[3+(2)*4], dt7[0+(3)*4], dt7[1+(3)*4], dt7[2+(3)*4], dt7[3+(3)*4] = 0.0, 0.30, 0.21, 0.62, 0.0, 0.30, -0.07, 0.85, 0.0, 0.30, -0.79, -0.74, 0.0, 0.30, 0.33, 1.27
		st7[0+(0)*4], st7[1+(0)*4], st7[2+(0)*4], st7[3+(0)*4], st7[0+(1)*4], st7[1+(1)*4], st7[2+(1)*4], st7[3+(1)*4], st7[0+(2)*4], st7[1+(2)*4], st7[2+(2)*4], st7[3+(2)*4], st7[0+(3)*4], st7[1+(3)*4], st7[2+(3)*4], st7[3+(3)*4] = 0.0, 0.30, 0.21, 0.62, 0.0, 0.30, -0.07, 0.85, 0.0, 0.30, -0.79, -0.74, 0.0, 0.30, 0.33, 1.27
		st7b[0+(0)*4], st7b[1+(0)*4], st7b[2+(0)*4], st7b[3+(0)*4], st7b[0+(1)*4], st7b[1+(1)*4], st7b[2+(1)*4], st7b[3+(1)*4], st7b[0+(2)*4], st7b[1+(2)*4], st7b[2+(2)*4], st7b[3+(2)*4], st7b[0+(3)*4], st7b[1+(3)*4], st7b[2+(3)*4], st7b[3+(3)*4] = .1, .4, .31, .72, .1, .4, .03, .95, .1, .4, -.69, -.64, .1, .4, .43, 1.37
		dt8[0+(0+(0)*4)*7], dt8[1+(0+(0)*4)*7], dt8[2+(0+(0)*4)*7], dt8[3+(0+(0)*4)*7], dt8[4+(0+(0)*4)*7], dt8[5+(0+(0)*4)*7], dt8[6+(0+(0)*4)*7], dt8[0+(1+(0)*4)*7], dt8[1+(1+(0)*4)*7], dt8[2+(1+(0)*4)*7], dt8[3+(1+(0)*4)*7], dt8[4+(1+(0)*4)*7], dt8[5+(1+(0)*4)*7], dt8[6+(1+(0)*4)*7], dt8[0+(2+(0)*4)*7], dt8[1+(2+(0)*4)*7], dt8[2+(2+(0)*4)*7], dt8[3+(2+(0)*4)*7], dt8[4+(2+(0)*4)*7], dt8[5+(2+(0)*4)*7], dt8[6+(2+(0)*4)*7], dt8[0+(3+(0)*4)*7], dt8[1+(3+(0)*4)*7], dt8[2+(3+(0)*4)*7], dt8[3+(3+(0)*4)*7], dt8[4+(3+(0)*4)*7], dt8[5+(3+(0)*4)*7], dt8[6+(3+(0)*4)*7], dt8[0+(0+(1)*4)*7], dt8[1+(0+(1)*4)*7], dt8[2+(0+(1)*4)*7], dt8[3+(0+(1)*4)*7], dt8[4+(0+(1)*4)*7], dt8[5+(0+(1)*4)*7], dt8[6+(0+(1)*4)*7], dt8[0+(1+(1)*4)*7], dt8[1+(1+(1)*4)*7], dt8[2+(1+(1)*4)*7], dt8[3+(1+(1)*4)*7], dt8[4+(1+(1)*4)*7], dt8[5+(1+(1)*4)*7], dt8[6+(1+(1)*4)*7], dt8[0+(2+(1)*4)*7], dt8[1+(2+(1)*4)*7], dt8[2+(2+(1)*4)*7], dt8[3+(2+(1)*4)*7], dt8[4+(2+(1)*4)*7], dt8[5+(2+(1)*4)*7], dt8[6+(2+(1)*4)*7], dt8[0+(3+(1)*4)*7], dt8[1+(3+(1)*4)*7], dt8[2+(3+(1)*4)*7], dt8[3+(3+(1)*4)*7], dt8[4+(3+(1)*4)*7], dt8[5+(3+(1)*4)*7], dt8[6+(3+(1)*4)*7], dt8[0+(0+(2)*4)*7], dt8[1+(0+(2)*4)*7], dt8[2+(0+(2)*4)*7], dt8[3+(0+(2)*4)*7], dt8[4+(0+(2)*4)*7], dt8[5+(0+(2)*4)*7], dt8[6+(0+(2)*4)*7], dt8[0+(1+(2)*4)*7], dt8[1+(1+(2)*4)*7], dt8[2+(1+(2)*4)*7], dt8[3+(1+(2)*4)*7], dt8[4+(1+(2)*4)*7], dt8[5+(1+(2)*4)*7], dt8[6+(1+(2)*4)*7], dt8[0+(2+(2)*4)*7], dt8[1+(2+(2)*4)*7], dt8[2+(2+(2)*4)*7], dt8[3+(2+(2)*4)*7], dt8[4+(2+(2)*4)*7], dt8[5+(2+(2)*4)*7], dt8[6+(2+(2)*4)*7], dt8[0+(3+(2)*4)*7], dt8[1+(3+(2)*4)*7], dt8[2+(3+(2)*4)*7], dt8[3+(3+(2)*4)*7], dt8[4+(3+(2)*4)*7], dt8[5+(3+(2)*4)*7], dt8[6+(3+(2)*4)*7], dt8[0+(0+(3)*4)*7], dt8[1+(0+(3)*4)*7], dt8[2+(0+(3)*4)*7], dt8[3+(0+(3)*4)*7], dt8[4+(0+(3)*4)*7], dt8[5+(0+(3)*4)*7], dt8[6+(0+(3)*4)*7], dt8[0+(1+(3)*4)*7], dt8[1+(1+(3)*4)*7], dt8[2+(1+(3)*4)*7], dt8[3+(1+(3)*4)*7], dt8[4+(1+(3)*4)*7], dt8[5+(1+(3)*4)*7], dt8[6+(1+(3)*4)*7], dt8[0+(2+(3)*4)*7], dt8[1+(2+(3)*4)*7], dt8[2+(2+(3)*4)*7], dt8[3+(2+(3)*4)*7], dt8[4+(2+(3)*4)*7], dt8[5+(2+(3)*4)*7], dt8[6+(2+(3)*4)*7], dt8[0+(3+(3)*4)*7], dt8[1+(3+(3)*4)*7], dt8[2+(3+(3)*4)*7], dt8[3+(3+(3)*4)*7], dt8[4+(3+(3)*4)*7], dt8[5+(3+(3)*4)*7], dt8[6+(3+(3)*4)*7] = 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.68, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.68, -0.87, 0.0, 0.0, 0.0, 0.0, 0.0, 0.68, -0.87, 0.15, 0.94, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.68, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.35, -0.9, 0.48, 0.0, 0.0, 0.0, 0.0, 0.38, -0.9, 0.57, 0.7, -0.75, 0.2, 0.98, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.68, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.35, -0.72, 0.0, 0.0, 0.0, 0.0, 0.0, 0.38, -0.63, 0.15, 0.88, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.68, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.68, -0.9, 0.33, 0.0, 0.0, 0.0, 0.0, 0.68, -0.9, 0.33, 0.7, -0.75, 0.2, 1.04
		dt10x[0+(0+(0)*4)*7], dt10x[1+(0+(0)*4)*7], dt10x[2+(0+(0)*4)*7], dt10x[3+(0+(0)*4)*7], dt10x[4+(0+(0)*4)*7], dt10x[5+(0+(0)*4)*7], dt10x[6+(0+(0)*4)*7], dt10x[0+(1+(0)*4)*7], dt10x[1+(1+(0)*4)*7], dt10x[2+(1+(0)*4)*7], dt10x[3+(1+(0)*4)*7], dt10x[4+(1+(0)*4)*7], dt10x[5+(1+(0)*4)*7], dt10x[6+(1+(0)*4)*7], dt10x[0+(2+(0)*4)*7], dt10x[1+(2+(0)*4)*7], dt10x[2+(2+(0)*4)*7], dt10x[3+(2+(0)*4)*7], dt10x[4+(2+(0)*4)*7], dt10x[5+(2+(0)*4)*7], dt10x[6+(2+(0)*4)*7], dt10x[0+(3+(0)*4)*7], dt10x[1+(3+(0)*4)*7], dt10x[2+(3+(0)*4)*7], dt10x[3+(3+(0)*4)*7], dt10x[4+(3+(0)*4)*7], dt10x[5+(3+(0)*4)*7], dt10x[6+(3+(0)*4)*7], dt10x[0+(0+(1)*4)*7], dt10x[1+(0+(1)*4)*7], dt10x[2+(0+(1)*4)*7], dt10x[3+(0+(1)*4)*7], dt10x[4+(0+(1)*4)*7], dt10x[5+(0+(1)*4)*7], dt10x[6+(0+(1)*4)*7], dt10x[0+(1+(1)*4)*7], dt10x[1+(1+(1)*4)*7], dt10x[2+(1+(1)*4)*7], dt10x[3+(1+(1)*4)*7], dt10x[4+(1+(1)*4)*7], dt10x[5+(1+(1)*4)*7], dt10x[6+(1+(1)*4)*7], dt10x[0+(2+(1)*4)*7], dt10x[1+(2+(1)*4)*7], dt10x[2+(2+(1)*4)*7], dt10x[3+(2+(1)*4)*7], dt10x[4+(2+(1)*4)*7], dt10x[5+(2+(1)*4)*7], dt10x[6+(2+(1)*4)*7], dt10x[0+(3+(1)*4)*7], dt10x[1+(3+(1)*4)*7], dt10x[2+(3+(1)*4)*7], dt10x[3+(3+(1)*4)*7], dt10x[4+(3+(1)*4)*7], dt10x[5+(3+(1)*4)*7], dt10x[6+(3+(1)*4)*7], dt10x[0+(0+(2)*4)*7], dt10x[1+(0+(2)*4)*7], dt10x[2+(0+(2)*4)*7], dt10x[3+(0+(2)*4)*7], dt10x[4+(0+(2)*4)*7], dt10x[5+(0+(2)*4)*7], dt10x[6+(0+(2)*4)*7], dt10x[0+(1+(2)*4)*7], dt10x[1+(1+(2)*4)*7], dt10x[2+(1+(2)*4)*7], dt10x[3+(1+(2)*4)*7], dt10x[4+(1+(2)*4)*7], dt10x[5+(1+(2)*4)*7], dt10x[6+(1+(2)*4)*7], dt10x[0+(2+(2)*4)*7], dt10x[1+(2+(2)*4)*7], dt10x[2+(2+(2)*4)*7], dt10x[3+(2+(2)*4)*7], dt10x[4+(2+(2)*4)*7], dt10x[5+(2+(2)*4)*7], dt10x[6+(2+(2)*4)*7], dt10x[0+(3+(2)*4)*7], dt10x[1+(3+(2)*4)*7], dt10x[2+(3+(2)*4)*7], dt10x[3+(3+(2)*4)*7], dt10x[4+(3+(2)*4)*7], dt10x[5+(3+(2)*4)*7], dt10x[6+(3+(2)*4)*7], dt10x[0+(0+(3)*4)*7], dt10x[1+(0+(3)*4)*7], dt10x[2+(0+(3)*4)*7], dt10x[3+(0+(3)*4)*7], dt10x[4+(0+(3)*4)*7], dt10x[5+(0+(3)*4)*7], dt10x[6+(0+(3)*4)*7], dt10x[0+(1+(3)*4)*7], dt10x[1+(1+(3)*4)*7], dt10x[2+(1+(3)*4)*7], dt10x[3+(1+(3)*4)*7], dt10x[4+(1+(3)*4)*7], dt10x[5+(1+(3)*4)*7], dt10x[6+(1+(3)*4)*7], dt10x[0+(2+(3)*4)*7], dt10x[1+(2+(3)*4)*7], dt10x[2+(2+(3)*4)*7], dt10x[3+(2+(3)*4)*7], dt10x[4+(2+(3)*4)*7], dt10x[5+(2+(3)*4)*7], dt10x[6+(2+(3)*4)*7], dt10x[0+(3+(3)*4)*7], dt10x[1+(3+(3)*4)*7], dt10x[2+(3+(3)*4)*7], dt10x[3+(3+(3)*4)*7], dt10x[4+(3+(3)*4)*7], dt10x[5+(3+(3)*4)*7], dt10x[6+(3+(3)*4)*7] = 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, -0.9, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, -0.9, 0.3, 0.7, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.3, 0.1, 0.5, 0.0, 0.0, 0.0, 0.0, 0.8, 0.1, -0.6, 0.8, 0.3, -0.3, 0.5, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.9, 0.1, 0.5, 0.0, 0.0, 0.0, 0.0, 0.7, 0.1, 0.3, 0.8, -0.9, -0.3, 0.5, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.3, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.3, -0.6, 0.8, 0.0, 0.0, 0.0
		dt10y[0+(0+(0)*4)*7], dt10y[1+(0+(0)*4)*7], dt10y[2+(0+(0)*4)*7], dt10y[3+(0+(0)*4)*7], dt10y[4+(0+(0)*4)*7], dt10y[5+(0+(0)*4)*7], dt10y[6+(0+(0)*4)*7], dt10y[0+(1+(0)*4)*7], dt10y[1+(1+(0)*4)*7], dt10y[2+(1+(0)*4)*7], dt10y[3+(1+(0)*4)*7], dt10y[4+(1+(0)*4)*7], dt10y[5+(1+(0)*4)*7], dt10y[6+(1+(0)*4)*7], dt10y[0+(2+(0)*4)*7], dt10y[1+(2+(0)*4)*7], dt10y[2+(2+(0)*4)*7], dt10y[3+(2+(0)*4)*7], dt10y[4+(2+(0)*4)*7], dt10y[5+(2+(0)*4)*7], dt10y[6+(2+(0)*4)*7], dt10y[0+(3+(0)*4)*7], dt10y[1+(3+(0)*4)*7], dt10y[2+(3+(0)*4)*7], dt10y[3+(3+(0)*4)*7], dt10y[4+(3+(0)*4)*7], dt10y[5+(3+(0)*4)*7], dt10y[6+(3+(0)*4)*7], dt10y[0+(0+(1)*4)*7], dt10y[1+(0+(1)*4)*7], dt10y[2+(0+(1)*4)*7], dt10y[3+(0+(1)*4)*7], dt10y[4+(0+(1)*4)*7], dt10y[5+(0+(1)*4)*7], dt10y[6+(0+(1)*4)*7], dt10y[0+(1+(1)*4)*7], dt10y[1+(1+(1)*4)*7], dt10y[2+(1+(1)*4)*7], dt10y[3+(1+(1)*4)*7], dt10y[4+(1+(1)*4)*7], dt10y[5+(1+(1)*4)*7], dt10y[6+(1+(1)*4)*7], dt10y[0+(2+(1)*4)*7], dt10y[1+(2+(1)*4)*7], dt10y[2+(2+(1)*4)*7], dt10y[3+(2+(1)*4)*7], dt10y[4+(2+(1)*4)*7], dt10y[5+(2+(1)*4)*7], dt10y[6+(2+(1)*4)*7], dt10y[0+(3+(1)*4)*7], dt10y[1+(3+(1)*4)*7], dt10y[2+(3+(1)*4)*7], dt10y[3+(3+(1)*4)*7], dt10y[4+(3+(1)*4)*7], dt10y[5+(3+(1)*4)*7], dt10y[6+(3+(1)*4)*7], dt10y[0+(0+(2)*4)*7], dt10y[1+(0+(2)*4)*7], dt10y[2+(0+(2)*4)*7], dt10y[3+(0+(2)*4)*7], dt10y[4+(0+(2)*4)*7], dt10y[5+(0+(2)*4)*7], dt10y[6+(0+(2)*4)*7], dt10y[0+(1+(2)*4)*7], dt10y[1+(1+(2)*4)*7], dt10y[2+(1+(2)*4)*7], dt10y[3+(1+(2)*4)*7], dt10y[4+(1+(2)*4)*7], dt10y[5+(1+(2)*4)*7], dt10y[6+(1+(2)*4)*7], dt10y[0+(2+(2)*4)*7], dt10y[1+(2+(2)*4)*7], dt10y[2+(2+(2)*4)*7], dt10y[3+(2+(2)*4)*7], dt10y[4+(2+(2)*4)*7], dt10y[5+(2+(2)*4)*7], dt10y[6+(2+(2)*4)*7], dt10y[0+(3+(2)*4)*7], dt10y[1+(3+(2)*4)*7], dt10y[2+(3+(2)*4)*7], dt10y[3+(3+(2)*4)*7], dt10y[4+(3+(2)*4)*7], dt10y[5+(3+(2)*4)*7], dt10y[6+(3+(2)*4)*7], dt10y[0+(0+(3)*4)*7], dt10y[1+(0+(3)*4)*7], dt10y[2+(0+(3)*4)*7], dt10y[3+(0+(3)*4)*7], dt10y[4+(0+(3)*4)*7], dt10y[5+(0+(3)*4)*7], dt10y[6+(0+(3)*4)*7], dt10y[0+(1+(3)*4)*7], dt10y[1+(1+(3)*4)*7], dt10y[2+(1+(3)*4)*7], dt10y[3+(1+(3)*4)*7], dt10y[4+(1+(3)*4)*7], dt10y[5+(1+(3)*4)*7], dt10y[6+(1+(3)*4)*7], dt10y[0+(2+(3)*4)*7], dt10y[1+(2+(3)*4)*7], dt10y[2+(2+(3)*4)*7], dt10y[3+(2+(3)*4)*7], dt10y[4+(2+(3)*4)*7], dt10y[5+(2+(3)*4)*7], dt10y[6+(2+(3)*4)*7], dt10y[0+(3+(3)*4)*7], dt10y[1+(3+(3)*4)*7], dt10y[2+(3+(3)*4)*7], dt10y[3+(3+(3)*4)*7], dt10y[4+(3+(3)*4)*7], dt10y[5+(3+(3)*4)*7], dt10y[6+(3+(3)*4)*7] = 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.1, -0.5, 0.8, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5, -0.9, 0.6, 0.0, 0.0, 0.0, 0.0, -0.4, -0.9, 0.9, 0.7, -0.5, 0.2, 0.6, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, -0.4, 0.9, -0.5, 0.6, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, -0.9, 0.1, 0.0, 0.0, 0.0, 0.0, 0.6, -0.9, 0.1, 0.7, -0.5, 0.2, 0.8
		ssize2[0+(0)*14], ssize2[1+(0)*14], ssize2[2+(0)*14], ssize2[3+(0)*14], ssize2[4+(0)*14], ssize2[5+(0)*14], ssize2[6+(0)*14], ssize2[7+(0)*14], ssize2[8+(0)*14], ssize2[9+(0)*14], ssize2[10+(0)*14], ssize2[11+(0)*14], ssize2[12+(0)*14], ssize2[13+(0)*14], ssize2[0+(1)*14], ssize2[1+(1)*14], ssize2[2+(1)*14], ssize2[3+(1)*14], ssize2[4+(1)*14], ssize2[5+(1)*14], ssize2[6+(1)*14], ssize2[7+(1)*14], ssize2[8+(1)*14], ssize2[9+(1)*14], ssize2[10+(1)*14], ssize2[11+(1)*14], ssize2[12+(1)*14], ssize2[13+(1)*14] = 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17

		dpar[0+(0)*5], dpar[1+(0)*5], dpar[2+(0)*5], dpar[3+(0)*5], dpar[4+(0)*5], dpar[0+(1)*5], dpar[1+(1)*5], dpar[2+(1)*5], dpar[3+(1)*5], dpar[4+(1)*5], dpar[0+(2)*5], dpar[1+(2)*5], dpar[2+(2)*5], dpar[3+(2)*5], dpar[4+(2)*5], dpar[0+(3)*5], dpar[1+(3)*5], dpar[2+(3)*5], dpar[3+(3)*5], dpar[4+(3)*5] = -2., 0., 0., 0., 0., -1., 2., -3., -4., 5., 0., 0., 2., -3., 0., 1., 5., 2., 0., -4.

		dt19x[0+(0+(0)*4)*7], dt19x[1+(0+(0)*4)*7], dt19x[2+(0+(0)*4)*7], dt19x[3+(0+(0)*4)*7], dt19x[4+(0+(0)*4)*7], dt19x[5+(0+(0)*4)*7], dt19x[6+(0+(0)*4)*7], dt19x[0+(1+(0)*4)*7], dt19x[1+(1+(0)*4)*7], dt19x[2+(1+(0)*4)*7], dt19x[3+(1+(0)*4)*7], dt19x[4+(1+(0)*4)*7], dt19x[5+(1+(0)*4)*7], dt19x[6+(1+(0)*4)*7], dt19x[0+(2+(0)*4)*7], dt19x[1+(2+(0)*4)*7], dt19x[2+(2+(0)*4)*7], dt19x[3+(2+(0)*4)*7], dt19x[4+(2+(0)*4)*7], dt19x[5+(2+(0)*4)*7], dt19x[6+(2+(0)*4)*7], dt19x[0+(3+(0)*4)*7], dt19x[1+(3+(0)*4)*7], dt19x[2+(3+(0)*4)*7], dt19x[3+(3+(0)*4)*7], dt19x[4+(3+(0)*4)*7], dt19x[5+(3+(0)*4)*7], dt19x[6+(3+(0)*4)*7], dt19x[0+(0+(1)*4)*7], dt19x[1+(0+(1)*4)*7], dt19x[2+(0+(1)*4)*7], dt19x[3+(0+(1)*4)*7], dt19x[4+(0+(1)*4)*7], dt19x[5+(0+(1)*4)*7], dt19x[6+(0+(1)*4)*7], dt19x[0+(1+(1)*4)*7], dt19x[1+(1+(1)*4)*7], dt19x[2+(1+(1)*4)*7], dt19x[3+(1+(1)*4)*7], dt19x[4+(1+(1)*4)*7], dt19x[5+(1+(1)*4)*7], dt19x[6+(1+(1)*4)*7], dt19x[0+(2+(1)*4)*7], dt19x[1+(2+(1)*4)*7], dt19x[2+(2+(1)*4)*7], dt19x[3+(2+(1)*4)*7], dt19x[4+(2+(1)*4)*7], dt19x[5+(2+(1)*4)*7], dt19x[6+(2+(1)*4)*7], dt19x[0+(3+(1)*4)*7], dt19x[1+(3+(1)*4)*7], dt19x[2+(3+(1)*4)*7], dt19x[3+(3+(1)*4)*7], dt19x[4+(3+(1)*4)*7], dt19x[5+(3+(1)*4)*7], dt19x[6+(3+(1)*4)*7], dt19x[0+(0+(2)*4)*7], dt19x[1+(0+(2)*4)*7], dt19x[2+(0+(2)*4)*7], dt19x[3+(0+(2)*4)*7], dt19x[4+(0+(2)*4)*7], dt19x[5+(0+(2)*4)*7], dt19x[6+(0+(2)*4)*7], dt19x[0+(1+(2)*4)*7], dt19x[1+(1+(2)*4)*7], dt19x[2+(1+(2)*4)*7], dt19x[3+(1+(2)*4)*7], dt19x[4+(1+(2)*4)*7], dt19x[5+(1+(2)*4)*7], dt19x[6+(1+(2)*4)*7], dt19x[0+(2+(2)*4)*7], dt19x[1+(2+(2)*4)*7], dt19x[2+(2+(2)*4)*7], dt19x[3+(2+(2)*4)*7], dt19x[4+(2+(2)*4)*7], dt19x[5+(2+(2)*4)*7], dt19x[6+(2+(2)*4)*7], dt19x[0+(3+(2)*4)*7], dt19x[1+(3+(2)*4)*7], dt19x[2+(3+(2)*4)*7], dt19x[3+(3+(2)*4)*7], dt19x[4+(3+(2)*4)*7], dt19x[5+(3+(2)*4)*7], dt19x[6+(3+(2)*4)*7], dt19x[0+(0+(3)*4)*7], dt19x[1+(0+(3)*4)*7], dt19x[2+(0+(3)*4)*7], dt19x[3+(0+(3)*4)*7], dt19x[4+(0+(3)*4)*7], dt19x[5+(0+(3)*4)*7], dt19x[6+(0+(3)*4)*7], dt19x[0+(1+(3)*4)*7], dt19x[1+(1+(3)*4)*7], dt19x[2+(1+(3)*4)*7], dt19x[3+(1+(3)*4)*7], dt19x[4+(1+(3)*4)*7], dt19x[5+(1+(3)*4)*7], dt19x[6+(1+(3)*4)*7], dt19x[0+(2+(3)*4)*7], dt19x[1+(2+(3)*4)*7], dt19x[2+(2+(3)*4)*7], dt19x[3+(2+(3)*4)*7], dt19x[4+(2+(3)*4)*7], dt19x[5+(2+(3)*4)*7], dt19x[6+(2+(3)*4)*7], dt19x[0+(3+(3)*4)*7], dt19x[1+(3+(3)*4)*7], dt19x[2+(3+(3)*4)*7], dt19x[3+(3+(3)*4)*7], dt19x[4+(3+(3)*4)*7], dt19x[5+(3+(3)*4)*7], dt19x[6+(3+(3)*4)*7] = .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., -.8, 0., 0., 0., 0., 0., 0., -.9, 0., 0., 0., 0., 0., 0., 3.5, 0., 0., 0., 0., 0., 0., .6, .1, 0., 0., 0., 0., 0., -.8, 3.8, 0., 0., 0., 0., 0., -.9, 2.8, 0., 0., 0., 0., 0., 3.5, -.4, 0., 0., 0., 0., 0., .6, .1, -.5, .8, 0., 0., 0., -.8, 3.8, -2.2, -1.2, 0., 0., 0., -.9, 2.8, -1.4, -1.3, 0., 0., 0., 3.5, -.4, -2.2, 4.7, 0., 0., 0.
		dt19x[0+(0+(0+4)*4)*7], dt19x[1+(0+(0+4)*4)*7], dt19x[2+(0+(0+4)*4)*7], dt19x[3+(0+(0+4)*4)*7], dt19x[4+(0+(0+4)*4)*7], dt19x[5+(0+(0+4)*4)*7], dt19x[6+(0+(0+4)*4)*7], dt19x[0+(1+(0+4)*4)*7], dt19x[1+(1+(0+4)*4)*7], dt19x[2+(1+(0+4)*4)*7], dt19x[3+(1+(0+4)*4)*7], dt19x[4+(1+(0+4)*4)*7], dt19x[5+(1+(0+4)*4)*7], dt19x[6+(1+(0+4)*4)*7], dt19x[0+(2+(0+4)*4)*7], dt19x[1+(2+(0+4)*4)*7], dt19x[2+(2+(0+4)*4)*7], dt19x[3+(2+(0+4)*4)*7], dt19x[4+(2+(0+4)*4)*7], dt19x[5+(2+(0+4)*4)*7], dt19x[6+(2+(0+4)*4)*7], dt19x[0+(3+(0+4)*4)*7], dt19x[1+(3+(0+4)*4)*7], dt19x[2+(3+(0+4)*4)*7], dt19x[3+(3+(0+4)*4)*7], dt19x[4+(3+(0+4)*4)*7], dt19x[5+(3+(0+4)*4)*7], dt19x[6+(3+(0+4)*4)*7], dt19x[0+(0+(1+4)*4)*7], dt19x[1+(0+(1+4)*4)*7], dt19x[2+(0+(1+4)*4)*7], dt19x[3+(0+(1+4)*4)*7], dt19x[4+(0+(1+4)*4)*7], dt19x[5+(0+(1+4)*4)*7], dt19x[6+(0+(1+4)*4)*7], dt19x[0+(1+(1+4)*4)*7], dt19x[1+(1+(1+4)*4)*7], dt19x[2+(1+(1+4)*4)*7], dt19x[3+(1+(1+4)*4)*7], dt19x[4+(1+(1+4)*4)*7], dt19x[5+(1+(1+4)*4)*7], dt19x[6+(1+(1+4)*4)*7], dt19x[0+(2+(1+4)*4)*7], dt19x[1+(2+(1+4)*4)*7], dt19x[2+(2+(1+4)*4)*7], dt19x[3+(2+(1+4)*4)*7], dt19x[4+(2+(1+4)*4)*7], dt19x[5+(2+(1+4)*4)*7], dt19x[6+(2+(1+4)*4)*7], dt19x[0+(3+(1+4)*4)*7], dt19x[1+(3+(1+4)*4)*7], dt19x[2+(3+(1+4)*4)*7], dt19x[3+(3+(1+4)*4)*7], dt19x[4+(3+(1+4)*4)*7], dt19x[5+(3+(1+4)*4)*7], dt19x[6+(3+(1+4)*4)*7], dt19x[0+(0+(2+4)*4)*7], dt19x[1+(0+(2+4)*4)*7], dt19x[2+(0+(2+4)*4)*7], dt19x[3+(0+(2+4)*4)*7], dt19x[4+(0+(2+4)*4)*7], dt19x[5+(0+(2+4)*4)*7], dt19x[6+(0+(2+4)*4)*7], dt19x[0+(1+(2+4)*4)*7], dt19x[1+(1+(2+4)*4)*7], dt19x[2+(1+(2+4)*4)*7], dt19x[3+(1+(2+4)*4)*7], dt19x[4+(1+(2+4)*4)*7], dt19x[5+(1+(2+4)*4)*7], dt19x[6+(1+(2+4)*4)*7], dt19x[0+(2+(2+4)*4)*7], dt19x[1+(2+(2+4)*4)*7], dt19x[2+(2+(2+4)*4)*7], dt19x[3+(2+(2+4)*4)*7], dt19x[4+(2+(2+4)*4)*7], dt19x[5+(2+(2+4)*4)*7], dt19x[6+(2+(2+4)*4)*7], dt19x[0+(3+(2+4)*4)*7], dt19x[1+(3+(2+4)*4)*7], dt19x[2+(3+(2+4)*4)*7], dt19x[3+(3+(2+4)*4)*7], dt19x[4+(3+(2+4)*4)*7], dt19x[5+(3+(2+4)*4)*7], dt19x[6+(3+(2+4)*4)*7], dt19x[0+(0+(3+4)*4)*7], dt19x[1+(0+(3+4)*4)*7], dt19x[2+(0+(3+4)*4)*7], dt19x[3+(0+(3+4)*4)*7], dt19x[4+(0+(3+4)*4)*7], dt19x[5+(0+(3+4)*4)*7], dt19x[6+(0+(3+4)*4)*7], dt19x[0+(1+(3+4)*4)*7], dt19x[1+(1+(3+4)*4)*7], dt19x[2+(1+(3+4)*4)*7], dt19x[3+(1+(3+4)*4)*7], dt19x[4+(1+(3+4)*4)*7], dt19x[5+(1+(3+4)*4)*7], dt19x[6+(1+(3+4)*4)*7], dt19x[0+(2+(3+4)*4)*7], dt19x[1+(2+(3+4)*4)*7], dt19x[2+(2+(3+4)*4)*7], dt19x[3+(2+(3+4)*4)*7], dt19x[4+(2+(3+4)*4)*7], dt19x[5+(2+(3+4)*4)*7], dt19x[6+(2+(3+4)*4)*7], dt19x[0+(3+(3+4)*4)*7], dt19x[1+(3+(3+4)*4)*7], dt19x[2+(3+(3+4)*4)*7], dt19x[3+(3+(3+4)*4)*7], dt19x[4+(3+(3+4)*4)*7], dt19x[5+(3+(3+4)*4)*7], dt19x[6+(3+(3+4)*4)*7] = .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., -.8, 0., 0., 0., 0., 0., 0., -.9, 0., 0., 0., 0., 0., 0., 3.5, 0., 0., 0., 0., 0., 0., .6, .1, -.5, 0., 0., 0., 0., 0., .1, -3.0, 0., 0., 0., 0., -.3, .1, -2.0, 0., 0., 0., 0., 3.3, .1, -2.0, 0., 0., 0., 0., .6, .1, -.5, .8, .9, -.3, -.4, -2.0, .1, 1.4, .8, .6, -.3, -2.8, -1.8, .1, 1.3, .8, 0., -.3, -1.9, 3.8, .1, -3.1, .8, 4.8, -.3, -1.5
		dt19x[0+(0+(0+8)*4)*7], dt19x[1+(0+(0+8)*4)*7], dt19x[2+(0+(0+8)*4)*7], dt19x[3+(0+(0+8)*4)*7], dt19x[4+(0+(0+8)*4)*7], dt19x[5+(0+(0+8)*4)*7], dt19x[6+(0+(0+8)*4)*7], dt19x[0+(1+(0+8)*4)*7], dt19x[1+(1+(0+8)*4)*7], dt19x[2+(1+(0+8)*4)*7], dt19x[3+(1+(0+8)*4)*7], dt19x[4+(1+(0+8)*4)*7], dt19x[5+(1+(0+8)*4)*7], dt19x[6+(1+(0+8)*4)*7], dt19x[0+(2+(0+8)*4)*7], dt19x[1+(2+(0+8)*4)*7], dt19x[2+(2+(0+8)*4)*7], dt19x[3+(2+(0+8)*4)*7], dt19x[4+(2+(0+8)*4)*7], dt19x[5+(2+(0+8)*4)*7], dt19x[6+(2+(0+8)*4)*7], dt19x[0+(3+(0+8)*4)*7], dt19x[1+(3+(0+8)*4)*7], dt19x[2+(3+(0+8)*4)*7], dt19x[3+(3+(0+8)*4)*7], dt19x[4+(3+(0+8)*4)*7], dt19x[5+(3+(0+8)*4)*7], dt19x[6+(3+(0+8)*4)*7], dt19x[0+(0+(1+8)*4)*7], dt19x[1+(0+(1+8)*4)*7], dt19x[2+(0+(1+8)*4)*7], dt19x[3+(0+(1+8)*4)*7], dt19x[4+(0+(1+8)*4)*7], dt19x[5+(0+(1+8)*4)*7], dt19x[6+(0+(1+8)*4)*7], dt19x[0+(1+(1+8)*4)*7], dt19x[1+(1+(1+8)*4)*7], dt19x[2+(1+(1+8)*4)*7], dt19x[3+(1+(1+8)*4)*7], dt19x[4+(1+(1+8)*4)*7], dt19x[5+(1+(1+8)*4)*7], dt19x[6+(1+(1+8)*4)*7], dt19x[0+(2+(1+8)*4)*7], dt19x[1+(2+(1+8)*4)*7], dt19x[2+(2+(1+8)*4)*7], dt19x[3+(2+(1+8)*4)*7], dt19x[4+(2+(1+8)*4)*7], dt19x[5+(2+(1+8)*4)*7], dt19x[6+(2+(1+8)*4)*7], dt19x[0+(3+(1+8)*4)*7], dt19x[1+(3+(1+8)*4)*7], dt19x[2+(3+(1+8)*4)*7], dt19x[3+(3+(1+8)*4)*7], dt19x[4+(3+(1+8)*4)*7], dt19x[5+(3+(1+8)*4)*7], dt19x[6+(3+(1+8)*4)*7], dt19x[0+(0+(2+8)*4)*7], dt19x[1+(0+(2+8)*4)*7], dt19x[2+(0+(2+8)*4)*7], dt19x[3+(0+(2+8)*4)*7], dt19x[4+(0+(2+8)*4)*7], dt19x[5+(0+(2+8)*4)*7], dt19x[6+(0+(2+8)*4)*7], dt19x[0+(1+(2+8)*4)*7], dt19x[1+(1+(2+8)*4)*7], dt19x[2+(1+(2+8)*4)*7], dt19x[3+(1+(2+8)*4)*7], dt19x[4+(1+(2+8)*4)*7], dt19x[5+(1+(2+8)*4)*7], dt19x[6+(1+(2+8)*4)*7], dt19x[0+(2+(2+8)*4)*7], dt19x[1+(2+(2+8)*4)*7], dt19x[2+(2+(2+8)*4)*7], dt19x[3+(2+(2+8)*4)*7], dt19x[4+(2+(2+8)*4)*7], dt19x[5+(2+(2+8)*4)*7], dt19x[6+(2+(2+8)*4)*7], dt19x[0+(3+(2+8)*4)*7], dt19x[1+(3+(2+8)*4)*7], dt19x[2+(3+(2+8)*4)*7], dt19x[3+(3+(2+8)*4)*7], dt19x[4+(3+(2+8)*4)*7], dt19x[5+(3+(2+8)*4)*7], dt19x[6+(3+(2+8)*4)*7], dt19x[0+(0+(3+8)*4)*7], dt19x[1+(0+(3+8)*4)*7], dt19x[2+(0+(3+8)*4)*7], dt19x[3+(0+(3+8)*4)*7], dt19x[4+(0+(3+8)*4)*7], dt19x[5+(0+(3+8)*4)*7], dt19x[6+(0+(3+8)*4)*7], dt19x[0+(1+(3+8)*4)*7], dt19x[1+(1+(3+8)*4)*7], dt19x[2+(1+(3+8)*4)*7], dt19x[3+(1+(3+8)*4)*7], dt19x[4+(1+(3+8)*4)*7], dt19x[5+(1+(3+8)*4)*7], dt19x[6+(1+(3+8)*4)*7], dt19x[0+(2+(3+8)*4)*7], dt19x[1+(2+(3+8)*4)*7], dt19x[2+(2+(3+8)*4)*7], dt19x[3+(2+(3+8)*4)*7], dt19x[4+(2+(3+8)*4)*7], dt19x[5+(2+(3+8)*4)*7], dt19x[6+(2+(3+8)*4)*7], dt19x[0+(3+(3+8)*4)*7], dt19x[1+(3+(3+8)*4)*7], dt19x[2+(3+(3+8)*4)*7], dt19x[3+(3+(3+8)*4)*7], dt19x[4+(3+(3+8)*4)*7], dt19x[5+(3+(3+8)*4)*7], dt19x[6+(3+(3+8)*4)*7] = .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., -.8, 0., 0., 0., 0., 0., 0., -.9, 0., 0., 0., 0., 0., 0., 3.5, 0., 0., 0., 0., 0., 0., .6, .1, -.5, 0., 0., 0., 0., 4.8, .1, -3.0, 0., 0., 0., 0., 3.3, .1, -2.0, 0., 0., 0., 0., 2.1, .1, -2.0, 0., 0., 0., 0., .6, .1, -.5, .8, .9, -.3, -.4, -1.6, .1, -2.2, .8, 5.4, -.3, -2.8, -1.5, .1, -1.4, .8, 3.6, -.3, -1.9, 3.7, .1, -2.2, .8, 3.6, -.3, -1.5
		dt19x[0+(0+(0+12)*4)*7], dt19x[1+(0+(0+12)*4)*7], dt19x[2+(0+(0+12)*4)*7], dt19x[3+(0+(0+12)*4)*7], dt19x[4+(0+(0+12)*4)*7], dt19x[5+(0+(0+12)*4)*7], dt19x[6+(0+(0+12)*4)*7], dt19x[0+(1+(0+12)*4)*7], dt19x[1+(1+(0+12)*4)*7], dt19x[2+(1+(0+12)*4)*7], dt19x[3+(1+(0+12)*4)*7], dt19x[4+(1+(0+12)*4)*7], dt19x[5+(1+(0+12)*4)*7], dt19x[6+(1+(0+12)*4)*7], dt19x[0+(2+(0+12)*4)*7], dt19x[1+(2+(0+12)*4)*7], dt19x[2+(2+(0+12)*4)*7], dt19x[3+(2+(0+12)*4)*7], dt19x[4+(2+(0+12)*4)*7], dt19x[5+(2+(0+12)*4)*7], dt19x[6+(2+(0+12)*4)*7], dt19x[0+(3+(0+12)*4)*7], dt19x[1+(3+(0+12)*4)*7], dt19x[2+(3+(0+12)*4)*7], dt19x[3+(3+(0+12)*4)*7], dt19x[4+(3+(0+12)*4)*7], dt19x[5+(3+(0+12)*4)*7], dt19x[6+(3+(0+12)*4)*7], dt19x[0+(0+(1+12)*4)*7], dt19x[1+(0+(1+12)*4)*7], dt19x[2+(0+(1+12)*4)*7], dt19x[3+(0+(1+12)*4)*7], dt19x[4+(0+(1+12)*4)*7], dt19x[5+(0+(1+12)*4)*7], dt19x[6+(0+(1+12)*4)*7], dt19x[0+(1+(1+12)*4)*7], dt19x[1+(1+(1+12)*4)*7], dt19x[2+(1+(1+12)*4)*7], dt19x[3+(1+(1+12)*4)*7], dt19x[4+(1+(1+12)*4)*7], dt19x[5+(1+(1+12)*4)*7], dt19x[6+(1+(1+12)*4)*7], dt19x[0+(2+(1+12)*4)*7], dt19x[1+(2+(1+12)*4)*7], dt19x[2+(2+(1+12)*4)*7], dt19x[3+(2+(1+12)*4)*7], dt19x[4+(2+(1+12)*4)*7], dt19x[5+(2+(1+12)*4)*7], dt19x[6+(2+(1+12)*4)*7], dt19x[0+(3+(1+12)*4)*7], dt19x[1+(3+(1+12)*4)*7], dt19x[2+(3+(1+12)*4)*7], dt19x[3+(3+(1+12)*4)*7], dt19x[4+(3+(1+12)*4)*7], dt19x[5+(3+(1+12)*4)*7], dt19x[6+(3+(1+12)*4)*7], dt19x[0+(0+(2+12)*4)*7], dt19x[1+(0+(2+12)*4)*7], dt19x[2+(0+(2+12)*4)*7], dt19x[3+(0+(2+12)*4)*7], dt19x[4+(0+(2+12)*4)*7], dt19x[5+(0+(2+12)*4)*7], dt19x[6+(0+(2+12)*4)*7], dt19x[0+(1+(2+12)*4)*7], dt19x[1+(1+(2+12)*4)*7], dt19x[2+(1+(2+12)*4)*7], dt19x[3+(1+(2+12)*4)*7], dt19x[4+(1+(2+12)*4)*7], dt19x[5+(1+(2+12)*4)*7], dt19x[6+(1+(2+12)*4)*7], dt19x[0+(2+(2+12)*4)*7], dt19x[1+(2+(2+12)*4)*7], dt19x[2+(2+(2+12)*4)*7], dt19x[3+(2+(2+12)*4)*7], dt19x[4+(2+(2+12)*4)*7], dt19x[5+(2+(2+12)*4)*7], dt19x[6+(2+(2+12)*4)*7], dt19x[0+(3+(2+12)*4)*7], dt19x[1+(3+(2+12)*4)*7], dt19x[2+(3+(2+12)*4)*7], dt19x[3+(3+(2+12)*4)*7], dt19x[4+(3+(2+12)*4)*7], dt19x[5+(3+(2+12)*4)*7], dt19x[6+(3+(2+12)*4)*7], dt19x[0+(0+(3+12)*4)*7], dt19x[1+(0+(3+12)*4)*7], dt19x[2+(0+(3+12)*4)*7], dt19x[3+(0+(3+12)*4)*7], dt19x[4+(0+(3+12)*4)*7], dt19x[5+(0+(3+12)*4)*7], dt19x[6+(0+(3+12)*4)*7], dt19x[0+(1+(3+12)*4)*7], dt19x[1+(1+(3+12)*4)*7], dt19x[2+(1+(3+12)*4)*7], dt19x[3+(1+(3+12)*4)*7], dt19x[4+(1+(3+12)*4)*7], dt19x[5+(1+(3+12)*4)*7], dt19x[6+(1+(3+12)*4)*7], dt19x[0+(2+(3+12)*4)*7], dt19x[1+(2+(3+12)*4)*7], dt19x[2+(2+(3+12)*4)*7], dt19x[3+(2+(3+12)*4)*7], dt19x[4+(2+(3+12)*4)*7], dt19x[5+(2+(3+12)*4)*7], dt19x[6+(2+(3+12)*4)*7], dt19x[0+(3+(3+12)*4)*7], dt19x[1+(3+(3+12)*4)*7], dt19x[2+(3+(3+12)*4)*7], dt19x[3+(3+(3+12)*4)*7], dt19x[4+(3+(3+12)*4)*7], dt19x[5+(3+(3+12)*4)*7], dt19x[6+(3+(3+12)*4)*7] = .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., -.8, 0., 0., 0., 0., 0., 0., -.9, 0., 0., 0., 0., 0., 0., 3.5, 0., 0., 0., 0., 0., 0., .6, .1, 0., 0., 0., 0., 0., -.8, -1.0, 0., 0., 0., 0., 0., -.9, -.8, 0., 0., 0., 0., 0., 3.5, .8, 0., 0., 0., 0., 0., .6, .1, -.5, .8, 0., 0., 0., -.8, -1.0, 1.4, -1.6, 0., 0., 0., -.9, -.8, 1.3, -1.6, 0., 0., 0., 3.5, .8, -3.1, 4.8, 0., 0., 0.

		dt19y[0+(0+(0)*4)*7], dt19y[1+(0+(0)*4)*7], dt19y[2+(0+(0)*4)*7], dt19y[3+(0+(0)*4)*7], dt19y[4+(0+(0)*4)*7], dt19y[5+(0+(0)*4)*7], dt19y[6+(0+(0)*4)*7], dt19y[0+(1+(0)*4)*7], dt19y[1+(1+(0)*4)*7], dt19y[2+(1+(0)*4)*7], dt19y[3+(1+(0)*4)*7], dt19y[4+(1+(0)*4)*7], dt19y[5+(1+(0)*4)*7], dt19y[6+(1+(0)*4)*7], dt19y[0+(2+(0)*4)*7], dt19y[1+(2+(0)*4)*7], dt19y[2+(2+(0)*4)*7], dt19y[3+(2+(0)*4)*7], dt19y[4+(2+(0)*4)*7], dt19y[5+(2+(0)*4)*7], dt19y[6+(2+(0)*4)*7], dt19y[0+(3+(0)*4)*7], dt19y[1+(3+(0)*4)*7], dt19y[2+(3+(0)*4)*7], dt19y[3+(3+(0)*4)*7], dt19y[4+(3+(0)*4)*7], dt19y[5+(3+(0)*4)*7], dt19y[6+(3+(0)*4)*7], dt19y[0+(0+(1)*4)*7], dt19y[1+(0+(1)*4)*7], dt19y[2+(0+(1)*4)*7], dt19y[3+(0+(1)*4)*7], dt19y[4+(0+(1)*4)*7], dt19y[5+(0+(1)*4)*7], dt19y[6+(0+(1)*4)*7], dt19y[0+(1+(1)*4)*7], dt19y[1+(1+(1)*4)*7], dt19y[2+(1+(1)*4)*7], dt19y[3+(1+(1)*4)*7], dt19y[4+(1+(1)*4)*7], dt19y[5+(1+(1)*4)*7], dt19y[6+(1+(1)*4)*7], dt19y[0+(2+(1)*4)*7], dt19y[1+(2+(1)*4)*7], dt19y[2+(2+(1)*4)*7], dt19y[3+(2+(1)*4)*7], dt19y[4+(2+(1)*4)*7], dt19y[5+(2+(1)*4)*7], dt19y[6+(2+(1)*4)*7], dt19y[0+(3+(1)*4)*7], dt19y[1+(3+(1)*4)*7], dt19y[2+(3+(1)*4)*7], dt19y[3+(3+(1)*4)*7], dt19y[4+(3+(1)*4)*7], dt19y[5+(3+(1)*4)*7], dt19y[6+(3+(1)*4)*7], dt19y[0+(0+(2)*4)*7], dt19y[1+(0+(2)*4)*7], dt19y[2+(0+(2)*4)*7], dt19y[3+(0+(2)*4)*7], dt19y[4+(0+(2)*4)*7], dt19y[5+(0+(2)*4)*7], dt19y[6+(0+(2)*4)*7], dt19y[0+(1+(2)*4)*7], dt19y[1+(1+(2)*4)*7], dt19y[2+(1+(2)*4)*7], dt19y[3+(1+(2)*4)*7], dt19y[4+(1+(2)*4)*7], dt19y[5+(1+(2)*4)*7], dt19y[6+(1+(2)*4)*7], dt19y[0+(2+(2)*4)*7], dt19y[1+(2+(2)*4)*7], dt19y[2+(2+(2)*4)*7], dt19y[3+(2+(2)*4)*7], dt19y[4+(2+(2)*4)*7], dt19y[5+(2+(2)*4)*7], dt19y[6+(2+(2)*4)*7], dt19y[0+(3+(2)*4)*7], dt19y[1+(3+(2)*4)*7], dt19y[2+(3+(2)*4)*7], dt19y[3+(3+(2)*4)*7], dt19y[4+(3+(2)*4)*7], dt19y[5+(3+(2)*4)*7], dt19y[6+(3+(2)*4)*7], dt19y[0+(0+(3)*4)*7], dt19y[1+(0+(3)*4)*7], dt19y[2+(0+(3)*4)*7], dt19y[3+(0+(3)*4)*7], dt19y[4+(0+(3)*4)*7], dt19y[5+(0+(3)*4)*7], dt19y[6+(0+(3)*4)*7], dt19y[0+(1+(3)*4)*7], dt19y[1+(1+(3)*4)*7], dt19y[2+(1+(3)*4)*7], dt19y[3+(1+(3)*4)*7], dt19y[4+(1+(3)*4)*7], dt19y[5+(1+(3)*4)*7], dt19y[6+(1+(3)*4)*7], dt19y[0+(2+(3)*4)*7], dt19y[1+(2+(3)*4)*7], dt19y[2+(2+(3)*4)*7], dt19y[3+(2+(3)*4)*7], dt19y[4+(2+(3)*4)*7], dt19y[5+(2+(3)*4)*7], dt19y[6+(2+(3)*4)*7], dt19y[0+(3+(3)*4)*7], dt19y[1+(3+(3)*4)*7], dt19y[2+(3+(3)*4)*7], dt19y[3+(3+(3)*4)*7], dt19y[4+(3+(3)*4)*7], dt19y[5+(3+(3)*4)*7], dt19y[6+(3+(3)*4)*7] = .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .7, 0., 0., 0., 0., 0., 0., 1.7, 0., 0., 0., 0., 0., 0., -2.6, 0., 0., 0., 0., 0., 0., .5, -.9, 0., 0., 0., 0., 0., .7, -4.8, 0., 0., 0., 0., 0., 1.7, -.7, 0., 0., 0., 0., 0., -2.6, 3.5, 0., 0., 0., 0., 0., .5, -.9, .3, .7, 0., 0., 0., .7, -4.8, 3.0, 1.1, 0., 0., 0., 1.7, -.7, -.7, 2.3, 0., 0., 0., -2.6, 3.5, -.7, -3.6, 0., 0., 0.
		dt19y[0+(0+(0+4)*4)*7], dt19y[1+(0+(0+4)*4)*7], dt19y[2+(0+(0+4)*4)*7], dt19y[3+(0+(0+4)*4)*7], dt19y[4+(0+(0+4)*4)*7], dt19y[5+(0+(0+4)*4)*7], dt19y[6+(0+(0+4)*4)*7], dt19y[0+(1+(0+4)*4)*7], dt19y[1+(1+(0+4)*4)*7], dt19y[2+(1+(0+4)*4)*7], dt19y[3+(1+(0+4)*4)*7], dt19y[4+(1+(0+4)*4)*7], dt19y[5+(1+(0+4)*4)*7], dt19y[6+(1+(0+4)*4)*7], dt19y[0+(2+(0+4)*4)*7], dt19y[1+(2+(0+4)*4)*7], dt19y[2+(2+(0+4)*4)*7], dt19y[3+(2+(0+4)*4)*7], dt19y[4+(2+(0+4)*4)*7], dt19y[5+(2+(0+4)*4)*7], dt19y[6+(2+(0+4)*4)*7], dt19y[0+(3+(0+4)*4)*7], dt19y[1+(3+(0+4)*4)*7], dt19y[2+(3+(0+4)*4)*7], dt19y[3+(3+(0+4)*4)*7], dt19y[4+(3+(0+4)*4)*7], dt19y[5+(3+(0+4)*4)*7], dt19y[6+(3+(0+4)*4)*7], dt19y[0+(0+(1+4)*4)*7], dt19y[1+(0+(1+4)*4)*7], dt19y[2+(0+(1+4)*4)*7], dt19y[3+(0+(1+4)*4)*7], dt19y[4+(0+(1+4)*4)*7], dt19y[5+(0+(1+4)*4)*7], dt19y[6+(0+(1+4)*4)*7], dt19y[0+(1+(1+4)*4)*7], dt19y[1+(1+(1+4)*4)*7], dt19y[2+(1+(1+4)*4)*7], dt19y[3+(1+(1+4)*4)*7], dt19y[4+(1+(1+4)*4)*7], dt19y[5+(1+(1+4)*4)*7], dt19y[6+(1+(1+4)*4)*7], dt19y[0+(2+(1+4)*4)*7], dt19y[1+(2+(1+4)*4)*7], dt19y[2+(2+(1+4)*4)*7], dt19y[3+(2+(1+4)*4)*7], dt19y[4+(2+(1+4)*4)*7], dt19y[5+(2+(1+4)*4)*7], dt19y[6+(2+(1+4)*4)*7], dt19y[0+(3+(1+4)*4)*7], dt19y[1+(3+(1+4)*4)*7], dt19y[2+(3+(1+4)*4)*7], dt19y[3+(3+(1+4)*4)*7], dt19y[4+(3+(1+4)*4)*7], dt19y[5+(3+(1+4)*4)*7], dt19y[6+(3+(1+4)*4)*7], dt19y[0+(0+(2+4)*4)*7], dt19y[1+(0+(2+4)*4)*7], dt19y[2+(0+(2+4)*4)*7], dt19y[3+(0+(2+4)*4)*7], dt19y[4+(0+(2+4)*4)*7], dt19y[5+(0+(2+4)*4)*7], dt19y[6+(0+(2+4)*4)*7], dt19y[0+(1+(2+4)*4)*7], dt19y[1+(1+(2+4)*4)*7], dt19y[2+(1+(2+4)*4)*7], dt19y[3+(1+(2+4)*4)*7], dt19y[4+(1+(2+4)*4)*7], dt19y[5+(1+(2+4)*4)*7], dt19y[6+(1+(2+4)*4)*7], dt19y[0+(2+(2+4)*4)*7], dt19y[1+(2+(2+4)*4)*7], dt19y[2+(2+(2+4)*4)*7], dt19y[3+(2+(2+4)*4)*7], dt19y[4+(2+(2+4)*4)*7], dt19y[5+(2+(2+4)*4)*7], dt19y[6+(2+(2+4)*4)*7], dt19y[0+(3+(2+4)*4)*7], dt19y[1+(3+(2+4)*4)*7], dt19y[2+(3+(2+4)*4)*7], dt19y[3+(3+(2+4)*4)*7], dt19y[4+(3+(2+4)*4)*7], dt19y[5+(3+(2+4)*4)*7], dt19y[6+(3+(2+4)*4)*7], dt19y[0+(0+(3+4)*4)*7], dt19y[1+(0+(3+4)*4)*7], dt19y[2+(0+(3+4)*4)*7], dt19y[3+(0+(3+4)*4)*7], dt19y[4+(0+(3+4)*4)*7], dt19y[5+(0+(3+4)*4)*7], dt19y[6+(0+(3+4)*4)*7], dt19y[0+(1+(3+4)*4)*7], dt19y[1+(1+(3+4)*4)*7], dt19y[2+(1+(3+4)*4)*7], dt19y[3+(1+(3+4)*4)*7], dt19y[4+(1+(3+4)*4)*7], dt19y[5+(1+(3+4)*4)*7], dt19y[6+(1+(3+4)*4)*7], dt19y[0+(2+(3+4)*4)*7], dt19y[1+(2+(3+4)*4)*7], dt19y[2+(2+(3+4)*4)*7], dt19y[3+(2+(3+4)*4)*7], dt19y[4+(2+(3+4)*4)*7], dt19y[5+(2+(3+4)*4)*7], dt19y[6+(2+(3+4)*4)*7], dt19y[0+(3+(3+4)*4)*7], dt19y[1+(3+(3+4)*4)*7], dt19y[2+(3+(3+4)*4)*7], dt19y[3+(3+(3+4)*4)*7], dt19y[4+(3+(3+4)*4)*7], dt19y[5+(3+(3+4)*4)*7], dt19y[6+(3+(3+4)*4)*7] = .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .7, 0., 0., 0., 0., 0., 0., 1.7, 0., 0., 0., 0., 0., 0., -2.6, 0., 0., 0., 0., 0., 0., .5, -.9, .3, 0., 0., 0., 0., 4.0, -.9, -.3, 0., 0., 0., 0., -.5, -.9, 1.5, 0., 0., 0., 0., -1.5, -.9, -1.8, 0., 0., 0., 0., .5, -.9, .3, .7, -.6, .2, .8, 3.7, -.9, -1.2, .7, -1.5, .2, 2.2, -.3, -.9, 2.1, .7, -1.6, .2, 2.0, -1.6, -.9, -2.1, .7, 2.9, .2, -3.8
		dt19y[0+(0+(0+8)*4)*7], dt19y[1+(0+(0+8)*4)*7], dt19y[2+(0+(0+8)*4)*7], dt19y[3+(0+(0+8)*4)*7], dt19y[4+(0+(0+8)*4)*7], dt19y[5+(0+(0+8)*4)*7], dt19y[6+(0+(0+8)*4)*7], dt19y[0+(1+(0+8)*4)*7], dt19y[1+(1+(0+8)*4)*7], dt19y[2+(1+(0+8)*4)*7], dt19y[3+(1+(0+8)*4)*7], dt19y[4+(1+(0+8)*4)*7], dt19y[5+(1+(0+8)*4)*7], dt19y[6+(1+(0+8)*4)*7], dt19y[0+(2+(0+8)*4)*7], dt19y[1+(2+(0+8)*4)*7], dt19y[2+(2+(0+8)*4)*7], dt19y[3+(2+(0+8)*4)*7], dt19y[4+(2+(0+8)*4)*7], dt19y[5+(2+(0+8)*4)*7], dt19y[6+(2+(0+8)*4)*7], dt19y[0+(3+(0+8)*4)*7], dt19y[1+(3+(0+8)*4)*7], dt19y[2+(3+(0+8)*4)*7], dt19y[3+(3+(0+8)*4)*7], dt19y[4+(3+(0+8)*4)*7], dt19y[5+(3+(0+8)*4)*7], dt19y[6+(3+(0+8)*4)*7], dt19y[0+(0+(1+8)*4)*7], dt19y[1+(0+(1+8)*4)*7], dt19y[2+(0+(1+8)*4)*7], dt19y[3+(0+(1+8)*4)*7], dt19y[4+(0+(1+8)*4)*7], dt19y[5+(0+(1+8)*4)*7], dt19y[6+(0+(1+8)*4)*7], dt19y[0+(1+(1+8)*4)*7], dt19y[1+(1+(1+8)*4)*7], dt19y[2+(1+(1+8)*4)*7], dt19y[3+(1+(1+8)*4)*7], dt19y[4+(1+(1+8)*4)*7], dt19y[5+(1+(1+8)*4)*7], dt19y[6+(1+(1+8)*4)*7], dt19y[0+(2+(1+8)*4)*7], dt19y[1+(2+(1+8)*4)*7], dt19y[2+(2+(1+8)*4)*7], dt19y[3+(2+(1+8)*4)*7], dt19y[4+(2+(1+8)*4)*7], dt19y[5+(2+(1+8)*4)*7], dt19y[6+(2+(1+8)*4)*7], dt19y[0+(3+(1+8)*4)*7], dt19y[1+(3+(1+8)*4)*7], dt19y[2+(3+(1+8)*4)*7], dt19y[3+(3+(1+8)*4)*7], dt19y[4+(3+(1+8)*4)*7], dt19y[5+(3+(1+8)*4)*7], dt19y[6+(3+(1+8)*4)*7], dt19y[0+(0+(2+8)*4)*7], dt19y[1+(0+(2+8)*4)*7], dt19y[2+(0+(2+8)*4)*7], dt19y[3+(0+(2+8)*4)*7], dt19y[4+(0+(2+8)*4)*7], dt19y[5+(0+(2+8)*4)*7], dt19y[6+(0+(2+8)*4)*7], dt19y[0+(1+(2+8)*4)*7], dt19y[1+(1+(2+8)*4)*7], dt19y[2+(1+(2+8)*4)*7], dt19y[3+(1+(2+8)*4)*7], dt19y[4+(1+(2+8)*4)*7], dt19y[5+(1+(2+8)*4)*7], dt19y[6+(1+(2+8)*4)*7], dt19y[0+(2+(2+8)*4)*7], dt19y[1+(2+(2+8)*4)*7], dt19y[2+(2+(2+8)*4)*7], dt19y[3+(2+(2+8)*4)*7], dt19y[4+(2+(2+8)*4)*7], dt19y[5+(2+(2+8)*4)*7], dt19y[6+(2+(2+8)*4)*7], dt19y[0+(3+(2+8)*4)*7], dt19y[1+(3+(2+8)*4)*7], dt19y[2+(3+(2+8)*4)*7], dt19y[3+(3+(2+8)*4)*7], dt19y[4+(3+(2+8)*4)*7], dt19y[5+(3+(2+8)*4)*7], dt19y[6+(3+(2+8)*4)*7], dt19y[0+(0+(3+8)*4)*7], dt19y[1+(0+(3+8)*4)*7], dt19y[2+(0+(3+8)*4)*7], dt19y[3+(0+(3+8)*4)*7], dt19y[4+(0+(3+8)*4)*7], dt19y[5+(0+(3+8)*4)*7], dt19y[6+(0+(3+8)*4)*7], dt19y[0+(1+(3+8)*4)*7], dt19y[1+(1+(3+8)*4)*7], dt19y[2+(1+(3+8)*4)*7], dt19y[3+(1+(3+8)*4)*7], dt19y[4+(1+(3+8)*4)*7], dt19y[5+(1+(3+8)*4)*7], dt19y[6+(1+(3+8)*4)*7], dt19y[0+(2+(3+8)*4)*7], dt19y[1+(2+(3+8)*4)*7], dt19y[2+(2+(3+8)*4)*7], dt19y[3+(2+(3+8)*4)*7], dt19y[4+(2+(3+8)*4)*7], dt19y[5+(2+(3+8)*4)*7], dt19y[6+(2+(3+8)*4)*7], dt19y[0+(3+(3+8)*4)*7], dt19y[1+(3+(3+8)*4)*7], dt19y[2+(3+(3+8)*4)*7], dt19y[3+(3+(3+8)*4)*7], dt19y[4+(3+(3+8)*4)*7], dt19y[5+(3+(3+8)*4)*7], dt19y[6+(3+(3+8)*4)*7] = .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .7, 0., 0., 0., 0., 0., 0., 1.7, 0., 0., 0., 0., 0., 0., -2.6, 0., 0., 0., 0., 0., 0., .5, -.9, 0., 0., 0., 0., 0., 4.0, -6.3, 0., 0., 0., 0., 0., -.5, .3, 0., 0., 0., 0., 0., -1.5, 3.0, 0., 0., 0., 0., 0., .5, -.9, .3, .7, 0., 0., 0., 3.7, -7.2, 3.0, 1.7, 0., 0., 0., -.3, .9, -.7, 1.9, 0., 0., 0., -1.6, 2.7, -.7, -3.4, 0., 0., 0.
		dt19y[0+(0+(0+12)*4)*7], dt19y[1+(0+(0+12)*4)*7], dt19y[2+(0+(0+12)*4)*7], dt19y[3+(0+(0+12)*4)*7], dt19y[4+(0+(0+12)*4)*7], dt19y[5+(0+(0+12)*4)*7], dt19y[6+(0+(0+12)*4)*7], dt19y[0+(1+(0+12)*4)*7], dt19y[1+(1+(0+12)*4)*7], dt19y[2+(1+(0+12)*4)*7], dt19y[3+(1+(0+12)*4)*7], dt19y[4+(1+(0+12)*4)*7], dt19y[5+(1+(0+12)*4)*7], dt19y[6+(1+(0+12)*4)*7], dt19y[0+(2+(0+12)*4)*7], dt19y[1+(2+(0+12)*4)*7], dt19y[2+(2+(0+12)*4)*7], dt19y[3+(2+(0+12)*4)*7], dt19y[4+(2+(0+12)*4)*7], dt19y[5+(2+(0+12)*4)*7], dt19y[6+(2+(0+12)*4)*7], dt19y[0+(3+(0+12)*4)*7], dt19y[1+(3+(0+12)*4)*7], dt19y[2+(3+(0+12)*4)*7], dt19y[3+(3+(0+12)*4)*7], dt19y[4+(3+(0+12)*4)*7], dt19y[5+(3+(0+12)*4)*7], dt19y[6+(3+(0+12)*4)*7], dt19y[0+(0+(1+12)*4)*7], dt19y[1+(0+(1+12)*4)*7], dt19y[2+(0+(1+12)*4)*7], dt19y[3+(0+(1+12)*4)*7], dt19y[4+(0+(1+12)*4)*7], dt19y[5+(0+(1+12)*4)*7], dt19y[6+(0+(1+12)*4)*7], dt19y[0+(1+(1+12)*4)*7], dt19y[1+(1+(1+12)*4)*7], dt19y[2+(1+(1+12)*4)*7], dt19y[3+(1+(1+12)*4)*7], dt19y[4+(1+(1+12)*4)*7], dt19y[5+(1+(1+12)*4)*7], dt19y[6+(1+(1+12)*4)*7], dt19y[0+(2+(1+12)*4)*7], dt19y[1+(2+(1+12)*4)*7], dt19y[2+(2+(1+12)*4)*7], dt19y[3+(2+(1+12)*4)*7], dt19y[4+(2+(1+12)*4)*7], dt19y[5+(2+(1+12)*4)*7], dt19y[6+(2+(1+12)*4)*7], dt19y[0+(3+(1+12)*4)*7], dt19y[1+(3+(1+12)*4)*7], dt19y[2+(3+(1+12)*4)*7], dt19y[3+(3+(1+12)*4)*7], dt19y[4+(3+(1+12)*4)*7], dt19y[5+(3+(1+12)*4)*7], dt19y[6+(3+(1+12)*4)*7], dt19y[0+(0+(2+12)*4)*7], dt19y[1+(0+(2+12)*4)*7], dt19y[2+(0+(2+12)*4)*7], dt19y[3+(0+(2+12)*4)*7], dt19y[4+(0+(2+12)*4)*7], dt19y[5+(0+(2+12)*4)*7], dt19y[6+(0+(2+12)*4)*7], dt19y[0+(1+(2+12)*4)*7], dt19y[1+(1+(2+12)*4)*7], dt19y[2+(1+(2+12)*4)*7], dt19y[3+(1+(2+12)*4)*7], dt19y[4+(1+(2+12)*4)*7], dt19y[5+(1+(2+12)*4)*7], dt19y[6+(1+(2+12)*4)*7], dt19y[0+(2+(2+12)*4)*7], dt19y[1+(2+(2+12)*4)*7], dt19y[2+(2+(2+12)*4)*7], dt19y[3+(2+(2+12)*4)*7], dt19y[4+(2+(2+12)*4)*7], dt19y[5+(2+(2+12)*4)*7], dt19y[6+(2+(2+12)*4)*7], dt19y[0+(3+(2+12)*4)*7], dt19y[1+(3+(2+12)*4)*7], dt19y[2+(3+(2+12)*4)*7], dt19y[3+(3+(2+12)*4)*7], dt19y[4+(3+(2+12)*4)*7], dt19y[5+(3+(2+12)*4)*7], dt19y[6+(3+(2+12)*4)*7], dt19y[0+(0+(3+12)*4)*7], dt19y[1+(0+(3+12)*4)*7], dt19y[2+(0+(3+12)*4)*7], dt19y[3+(0+(3+12)*4)*7], dt19y[4+(0+(3+12)*4)*7], dt19y[5+(0+(3+12)*4)*7], dt19y[6+(0+(3+12)*4)*7], dt19y[0+(1+(3+12)*4)*7], dt19y[1+(1+(3+12)*4)*7], dt19y[2+(1+(3+12)*4)*7], dt19y[3+(1+(3+12)*4)*7], dt19y[4+(1+(3+12)*4)*7], dt19y[5+(1+(3+12)*4)*7], dt19y[6+(1+(3+12)*4)*7], dt19y[0+(2+(3+12)*4)*7], dt19y[1+(2+(3+12)*4)*7], dt19y[2+(2+(3+12)*4)*7], dt19y[3+(2+(3+12)*4)*7], dt19y[4+(2+(3+12)*4)*7], dt19y[5+(2+(3+12)*4)*7], dt19y[6+(2+(3+12)*4)*7], dt19y[0+(3+(3+12)*4)*7], dt19y[1+(3+(3+12)*4)*7], dt19y[2+(3+(3+12)*4)*7], dt19y[3+(3+(3+12)*4)*7], dt19y[4+(3+(3+12)*4)*7], dt19y[5+(3+(3+12)*4)*7], dt19y[6+(3+(3+12)*4)*7] = .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .7, 0., 0., 0., 0., 0., 0., 1.7, 0., 0., 0., 0., 0., 0., -2.6, 0., 0., 0., 0., 0., 0., .5, -.9, .3, 0., 0., 0., 0., .7, -.9, 1.2, 0., 0., 0., 0., 1.7, -.9, .5, 0., 0., 0., 0., -2.6, -.9, -1.3, 0., 0., 0., 0., .5, -.9, .3, .7, -.6, .2, .8, .7, -.9, 1.2, .7, -1.5, .2, 1.6, 1.7, -.9, .5, .7, -1.6, .2, 2.4, -2.6, -.9, -1.3, .7, 2.9, .2, -4.0

		for _, icase = range []int{1, 2, 5, 6, 12, 13} {
			for off = 0; off <= 25; off += 5 {
				for ki = 1; ki <= 4; ki++ {
					incx = incxs[ki-1]
					incy = incys[ki-1]
					mx = absint(incx)
					my = absint(incy)

					for kn = 1; kn <= 4; kn++ {
						n = ns[kn-1]
						ksize = minint(int(2), kn)
						lenx = lens[kn-1+(mx-1)*4]
						leny = lens[kn-1+(my-1)*4]
						for i = 1; i <= 7; i++ {
							sx[i-1+off] = dx1[i-1]
							sxf[i-1+off] = float32(dx1[i-1])
							sy[i-1+off] = dy1[i-1]
							syf[i-1+off] = float32(dy1[i-1])
						}

						if icase == 1 {
							dcompare1(func() *float64 { y := Ddot(&n, &sx, &off, &incx, &sy, &off, &incy); return &y }(), &(dt7[kn-1+(ki-1)*4]), &ssize1, func() *int { y := kn - 1; return &y }(), &sfac, t, []byte("Ddot"))
						} else if icase == 2 {
							Daxpy(&n, &sa, &sx, &off, &incx, &sy, &off, &incy)
							for j = 1; j <= leny; j++ {
								sty[j-1] = dt8[j-1+(kn-1+(ki-1)*4)*7]
							}
							dcompare(&leny, &sy, &off, &sty, &izero, &ssize2, func() *int { y := 0 + (ksize-1)*14; return &y }(), &sfac, t, []byte("Daxpy"))
						} else if icase == 5 {
							for i = 1; i <= 7; i++ {
								sty[i-1] = dt10y[i-1+(kn-1+(ki-1)*4)*7]
							}
							Dcopy(&n, &sx, &off, &incx, &sy, &off, &incy)
							dcompare(&leny, &sy, &off, &sty, &izero, &ssize2, &izero, func() *float64 { y := float64(1.0); return &y }(), t, []byte("Dcopy"))
						} else if icase == 6 {
							Dswap(&n, &sx, &off, &incx, &sy, &off, &incy)
							for i = 1; i <= 7; i++ {
								stx[i-1] = dt10x[i-1+(kn-1+(ki-1)*4)*7]
								sty[i-1] = dt10y[i-1+(kn-1+(ki-1)*4)*7]
							}
							dcompare(&lenx, &sx, &off, &stx, &izero, &ssize2, &izero, func() *float64 { y := float64(1.0); return &y }(), t, []byte("Dswap"))
							dcompare(&leny, &sy, &off, &sty, &izero, &ssize2, &izero, func() *float64 { y := float64(1.0); return &y }(), t, []byte("Dswap"))
						} else if icase == 12 {
							kni = kn + 4*(ki-1)
							for kpar = 1; kpar <= 4; kpar++ {
								for i = 1; i <= 7; i++ {
									sx[i-1+off] = dx1[i-1]
									sy[i-1+off] = dy1[i-1]
									stx[i-1] = dt19x[i-1+(kpar-1+(kni-1)*4)*7]
									sty[i-1] = dt19y[i-1+(kpar-1+(kni-1)*4)*7]
								}

								for i = 1; i <= 5; i++ {
									dtemp[i-1] = dpar[i-1+(kpar-1)*5]
								}

								for i = 1; i <= lenx; i++ {
									ssize[i-1] = stx[i-1]
								}
								//                   SEE REMARK ABOVE ABOUT DT11X(1,2,7)
								//                       AND DT11X(5,3,8).
								if (kpar == 2) && (kni == 7) {
									ssize[0] = 2.4
								}
								if (kpar == 3) && (kni == 8) {
									ssize[4] = 1.8
								}

								Drotm(&n, &sx, &off, &incx, &sy, &off, &incy, &dtemp)
								dcompare(&lenx, &sx, &off, &stx, &izero, &ssize, &izero, &sfac, t, []byte("Drotm"))
								dcompare(&leny, &sy, &off, &sty, &izero, &sty, &izero, &sfac, t, []byte("Drotm"))
							}
						} else if icase == 13 {
							scompare1(func() *float32 {
								y := float32(Dsdot(&n, &sxf, &off, &incx, &syf, &off, &incy))
								return &y
							}(), &(st7[kn-1+(ki-1)*4]), &ssize1f, func() *int { y := kn - 1; return &y }(), func() *float32 { y := float32(0.3125e-1); return &y }(), t, []byte("Dsdot"))
						}
					}
				}
			}
		}
	}
	{
		// Tests for Drot
		var sc float64 = 0.8
		var ss float64 = 0.6
		copyx := make([]float64, 5*25)
		copyy := make([]float64, 5*25)
		var dx1 []float64 = []float64{0.6, 0.1, -0.5, 0.8, 0.9, -0.3, -0.4}
		var dy1 []float64 = []float64{0.5, -0.9, 0.3, 0.7, -0.6, 0.2, 0.8}
		mwpc := make([]float64, 11)
		mwps := make([]float64, 11)
		mwpstx := make([]float64, 5)
		mwpsty := make([]float64, 5)
		mwpx := make([]float64, 5)
		mwpy := make([]float64, 5)
		stx := make([]float64, 7)
		sty := make([]float64, 7)
		sx := make([]float64, 7*25)
		sy := make([]float64, 7*25)
		var incxs []int = []int{1, 2, -2, -1}
		var incys []int = []int{1, -2, 1, -2}
		mwpinx := make([]int, 11)
		dt9x := make([]float64, 7*4*4)
		dt9y := make([]float64, 7*4*4)
		mwpiny := make([]int, 11)
		mwpn := make([]int, 11)
		var ns []int = []int{0, 1, 2, 4}
		mwptx := make([]float64, 11*5)
		mwpty := make([]float64, 11*5)
		ssize2 := make([]float64, 14*2)
		lens := make([]int, 4*2)

		lens[0+(0)*4], lens[1+(0)*4], lens[2+(0)*4], lens[3+(0)*4], lens[0+(1)*4], lens[1+(1)*4], lens[2+(1)*4], lens[3+(1)*4] = 1, 1, 2, 4, 1, 1, 3, 7
		dt9x[0+(0+(0)*4)*4], dt9x[1+(0+(0)*4)*4], dt9x[2+(0+(0)*4)*4], dt9x[3+(0+(0)*4)*4], dt9x[4+(0+(0)*4)*4], dt9x[5+(0+(0)*4)*4], dt9x[6+(0+(0)*4)*4], dt9x[0+(1+(0)*4)*4], dt9x[1+(1+(0)*4)*4], dt9x[2+(1+(0)*4)*4], dt9x[3+(1+(0)*4)*4], dt9x[4+(1+(0)*4)*4], dt9x[5+(1+(0)*4)*4], dt9x[6+(1+(0)*4)*4], dt9x[0+(2+(0)*4)*4], dt9x[1+(2+(0)*4)*4], dt9x[2+(2+(0)*4)*4], dt9x[3+(2+(0)*4)*4], dt9x[4+(2+(0)*4)*4], dt9x[5+(2+(0)*4)*4], dt9x[6+(2+(0)*4)*4], dt9x[0+(3+(0)*4)*4], dt9x[1+(3+(0)*4)*4], dt9x[2+(3+(0)*4)*4], dt9x[3+(3+(0)*4)*4], dt9x[4+(3+(0)*4)*4], dt9x[5+(3+(0)*4)*4], dt9x[6+(3+(0)*4)*4], dt9x[0+(0+(1)*4)*4], dt9x[1+(0+(1)*4)*4], dt9x[2+(0+(1)*4)*4], dt9x[3+(0+(1)*4)*4], dt9x[4+(0+(1)*4)*4], dt9x[5+(0+(1)*4)*4], dt9x[6+(0+(1)*4)*4], dt9x[0+(1+(1)*4)*4], dt9x[1+(1+(1)*4)*4], dt9x[2+(1+(1)*4)*4], dt9x[3+(1+(1)*4)*4], dt9x[4+(1+(1)*4)*4], dt9x[5+(1+(1)*4)*4], dt9x[6+(1+(1)*4)*4], dt9x[0+(2+(1)*4)*4], dt9x[1+(2+(1)*4)*4], dt9x[2+(2+(1)*4)*4], dt9x[3+(2+(1)*4)*4], dt9x[4+(2+(1)*4)*4], dt9x[5+(2+(1)*4)*4], dt9x[6+(2+(1)*4)*4], dt9x[0+(3+(1)*4)*4], dt9x[1+(3+(1)*4)*4], dt9x[2+(3+(1)*4)*4], dt9x[3+(3+(1)*4)*4], dt9x[4+(3+(1)*4)*4], dt9x[5+(3+(1)*4)*4], dt9x[6+(3+(1)*4)*4], dt9x[0+(0+(2)*4)*4], dt9x[1+(0+(2)*4)*4], dt9x[2+(0+(2)*4)*4], dt9x[3+(0+(2)*4)*4], dt9x[4+(0+(2)*4)*4], dt9x[5+(0+(2)*4)*4], dt9x[6+(0+(2)*4)*4], dt9x[0+(1+(2)*4)*4], dt9x[1+(1+(2)*4)*4], dt9x[2+(1+(2)*4)*4], dt9x[3+(1+(2)*4)*4], dt9x[4+(1+(2)*4)*4], dt9x[5+(1+(2)*4)*4], dt9x[6+(1+(2)*4)*4], dt9x[0+(2+(2)*4)*4], dt9x[1+(2+(2)*4)*4], dt9x[2+(2+(2)*4)*4], dt9x[3+(2+(2)*4)*4], dt9x[4+(2+(2)*4)*4], dt9x[5+(2+(2)*4)*4], dt9x[6+(2+(2)*4)*4], dt9x[0+(3+(2)*4)*4], dt9x[1+(3+(2)*4)*4], dt9x[2+(3+(2)*4)*4], dt9x[3+(3+(2)*4)*4], dt9x[4+(3+(2)*4)*4], dt9x[5+(3+(2)*4)*4], dt9x[6+(3+(2)*4)*4], dt9x[0+(0+(3)*4)*4], dt9x[1+(0+(3)*4)*4], dt9x[2+(0+(3)*4)*4], dt9x[3+(0+(3)*4)*4], dt9x[4+(0+(3)*4)*4], dt9x[5+(0+(3)*4)*4], dt9x[6+(0+(3)*4)*4], dt9x[0+(1+(3)*4)*4], dt9x[1+(1+(3)*4)*4], dt9x[2+(1+(3)*4)*4], dt9x[3+(1+(3)*4)*4], dt9x[4+(1+(3)*4)*4], dt9x[5+(1+(3)*4)*4], dt9x[6+(1+(3)*4)*4], dt9x[0+(2+(3)*4)*4], dt9x[1+(2+(3)*4)*4], dt9x[2+(2+(3)*4)*4], dt9x[3+(2+(3)*4)*4], dt9x[4+(2+(3)*4)*4], dt9x[5+(2+(3)*4)*4], dt9x[6+(2+(3)*4)*4], dt9x[0+(3+(3)*4)*4], dt9x[1+(3+(3)*4)*4], dt9x[2+(3+(3)*4)*4], dt9x[3+(3+(3)*4)*4], dt9x[4+(3+(3)*4)*4], dt9x[5+(3+(3)*4)*4], dt9x[6+(3+(3)*4)*4] = 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.78, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.78, -0.46, 0.0, 0.0, 0.0, 0.0, 0.0, 0.78, -0.46, -0.22, 1.06, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.78, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.66, 0.1, -0.1, 0.0, 0.0, 0.0, 0.0, 0.96, 0.1, -0.76, 0.8, 0.90, -0.3, -0.02, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.78, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.06, 0.1, -0.1, 0.0, 0.0, 0.0, 0.0, 0.90, 0.1, -0.22, 0.8, 0.18, -0.3, -0.02, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.78, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.78, 0.26, 0.0, 0.0, 0.0, 0.0, 0.0, 0.78, 0.26, -0.76, 1.12, 0.0, 0.0, 0.0
		dt9y[0+(0+(0)*4)*4], dt9y[1+(0+(0)*4)*4], dt9y[2+(0+(0)*4)*4], dt9y[3+(0+(0)*4)*4], dt9y[4+(0+(0)*4)*4], dt9y[5+(0+(0)*4)*4], dt9y[6+(0+(0)*4)*4], dt9y[0+(1+(0)*4)*4], dt9y[1+(1+(0)*4)*4], dt9y[2+(1+(0)*4)*4], dt9y[3+(1+(0)*4)*4], dt9y[4+(1+(0)*4)*4], dt9y[5+(1+(0)*4)*4], dt9y[6+(1+(0)*4)*4], dt9y[0+(2+(0)*4)*4], dt9y[1+(2+(0)*4)*4], dt9y[2+(2+(0)*4)*4], dt9y[3+(2+(0)*4)*4], dt9y[4+(2+(0)*4)*4], dt9y[5+(2+(0)*4)*4], dt9y[6+(2+(0)*4)*4], dt9y[0+(3+(0)*4)*4], dt9y[1+(3+(0)*4)*4], dt9y[2+(3+(0)*4)*4], dt9y[3+(3+(0)*4)*4], dt9y[4+(3+(0)*4)*4], dt9y[5+(3+(0)*4)*4], dt9y[6+(3+(0)*4)*4], dt9y[0+(0+(1)*4)*4], dt9y[1+(0+(1)*4)*4], dt9y[2+(0+(1)*4)*4], dt9y[3+(0+(1)*4)*4], dt9y[4+(0+(1)*4)*4], dt9y[5+(0+(1)*4)*4], dt9y[6+(0+(1)*4)*4], dt9y[0+(1+(1)*4)*4], dt9y[1+(1+(1)*4)*4], dt9y[2+(1+(1)*4)*4], dt9y[3+(1+(1)*4)*4], dt9y[4+(1+(1)*4)*4], dt9y[5+(1+(1)*4)*4], dt9y[6+(1+(1)*4)*4], dt9y[0+(2+(1)*4)*4], dt9y[1+(2+(1)*4)*4], dt9y[2+(2+(1)*4)*4], dt9y[3+(2+(1)*4)*4], dt9y[4+(2+(1)*4)*4], dt9y[5+(2+(1)*4)*4], dt9y[6+(2+(1)*4)*4], dt9y[0+(3+(1)*4)*4], dt9y[1+(3+(1)*4)*4], dt9y[2+(3+(1)*4)*4], dt9y[3+(3+(1)*4)*4], dt9y[4+(3+(1)*4)*4], dt9y[5+(3+(1)*4)*4], dt9y[6+(3+(1)*4)*4], dt9y[0+(0+(2)*4)*4], dt9y[1+(0+(2)*4)*4], dt9y[2+(0+(2)*4)*4], dt9y[3+(0+(2)*4)*4], dt9y[4+(0+(2)*4)*4], dt9y[5+(0+(2)*4)*4], dt9y[6+(0+(2)*4)*4], dt9y[0+(1+(2)*4)*4], dt9y[1+(1+(2)*4)*4], dt9y[2+(1+(2)*4)*4], dt9y[3+(1+(2)*4)*4], dt9y[4+(1+(2)*4)*4], dt9y[5+(1+(2)*4)*4], dt9y[6+(1+(2)*4)*4], dt9y[0+(2+(2)*4)*4], dt9y[1+(2+(2)*4)*4], dt9y[2+(2+(2)*4)*4], dt9y[3+(2+(2)*4)*4], dt9y[4+(2+(2)*4)*4], dt9y[5+(2+(2)*4)*4], dt9y[6+(2+(2)*4)*4], dt9y[0+(3+(2)*4)*4], dt9y[1+(3+(2)*4)*4], dt9y[2+(3+(2)*4)*4], dt9y[3+(3+(2)*4)*4], dt9y[4+(3+(2)*4)*4], dt9y[5+(3+(2)*4)*4], dt9y[6+(3+(2)*4)*4], dt9y[0+(0+(3)*4)*4], dt9y[1+(0+(3)*4)*4], dt9y[2+(0+(3)*4)*4], dt9y[3+(0+(3)*4)*4], dt9y[4+(0+(3)*4)*4], dt9y[5+(0+(3)*4)*4], dt9y[6+(0+(3)*4)*4], dt9y[0+(1+(3)*4)*4], dt9y[1+(1+(3)*4)*4], dt9y[2+(1+(3)*4)*4], dt9y[3+(1+(3)*4)*4], dt9y[4+(1+(3)*4)*4], dt9y[5+(1+(3)*4)*4], dt9y[6+(1+(3)*4)*4], dt9y[0+(2+(3)*4)*4], dt9y[1+(2+(3)*4)*4], dt9y[2+(2+(3)*4)*4], dt9y[3+(2+(3)*4)*4], dt9y[4+(2+(3)*4)*4], dt9y[5+(2+(3)*4)*4], dt9y[6+(2+(3)*4)*4], dt9y[0+(3+(3)*4)*4], dt9y[1+(3+(3)*4)*4], dt9y[2+(3+(3)*4)*4], dt9y[3+(3+(3)*4)*4], dt9y[4+(3+(3)*4)*4], dt9y[5+(3+(3)*4)*4], dt9y[6+(3+(3)*4)*4] = 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04, -0.78, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04, -0.78, 0.54, 0.08, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.7, -0.9, -0.12, 0.0, 0.0, 0.0, 0.0, 0.64, -0.9, -0.30, 0.7, -0.18, 0.2, 0.28, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.7, -1.08, 0.0, 0.0, 0.0, 0.0, 0.0, 0.64, -1.26, 0.54, 0.20, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04, -0.9, 0.18, 0.0, 0.0, 0.0, 0.0, 0.04, -0.9, 0.18, 0.7, -0.18, 0.2, 0.16
		ssize2[0+(0)*14], ssize2[1+(0)*14], ssize2[2+(0)*14], ssize2[3+(0)*14], ssize2[4+(0)*14], ssize2[5+(0)*14], ssize2[6+(0)*14], ssize2[7+(0)*14], ssize2[8+(0)*14], ssize2[9+(0)*14], ssize2[10+(0)*14], ssize2[11+(0)*14], ssize2[12+(0)*14], ssize2[13+(0)*14], ssize2[0+(1)*14], ssize2[1+(1)*14], ssize2[2+(1)*14], ssize2[3+(1)*14], ssize2[4+(1)*14], ssize2[5+(1)*14], ssize2[6+(1)*14], ssize2[7+(1)*14], ssize2[8+(1)*14], ssize2[9+(1)*14], ssize2[10+(1)*14], ssize2[11+(1)*14], ssize2[12+(1)*14], ssize2[13+(1)*14] = 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17

		n = 0
		for off = 0; off <= 25; off += 5 {
			for ki = 1; ki <= 4; ki++ {
				incx = incxs[ki-1]
				incy = incys[ki-1]
				mx = absint(incx)
				my = absint(incy)

				for kn = 1; kn <= 4; kn++ {
					n++
					ksize = minint(int(2), kn)
					lenx = lens[kn-1+(mx-1)*4]
					leny = lens[kn-1+(my-1)*4]

					for i = 1; i <= 7; i++ {
						sx[i-1+off] = dx1[i-1]
						sy[i-1+off] = dy1[i-1]
						stx[i-1] = dt9x[i-1+(kn-1+(ki-1)*4)*4]
						sty[i-1] = dt9y[i-1+(kn-1+(ki-1)*4)*4]
					}
					Drot(&ns[kn-1], &sx, &off, &incx, &sy, &off, &incy, &sc, &ss)
					dcompare(&lenx, &sx, &off, &stx, &izero, &ssize2, func() *int { y := (ksize - 1) * 14; return &y }(), &sfac, t, []byte("Drot"))
					dcompare(&leny, &sy, &off, &sty, &izero, &ssize2, func() *int { y := (ksize - 1) * 14; return &y }(), &sfac, t, []byte("Drot"))
				}
			}
		}

		mwpc[0] = 1
		for i = 2; i <= 11; i++ {
			mwpc[i-1] = 0
		}
		mwps[0] = 0
		for i = 2; i <= 6; i++ {
			mwps[i-1] = 1
		}
		for i = 7; i <= 11; i++ {
			mwps[i-1] = -1
		}
		mwpinx[0] = 1
		mwpinx[1] = 1
		mwpinx[2] = 1
		mwpinx[3] = -1
		mwpinx[4] = 1
		mwpinx[5] = -1
		mwpinx[6] = 1
		mwpinx[7] = 1
		mwpinx[8] = -1
		mwpinx[9] = 1
		mwpinx[10] = -1
		mwpiny[0] = 1
		mwpiny[1] = 1
		mwpiny[2] = -1
		mwpiny[3] = -1
		mwpiny[4] = 2
		mwpiny[5] = 1
		mwpiny[6] = 1
		mwpiny[7] = -1
		mwpiny[8] = -1
		mwpiny[9] = 2
		mwpiny[10] = 1
		for i = 1; i <= 11; i++ {
			mwpn[i-1] = 5
		}
		mwpn[4] = 3
		mwpn[9] = 3
		for i = 1; i <= 5; i++ {
			_i := float64(i)
			mwpx[i-1] = _i
			mwpy[i-1] = _i
			mwptx[0+(i-1)*11] = _i
			mwpty[0+(i-1)*11] = _i
			mwptx[1+(i-1)*11] = _i
			mwpty[1+(i-1)*11] = -_i
			mwptx[2+(i-1)*11] = 6 - _i
			mwpty[2+(i-1)*11] = _i - 6
			mwptx[3+(i-1)*11] = _i
			mwpty[3+(i-1)*11] = -_i
			mwptx[5+(i-1)*11] = 6 - _i
			mwpty[5+(i-1)*11] = _i - 6
			mwptx[6+(i-1)*11] = -_i
			mwpty[6+(i-1)*11] = _i
			mwptx[7+(i-1)*11] = _i - 6
			mwpty[7+(i-1)*11] = 6 - _i
			mwptx[8+(i-1)*11] = -_i
			mwpty[8+(i-1)*11] = _i
			mwptx[10+(i-1)*11] = _i - 6
			mwpty[10+(i-1)*11] = 6 - _i
		}
		mwptx[4+(0)*11] = 1
		mwptx[4+(1)*11] = 3
		mwptx[4+(2)*11] = 5
		mwptx[4+(3)*11] = 4
		mwptx[4+(4)*11] = 5
		mwpty[4+(0)*11] = -1
		mwpty[4+(1)*11] = 2
		mwpty[4+(2)*11] = -2
		mwpty[4+(3)*11] = 4
		mwpty[4+(4)*11] = -3
		mwptx[9+(0)*11] = -1
		mwptx[9+(1)*11] = -3
		mwptx[9+(2)*11] = -5
		mwptx[9+(3)*11] = 4
		mwptx[9+(4)*11] = 5
		mwpty[9+(0)*11] = 1
		mwpty[9+(1)*11] = 2
		mwpty[9+(2)*11] = 2
		mwpty[9+(3)*11] = 4
		mwpty[9+(4)*11] = 3
		for off = 0; off <= 25; off += 5 {
			for i = 1; i <= 11; i++ {
				n++
				incx = mwpinx[i-1]
				incy = mwpiny[i-1]
				for k = 1; k <= 5; k++ {
					copyx[k-1+off] = mwpx[k-1]
					copyy[k-1+off] = mwpy[k-1]
					mwpstx[k-1] = mwptx[i-1+(k-1)*11]
					mwpsty[k-1] = mwpty[i-1+(k-1)*11]
				}
				Drot(&(mwpn[i-1]), &copyx, &off, &incx, &copyy, &off, &incy, &(mwpc[i-1]), &(mwps[i-1]))
				dcompare(&ifive, &copyx, &off, &mwpstx, &izero, &mwpstx, &izero, &sfac, t, []byte("Drot"))
				dcompare(&ifive, &copyy, &off, &mwpsty, &izero, &mwpsty, &izero, &sfac, t, []byte("Drot"))
			}
		}
	}
}

func TestDblasLevel2(t *testing.T) {
	var fatal, null, reset, same, tran, upper bool
	var diag, diags, trans, transs, uplo, uplos byte
	var alpha, als, beta, bls, err, errmax, transl float64
	var i, j, n int
	var ok bool = true
	var idim []int = []int{0, 1, 2, 3, 5, 9}
	var kb []int = []int{0, 1, 2, 4}
	var inc []int = []int{1, 2, -1, -2}
	var alf []float64 = []float64{0.0, 1.0, 0.7}
	var bet []float64 = []float64{0.0, 1.0, 0.9}
	var thresh float64 = 16.0
	var eps float64 = epsilonf64()
	var zero float64 = 0.0
	var half float64 = 0.5
	var one float64 = 1.0
	var nmax int = 65
	var incmax int = 2
	var inegone int = -1
	var izero int = 0
	var ione int = 1
	var itwo int = 2
	var snames [][]byte = [][]byte{[]byte("DGEMV"), []byte("DGBMV"), []byte("DSYMV"), []byte("DSBMV"), []byte("DSPMV"), []byte("DTRMV"), []byte("DTBMV"), []byte("DTPMV"), []byte("DTRSV"), []byte("DTBSV"), []byte("DTPSV"), []byte("DGER"), []byte("DSYR"), []byte("DSPR"), []byte("DSYR2"), []byte("DSPR2")}
	isame := make([]bool, 13)
	var ichd []byte = []byte{'U', 'N'}
	var icht []byte = []byte{'N', 'T', 'C'}
	var ichu []byte = []byte{'U', 'L'}
	a := make([]float64, nmax*nmax)
	aa := make([]float64, nmax*nmax)
	as := make([]float64, nmax*nmax)
	g := make([]float64, nmax)
	x := make([]float64, nmax)
	xs := make([]float64, nmax*incmax)
	xt := make([]float64, nmax)
	xx := make([]float64, nmax*incmax)
	y := make([]float64, nmax)
	ys := make([]float64, nmax*incmax)
	yt := make([]float64, nmax)
	yy := make([]float64, nmax*incmax)
	z := make([]float64, 2*nmax)

	n = minint(int(32), nmax)
	for j = 1; j <= n; j++ {
		for i = 1; i <= n; i++ {
			a[i-1+(j-1)*nmax] = float64(maxint(i-j+1, 0))
		}
		x[j-1] = float64(j)
		y[j-1] = zero
	}
	for j = 1; j <= n; j++ {
		yy[j-1] = float64(j*((j+1)*j))/2 - float64(((j+1)*j*(j-1)))/3
	}
	//     YY holds the exact result. On exit from SMVCH YT holds
	//     the result computed by SMVCH.
	trans = 'N'
	dmvch(&trans, &n, &n, &one, &a, &izero, &nmax, &x, &izero, &ione, &zero, &y, &izero, &ione, &yt, &g, &yy, &izero, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lde(&yy, &yt, &izero, &n)
	if !same || err != zero {
		t.Errorf(" ERROR IN DMVCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n SMVCH WAS CALLED WITH TRANS = %c AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", trans, same, err)
	}
	trans = 'T'
	dmvch(&trans, &n, &n, &one, &a, &izero, &nmax, &x, &izero, &inegone, &zero, &y, &izero, &inegone, &yt, &g, &yy, &izero, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lde(&yy, &yt, &izero, &n)
	if !same || err != zero {
		t.Errorf(" ERROR IN DMVCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n SMVCH WAS CALLED WITH TRANS = %c AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", trans, same, err)
	}
	for _, dname := range snames {
		if bytes.Equal(dname, []byte("DGEMV")) || bytes.Equal(dname, []byte("DGBMV")) {
			var aoff, i, im, incx, incxs, incy, incys, kl, kls, ku, kus, laa, lda, ldas, lx, ly, m, ml, ms, n, nargs, nc, nd, nl, ns, xoff, yoff int
			var full bool = dname[2] == 'E'
			var banded bool = dname[2] == 'B'

			ok = true
			if full {
				nargs = 11
			} else if banded {
				nargs = 13
			}

			nc = 0
			reset = true
			errmax = zero

			for aoff = 0; aoff <= 20; aoff += 10 {
				for xoff = 0; xoff <= 20; xoff += 10 {
					for yoff = 0; yoff <= 20; yoff += 10 {
						for _, n = range idim {
							nd = n/2 + 1

							for im = 1; im <= 2; im++ {
								if im == 1 {
									m = maxint(n-nd, 0)
								}
								if im == 2 {
									m = minint(n+nd, nmax)
								}

								for _, ku = range kb {
									if banded {
										kl = maxint(ku-1, 0)
									} else {
										ku = n - 1
										kl = m - 1
									}
									//              Set LDA to 1 more than minimum value if room.
									if banded {
										lda = kl + ku + 1
									} else {
										lda = m
									}
									if lda < nmax {
										lda++
									}
									//              Skip tests if not enough room.
									if lda > nmax {
										goto label100
									}
									laa = lda * n
									null = n <= 0 || m <= 0
									//
									//              Generate the matrix A.
									//
									transl = zero
									dmakeL2(func() *[]byte { y := dname[1:3]; return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &m, &n, &a, &nmax, &aa, &aoff, &lda, &kl, &ku, &reset, &transl)

									for _, trans = range []byte{'N', 'T', 'C'} {
										tran = trans == 'T' || trans == 'C'

										if tran {
											ml = n
											nl = m
										} else {
											ml = m
											nl = n
										}

										for _, incx = range inc {
											lx = absint(incx) * nl
											//
											//                    Generate the vector X.
											//
											transl = half
											dmakeL2(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &nl, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := nl - 1; return &y }(), &reset, &transl)
											if nl > 1 {
												x[nl/2-1+xoff] = zero
												xx[1+absint(incx)*(nl/2-1)-1+xoff] = zero
											}

											for _, incy = range inc {
												ly = absint(incy) * ml

												for _, alpha = range alf {

													for _, beta = range bet {
														//
														//                             Generate the vector Y.
														//
														transl = zero
														dmakeL2(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &ml, &y, &ione, &yy, &yoff, func() *int { y := absint(incy); return &y }(), &izero, func() *int { y := ml - 1; return &y }(), &reset, &transl)

														nc++
														//
														//                             Save every datum before calling the
														//                             subroutine.
														//
														transs = trans
														ms = m
														ns = n
														kls = kl
														kus = ku
														als = alpha
														for i = 1; i <= laa; i++ {
															as[i-1+aoff] = aa[i-1+aoff]
														}
														ldas = lda
														for i = 1; i <= lx; i++ {
															xs[i-1+xoff] = xx[i-1+xoff]
														}
														incxs = incx
														bls = beta
														for i = 1; i <= ly; i++ {
															ys[i-1+yoff] = yy[i-1+yoff]
														}
														incys = incy
														//
														//                             Call the subroutine.
														//
														if full {
															Dgemv(&trans, &m, &n, &alpha, &aa, &aoff, &lda, &xx, &xoff, &incx, &beta, &yy, &yoff, &incy)
														} else if banded {
															Dgbmv(&trans, &m, &n, &kl, &ku, &alpha, &aa, &aoff, &lda, &xx, &xoff, &incx, &beta, &yy, &yoff, &incy)
														}
														//
														//                             Check if error-exit was taken incorrectly.
														//
														if !ok {
															t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
															fatal = true
															goto label130
														}
														//
														//                             See what data changed inside subroutines.
														//
														isame[0] = trans == transs
														isame[1] = ms == m
														isame[2] = ns == n
														if full {
															isame[3] = als == alpha
															isame[4] = lde(&as, &aa, &aoff, &laa)
															isame[5] = ldas == lda
															isame[6] = lde(&xs, &xx, &xoff, &lx)
															isame[7] = incxs == incx
															isame[8] = bls == beta
															if null {
																isame[9] = lde(&ys, &yy, &yoff, &ly)
															} else {
																isame[9] = lderes(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &ml, &ys, &yy, &yoff, func() *int { y := absint(incy); return &y }())
															}
															isame[10] = incys == incy
														} else if banded {
															isame[3] = kls == kl
															isame[4] = kus == ku
															isame[5] = als == alpha
															isame[6] = lde(&as, &aa, &aoff, &laa)
															isame[7] = ldas == lda
															isame[8] = lde(&xs, &xx, &xoff, &lx)
															isame[9] = incxs == incx
															isame[10] = bls == beta
															if null {
																isame[11] = lde(&ys, &yy, &yoff, &ly)
															} else {
																isame[11] = lderes(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &ml, &ys, &yy, &yoff, func() *int { y := absint(incy); return &y }())
															}
															isame[12] = incys == incy
														}
														//
														//                             If data was incorrectly changed, report
														//                             and return.
														//
														same = true
														for i = 1; i <= nargs; i++ {
															same = same && isame[i-1]
															if !isame[i-1] {
																t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
															}
														}
														if !same {
															fatal = true
															goto label130
														}

														if !null {
															//
															//                                Check the result.
															//
															dmvch(&trans, &m, &n, &alpha, &a, &aoff, &nmax, &x, &xoff, &incx, &beta, &y, &yoff, &incy, &yt, &g, &yy, &yoff, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
															errmax = maxf64(errmax, err)
															//                                If got really bad answer, report and
															//                                return.
															if fatal {
																goto label130
															}
														} else {
															//                                Avoid repeating tests with M.le.0 or
															//                                N.le.0.
															goto label110
														}

													}

												}

											}

										}

									}

								label100:
								}

							label110:
							}

						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", dname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", dname, nc, errmax)
			}
			continue

		label130:
			if full {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%3d,%4.1f, A,%3d,%3d, X,%2d,%2d,%4.1f, Y,%2d,%2d)         .\n", dname, nc, dname, trans, m, n, alpha, izero, lda, izero, incx, beta, izero, incy)
			} else if banded {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%3d,%3d,%3d,%4.1f, A,%3d,%3d, X,%2d,%2d,%4.1f, Y,%2d,%2d) .\n", dname, nc, dname, trans, m, n, kl, ku, alpha, izero, lda, izero, incx, beta, izero, incy)
			}

		} else if bytes.Equal(dname, []byte("DSYMV")) || bytes.Equal(dname, []byte("DSBMV")) || bytes.Equal(dname, []byte("DSPMV")) {
			var aoff, i, incx, incxs, incy, incys, k, ks, laa, lda, ldas, lx, ly, n, nargs, nc, ns, xoff, yoff int
			var full bool = dname[2] == 'Y'
			var banded bool = dname[2] == 'B'
			var packed bool = dname[2] == 'P'

			//     Define the number of arguments.
			ok = true
			if full {
				nargs = 10
			} else if banded {
				nargs = 11
			} else if packed {
				nargs = 9
			}
			//
			nc = 0
			reset = true
			errmax = zero
			//
			for aoff = 0; aoff <= 30; aoff += 10 {
				for xoff = 0; xoff <= 30; xoff += 10 {
					for yoff = 0; yoff <= 30; yoff += 10 {
						for _, n = range idim {

							for _, k = range kb {
								if !banded {
									k = n - 1
								}
								//           Set LDA to 1 more than minimum value if room.
								if banded {
									lda = k + 1
								} else {
									lda = n
								}
								if lda < nmax {
									lda++
								}
								//           Skip tests if not enough room.
								if lda > nmax {
									goto label1100
								}
								if packed {
									laa = (n * (n + 1)) / 2
								} else {
									laa = lda * n
								}
								null = n <= 0

								for _, uplo = range ichu {
									//
									//              Generate the matrix A.
									//
									transl = zero
									dmakeL2(func() *[]byte { y := dname[1:3]; return &y }(), &uplo, func() *byte { y := byte(' '); return &y }(), &n, &n, &a, &nmax, &aa, &aoff, &lda, &k, &k, &reset, &transl)
									//
									for _, incx = range inc {
										lx = absint(incx) * n
										//
										//                 Generate the vector X.
										//
										transl = half
										dmakeL2(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &n, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
										if n > 1 {
											x[n/2-1+xoff] = zero
											xx[1+absint(incx)*(n/2-1)-1+xoff] = zero
										}

										for _, incy = range inc {
											ly = absint(incy) * n

											for _, alpha = range alf {

												for _, beta = range bet {
													//
													//                          Generate the vector Y.
													//
													transl = zero
													dmakeL2(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &n, &y, &ione, &yy, &yoff, func() *int { y := absint(incy); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
													//
													nc++
													//
													//                          Save every datum before calling the
													//                          subroutine.
													//
													uplos = uplo
													ns = n
													ks = k
													als = alpha
													for i = 1; i <= laa; i++ {
														as[i-1+aoff] = aa[i-1+aoff]
													}
													ldas = lda
													for i = 1; i <= lx; i++ {
														xs[i-1+xoff] = xx[i-1+xoff]
													}
													incxs = incx
													bls = beta
													for i = 1; i <= ly; i++ {
														ys[i-1+yoff] = yy[i-1+yoff]
													}
													incys = incy
													//
													//                          Call the subroutine.
													//
													if full {
														Dsymv(&uplo, &n, &alpha, &aa, &aoff, &lda, &xx, &xoff, &incx, &beta, &yy, &yoff, &incy)
													} else if banded {
														Dsbmv(&uplo, &n, &k, &alpha, &aa, &aoff, &lda, &xx, &xoff, &incx, &beta, &yy, &yoff, &incy)
													} else if packed {
														Dspmv(&uplo, &n, &alpha, &aa, &aoff, &xx, &xoff, &incx, &beta, &yy, &yoff, &incy)
													}
													//
													//                          Check if error-exit was taken incorrectly.
													//
													if !ok {
														t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
														fatal = true
														goto label1120
													}
													//
													//                          See what data changed inside subroutines.
													//
													isame[0] = uplo == uplos
													isame[1] = ns == n
													if full {
														isame[2] = als == alpha
														isame[3] = lde(&as, &aa, &aoff, &laa)
														isame[4] = ldas == lda
														isame[5] = lde(&xs, &xx, &xoff, &lx)
														isame[6] = incxs == incx
														isame[7] = bls == beta
														if null {
															isame[8] = lde(&ys, &yy, &yoff, &ly)
														} else {
															isame[8] = lderes(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &n, &ys, &yy, &yoff, func() *int { y := absint(incy); return &y }())
														}
														isame[9] = incys == incy
													} else if banded {
														isame[2] = ks == k
														isame[3] = als == alpha
														isame[4] = lde(&as, &aa, &aoff, &laa)
														isame[5] = ldas == lda
														isame[6] = lde(&xs, &xx, &xoff, &lx)
														isame[7] = incxs == incx
														isame[8] = bls == beta
														if null {
															isame[9] = lde(&ys, &yy, &yoff, &ly)
														} else {
															isame[9] = lderes(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &n, &ys, &yy, &yoff, func() *int { y := absint(incy); return &y }())
														}
														isame[10] = incys == incy
													} else if packed {
														isame[2] = als == alpha
														isame[3] = lde(&as, &aa, &aoff, &laa)
														isame[4] = lde(&xs, &xx, &xoff, &lx)
														isame[5] = incxs == incx
														isame[6] = bls == beta
														if null {
															isame[7] = lde(&ys, &yy, &yoff, &ly)
														} else {
															isame[7] = lderes(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &n, &ys, &yy, &yoff, func() *int { y := absint(incy); return &y }())
														}
														isame[8] = incys == incy
													}
													//
													//                          If data was incorrectly changed, report and
													//                          return.
													//
													same = true
													for i = 1; i <= nargs; i++ {
														same = same && isame[i-1]
														if !isame[i-1] {
															t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
														}
													}
													if !same {
														fatal = true
														goto label1120
													}

													if !null {
														//
														//                             Check the result.
														//
														dmvch(func() *byte { y := byte('N'); return &y }(), &n, &n, &alpha, &a, &aoff, &nmax, &x, &xoff, &incx, &beta, &y, &yoff, &incy, &yt, &g, &yy, &yoff, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
														errmax = maxf64(errmax, err)
														//                             If got really bad answer, report and
														//                             return.
														if fatal {
															goto label1120
														}
													} else {
														//                             Avoid repeating tests with N.le.0
														goto label1110
													}

												}

											}

										}
									}

								}

							label1100:
							}

						label1110:
						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", dname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", dname, nc, errmax)
			}
			continue
			//
		label1120:
			;
			if full {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, A,%3d,%3d, X,%2d,%2d,%4.1f, Y,%2d,%2d)             .\n", dname, nc, dname, uplo, n, alpha, aoff, lda, xoff, incx, beta, yoff, incy)
			} else if banded {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%3d,%4.1f, A,%3d,%3d, X,%2d,%2d,%4.1f, Y,%2d,%2d)         .\n", dname, nc, dname, uplo, n, k, alpha, aoff, lda, xoff, incx, beta, yoff, incy)
			} else if packed {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, AP,%3d, X,%2d,%2d,%4.1f, Y,%2d,%2d)                .\n", dname, nc, dname, uplo, n, alpha, aoff, xoff, incx, beta, yoff, incy)
			}

		} else if bytes.Equal(dname, []byte("DTRMV")) || bytes.Equal(dname, []byte("DTBMV")) || bytes.Equal(dname, []byte("DTPMV")) || bytes.Equal(dname, []byte("DTRSV")) || bytes.Equal(dname, []byte("DTBSV")) || bytes.Equal(dname, []byte("DTPSV")) {
			var aoff, i, incx, incxs, k, ks, laa, lda, ldas, lx, n, nargs, nc, ns, xoff int
			var full bool = dname[2] == 'R'
			var banded bool = dname[2] == 'B'
			var packed bool = dname[2] == 'P'

			//     Define the number of arguments.
			ok = true
			if full {
				nargs = 8
			} else if banded {
				nargs = 9
			} else if packed {
				nargs = 7
			}

			nc = 0
			reset = true
			errmax = zero
			//     Set up zero vector for SMVCH.
			for i = 1; i <= nmax; i++ {
				z[i-1] = zero
			}

			for aoff = 0; aoff <= 30; aoff += 10 {
				for xoff = 0; xoff <= 30; xoff += 10 {
					for _, n = range idim {

						for _, k = range kb {
							if !banded {
								k = n - 1
							}
							//           Set LDA to 1 more than minimum value if room.
							if banded {
								lda = k + 1
							} else {
								lda = n
							}
							if lda < nmax {
								lda++
							}
							//           Skip tests if not enough room.
							if lda > nmax {
								goto label2100
							}
							if packed {
								laa = (n * (n + 1)) / 2
							} else {
								laa = lda * n
							}
							null = n <= 0

							for _, uplo = range ichu {

								for _, trans = range icht {

									for _, diag = range ichd {
										//
										//                    Generate the matrix A.
										//
										transl = zero
										dmakeL2(func() *[]byte { y := dname[1:3]; return &y }(), &uplo, &diag, &n, &n, &a, &nmax, &aa, &aoff, &lda, &k, &k, &reset, &transl)

										for _, incx = range inc {
											lx = absint(incx) * n
											//
											//                       Generate the vector X.
											//
											transl = half
											dmakeL2(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &n, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
											if n > 1 {
												x[n/2-1+xoff] = zero
												xx[1+absint(incx)*(n/2-1)-1+xoff] = zero
											}

											nc++
											//
											//                       Save every datum before calling the subroutine.
											//
											uplos = uplo
											transs = trans
											diags = diag
											ns = n
											ks = k
											for i = 1; i <= laa; i++ {
												as[i-1+aoff] = aa[i-1+aoff]
											}
											ldas = lda
											for i = 1; i <= lx; i++ {
												xs[i-1+xoff] = xx[i-1+xoff]
											}
											incxs = incx
											//
											//                       Call the subroutine.
											//
											if bytes.Equal(dname[3:5], []byte("MV")) {
												if full {
													Dtrmv(&uplo, &trans, &diag, &n, &aa, &aoff, &lda, &xx, &xoff, &incx)
												} else if banded {
													Dtbmv(&uplo, &trans, &diag, &n, &k, &aa, &aoff, &lda, &xx, &xoff, &incx)
												} else if packed {
													Dtpmv(&uplo, &trans, &diag, &n, &aa, &aoff, &xx, &xoff, &incx)
												}
											} else if bytes.Equal(dname[3:5], []byte("SV")) {
												if full {
													Dtrsv(&uplo, &trans, &diag, &n, &aa, &aoff, &lda, &xx, &xoff, &incx)
												} else if banded {
													Dtbsv(&uplo, &trans, &diag, &n, &k, &aa, &aoff, &lda, &xx, &xoff, &incx)
												} else if packed {
													Dtpsv(&uplo, &trans, &diag, &n, &aa, &aoff, &xx, &xoff, &incx)
												}
											}
											//
											//                       Check if error-exit was taken incorrectly.
											//
											if !ok {
												t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
												fatal = true
												goto label2120
											}
											//
											//                       See what data changed inside subroutines.
											//
											isame[0] = uplo == uplos
											isame[1] = trans == transs
											isame[2] = diag == diags
											isame[3] = ns == n
											if full {
												isame[4] = lde(&as, &aa, &aoff, &laa)
												isame[5] = ldas == lda
												if null {
													isame[6] = lde(&xs, &xx, &xoff, &lx)
												} else {
													isame[6] = lderes(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &n, &xs, &xx, &xoff, func() *int { y := absint(incx); return &y }())
												}
												isame[7] = incxs == incx
											} else if banded {
												isame[4] = ks == k
												isame[5] = lde(&as, &aa, &aoff, &laa)
												isame[6] = ldas == lda
												if null {
													isame[7] = lde(&xs, &xx, &xoff, &lx)
												} else {
													isame[7] = lderes(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &n, &xs, &xx, &xoff, func() *int { y := absint(incx); return &y }())
												}
												isame[8] = incxs == incx
											} else if packed {
												isame[4] = lde(&as, &aa, &aoff, &laa)
												if null {
													isame[5] = lde(&xs, &xx, &xoff, &lx)
												} else {
													isame[5] = lderes(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &n, &xs, &xx, &xoff, func() *int { y := absint(incx); return &y }())
												}
												isame[6] = incxs == incx
											}
											//
											//                       If data was incorrectly changed, report and
											//                       return.
											//
											same = true
											for i = 1; i <= nargs; i++ {
												same = same && isame[i-1]
												if !isame[i-1] {
													t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
												}
											}
											if !same {
												fatal = true
												goto label2120
											}

											if !null {
												if bytes.Equal(dname[3:5], []byte("MV")) {
													//
													//                             Check the result.
													//
													dmvch(&trans, &n, &n, &one, &a, &aoff, &nmax, &x, &xoff, &incx, &zero, &z, &izero, &incx, &xt, &g, &xx, &xoff, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
												} else if bytes.Equal(dname[3:5], []byte("SV")) {
													//
													//                             Compute approximation to original vector.
													//
													for i = 1; i <= n; i++ {
														z[i-1] = xx[1+(i-1)*absint(incx)-1+xoff]
														xx[1+(i-1)*absint(incx)-1+xoff] = x[i-1+xoff]
													}
													dmvch(&trans, &n, &n, &one, &a, &aoff, &nmax, &z, &izero, &incx, &zero, &x, &xoff, &incx, &xt, &g, &xx, &xoff, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
												}
												errmax = maxf64(errmax, err)
												//                          If got really bad answer, report and return.
												if fatal {
													goto label2120
												}
											} else {
												//                          Avoid repeating tests with N.le.0.
												goto label2110
											}

										}

									}

								}

							}

						label2100:
						}

					label2110:
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", dname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", dname, nc, errmax)
			}
			continue

		label2120:
			;
			if full {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c','%c',%3d, A,%3d,%3d, X,%2d,%2d)                     .\n", dname, nc, dname, uplo, trans, diag, n, aoff, lda, xoff, incx)
			} else if banded {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c','%c',%3d,%3d, A,%3d,%3d, X,%2d,%2d)                 .\n", dname, nc, dname, uplo, trans, diag, n, k, aoff, lda, xoff, incx)
			} else if packed {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c','%c',%3d, AP,%3d, X,%2d,%2d)                        .\n", dname, nc, dname, uplo, trans, diag, n, aoff, xoff, incx)
			}

		} else if bytes.Equal(dname, []byte("DGER")) {
			var aoff, i, im, incx, incxs, incy, incys, j, laa, lda, ldas, lx, ly, m, ms, n, nd, ns, xoff, yoff int
			w := make([]float64, 1)
			var nargs int = 9
			var nc int = 0

			errmax = zero
			ok = true
			for aoff = 0; aoff <= 30; aoff += 10 {
				for xoff = 0; xoff <= 30; xoff += 10 {
					for yoff = 0; yoff <= 30; yoff += 10 {
						for _, n = range idim {
							nd = n/2 + 1

							for im = 1; im <= 2; im++ {
								if im == 1 {
									m = maxint(n-nd, 0)
								}
								if im == 2 {
									m = minint(n+nd, nmax)
								}
								//
								//           Set LDA to 1 more than minimum value if room.
								lda = m
								if lda < nmax {
									lda++
								}
								//           Skip tests if not enough room.
								if lda > nmax {
									goto label3110
								}
								laa = lda * n
								null = n <= 0 || m <= 0

								for _, incx = range inc {
									lx = absint(incx) * m
									//
									//              Generate the vector X.
									//
									transl = half
									dmakeL2(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &m, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := m - 1; return &y }(), &reset, &transl)
									if m > 1 {
										x[m/2-1+xoff] = zero
										xx[1+absint(incx)*(m/2-1)-1+xoff] = zero
									}

									for _, incy = range inc {
										ly = absint(incy) * n
										//
										//                 Generate the vector Y.
										//
										transl = zero
										dmakeL2(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &n, &y, &ione, &yy, &yoff, func() *int { y := absint(incy); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
										if n > 1 {
											y[n/2-1+yoff] = zero
											yy[1+absint(incy)*(n/2-1)-1+yoff] = zero
										}

										for _, alpha = range alf {
											//
											//                    Generate the matrix A.
											//
											transl = zero
											dmakeL2(func() *[]byte { y := dname[1:3]; return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &m, &n, &a, &nmax, &aa, &aoff, &lda, func() *int { y := m - 1; return &y }(), func() *int { y := n - 1; return &y }(), &reset, &transl)

											nc++
											//
											//                    Save every datum before calling the subroutine.
											//
											ms = m
											ns = n
											als = alpha
											for i = 1; i <= laa; i++ {
												as[i-1+aoff] = aa[i-1+aoff]
											}
											ldas = lda
											for i = 1; i <= lx; i++ {
												xs[i-1+xoff] = xx[i-1+xoff]
											}
											incxs = incx
											for i = 1; i <= ly; i++ {
												ys[i-1+yoff] = yy[i-1+yoff]
											}
											incys = incy
											//
											//                    Call the subroutine.
											//
											Dger(&m, &n, &alpha, &xx, &xoff, &incx, &yy, &yoff, &incy, &aa, &aoff, &lda)
											//
											//                    Check if error-exit was taken incorrectly.
											//
											if !ok {
												t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
												fatal = true
												goto label3140
											}
											//
											//                    See what data changed inside subroutine.
											//
											isame[0] = ms == m
											isame[1] = ns == n
											isame[2] = als == alpha
											isame[3] = lde(&xs, &xx, &xoff, &lx)
											isame[4] = incxs == incx
											isame[5] = lde(&ys, &yy, &yoff, &ly)
											isame[6] = incys == incy
											if null {
												isame[7] = lde(&as, &aa, &aoff, &laa)
											} else {
												isame[7] = lderes(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), &m, &n, &as, &aa, &aoff, &lda)
											}
											isame[8] = ldas == lda
											//
											//                    If data was incorrectly changed, report and return.
											//
											same = true
											for i = 1; i <= nargs; i++ {
												same = same && isame[i-1]
												if !isame[i-1] {
													t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
												}
											}
											if !same {
												fatal = true
												goto label3140
											}

											if !null {
												//
												//                       Check the result column by column.
												//
												if incx > 0 {
													for i = 1; i <= m; i++ {
														z[i-1] = x[i-1+xoff]
													}
												} else {
													for i = 1; i <= m; i++ {
														z[i-1] = x[m-i+1-1+xoff]
													}
												}
												for j = 1; j <= n; j++ {
													if incy > 0 {
														w[0] = y[j-1+yoff]
													} else {
														w[0] = y[n-j+1-1+yoff]
													}
													dmvch(func() *byte { y := byte('N'); return &y }(), &m, &ione, &alpha, &z, &izero, &nmax, &w, &izero, &ione, &one, &a, func() *int { y := 0 + (j-1)*nmax + aoff; return &y }(), &ione, &yt, &g, &aa, func() *int { y := 1 + (j-1)*lda - 1 + aoff; return &y }(), &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													errmax = maxf64(errmax, err)
													//                          If got really bad answer, report and return.
													if fatal {
														goto label3130
													}

												}
											} else {
												//                       Avoid repeating tests with M.le.0 or N.le.0.
												goto label3110
											}

										}

									}

								}

							label3110:
							}

						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", dname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", dname, nc, errmax)
			}
			continue

		label3130:
			;
			t.Errorf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)

		label3140:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s(%3d,%3d,%4.1f, X,%2d,%2d, Y,%2d,%2d, A,%3d,%3d)                  .\n", dname, nc, dname, m, n, alpha, xoff, incx, yoff, incy, aoff, lda)

		} else if bytes.Equal(dname, []byte("DSYR")) || bytes.Equal(dname, []byte("DSPR")) {
			var aoff, i, incx, incxs, j, ja, jj, laa, lda, ldas, lj, lx, n, nargs, nc, ns, xoff int
			w := make([]float64, 1)
			var full bool = dname[2] == 'Y'
			var packed bool = dname[2] == 'P'

			//     Define the number of arguments.
			ok = true
			if full {
				nargs = 7
			} else if packed {
				nargs = 6
			}

			nc = 0
			reset = true
			errmax = zero

			for aoff = 0; aoff <= 30; aoff += 10 {
				for xoff = 0; xoff <= 30; xoff += 10 {
					for _, n = range idim {
						//        Set LDA to 1 more than minimum value if room.
						lda = n
						if lda < nmax {
							lda++
						}
						//        Skip tests if not enough room.
						if lda > nmax {
							goto label4100
						}
						if packed {
							laa = (n * (n + 1)) / 2
						} else {
							laa = lda * n
						}

						for _, uplo = range ichu {
							upper = uplo == 'U'

							for _, incx = range inc {
								lx = absint(incx) * n
								//
								//              Generate the vector X.
								//
								transl = half
								dmakeL2(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &n, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
								if n > 1 {
									x[n/2-1+xoff] = zero
									xx[1+absint(incx)*(n/2-1)-1+xoff] = zero
								}

								for _, alpha = range alf {
									null = n <= 0 || alpha == zero
									//
									//                 Generate the matrix A.
									//
									transl = zero
									dmakeL2(func() *[]byte { y := dname[1:3]; return &y }(), &uplo, func() *byte { y := byte(' '); return &y }(), &n, &n, &a, &nmax, &aa, &aoff, &lda, func() *int { y := n - 1; return &y }(), func() *int { y := n - 1; return &y }(), &reset, &transl)

									nc++
									//
									//                 Save every datum before calling the subroutine.
									//
									uplos = uplo
									ns = n
									als = alpha
									for i = 1; i <= laa; i++ {
										as[i-1+aoff] = aa[i-1+aoff]
									}
									ldas = lda
									for i = 1; i <= lx; i++ {
										xs[i-1+xoff] = xx[i-1+xoff]
									}
									incxs = incx
									//
									//                 Call the subroutine.
									//
									if full {
										Dsyr(&uplo, &n, &alpha, &xx, &xoff, &incx, &aa, &aoff, &lda)
									} else if packed {
										Dspr(&uplo, &n, &alpha, &xx, &xoff, &incx, &aa, &aoff)
									}
									//
									//                 Check if error-exit was taken incorrectly.
									//
									if !ok {
										t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
										fatal = true
										goto label4120
									}
									//
									//                 See what data changed inside subroutines.
									//
									isame[0] = uplo == uplos
									isame[1] = ns == n
									isame[2] = als == alpha
									isame[3] = lde(&xs, &xx, &xoff, &lx)
									isame[4] = incxs == incx
									if null {
										isame[5] = lde(&as, &aa, &aoff, &laa)
									} else {
										isame[5] = lderes(func() *[]byte { y := dname[1:3]; return &y }(), &uplo, &n, &n, &as, &aa, &aoff, &lda)
									}
									if !packed {
										isame[6] = ldas == lda
									}
									//
									//                 If data was incorrectly changed, report and return.
									//
									same = true
									for i = 1; i <= nargs; i++ {
										same = same && isame[i-1]
										if !isame[i-1] {
											t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
										}
									}
									if !same {
										fatal = true
										goto label4120
									}

									if !null {
										//
										//                    Check the result column by column.
										//
										if incx > 0 {
											for i = 1; i <= n; i++ {
												z[i-1] = x[i-1+xoff]
											}
										} else {
											for i = 1; i <= n; i++ {
												z[i-1] = x[n-i+1-1+xoff]
											}
										}
										ja = 1
										for j = 1; j <= n; j++ {
											w[0] = z[j-1]
											if upper {
												jj = 1
												lj = j
											} else {
												jj = j
												lj = n - j + 1
											}
											dmvch(func() *byte { y := byte('N'); return &y }(), &lj, &ione, &alpha, &z, func() *int { y := jj - 1; return &y }(), &lj, &w, &izero, &ione, &one, &a, func() *int { y := jj - 1 + (j-1)*nmax + aoff; return &y }(), &ione, &yt, &g, &aa, func() *int { y := ja - 1 + aoff; return &y }(), &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
											if full {
												if upper {
													ja = ja + lda
												} else {
													ja = ja + lda + 1
												}
											} else {
												ja = ja + lj
											}
											errmax = maxf64(errmax, err)
											//                       If got really bad answer, report and return.
											if fatal {
												goto label4110
											}
										}
									} else {
										//                    Avoid repeating tests if N.le.0.
										if n <= 0 {
											goto label4100
										}
									}

								}

							}
						}

					label4100:
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", dname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", dname, nc, errmax)
			}
			continue

		label4110:
			;
			t.Errorf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)

		label4120:
			;
			if full {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, X,%2d,%2d, A,%3d,%3d)                        .\n", dname, nc, dname, uplo, n, alpha, xoff, incx, aoff, lda)
			} else if packed {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, X,%2d,%2d, AP,%3d)                           .\n", dname, nc, dname, uplo, n, alpha, xoff, incx, aoff)
			}

		} else if bytes.Equal(dname, []byte("DSYR2")) || bytes.Equal(dname, []byte("DSPR2")) {
			var aoff, i, incx, incxs, incy, incys, j, ja, jj, laa, lda, ldas, lj, lx, ly, n, nargs, nc, ns, xoff, yoff int
			w := make([]float64, 2)
			var full = dname[2] == 'Y'
			var packed = dname[2] == 'P'

			//     Define the number of arguments.
			ok = true
			if full {
				nargs = 9
			} else if packed {
				nargs = 8
			}

			nc = 0
			reset = true
			errmax = zero

			for aoff = 0; aoff <= 30; aoff += 10 {
				for xoff = 0; xoff <= 30; xoff += 10 {
					for yoff = 0; yoff <= 30; yoff += 10 {
						for _, n = range idim {
							//        Set LDA to 1 more than minimum value if room.
							lda = n
							if lda < nmax {
								lda++
							}
							//        Skip tests if not enough room.
							if lda > nmax {
								goto label5140
							}
							if packed {
								laa = (n * (n + 1)) / 2
							} else {
								laa = lda * n
							}

							for _, uplo = range ichu {
								upper = uplo == 'U'

								for _, incx = range inc {
									lx = absint(incx) * n
									//
									//              Generate the vector X.
									//
									transl = half
									dmakeL2(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &n, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
									if n > 1 {
										x[n/2-1+xoff] = zero
										xx[1+absint(incx)*(n/2-1)-1+xoff] = zero
									}

									for _, incy = range inc {
										ly = absint(incy) * n
										//
										//                 Generate the vector Y.
										//
										transl = zero
										dmakeL2(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &ione, &n, &y, &ione, &yy, &yoff, func() *int { y := absint(incy); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
										if n > 1 {
											y[n/2-1+yoff] = zero
											yy[1+absint(incy)*(n/2-1)-1+yoff] = zero
										}

										for _, alpha = range alf {
											null = n <= 0 || alpha == zero
											//
											//                    Generate the matrix A.
											//
											transl = zero
											dmakeL2(func() *[]byte { y := dname[1:3]; return &y }(), &uplo, func() *byte { y := byte(' '); return &y }(), &n, &n, &a, &nmax, &aa, &aoff, &lda, func() *int { y := n - 1; return &y }(), func() *int { y := n - 1; return &y }(), &reset, &transl)
											//
											nc++
											//
											//                    Save every datum before calling the subroutine.
											//
											uplos = uplo
											ns = n
											als = alpha
											for i = 1; i <= laa; i++ {
												as[i-1+aoff] = aa[i-1+aoff]
											}
											ldas = lda
											for i = 1; i <= lx; i++ {
												xs[i-1+xoff] = xx[i-1+xoff]
											}
											incxs = incx
											for i = 1; i <= ly; i++ {
												ys[i-1+yoff] = yy[i-1+yoff]
											}
											incys = incy
											//
											//                    Call the subroutine.
											//
											if full {
												Dsyr2(&uplo, &n, &alpha, &xx, &xoff, &incx, &yy, &yoff, &incy, &aa, &aoff, &lda)
											} else if packed {
												Dspr2(&uplo, &n, &alpha, &xx, &xoff, &incx, &yy, &yoff, &incy, &aa, &aoff)
											}
											//
											//                    Check if error-exit was taken incorrectly.
											//
											if !ok {
												t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
												fatal = true
												goto label5160
											}
											//
											//                    See what data changed inside subroutines.
											//
											isame[0] = uplo == uplos
											isame[1] = ns == n
											isame[2] = als == alpha
											isame[3] = lde(&xs, &xx, &xoff, &lx)
											isame[4] = incxs == incx
											isame[5] = lde(&ys, &yy, &yoff, &ly)
											isame[6] = incys == incy
											if null {
												isame[7] = lde(&as, &aa, &aoff, &laa)
											} else {
												isame[7] = lderes(func() *[]byte { y := dname[1:3]; return &y }(), &uplo, &n, &n, &as, &aa, &aoff, &lda)
											}
											if !packed {
												isame[8] = ldas == lda
											}
											//
											//                    If data was incorrectly changed, report and return.
											//
											same = true
											for i = 1; i <= nargs; i++ {
												same = same && isame[i-1]
												if !isame[i-1] {
													t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
												}
											}
											if !same {
												fatal = true
												goto label5160
											}

											if !null {
												//
												//                       Check the result column by column.
												//
												if incx > 0 {
													for i = 1; i <= n; i++ {
														z[i-1+0*nmax] = x[i-1+xoff]
													}
												} else {
													for i = 1; i <= n; i++ {
														z[i-1+0*nmax] = x[n-i+1-1+xoff]
													}
												}
												if incy > 0 {
													for i = 1; i <= n; i++ {
														z[i-1+1*nmax] = y[i-1+yoff]
													}
												} else {
													for i = 1; i <= n; i++ {
														z[i-1+1*nmax] = y[n-i+1-1+yoff]
													}
												}
												ja = 1
												for j = 1; j <= n; j++ {
													w[0] = z[j-1+1*nmax]
													w[1] = z[j-1+0*nmax]
													if upper {
														jj = 1
														lj = j
													} else {
														jj = j
														lj = n - j + 1
													}
													dmvch(func() *byte { y := byte('N'); return &y }(), &lj, &itwo, &alpha, &z, func() *int { y := jj - 1 + 0*nmax; return &y }(), &nmax, &w, &izero, &ione, &one, &a, func() *int { y := jj - 1 + (j-1)*nmax + aoff; return &y }(), &ione, &yt, &g, &aa, func() *int { y := ja - 1 + aoff; return &y }(), &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													if full {
														if upper {
															ja = ja + lda
														} else {
															ja = ja + lda + 1
														}
													} else {
														ja = ja + lj
													}
													errmax = maxf64(errmax, err)
													//                          If got really bad answer, report and return.
													if fatal {
														goto label5150
													}
												}
											} else {
												//                       Avoid repeating tests with N.le.0.
												if n <= 0 {
													goto label5140
												}
											}

										}

									}

								}

							}

						label5140:
						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", dname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", dname, nc, errmax)
			}
			continue

		label5150:
			;
			t.Errorf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)

		label5160:
			;
			if full {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, X,%2d, Y,%2d, A,%3d)                  .\n", dname, nc, dname, uplo, n, alpha, incx, incy, lda)
			} else if packed {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, X,%2d, Y,%2d, AP)                     .\n", dname, nc, dname, uplo, n, alpha, incx, incy)
			}
		}
	}
}

func TestDblasLevel3(t *testing.T) {
	var diag, diags, side, sides, tranas, tranbs, transa, transb, uplo, uplos byte
	var fatal, left, null, tran, same, upper bool
	var alpha, als, beta, bls, bets, err float64
	var i, j, n int
	var ok bool = true
	var reset bool = true
	var zero float64 = 0.0
	var one float64 = 1.0
	var eps float64 = epsilonf64()
	var thresh float64 = 16.0
	var errmax float64 = zero
	var nmax int = 65
	var izero int = 0
	var idim []int = []int{0, 1, 2, 3, 5, 9}
	var alf []float64 = []float64{0.0, 1.0, 0.7}
	var bet []float64 = []float64{0.0, 1.0, 1.3}
	isame := make([]bool, 13)
	var ichd []byte = []byte{'U', 'N'}
	var ichs []byte = []byte{'L', 'R'}
	var icht []byte = []byte{'N', 'T', 'C'}
	var ichu []byte = []byte{'U', 'L'}
	a := make([]float64, nmax*2*nmax)
	aa := make([]float64, nmax*nmax)
	ab := make([]float64, nmax*2*nmax)
	as := make([]float64, nmax*nmax)
	b := make([]float64, nmax*2*nmax)
	bb := make([]float64, nmax*nmax)
	bs := make([]float64, nmax*nmax)
	c := make([]float64, nmax*nmax)
	cc := make([]float64, nmax*nmax)
	cs := make([]float64, nmax*nmax)
	ct := make([]float64, nmax)
	g := make([]float64, nmax)
	w := make([]float64, 2*nmax)
	var snames [][]byte = [][]byte{[]byte("DGEMM"), []byte("DSYMM"), []byte("DTRMM"), []byte("DTRSM"), []byte("DSYRK"), []byte("DSYR2K")}

	n = minint(int(32), nmax)
	for j = 1; j <= n; j++ {
		for i = 1; i <= n; i++ {
			a[i-1+(j-1)*nmax] = float64(maxint(i-j+1, 0))
			ab[i-1+(j-1)*nmax] = float64(maxint(i-j+1, 0))
			b[i-1+(j-1)*nmax] = float64(maxint(i-j+1, 0))
		}
		a[j-1+(nmax)*nmax] = float64(j)
		a[0+(nmax+j-1)*nmax] = float64(j)
		ab[j-1+(nmax)*nmax] = float64(j)
		ab[0+(nmax+j-1)*nmax] = float64(j)
		b[j-1+(nmax)*nmax] = float64(j)
		b[0+(nmax+j-1)*nmax] = float64(j)
		c[j-1+0*nmax] = zero
	}
	for j = 1; j <= n; j++ {
		cc[j-1] = float64(j*((j+1)*j))/2 - float64((j+1)*j*(j-1))/3
	}
	//     CC holds the exact result. On exit from SMMCH CT holds
	//     the result computed by SMMCH.
	transa = byte('N')
	transb = byte('N')
	dmmch(&transa, &transb, &n, func() *int { y := 1; return &y }(), &n, &one, &a, &izero, &nmax, &a, func() *int { y := nmax * nmax; return &y }(), &nmax, &zero, &c, &izero, &nmax, &ct, &g, &cc, &izero, &nmax, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lde(&cc, &ct, &izero, &n)
	if !same || err != zero {
		t.Errorf(" ERROR IN DMMCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n DMMCH WAS CALLED WITH TRANSA = %c AND TRANSB = %c\n AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", transa, transb, same, err)
	}
	transb = byte('T')
	dmmch(&transa, &transb, &n, func() *int { y := 1; return &y }(), &n, &one, &a, &izero, &nmax, &a, func() *int { y := nmax * nmax; return &y }(), &nmax, &zero, &c, &izero, &nmax, &ct, &g, &cc, &izero, &nmax, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lde(&cc, &ct, &izero, &n)
	if !same || err != zero {
		t.Errorf(" ERROR IN DMMCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n DMMCH WAS CALLED WITH TRANSA = %c AND TRANSB = %c\n AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", transa, transb, same, err)
	}
	for j = 1; j <= n; j++ {
		a[j-1+(nmax)*nmax] = float64(n - j + 1)
		a[0+(nmax+j-1)*nmax] = float64(n - j + 1)
		ab[j-1+(nmax)*nmax] = float64(n - j + 1)
		ab[0+(nmax+j-1)*nmax] = float64(n - j + 1)
		b[j-1+(nmax)*nmax] = float64(n - j + 1)
		b[0+(nmax+j-1)*nmax] = float64(n - j + 1)
	}
	for j = 1; j <= n; j++ {
		cc[n-j+1-1] = float64(j*((j+1)*j))/2 - float64((j+1)*j*(j-1))/3
	}
	transa = byte('T')
	transb = byte('N')
	dmmch(&transa, &transb, &n, func() *int { y := 1; return &y }(), &n, &one, &a, &izero, &nmax, &a, func() *int { y := nmax * nmax; return &y }(), &nmax, &zero, &c, &izero, &nmax, &ct, &g, &cc, &izero, &nmax, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lde(&cc, &ct, &izero, &n)
	if !same || err != zero {
		t.Errorf(" ERROR IN DMMCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n DMMCH WAS CALLED WITH TRANSA = %c AND TRANSB = %c\n AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", transa, transb, same, err)
	}
	transb = byte('T')
	dmmch(&transa, &transb, &n, func() *int { y := 1; return &y }(), &n, &one, &a, &izero, &nmax, &a, func() *int { y := nmax * nmax; return &y }(), &nmax, &zero, &c, &izero, &nmax, &ct, &g, &cc, &izero, &nmax, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lde(&cc, &ct, &izero, &n)
	if !same || err != zero {
		t.Errorf(" ERROR IN DMMCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n DMMCH WAS CALLED WITH TRANSA = %c AND TRANSB = %c\n AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", transa, transb, same, err)
	}

	for _, dname := range snames {
		if bytes.Equal(dname, []byte("DGEMM")) {
			var trana, tranb bool
			var aoff, boff, coff, i, k, ks, laa, lbb, lcc, lda, ldas, ldb, ldbs, ldc, ldcs, m, ma, mb, ms, n, na, nb, ns int
			var nargs int = 13
			var nc int = 0

			ok = true
			for aoff = 0; aoff <= 25; aoff += 25 {
				for boff = 0; boff <= 25; boff += 25 {
					for coff = 0; coff <= 25; coff += 25 {
						for _, m = range idim {

							for _, n = range idim {
								//           Set LDC to 1 more than minimum value if room.
								ldc = m
								if ldc < nmax {
									ldc = ldc + 1
								}
								//           Skip tests if not enough room.
								if ldc > nmax {
									goto label1100
								}
								lcc = ldc * n
								null = n <= 0 || m <= 0

								for _, k = range idim {

									for _, transa = range icht {
										trana = transa == 'T' || transa == 'C'

										if trana {
											ma = k
											na = m
										} else {
											ma = m
											na = k
										}
										//                 Set LDA to 1 more than minimum value if room.
										lda = ma
										if lda < nmax {
											lda = lda + 1
										}
										//                 Skip tests if not enough room.
										if lda > nmax {
											goto label180
										}
										laa = lda * na
										//
										//                 Generate the matrix A.
										//
										dmakeL3(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &ma, &na, &a, &nmax, &aa, &aoff, &lda, &reset, &zero)

										for _, transb = range icht {
											tranb = transb == 'T' || transb == 'C'

											if tranb {
												mb = n
												nb = k
											} else {
												mb = k
												nb = n
											}
											//                    Set LDB to 1 more than minimum value if room.
											ldb = mb
											if ldb < nmax {
												ldb = ldb + 1
											}
											//                    Skip tests if not enough room.
											if ldb > nmax {
												goto label170
											}
											lbb = ldb * nb
											//
											//                    Generate the matrix B.
											//
											dmakeL3(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &mb, &nb, &b, &nmax, &bb, &boff, &ldb, &reset, &zero)

											for _, alpha = range alf {

												for _, beta = range bet {
													//
													//                          Generate the matrix C.
													//
													dmakeL3(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &m, &n, &c, &nmax, &cc, &coff, &ldc, &reset, &zero)

													nc++
													//
													//                          Save every datum before calling the
													//                          subroutine.
													//
													tranas = transa
													tranbs = transb
													ms = m
													ns = n
													ks = k
													als = alpha
													for i = 1; i <= laa; i++ {
														as[i-1+aoff] = aa[i-1+aoff]
													}
													ldas = lda
													for i = 1; i <= lbb; i++ {
														bs[i-1+boff] = bb[i-1+boff]
													}
													ldbs = ldb
													bls = beta
													for i = 1; i <= lcc; i++ {
														cs[i-1+coff] = cc[i-1+coff]
													}
													ldcs = ldc
													//
													//                          Call the subroutine.
													//
													Dgemm(&transa, &transb, &m, &n, &k, &alpha, &aa, &aoff, &lda, &bb, &boff, &ldb, &beta, &cc, &coff, &ldc)
													//
													//                          Check if error-exit was taken incorrectly.
													//
													if !ok {
														t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
														fatal = true
														goto label1120
													}
													//
													//                          See what data changed inside subroutines.
													//
													isame[0] = transa == tranas
													isame[1] = transb == tranbs
													isame[2] = ms == m
													isame[3] = ns == n
													isame[4] = ks == k
													isame[5] = als == alpha
													isame[6] = lde(&as, &aa, &aoff, &laa)
													isame[7] = ldas == lda
													isame[8] = lde(&bs, &bb, &boff, &lbb)
													isame[9] = ldbs == ldb
													isame[10] = bls == beta
													if null {
														isame[11] = lde(&cs, &cc, &coff, &lcc)
													} else {
														isame[11] = lderes(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), &m, &n, &cs, &cc, &coff, &ldc)
													}
													isame[12] = ldcs == ldc
													//
													//                          If data was incorrectly changed, report
													//                          and return.
													//
													same = true
													for i = 1; i <= nargs; i++ {
														same = same && isame[i-1]
														if !isame[i-1] {
															t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
														}
													}
													if !same {
														fatal = true
														goto label1120
													}

													if !null {
														//
														//                             Check the result.
														//
														dmmch(&transa, &transb, &m, &n, &k, &alpha, &a, &aoff, &nmax, &b, &boff, &nmax, &beta, &c, &coff, &nmax, &ct, &g, &cc, &coff, &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
														errmax = maxf64(errmax, err)
														//                             If got really bad answer, report and
														//                             return.
														if fatal {
															goto label1120
														}
													}

												}

											}

										label170:
										}

									label180:
									}

								}

							label1100:
							}

						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", dname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", dname, nc, errmax)
			}
			continue

		label1120:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c',%3d,%3d,%3d,%4.1f, A,%3d,%3d, B,%3d,%3d,%4.1f, C,%3d,%3d).\n", dname, nc, dname, transa, transb, m, n, k, alpha, aoff, lda, boff, ldb, beta, coff, ldc)
		} else if bytes.Equal(dname, []byte("DSYMM")) {
			var aoff, boff, coff, i, laa, lbb, lcc, lda, ldas, ldb, ldbs, ldc, ldcs, m, ms, n, na, ns int
			var nargs int = 12
			var nc int = 0

			ok = true
			for aoff = 0; aoff <= 30; aoff += 10 {
				for boff = 0; boff <= 30; boff += 10 {
					for coff = 0; coff <= 30; coff += 10 {
						for _, m = range idim {

							for _, n = range idim {
								//           Set LDC to 1 more than minimum value if room.
								ldc = m
								if ldc < nmax {
									ldc = ldc + 1
								}
								//           Skip tests if not enough room.
								if ldc > nmax {
									goto label290
								}
								lcc = ldc * n
								null = n <= 0 || m <= 0
								//
								//           Set LDB to 1 more than minimum value if room.
								ldb = m
								if ldb < nmax {
									ldb = ldb + 1
								}
								//           Skip tests if not enough room.
								if ldb > nmax {
									goto label290
								}
								lbb = ldb * n
								//
								//           Generate the matrix B.
								//
								dmakeL3(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &m, &n, &b, &nmax, &bb, &boff, &ldb, &reset, &zero)

								for _, side = range ichs {
									left = side == 'L'

									if left {
										na = m
									} else {
										na = n
									}
									//              Set LDA to 1 more than minimum value if room.
									lda = na
									if lda < nmax {
										lda = lda + 1
									}
									//              Skip tests if not enough room.
									if lda > nmax {
										goto label280
									}
									laa = lda * na

									for _, uplo = range ichu {
										//
										//                 Generate the symmetric matrix A.
										//
										dmakeL3(func() *[]byte { y := []byte("SY"); return &y }(), &uplo, func() *byte { y := byte(' '); return &y }(), &na, &na, &a, &nmax, &aa, &aoff, &lda, &reset, &zero)

										for _, alpha = range alf {

											for _, beta = range bet {
												//
												//                       Generate the matrix C.
												//
												dmakeL3(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &m, &n, &c, &nmax, &cc, &coff, &ldc, &reset, &zero)

												nc++
												//
												//                       Save every datum before calling the
												//                       subroutine.
												//
												sides = side
												uplos = uplo
												ms = m
												ns = n
												als = alpha
												for i = 1; i <= laa; i++ {
													as[i-1+aoff] = aa[i-1+aoff]
												}
												ldas = lda
												for i = 1; i <= lbb; i++ {
													bs[i-1+boff] = bb[i-1+boff]
												}
												ldbs = ldb
												bls = beta
												for i = 1; i <= lcc; i++ {
													cs[i-1+coff] = cc[i-1+coff]
												}
												ldcs = ldc
												//
												//                       Call the subroutine.
												//
												Dsymm(&side, &uplo, &m, &n, &alpha, &aa, &aoff, &lda, &bb, &boff, &ldb, &beta, &cc, &coff, &ldc)
												//
												//                       Check if error-exit was taken incorrectly.
												//
												if !ok {
													t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
													fatal = true
													goto label2110
												}
												//
												//                       See what data changed inside subroutines.
												//
												isame[0] = sides == side
												isame[1] = uplos == uplo
												isame[2] = ms == m
												isame[3] = ns == n
												isame[4] = als == alpha
												isame[5] = lde(&as, &aa, &aoff, &laa)
												isame[6] = ldas == lda
												isame[7] = lde(&bs, &bb, &boff, &lbb)
												isame[8] = ldbs == ldb
												isame[9] = bls == beta
												if null {
													isame[10] = lde(&cs, &cc, &coff, &lcc)
												} else {
													isame[10] = lderes(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), &m, &n, &cs, &cc, &coff, &ldc)
												}
												isame[11] = ldcs == ldc
												//
												//                       If data was incorrectly changed, report and
												//                       return.
												//
												same = true
												for i = 1; i <= nargs; i++ {
													same = same && isame[i-1]
													if !isame[i-1] {
														t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
													}
												}
												if !same {
													fatal = true
													goto label2110
												}

												if !null {
													//
													//                          Check the result.
													//
													if left {
														dmmch(func() *byte { y := byte('N'); return &y }(), func() *byte { y := byte('N'); return &y }(), &m, &n, &m, &alpha, &a, &aoff, &nmax, &b, &boff, &nmax, &beta, &c, &coff, &nmax, &ct, &g, &cc, &coff, &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													} else {
														dmmch(func() *byte { y := byte('N'); return &y }(), func() *byte { y := byte('N'); return &y }(), &m, &n, &n, &alpha, &b, &boff, &nmax, &a, &aoff, &nmax, &beta, &c, &coff, &nmax, &ct, &g, &cc, &coff, &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													}
													errmax = maxf64(errmax, err)
													//                          If got really bad answer, report and
													//                          return.
													if fatal {
														goto label2110
													}
												}

											}

										}

									}

								label280:
								}

							label290:
							}
						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", dname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", dname, nc, errmax)
			}
			continue

		label2110:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c',%3d,%3d,%4.1f, A,%3d,%3d, B,%3d,%3d,%4.1f, C,%3d,%3d)    .\n", dname, nc, dname, side, uplo, m, n, alpha, aoff, lda, boff, ldb, beta, coff, ldc)
		} else if bytes.Equal(dname, []byte("DTRMM")) || bytes.Equal(dname, []byte("DTRSM")) {
			var aoff, boff, i, j, laa, lbb, lda, ldas, ldb, ldbs, m, ms, n, na, ns int
			var nargs int = 11
			var nc int = 0

			ok = true
			//
			//     Set up zero matrix for SMMCH.
			for j = 1; j <= nmax; j++ {
				for i = 1; i <= nmax; i++ {
					c[i-1+(j-1)*nmax] = zero
				}
			}

			for aoff = 0; aoff <= 30; aoff += 10 {
				for boff = 0; boff <= 30; boff += 10 {
					for _, m = range idim {

						for _, n = range idim {
							//           Set LDB to 1 more than minimum value if room.
							ldb = m
							if ldb < nmax {
								ldb = ldb + 1
							}
							//           Skip tests if not enough room.
							if ldb > nmax {
								goto label3130
							}
							lbb = ldb * n
							null = m <= 0 || n <= 0

							for _, side = range ichs {
								left = side == 'L'
								if left {
									na = m
								} else {
									na = n
								}
								//              Set LDA to 1 more than minimum value if room.
								lda = na
								if lda < nmax {
									lda = lda + 1
								}
								//              Skip tests if not enough room.
								if lda > nmax {
									goto label3130
								}
								laa = lda * na

								for _, uplo = range ichu {

									for _, transa = range icht {

										for _, diag = range ichd {

											for _, alpha = range alf {
												//
												//                          Generate the matrix A.
												//
												dmakeL3(func() *[]byte { y := []byte("TR"); return &y }(), &uplo, &diag, &na, &na, &a, &nmax, &aa, &aoff, &lda, &reset, &zero)
												//
												//                          Generate the matrix B.
												//
												dmakeL3(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &m, &n, &b, &nmax, &bb, &boff, &ldb, &reset, &zero)

												nc++
												//
												//                          Save every datum before calling the
												//                          subroutine.
												//
												sides = side
												uplos = uplo
												tranas = transa
												diags = diag
												ms = m
												ns = n
												als = alpha
												for i = 1; i <= laa; i++ {
													as[i-1+aoff] = aa[i-1+aoff]
												}
												ldas = lda
												for i = 1; i <= lbb; i++ {
													bs[i-1+boff] = bb[i-1+boff]
												}
												ldbs = ldb
												//
												//                          Call the subroutine.
												//
												if bytes.Equal(dname[3:5], []byte("MM")) {
													Dtrmm(&side, &uplo, &transa, &diag, &m, &n, &alpha, &aa, &aoff, &lda, &bb, &boff, &ldb)
												} else if bytes.Equal(dname[3:5], []byte("SM")) {
													Dtrsm(&side, &uplo, &transa, &diag, &m, &n, &alpha, &aa, &aoff, &lda, &bb, &boff, &ldb)
												}
												//
												//                          Check if error-exit was taken incorrectly.
												//
												if !ok {
													t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
													fatal = true
													goto label3150
												}
												//
												//                          See what data changed inside subroutines.
												//
												isame[0] = sides == side
												isame[1] = uplos == uplo
												isame[2] = tranas == transa
												isame[3] = diags == diag
												isame[4] = ms == m
												isame[5] = ns == n
												isame[6] = als == alpha
												isame[7] = lde(&as, &aa, &aoff, &laa)
												isame[8] = ldas == lda
												if null {
													isame[9] = lde(&bs, &bb, &boff, &lbb)
												} else {
													isame[9] = lderes(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), &m, &n, &bs, &bb, &boff, &ldb)
												}
												isame[10] = ldbs == ldb
												//
												//                          If data was incorrectly changed, report and
												//                          return.
												//
												same = true
												for i = 1; i <= nargs; i++ {
													same = same && isame[i-1]
													if !isame[i-1] {
														t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
													}
												}
												if !same {
													fatal = true
													goto label3150
												}

												if !null {
													if bytes.Equal(dname[3:5], []byte("MM")) {
														//
														//                                Check the result.
														//
														if left {
															dmmch(&transa, func() *byte { y := byte('N'); return &y }(), &m, &n, &m, &alpha, &a, &aoff, &nmax, &b, &boff, &nmax, &zero, &c, &izero, &nmax, &ct, &g, &bb, &boff, &ldb, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
														} else {
															dmmch(func() *byte { y := byte('N'); return &y }(), &transa, &m, &n, &n, &alpha, &b, &boff, &nmax, &a, &aoff, &nmax, &zero, &c, &izero, &nmax, &ct, &g, &bb, &boff, &ldb, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
														}
													} else if bytes.Equal(dname[3:5], []byte("SM")) {
														//
														//                                Compute approximation to original
														//                                matrix.
														//
														for j = 1; j <= n; j++ {
															for i = 1; i <= m; i++ {
																c[i-1+(j-1)*nmax] = bb[i+(j-1)*ldb-1+boff]
																bb[i+(j-1)*ldb-1+boff] = alpha * b[i-1+(j-1)*nmax+boff]
															}
														}

														if left {
															dmmch(&transa, func() *byte { y := byte('N'); return &y }(), &m, &n, &m, &one, &a, &aoff, &nmax, &c, &izero, &nmax, &zero, &b, &boff, &nmax, &ct, &g, &bb, &boff, &ldb, &eps, &err, &fatal, func() *bool { y := false; return &y }(), t)
														} else {
															dmmch(func() *byte { y := byte('N'); return &y }(), &transa, &m, &n, &n, &one, &c, &izero, &nmax, &a, &aoff, &nmax, &zero, &b, &boff, &nmax, &ct, &g, &bb, &boff, &ldb, &eps, &err, &fatal, func() *bool { y := false; return &y }(), t)
														}
													}
													errmax = maxf64(errmax, err)
													//                             If got really bad answer, report and
													//                             return.
													if fatal {
														goto label3150
													}
												}

											}

										}

									}

								}

							}

						label3130:
						}

					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", dname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", dname, nc, errmax)
			}
			continue

		label3150:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c','%c','%c',%3d,%3d,%4.1f, A,%3d,%3d, B,%3d,%3d)        .\n", dname, nc, dname, side, uplo, transa, diag, m, n, alpha, aoff, lda, boff, ldb)
		} else if bytes.Equal(dname, []byte("DSYRK")) {
			var trans, transs byte
			var aoff, coff, i, j, jc, jj, k, ks, laa, lcc, lda, ldas, ldc, ldcs, lj, ma, n, na, ns int
			var nargs int = 10
			var nc int = 0

			ok = true
			for aoff = 0; aoff <= 30; aoff += 10 {
				for coff = 0; coff <= 30; coff += 10 {
					for _, n = range idim {
						//        Set LDC to 1 more than minimum value if room.
						ldc = n
						if ldc < nmax {
							ldc = ldc + 1
						}
						//        Skip tests if not enough room.
						if ldc > nmax {
							goto label4100
						}
						lcc = ldc * n
						null = n <= 0

						for _, k = range idim {

							for _, trans = range icht {
								tran = trans == 'T' || trans == 'C'
								if tran {
									ma = k
									na = n
								} else {
									ma = n
									na = k
								}
								//              Set LDA to 1 more than minimum value if room.
								lda = ma
								if lda < nmax {
									lda = lda + 1
								}
								//              Skip tests if not enough room.
								if lda > nmax {
									goto label480
								}
								laa = lda * na
								//
								//              Generate the matrix A.
								//
								dmakeL3(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &ma, &na, &a, &nmax, &aa, &aoff, &lda, &reset, &zero)

								for _, uplo = range ichu {
									upper = uplo == 'U'

									for _, alpha = range alf {

										for _, beta = range bet {
											//
											//                       Generate the matrix C.
											//
											dmakeL3(func() *[]byte { y := []byte("SY"); return &y }(), &uplo, func() *byte { y := byte(' '); return &y }(), &n, &n, &c, &nmax, &cc, &coff, &ldc, &reset, &zero)

											nc++
											//
											//                       Save every datum before calling the subroutine.
											//
											uplos = uplo
											transs = trans
											ns = n
											ks = k
											als = alpha
											for i = 1; i <= laa; i++ {
												as[i-1+aoff] = aa[i-1+aoff]
											}
											ldas = lda
											bets = beta
											for i = 1; i <= lcc; i++ {
												cs[i-1+coff] = cc[i-1+coff]
											}
											ldcs = ldc
											//
											//                       Call the subroutine.
											//
											Dsyrk(&uplo, &trans, &n, &k, &alpha, &aa, &aoff, &lda, &beta, &cc, &coff, &ldc)
											//
											//                       Check if error-exit was taken incorrectly.
											//
											if !ok {
												t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
												fatal = true
												goto label4120
											}
											//
											//                       See what data changed inside subroutines.
											//
											isame[0] = uplos == uplo
											isame[1] = transs == trans
											isame[2] = ns == n
											isame[3] = ks == k
											isame[4] = als == alpha
											isame[5] = lde(&as, &aa, &aoff, &laa)
											isame[6] = ldas == lda
											isame[7] = bets == beta
											if null {
												isame[8] = lde(&cs, &cc, &coff, &lcc)
											} else {
												isame[8] = lderes(func() *[]byte { y := []byte("SY"); return &y }(), &uplo, &n, &n, &cs, &cc, &coff, &ldc)
											}
											isame[9] = ldcs == ldc
											//
											//                       If data was incorrectly changed, report and
											//                       return.
											//
											same = true
											for i = 1; i <= nargs; i++ {
												same = same && isame[i-1]
												if !isame[i-1] {
													t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
												}
											}
											if !same {
												fatal = true
												goto label4120
											}

											if !null {
												//
												//                          Check the result column by column.
												//
												jc = 1
												for j = 1; j <= n; j++ {
													if upper {
														jj = 1
														lj = j
													} else {
														jj = j
														lj = n - j + 1
													}
													if tran {
														dmmch(func() *byte { y := byte('T'); return &y }(), func() *byte { y := byte('N'); return &y }(), &lj, func() *int { y := 1; return &y }(), &k, &alpha, &a, func() *int { y := 0 + (jj-1)*nmax + aoff; return &y }(), &nmax, &a, func() *int { y := 0 + (j-1)*nmax + aoff; return &y }(), &nmax, &beta, &c, func() *int { y := jj - 1 + (j-1)*nmax + coff; return &y }(), &nmax, &ct, &g, &cc, func() *int { y := jc - 1 + coff; return &y }(), &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													} else {
														dmmch(func() *byte { y := byte('N'); return &y }(), func() *byte { y := byte('T'); return &y }(), &lj, func() *int { y := 1; return &y }(), &k, &alpha, &a, func() *int { y := jj - 1 + (0)*nmax + aoff; return &y }(), &nmax, &a, func() *int { y := j - 1 + (0)*nmax + aoff; return &y }(), &nmax, &beta, &c, func() *int { y := jj - 1 + (j-1)*nmax + coff; return &y }(), &nmax, &ct, &g, &cc, func() *int { y := jc - 1 + coff; return &y }(), &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													}
													if upper {
														jc = jc + ldc
													} else {
														jc = jc + ldc + 1
													}
													errmax = maxf64(errmax, err)
													//                             If got really bad answer, report and
													//                             return.
													if fatal {
														goto label4110
													}
												}
											}

										}

									}

								}

							label480:
							}

						}

					label4100:
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", dname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", dname, nc, errmax)
			}
			continue

		label4110:
			;
			if n > 1 {
				t.Errorf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)
			}
			//
		label4120:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c',%3d,%3d,%4.1f, A,%3d,%4.1f, C,%3d)           .\n", dname, nc, dname, uplo, trans, n, k, alpha, lda, beta, ldc)
		} else if bytes.Equal(dname, []byte("DSYR2K")) {
			var trans, transs byte
			var aoff, boff, coff, i, j, jc, jj, jjab, k, ks, laa, lbb, lcc, lda, ldas, ldb, ldbs, ldc, ldcs, lj, ma, n, na, ns int
			var nargs int = 12
			var nc int = 0

			ok = true
			for coff = 0; coff <= 30; coff += 10 {
				for _, n = range idim {
					//        Set LDC to 1 more than minimum value if room.
					ldc = n
					if ldc < nmax {
						ldc = ldc + 1
					}
					//        Skip tests if not enough room.
					if ldc > nmax {
						goto label5130
					}
					lcc = ldc * n
					null = n <= 0

					for _, k = range idim {

						for _, trans = range icht {
							tran = trans == 'T' || trans == 'C'
							if tran {
								ma = k
								na = n
							} else {
								ma = n
								na = k
							}
							//              Set LDA to 1 more than minimum value if room.
							lda = ma
							if lda < nmax {
								lda = lda + 1
							}
							//              Skip tests if not enough room.
							if lda > nmax {
								goto label5110
							}
							laa = lda * na
							//
							//              Generate the matrix A.
							//
							if tran {
								dmakeL3(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &ma, &na, &ab, func() *int { y := 2 * nmax; return &y }(), &aa, &izero, &lda, &reset, &zero)
							} else {
								dmakeL3(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &ma, &na, &ab, &nmax, &aa, &izero, &lda, &reset, &zero)
							}
							//
							//              Generate the matrix B.
							//
							ldb = lda
							lbb = laa
							if tran {
								dmakeL3(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &ma, &na, func() *[]float64 { y := ab[k+1-1:]; return &y }(), func() *int { y := 2 * nmax; return &y }(), &bb, &izero, &ldb, &reset, &zero)
							} else {
								dmakeL3(func() *[]byte { y := []byte("GE"); return &y }(), func() *byte { y := byte(' '); return &y }(), func() *byte { y := byte(' '); return &y }(), &ma, &na, func() *[]float64 { y := ab[k*nmax+1-1:]; return &y }(), &nmax, &bb, &izero, &ldb, &reset, &zero)
							}

							for _, uplo = range ichu {
								upper = uplo == 'U'

								for _, alpha = range alf {

									for _, beta = range bet {
										//
										//                       Generate the matrix C.
										//
										dmakeL3(func() *[]byte { y := []byte("SY"); return &y }(), &uplo, func() *byte { y := byte(' '); return &y }(), &n, &n, &c, &nmax, &cc, &coff, &ldc, &reset, &zero)
										//
										nc++
										//
										//                       Save every datum before calling the subroutine.
										//
										uplos = uplo
										transs = trans
										ns = n
										ks = k
										als = alpha
										for i = 1; i <= laa; i++ {
											as[i-1] = aa[i-1]
										}
										ldas = lda
										for i = 1; i <= lbb; i++ {
											bs[i-1] = bb[i-1]
										}
										ldbs = ldb
										bets = beta
										for i = 1; i <= lcc; i++ {
											cs[i-1+coff] = cc[i-1+coff]
										}
										ldcs = ldc
										//
										//                       Call the subroutine.
										//
										Dsyr2k(&uplo, &trans, &n, &k, &alpha, &aa, &izero, &lda, &bb, &izero, &ldb, &beta, &cc, &coff, &ldc)
										//
										//                       Check if error-exit was taken incorrectly.
										//
										if !ok {
											t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
											fatal = true
											goto label5150
										}
										//
										//                       See what data changed inside subroutines.
										//
										isame[0] = uplos == uplo
										isame[1] = transs == trans
										isame[2] = ns == n
										isame[3] = ks == k
										isame[4] = als == alpha
										isame[5] = lde(&as, &aa, &izero, &laa)
										isame[6] = ldas == lda
										isame[7] = lde(&bs, &bb, &izero, &lbb)
										isame[8] = ldbs == ldb
										isame[9] = bets == beta
										if null {
											isame[10] = lde(&cs, &cc, &coff, &lcc)
										} else {
											isame[10] = lderes(func() *[]byte { y := []byte("SY"); return &y }(), &uplo, &n, &n, &cs, &cc, &coff, &ldc)
										}
										isame[11] = ldcs == ldc
										//
										//                       If data was incorrectly changed, report and
										//                       return.
										//
										same = true
										for i = 1; i <= nargs; i++ {
											same = same && isame[i-1]
											if !isame[i-1] {
												t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
											}
										}
										if !same {
											fatal = true
											goto label5150
										}

										if !null {
											//
											//                          Check the result column by column.
											//
											jjab = 1
											jc = 1
											for j = 1; j <= n; j++ {
												if upper {
													jj = 1
													lj = j
												} else {
													jj = j
													lj = n - j + 1
												}
												if tran {
													for i = 1; i <= k; i++ {
														w[i-1] = ab[(j-1)*2*nmax+k+i-1]
														w[k+i-1] = ab[(j-1)*2*nmax+i-1]
													}
													dmmch(func() *byte { y := byte('T'); return &y }(), func() *byte { y := byte('N'); return &y }(), &lj, func() *int { y := 1; return &y }(), func() *int { y := 2 * k; return &y }(), &alpha, &ab, func() *int { y := jjab - 1; return &y }(), func() *int { y := 2 * nmax; return &y }(), &w, &izero, func() *int { y := 2 * nmax; return &y }(), &beta, &c, func() *int { y := jj - 1 + (j-1)*nmax + coff; return &y }(), &nmax, &ct, &g, &cc, func() *int { y := jc - 1 + coff; return &y }(), &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
												} else {
													for i = 1; i <= k; i++ {
														w[i-1] = ab[(k+i-1)*nmax+j-1]
														w[k+i-1] = ab[(i-1)*nmax+j-1]
													}
													dmmch(func() *byte { y := byte('N'); return &y }(), func() *byte { y := byte('N'); return &y }(), &lj, func() *int { y := 1; return &y }(), func() *int { y := 2 * k; return &y }(), &alpha, &ab, func() *int { y := jj - 1; return &y }(), &nmax, &w, &izero, func() *int { y := 2 * nmax; return &y }(), &beta, &c, func() *int { y := jj - 1 + (j-1)*nmax + coff; return &y }(), &nmax, &ct, &g, &cc, func() *int { y := jc - 1 + coff; return &y }(), &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
												}
												if upper {
													jc = jc + ldc
												} else {
													jc = jc + ldc + 1
													if tran {
														jjab = jjab + 2*nmax
													}
												}
												errmax = maxf64(errmax, err)
												//                             If got really bad answer, report and
												//                             return.
												if fatal {
													goto label5140
												}
											}
										}

									}

								}

							}

						label5110:
						}

					}

				label5130:
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", dname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", dname, nc, errmax)
			}
			continue
			//
		label5140:
			;
			if n > 1 {
				t.Errorf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)
			}
			//
		label5150:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c',%3d,%3d,%4.1f, A,%3d,%3d, B,%3d,%3d,%4.1f, C,%3d,%3d)    .\n", dname, nc, dname, uplo, trans, n, k, alpha, aoff, lda, boff, ldb, beta, coff, ldc)
		}
	}
}

func dcompare1(scomp1 *float64, strue1 *float64, ssize *[]float64, ssizeoff *int, sfac *float64, t *testing.T, fname []byte) {
	var scomp []float64 = []float64{*scomp1}
	var strue []float64 = []float64{*strue1}
	var izero int = 0
	var ione int = 1

	dcompare(&ione, &scomp, &izero, &strue, &izero, ssize, ssizeoff, sfac, t, fname)
}

func dcompare(len *int, scomp *[]float64, scompoff *int, strue *[]float64, strueoff *int, ssize *[]float64, ssizeoff *int, sfac *float64, t *testing.T, fname []byte) {
	var sd float64
	var i int
	var pass *bool = &common.combla.pass
	var icase *int = &common.combla.icase
	var incx *int = &common.combla.incx
	var incy *int = &common.combla.incy
	var n *int = &common.combla.n
	var off *int = &common.combla.off

	for i = 1; i <= (*len); i++ {
		sd = (*scomp)[i-1+(*scompoff)] - (*strue)[i-1+(*strueoff)]
		if absf64((*sfac)*sd) <= absf64((*ssize)[i-1+(*ssizeoff)])*epsilonf64() {
			return
		}
		//
		//                             HERE    SCOMP(I) IS NOT CLOSE TO STRUE(I).
		//
		(*pass) = false
		t.Logf("%s\n", fname)
		t.Logf("                                       FAIL\n")
		t.Logf("\n CASE OFF  N INCX INCY  I                             COMP(I)                             TRUE(I)  DIFFERENCE     SIZE(I)\n \n")
		t.Errorf(" %4d%4d%3d%5d%5d%3d%36.24f%36.24f%12.8f%12.8f\n", *icase, *off, *n, *incx, *incy, i, (*scomp)[i-1+(*scompoff)], (*strue)[i-1+(*strueoff)], sd, (*ssize)[i-1+(*ssizeoff)])
	}
}

func dbeg(reset *bool) (dbegReturn float64) {
	var i *int = &common.begc.i
	var ic *int = &common.begc.ic
	var mi *int = &common.begc.mi

	if *reset {
		//        Initialize local variables.
		*mi = 891
		*i = 7
		*ic = 0
		(*reset) = false
	}
	//
	//     The sequence of values of I is bounded between 1 and 999.
	//     If initial I = 1,2,3,6,7 or 9, the period will be 50.
	//     If initial I = 4 or 8, the period will be 25.
	//     If initial I = 5, the period will be 10.
	//     IC is used to break up the period by skipping 1 value of I in 6.
	//
	*ic++
label10:
	;
	*i = (*i) * (*mi)
	*i = (*i) - 1000*((*i)/1000)
	if *ic >= 5 {
		*ic = 0
		goto label10
	}
	dbegReturn = float64((*i)-500) / 1001.0
	return
}

func lde(ri *[]float64, rj *[]float64, roff, lr *int) bool {
	var i int

	for i = 1; i <= (*lr); i++ {
		if (*ri)[i-1+(*roff)] != (*rj)[i-1+(*roff)] {
			return false
		}
	}
	return true
}

func lderes(_type *[]byte, uplo *byte, m *int, n *int, aa *[]float64, as *[]float64, aoff *int, lda *int) bool {
	var upper bool
	var i, ibeg, iend, j int

	upper = (*uplo) == 'U'
	if bytes.Equal(*_type, []byte("GE")) {
		for j = 1; j <= (*n); j++ {
			for i = (*m) + 1; i <= (*lda); i++ {
				if (*aa)[i-1+(j-1)*(*lda)+(*aoff)] != (*as)[i-1+(j-1)*(*lda)+(*aoff)] {
					return false
				}
			}
		}
	} else if bytes.Equal(*_type, []byte("SY")) {
		for j = 1; j <= (*n); j++ {
			if upper {
				ibeg = 1
				iend = j
			} else {
				ibeg = j
				iend = (*n)
			}
			for i = 1; i <= ibeg-1; i++ {
				if (*aa)[i-1+(j-1)*(*lda)+(*aoff)] != (*as)[i-1+(j-1)*(*lda)+(*aoff)] {
					return false
				}
			}
			for i = iend + 1; i <= (*lda); i++ {
				if (*aa)[i-1+(j-1)*(*lda)+(*aoff)] != (*as)[i-1+(j-1)*(*lda)+(*aoff)] {
					return false
				}
			}
		}
	}

	return true
}

func dmvch(trans *byte, m *int, n *int, alpha *float64, a *[]float64, aoff, nmax *int, x *[]float64, xoff, incx *int, beta *float64, y *[]float64, yoff, incy *int, yt *[]float64, g *[]float64, yy *[]float64, yyoff *int, eps *float64, err *float64, fatal *bool, mv *bool, t *testing.T) {
	var tran bool
	var erri float64
	var i, incxl, incyl, iy, j, jx, kx, ky, ml, nl int
	var zero float64 = 0.0
	var one float64 = 1.0

	tran = (*trans) == 'T' || (*trans) == 'C'
	if tran {
		ml = (*n)
		nl = (*m)
	} else {
		ml = (*m)
		nl = (*n)
	}
	if (*incx) < 0 {
		kx = nl
		incxl = -1
	} else {
		kx = 1
		incxl = 1
	}
	if (*incy) < 0 {
		ky = ml
		incyl = -1
	} else {
		ky = 1
		incyl = 1
	}
	//
	//     Compute expected result in YT using data in A, X and Y.
	//     Compute gauges in G.
	//
	iy = ky
	for i = 1; i <= ml; i++ {
		(*yt)[iy-1] = zero
		(*g)[iy-1] = zero
		jx = kx
		if tran {
			for j = 1; j <= nl; j++ {
				(*yt)[iy-1] = (*yt)[iy-1] + (*a)[j-1+(i-1)*(*nmax)+(*aoff)]*(*x)[jx-1+(*xoff)]
				(*g)[iy-1] = (*g)[iy-1] + absf64((*a)[j-1+(i-1)*(*nmax)+(*aoff)]*(*x)[jx-1+(*xoff)])
				jx = jx + incxl
			}
		} else {
			for j = 1; j <= nl; j++ {
				(*yt)[iy-1] = (*yt)[iy-1] + (*a)[i-1+(j-1)*(*nmax)+(*aoff)]*(*x)[jx-1+(*xoff)]
				(*g)[iy-1] = (*g)[iy-1] + absf64((*a)[i-1+(j-1)*(*nmax)+(*aoff)]*(*x)[jx-1+(*xoff)])
				jx = jx + incxl
			}
		}
		(*yt)[iy-1] = (*alpha)*(*yt)[iy-1] + (*beta)*(*y)[iy-1+(*yoff)]
		(*g)[iy-1] = absf64(*alpha)*(*g)[iy-1] + absf64((*beta)*(*y)[iy-1+(*yoff)])
		iy = iy + incyl
	}
	//
	//     Compute the error ratio for this result.
	//
	(*err) = zero
	for i = 1; i <= ml; i++ {
		erri = absf64((*yt)[i-1]-(*yy)[1+(i-1)*absint(*incy)-1+(*yyoff)]) / (*eps)
		if (*g)[i-1] != zero {
			erri = erri / (*g)[i-1]
		}
		(*err) = maxf64(*err, erri)
		if (*err)*sqrtf64(*eps) >= one {
			goto label50
		}
	}
	//     If the loop completes, all results are at least half accurate.
	return
	//
	//     Report fatal error.
	//
label50:
	;
	(*fatal) = true
	t.Errorf(" ******* FATAL ERROR - COMPUTED RESULT IS LESS THAN HALF ACCURATE *******\n           EXPECTED RESULT   COMPUTED RESULT\n")
	for i = 1; i <= ml; i++ {
		if *mv {
			t.Errorf(" %7d%18.6f%18.6f\n", i, (*yt)[i-1], (*yy)[1+(i-1)*absint(*incy)-1+(*yyoff)])
		} else {
			t.Errorf(" %7d%18.6f%18.6f\n", i, (*yy)[1+(i-1)*absint(*incy)-1+(*yyoff)], (*yt)[i-1])
		}
	}
}

func dmmch(transa *byte, transb *byte, m *int, n *int, kk *int, alpha *float64, a *[]float64, aoff, lda *int, b *[]float64, boff, ldb *int, beta *float64, c *[]float64, coff, ldc *int, ct *[]float64, g *[]float64, cc *[]float64, ccoff, ldcc *int, eps *float64, err *float64, fatal *bool, mv *bool, t *testing.T) {
	var erri float64
	var i, j, k int
	var zero float64 = 0.0
	var one float64 = 1.0
	var trana bool = (*transa) == 'T' || (*transa) == 'C'
	var tranb bool = (*transb) == 'T' || (*transb) == 'C'

	//
	//     Compute expected result, one column at a time, in CT using data
	//     in A, B and C.
	//     Compute gauges in G.
	//
	for j = 1; j <= (*n); j++ {
		//
		for i = 1; i <= (*m); i++ {
			(*ct)[i-1] = zero
			(*g)[i-1] = zero
		}
		if !trana && !tranb {
			for k = 1; k <= (*kk); k++ {
				for i = 1; i <= (*m); i++ {
					(*ct)[i-1] = (*ct)[i-1] + (*a)[i-1+(k-1)*(*lda)+(*aoff)]*(*b)[k-1+(j-1)*(*ldb)+(*boff)]
					(*g)[i-1] = (*g)[i-1] + absf64((*a)[i-1+(k-1)*(*lda)+(*aoff)])*absf64((*b)[k-1+(j-1)*(*ldb)+(*boff)])
				}
			}
		} else if trana && !tranb {
			for k = 1; k <= (*kk); k++ {
				for i = 1; i <= (*m); i++ {
					(*ct)[i-1] = (*ct)[i-1] + (*a)[k-1+(i-1)*(*lda)+(*aoff)]*(*b)[k-1+(j-1)*(*ldb)+(*boff)]
					(*g)[i-1] = (*g)[i-1] + absf64((*a)[k-1+(i-1)*(*lda)+(*aoff)])*absf64((*b)[k-1+(j-1)*(*ldb)+(*boff)])
				}
			}
		} else if !trana && tranb {
			for k = 1; k <= (*kk); k++ {
				for i = 1; i <= (*m); i++ {
					(*ct)[i-1] = (*ct)[i-1] + (*a)[i-1+(k-1)*(*lda)+(*aoff)]*(*b)[j-1+(k-1)*(*ldb)+(*boff)]
					(*g)[i-1] = (*g)[i-1] + absf64((*a)[i-1+(k-1)*(*lda)+(*aoff)])*absf64((*b)[j-1+(k-1)*(*ldb)+(*boff)])
				}
			}
		} else if trana && tranb {
			for k = 1; k <= (*kk); k++ {
				for i = 1; i <= (*m); i++ {
					(*ct)[i-1] = (*ct)[i-1] + (*a)[k-1+(i-1)*(*lda)+(*aoff)]*(*b)[j-1+(k-1)*(*ldb)+(*boff)]
					(*g)[i-1] = (*g)[i-1] + absf64((*a)[k-1+(i-1)*(*lda)+(*aoff)])*absf64((*b)[j-1+(k-1)*(*ldb)+(*boff)])
				}
			}
		}
		for i = 1; i <= (*m); i++ {
			(*ct)[i-1] = (*alpha)*(*ct)[i-1] + (*beta)*(*c)[i-1+(j-1)*(*ldc)+(*coff)]
			(*g)[i-1] = absf64(*alpha)*(*g)[i-1] + absf64(*beta)*absf64((*c)[i-1+(j-1)*(*ldc)+(*coff)])
		}
		//
		//        Compute the error ratio for this result.
		//
		(*err) = zero
		for i = 1; i <= (*m); i++ {
			erri = absf64((*ct)[i-1]-(*cc)[i-1+(j-1)*(*ldcc)+(*ccoff)]) / (*eps)
			if (*g)[i-1] != zero {
				erri = erri / (*g)[i-1]
			}
			(*err) = maxf64(*err, erri)
			if (*err)*sqrtf64(*eps) >= one {
				goto label130
			}
		}
	}
	//
	//     If the loop completes, all results are at least half accurate.
	return
	//
	//     Report fatal error.
	//
label130:
	;
	*fatal = true
	t.Errorf(" ******* FATAL ERROR - COMPUTED RESULT IS LESS THAN HALF ACCURATE *******\n           EXPECTED RESULT   COMPUTED RESULT\n")
	for i = 1; i <= (*m); i++ {
		if *mv {
			t.Errorf(" %7d%18.6f%18.6f\n", i, (*ct)[i-1], (*cc)[i-1+(j-1)*(*ldc)])
		} else {
			t.Errorf(" %7d%18.6f%18.6f\n", i, (*cc)[i-1+(j-1)*(*ldc)], (*ct)[i-1])
		}
	}
	if (*n) > 1 {
		t.Errorf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)
	}
}

func dmakeL2(_type *[]byte, uplo *byte, diag *byte, m *int, n *int, a *[]float64, nmax *int, aa *[]float64, aoff, lda *int, kl *int, ku *int, reset *bool, transl *float64) {
	var i, i1, i2, i3, ibeg, iend, ioff, j, kk int
	var zero float64 = 0.0
	var one float64 = 1.0
	var rogue float64 = -1.0e10
	var gen bool = (*_type)[0] == 'G'
	var sym bool = (*_type)[0] == 'S'
	var tri bool = (*_type)[0] == 'T'
	var upper bool = (sym || tri) && (*uplo) == 'U'
	var lower bool = (sym || tri) && (*uplo) == 'L'
	var unit bool = tri && (*diag) == 'U'

	//
	//     Generate data in array A.
	//
	for j = 1; j <= (*n); j++ {
		for i = 1; i <= (*m); i++ {
			if gen || (upper && i <= j) || (lower && i >= j) {
				if (i <= j && j-i <= (*ku)) || (i >= j && i-j <= (*kl)) {
					(*a)[i+(j-1)*(*nmax)-1+(*aoff)] = dbeg(reset) + (*transl)
				} else {
					(*a)[i+(j-1)*(*nmax)-1+(*aoff)] = zero
				}
				if i != j {
					if sym {
						(*a)[j-1+(i-1)*(*nmax)+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
					} else if tri {
						(*a)[j-1+(i-1)*(*nmax)+(*aoff)] = zero
					}
				}
			}
		}
		if tri {
			(*a)[j-1+(j-1)*(*nmax)+(*aoff)] = (*a)[j-1+(j-1)*(*nmax)+(*aoff)] + one
		}
		if unit {
			(*a)[j-1+(j-1)*(*nmax)+(*aoff)] = one
		}
	}
	//
	//     Store elements in array AS in data structure required by routine.
	//
	if bytes.Equal(*_type, []byte("GE")) {
		for j = 1; j <= (*n); j++ {
			for i = 1; i <= (*m); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i = (*m) + 1; i <= (*lda); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
		}
	} else if bytes.Equal(*_type, []byte("GB")) {
		for j = 1; j <= (*n); j++ {
			for i1 = 1; i1 <= (*ku)+1-j; i1++ {
				(*aa)[i1+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
			for i2 = i1; i2 <= minint((*kl)+(*ku)+1, (*ku)+1+(*m)-j); i2++ {
				(*aa)[i2+(j-1)*(*lda)-1+(*aoff)] = (*a)[i2+j-(*ku)-1-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i3 = i2; i3 <= (*lda); i3++ {
				(*aa)[i3+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
		}
	} else if bytes.Equal(*_type, []byte("SY")) || bytes.Equal(*_type, []byte("TR")) {
		for j = 1; j <= (*n); j++ {
			if upper {
				ibeg = 1
				if unit {
					iend = j - 1
				} else {
					iend = j
				}
			} else {
				if unit {
					ibeg = j + 1
				} else {
					ibeg = j
				}
				iend = (*n)
			}
			for i = 1; i <= ibeg-1; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
			for i = ibeg; i <= iend; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i = iend + 1; i <= (*lda); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
		}
	} else if bytes.Equal(*_type, []byte("SB")) || bytes.Equal(*_type, []byte("TB")) {
		for j = 1; j <= (*n); j++ {
			if upper {
				kk = (*kl) + 1
				ibeg = maxint(1, (*kl)+2-j)
				if unit {
					iend = (*kl)
				} else {
					iend = (*kl) + 1
				}
			} else {
				kk = 1
				if unit {
					ibeg = 2
				} else {
					ibeg = 1
				}
				iend = minint((*kl)+1, 1+(*m)-j)
			}
			for i = 1; i <= ibeg-1; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
			for i = ibeg; i <= iend; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = (*a)[i+j-kk-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i = iend + 1; i <= (*lda); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
		}
	} else if bytes.Equal(*_type, []byte("SP")) || bytes.Equal(*_type, []byte("TP")) {
		ioff = 0
		for j = 1; j <= (*n); j++ {
			if upper {
				ibeg = 1
				iend = j
			} else {
				ibeg = j
				iend = (*n)
			}
			for i = ibeg; i <= iend; i++ {
				ioff = ioff + 1
				(*aa)[ioff-1+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
				if i == j {
					if unit {
						(*aa)[ioff-1+(*aoff)] = rogue
					}
				}
			}
		}
	}
}

func dmakeL3(_type *[]byte, uplo *byte, diag *byte, m *int, n *int, a *[]float64, nmax *int, aa *[]float64, aoff, lda *int, reset *bool, transl *float64) {
	var i, ibeg, iend, j int
	var zero float64 = 0.0
	var one float64 = 1.0
	var rogue float64 = -1.0e10
	var gen bool = bytes.Equal(*_type, []byte("GE"))
	var sym bool = bytes.Equal(*_type, []byte("SY"))
	var tri bool = bytes.Equal(*_type, []byte("TR"))
	var upper bool = (sym || tri) && (*uplo) == 'U'
	var lower bool = (sym || tri) && (*uplo) == 'L'
	var unit bool = tri && (*diag) == 'U'

	//
	//     Generate data in array A.
	//
	for j = 1; j <= (*n); j++ {
		for i = 1; i <= (*m); i++ {
			if gen || (upper && i <= j) || (lower && i >= j) {
				(*a)[i-1+(j-1)*(*nmax)+(*aoff)] = dbeg(reset) + (*transl)
				if i != j {
					//                 Set some elements to zero
					if (*n) > 3 && j == (*n)/2 {
						(*a)[i-1+(j-1)*(*nmax)+(*aoff)] = zero
					}
					if sym {
						(*a)[j-1+(i-1)*(*nmax)+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
					} else if tri {
						(*a)[j-1+(i-1)*(*nmax)+(*aoff)] = zero
					}
				}
			}
		}
		if tri {
			(*a)[j-1+(j-1)*(*nmax)+(*aoff)] = (*a)[j-1+(j-1)*(*nmax)+(*aoff)] + one
		}
		if unit {
			(*a)[j-1+(j-1)*(*nmax)+(*aoff)] = one
		}
	}
	//
	//     Store elements in array AS in data structure required by routine.
	//
	if bytes.Equal(*_type, []byte("GE")) {
		for j = 1; j <= (*n); j++ {
			for i = 1; i <= (*m); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i = (*m) + 1; i <= (*lda); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
		}
	} else if bytes.Equal(*_type, []byte("SY")) || bytes.Equal(*_type, []byte("TR")) {
		for j = 1; j <= (*n); j++ {
			if upper {
				ibeg = 1
				if unit {
					iend = j - 1
				} else {
					iend = j
				}
			} else {
				if unit {
					ibeg = j + 1
				} else {
					ibeg = j
				}
				iend = (*n)
			}
			for i = 1; i <= ibeg-1; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
			for i = ibeg; i <= iend; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i = iend + 1; i <= (*lda); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
		}
	}
}
