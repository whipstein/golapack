package golapack

import (
	"testing"
)

func TestSblasLevel1(t *testing.T) {
	var i, incx, incy, j, k, ki, kn, kni, kpar, ksize, len, lenx, leny, mx, my, n, np1, off int
	var sfac float32 = 9.765625e-4
	var snames []string = []string{
		"Srotg",
		"Srotmg",
		"Srotm",
		"Srot",
		"Sdot",
		"Sdsdot",
		"Saxpy",
		"Scopy",
		"Sswap",
		"Snrm2",
		"Sasum",
		"Sscal",
		"Isamax",
	}

	for _, sname := range snames {
		if sname == "Srotg" || sname == "Srotmg" {
			var nc int
			var d12, sa, sb, sc, ss float32
			var da1 []float32 = []float32{0.3, 0.4, -0.3, -0.4, -0.3, 0.0, 0.0, 1.0}
			var datrue []float32 = []float32{0.5, 0.5, 0.5, -0.5, -0.5, 0.0, 1.0, 1.0}
			var db1 []float32 = []float32{0.4, 0.3, 0.4, 0.3, -0.4, 0.0, 1.0, 0.0}
			var dbtrue []float32 = []float32{0.0, 0.6, 0.0, -0.6, 0.0, 0.0, 1.0, 0.0}
			var dc1 []float32 = []float32{0.6, 0.8, -0.6, 0.8, 0.6, 1.0, 0.0, 1.0}
			var ds1 []float32 = []float32{0.8, 0.6, 0.8, -0.6, 0.8, 0.0, 1.0, 0.0}
			dtemp := make([]float32, 9+25)
			dab := make([]float32, 4*9)
			dtrue := make([]float32, 9*9)

			dab[0+0*4], dab[1+0*4], dab[2+0*4], dab[3+0*4], dab[0+1*4], dab[1+1*4], dab[2+1*4], dab[3+1*4], dab[0+2*4], dab[1+2*4], dab[2+2*4], dab[3+2*4], dab[0+3*4], dab[1+3*4], dab[2+3*4], dab[3+3*4], dab[0+4*4], dab[1+4*4], dab[2+4*4], dab[3+4*4], dab[0+5*4], dab[1+5*4], dab[2+5*4], dab[3+5*4], dab[0+6*4], dab[1+6*4], dab[2+6*4], dab[3+6*4], dab[0+7*4], dab[1+7*4], dab[2+7*4], dab[3+7*4], dab[0+8*4], dab[1+8*4], dab[2+8*4], dab[3+8*4] = .1, .3, 1.2, .2, .7, .2, .6, 4.2, 0., 0., 0., 0., 4., -1., 2., 4., 6.e-10, 2.e-2, 1.e5, 10., 4.e10, 2.e-2, 1.e-5, 10., 2.e-10, 4.e-2, 1.e5, 10., 2.e10, 4.e-2, 1.e-5, 10., 4., -2., 8., 4.
			//    TRUE RESULTS FOR MODIFIED GIVENS
			dtrue[0+0*9], dtrue[1+0*9], dtrue[2+0*9], dtrue[3+0*9], dtrue[4+0*9], dtrue[5+0*9], dtrue[6+0*9], dtrue[7+0*9], dtrue[8+0*9], dtrue[0+1*9], dtrue[1+1*9], dtrue[2+1*9], dtrue[3+1*9], dtrue[4+1*9], dtrue[5+1*9], dtrue[6+1*9], dtrue[7+1*9], dtrue[8+1*9], dtrue[0+2*9], dtrue[1+2*9], dtrue[2+2*9], dtrue[3+2*9], dtrue[4+2*9], dtrue[5+2*9], dtrue[6+2*9], dtrue[7+2*9], dtrue[8+2*9], dtrue[0+3*9], dtrue[1+3*9], dtrue[2+3*9], dtrue[3+3*9], dtrue[4+3*9], dtrue[5+3*9], dtrue[6+3*9], dtrue[7+3*9], dtrue[8+3*9], dtrue[0+4*9], dtrue[1+4*9], dtrue[2+4*9], dtrue[3+4*9], dtrue[4+4*9], dtrue[5+4*9], dtrue[6+4*9], dtrue[7+4*9], dtrue[8+4*9], dtrue[0+5*9], dtrue[1+5*9], dtrue[2+5*9], dtrue[3+5*9], dtrue[4+5*9], dtrue[5+5*9], dtrue[6+5*9], dtrue[7+5*9], dtrue[8+5*9], dtrue[0+6*9], dtrue[1+6*9], dtrue[2+6*9], dtrue[3+6*9], dtrue[4+6*9], dtrue[5+6*9], dtrue[6+6*9], dtrue[7+6*9], dtrue[8+6*9], dtrue[0+7*9], dtrue[1+7*9], dtrue[2+7*9], dtrue[3+7*9], dtrue[4+7*9], dtrue[5+7*9], dtrue[6+7*9], dtrue[7+7*9], dtrue[8+7*9], dtrue[0+8*9], dtrue[1+8*9], dtrue[2+8*9], dtrue[3+8*9], dtrue[4+8*9], dtrue[5+8*9], dtrue[6+8*9], dtrue[7+8*9], dtrue[8+8*9] = 0., 0., 1.3, .2, 0., 0., 0., .5, 0., 0., 0., 4.5, 4.2, 1., .5, 0., 0., 0., 0., 0., 0., 0., -2., 0., 0., 0., 0., 0., 0., 0., 4., -1., 0., 0., 0., 0., 0., 15.e-3, 0., 10., -1., 0., -1.e-4, 0., 1., 0., 0., 6144.e-5, 10., -1., 4096., -1.e6, 0., 1., 0., 0., 15., 10., -1., 5.e-5, 0., 1., 0., 0., 0., 15., 10., -1.0, 5e5, -4096., 1., 4096.e-6, 0., 0., 7., 4., 0., 0., -.5, -.25, 0.
			//                   4096 = 2 ** 12
			d12 = 4096.
			dtrue[0+0*9] = 12. / 130.
			dtrue[1+0*9] = 36. / 130.
			dtrue[6+0*9] = -1. / 6.
			dtrue[0+1*9] = 14. / 75.
			dtrue[1+1*9] = 49. / 75.
			dtrue[8+1*9] = 1. / 7.
			dtrue[0+4*9] = 45.e-11 * (d12 * d12)
			dtrue[2+4*9] = 4.e5 / (3. * d12)
			dtrue[5+4*9] = 1. / d12
			dtrue[7+4*9] = 1.e4 / (3. * d12)
			dtrue[0+5*9] = 4.e10 / (1.5 * d12 * d12)
			dtrue[1+5*9] = 2.e-2 / 1.5
			dtrue[7+5*9] = 5.e-7 * d12
			dtrue[0+6*9] = 4. / 150.
			dtrue[1+6*9] = (2.e-10 / 1.5) * (d12 * d12)
			dtrue[6+6*9] = -dtrue[5+4*9]
			dtrue[8+6*9] = 1.e4 / d12
			dtrue[0+7*9] = dtrue[0+6*9]
			dtrue[1+7*9] = 2.e10 / (1.5 * d12 * d12)
			dtrue[0+8*9] = 32. / 7.
			dtrue[1+8*9] = -16. / 7.
			//
			//     Compute true values which cannot be prestored
			//     in decimal notation
			//
			dbtrue[0] = 1.0 / 0.6
			dbtrue[2] = -1.0 / 0.6
			dbtrue[4] = 1.0 / 0.6

			n = 0
			for off = 0; off <= 25; off += 5 {
				for k = 1; k <= 8; k++ {

					nc++

					if sname == "Srotg" {
						if off != 0 {
							continue
						}
						if k > 8 {
							continue
						}
						n++
						sa = da1[k-1]
						sb = db1[k-1]
						Srotg(&sa, &sb, &sc, &ss)
						scompare1(sa, datrue[k-1], &datrue, k-1, sfac, t, sname)
						scompare1(sb, dbtrue[k-1], &dbtrue, k-1, sfac, t, sname)
						scompare1(sc, dc1[k-1], &dc1, k-1, sfac, t, sname)
						scompare1(ss, ds1[k-1], &ds1, k-1, sfac, t, sname)
					} else if sname == "Srotmg" {
						n++
						for i = 1; i <= 4; i++ {
							dtemp[i-1+off] = dab[i-1+(k-1)*4]
							dtemp[i+4-1+off] = 0.0
						}
						dtemp[8+off] = 0.0
						Srotmg(&(dtemp[0+off]), &(dtemp[1+off]), &(dtemp[2+off]), &(dtemp[3+off]), &dtemp, func() *int { y := 4 + off; return &y }())
						scompare(9, &dtemp, off, &dtrue, 0+(k-1)*9, &dtrue, 0+(k-1)*9, sfac, t, sname)
					}
				}
			}

			t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)

		} else if sname == "Snrm2" || sname == "Sasum" || sname == "Sscal" || sname == "Isamax" {
			var nc int
			var dtrue1 []float32 = []float32{0.0, 0.3, 0.5, 0.7, 0.6}
			var dtrue3 []float32 = []float32{0.0, 0.3, 0.7, 1.1, 1.0}
			var sa []float32 = []float32{0.3, -1.0, 0.0, 1.0, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3}
			stemp := make([]float32, 1)
			strue := make([]float32, 8+25)
			sx := make([]float32, 8*25)
			var itrue2 []int = []int{0, 1, 2, 2, 3}
			dtrue5 := make([]float32, 8*5*2)
			dv := make([]float32, 8*5*2)

			dv[0+(0+(0)*5)*8], dv[1+(0+(0)*5)*8], dv[2+(0+(0)*5)*8], dv[3+(0+(0)*5)*8], dv[4+(0+(0)*5)*8], dv[5+(0+(0)*5)*8], dv[6+(0+(0)*5)*8], dv[7+(0+(0)*5)*8], dv[0+(1+(0)*5)*8], dv[1+(1+(0)*5)*8], dv[2+(1+(0)*5)*8], dv[3+(1+(0)*5)*8], dv[4+(1+(0)*5)*8], dv[5+(1+(0)*5)*8], dv[6+(1+(0)*5)*8], dv[7+(1+(0)*5)*8], dv[0+(2+(0)*5)*8], dv[1+(2+(0)*5)*8], dv[2+(2+(0)*5)*8], dv[3+(2+(0)*5)*8], dv[4+(2+(0)*5)*8], dv[5+(2+(0)*5)*8], dv[6+(2+(0)*5)*8], dv[7+(2+(0)*5)*8], dv[0+(3+(0)*5)*8], dv[1+(3+(0)*5)*8], dv[2+(3+(0)*5)*8], dv[3+(3+(0)*5)*8], dv[4+(3+(0)*5)*8], dv[5+(3+(0)*5)*8], dv[6+(3+(0)*5)*8], dv[7+(3+(0)*5)*8], dv[0+(4+(0)*5)*8], dv[1+(4+(0)*5)*8], dv[2+(4+(0)*5)*8], dv[3+(4+(0)*5)*8], dv[4+(4+(0)*5)*8], dv[5+(4+(0)*5)*8], dv[6+(4+(0)*5)*8], dv[7+(4+(0)*5)*8], dv[0+(0+(1)*5)*8], dv[1+(0+(1)*5)*8], dv[2+(0+(1)*5)*8], dv[3+(0+(1)*5)*8], dv[4+(0+(1)*5)*8], dv[5+(0+(1)*5)*8], dv[6+(0+(1)*5)*8], dv[7+(0+(1)*5)*8], dv[0+(1+(1)*5)*8], dv[1+(1+(1)*5)*8], dv[2+(1+(1)*5)*8], dv[3+(1+(1)*5)*8], dv[4+(1+(1)*5)*8], dv[5+(1+(1)*5)*8], dv[6+(1+(1)*5)*8], dv[7+(1+(1)*5)*8], dv[0+(2+(1)*5)*8], dv[1+(2+(1)*5)*8], dv[2+(2+(1)*5)*8], dv[3+(2+(1)*5)*8], dv[4+(2+(1)*5)*8], dv[5+(2+(1)*5)*8], dv[6+(2+(1)*5)*8], dv[7+(2+(1)*5)*8], dv[0+(3+(1)*5)*8], dv[1+(3+(1)*5)*8], dv[2+(3+(1)*5)*8], dv[3+(3+(1)*5)*8], dv[4+(3+(1)*5)*8], dv[5+(3+(1)*5)*8], dv[6+(3+(1)*5)*8], dv[7+(3+(1)*5)*8], dv[0+(4+(1)*5)*8], dv[1+(4+(1)*5)*8], dv[2+(4+(1)*5)*8], dv[3+(4+(1)*5)*8], dv[4+(4+(1)*5)*8], dv[5+(4+(1)*5)*8], dv[6+(4+(1)*5)*8], dv[7+(4+(1)*5)*8] = 0.1, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 0.3, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 0.3, -0.4, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 0.2, -0.6, 0.3, 5.0, 5.0, 5.0, 5.0, 5.0, 0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0, 0.1, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 0.3, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 0.3, 2.0, -0.4, 2.0, 2.0, 2.0, 2.0, 2.0, 0.2, 3.0, -0.6, 5.0, 0.3, 2.0, 2.0, 2.0, 0.1, 4.0, -0.3, 6.0, -0.5, 7.0, -0.1, 3.0
			dtrue5[0+(0+(0)*5)*8], dtrue5[1+(0+(0)*5)*8], dtrue5[2+(0+(0)*5)*8], dtrue5[3+(0+(0)*5)*8], dtrue5[4+(0+(0)*5)*8], dtrue5[5+(0+(0)*5)*8], dtrue5[6+(0+(0)*5)*8], dtrue5[7+(0+(0)*5)*8], dtrue5[0+(1+(0)*5)*8], dtrue5[1+(1+(0)*5)*8], dtrue5[2+(1+(0)*5)*8], dtrue5[3+(1+(0)*5)*8], dtrue5[4+(1+(0)*5)*8], dtrue5[5+(1+(0)*5)*8], dtrue5[6+(1+(0)*5)*8], dtrue5[7+(1+(0)*5)*8], dtrue5[0+(2+(0)*5)*8], dtrue5[1+(2+(0)*5)*8], dtrue5[2+(2+(0)*5)*8], dtrue5[3+(2+(0)*5)*8], dtrue5[4+(2+(0)*5)*8], dtrue5[5+(2+(0)*5)*8], dtrue5[6+(2+(0)*5)*8], dtrue5[7+(2+(0)*5)*8], dtrue5[0+(3+(0)*5)*8], dtrue5[1+(3+(0)*5)*8], dtrue5[2+(3+(0)*5)*8], dtrue5[3+(3+(0)*5)*8], dtrue5[4+(3+(0)*5)*8], dtrue5[5+(3+(0)*5)*8], dtrue5[6+(3+(0)*5)*8], dtrue5[7+(3+(0)*5)*8], dtrue5[0+(4+(0)*5)*8], dtrue5[1+(4+(0)*5)*8], dtrue5[2+(4+(0)*5)*8], dtrue5[3+(4+(0)*5)*8], dtrue5[4+(4+(0)*5)*8], dtrue5[5+(4+(0)*5)*8], dtrue5[6+(4+(0)*5)*8], dtrue5[7+(4+(0)*5)*8], dtrue5[0+(0+(1)*5)*8], dtrue5[1+(0+(1)*5)*8], dtrue5[2+(0+(1)*5)*8], dtrue5[3+(0+(1)*5)*8], dtrue5[4+(0+(1)*5)*8], dtrue5[5+(0+(1)*5)*8], dtrue5[6+(0+(1)*5)*8], dtrue5[7+(0+(1)*5)*8], dtrue5[0+(1+(1)*5)*8], dtrue5[1+(1+(1)*5)*8], dtrue5[2+(1+(1)*5)*8], dtrue5[3+(1+(1)*5)*8], dtrue5[4+(1+(1)*5)*8], dtrue5[5+(1+(1)*5)*8], dtrue5[6+(1+(1)*5)*8], dtrue5[7+(1+(1)*5)*8], dtrue5[0+(2+(1)*5)*8], dtrue5[1+(2+(1)*5)*8], dtrue5[2+(2+(1)*5)*8], dtrue5[3+(2+(1)*5)*8], dtrue5[4+(2+(1)*5)*8], dtrue5[5+(2+(1)*5)*8], dtrue5[6+(2+(1)*5)*8], dtrue5[7+(2+(1)*5)*8], dtrue5[0+(3+(1)*5)*8], dtrue5[1+(3+(1)*5)*8], dtrue5[2+(3+(1)*5)*8], dtrue5[3+(3+(1)*5)*8], dtrue5[4+(3+(1)*5)*8], dtrue5[5+(3+(1)*5)*8], dtrue5[6+(3+(1)*5)*8], dtrue5[7+(3+(1)*5)*8], dtrue5[0+(4+(1)*5)*8], dtrue5[1+(4+(1)*5)*8], dtrue5[2+(4+(1)*5)*8], dtrue5[3+(4+(1)*5)*8], dtrue5[4+(4+(1)*5)*8], dtrue5[5+(4+(1)*5)*8], dtrue5[6+(4+(1)*5)*8], dtrue5[7+(4+(1)*5)*8] = 0.10, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, -0.3, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 0.0, 0.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 0.20, -0.60, 0.30, 5.0, 5.0, 5.0, 5.0, 5.0, 0.03, -0.09, 0.15, -0.03, 6.0, 6.0, 6.0, 6.0, 0.10, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 0.09, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 0.09, 2.0, -0.12, 2.0, 2.0, 2.0, 2.0, 2.0, 0.06, 3.0, -0.18, 5.0, 0.09, 2.0, 2.0, 2.0, 0.03, 4.0, -0.09, 6.0, -0.15, 7.0, -0.03, 3.0

			n = 0
			for incx = 1; incx <= 2; incx++ {
				for np1 = 1; np1 <= 5; np1++ {
					n++
					len = 2 * maxint(np1-1, 1)
					for i = 1; i <= len; i++ {
						sx[i-1+off] = dv[i-1+(np1-1+(incx-1)*5)*8]
					}

					nc++

					if sname == "Snrm2" {
						stemp[0] = dtrue1[np1-1]
						scompare1(Snrm2(func() *int { y := np1 - 1; return &y }(), &sx, &off, &incx), stemp[0], &stemp, 0, sfac, t, sname)
					} else if sname == "Sasum" {
						stemp[0] = dtrue3[np1-1]
						scompare1(Sasum(func() *int { y := np1 - 1; return &y }(), &sx, &off, &incx), stemp[0], &stemp, 0, sfac, t, sname)
					} else if sname == "Sscal" {
						Sscal(func() *int { y := np1 - 1; return &y }(), &(sa[(incx-1)*5+np1-1]), &sx, &off, &incx)
						for i = 1; i <= len; i++ {
							strue[i-1] = dtrue5[i-1+(np1-1+(incx-1)*5)*8]
						}
						scompare(len, &sx, off, &strue, 0, &strue, 0, sfac, t, sname)
					} else if sname == "Isamax" {
						icompare1(Isamax(func() *int { y := np1 - 1; return &y }(), &sx, &off, &incx), itrue2[np1-1], t, sname)
					}
				}
			}

			t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)

		} else if sname == "Sdot" || sname == "Saxpy" || sname == "Scopy" || sname == "Sswap" || sname == "Srotm" || sname == "Sdsdot" {
			var nc int
			var sa float32 = 0.3
			dtemp := make([]float32, 5)
			var dx1 []float32 = []float32{0.6, 0.1, -0.5, 0.8, 0.9, -0.3, -0.4}
			var dy1 []float32 = []float32{0.5, -0.9, 0.3, 0.7, -0.6, 0.2, 0.8}
			ssize := make([]float32, 7)
			var ssize1 []float32 = []float32{0.0, 0.3, 1.6, 3.2}
			var ssize3 []float32 = []float32{.1, .4, 1.7, 3.3}
			stx := make([]float32, 7)
			sty := make([]float32, 7)
			sx := make([]float32, 7*25)
			sy := make([]float32, 7*25)
			var incxs []int = []int{1, 2, -2, -1}
			var incys []int = []int{1, -2, 1, -2}
			var ns []int = []int{0, 1, 2, 4}
			dpar := make([]float32, 5*4)
			dt7 := make([]float32, 4*4)
			ssize2 := make([]float32, 14*2)
			dt10x := make([]float32, 7*4*4)
			dt10y := make([]float32, 7*4*4)
			st7b := make([]float32, 4*4)
			dt8 := make([]float32, 7*4*4)
			lens := make([]int, 4*2)
			dt19x := make([]float32, 7*4*16)
			dt19y := make([]float32, 7*4*16)

			lens[0+(0)*4], lens[1+(0)*4], lens[2+(0)*4], lens[3+(0)*4], lens[0+(1)*4], lens[1+(1)*4], lens[2+(1)*4], lens[3+(1)*4] = 1, 1, 2, 4, 1, 1, 3, 7
			dt7[0+(0)*4], dt7[1+(0)*4], dt7[2+(0)*4], dt7[3+(0)*4], dt7[0+(1)*4], dt7[1+(1)*4], dt7[2+(1)*4], dt7[3+(1)*4], dt7[0+(2)*4], dt7[1+(2)*4], dt7[2+(2)*4], dt7[3+(2)*4], dt7[0+(3)*4], dt7[1+(3)*4], dt7[2+(3)*4], dt7[3+(3)*4] = 0.0, 0.30, 0.21, 0.62, 0.0, 0.30, -0.07, 0.85, 0.0, 0.30, -0.79, -0.74, 0.0, 0.30, 0.33, 1.27
			st7b[0+(0)*4], st7b[1+(0)*4], st7b[2+(0)*4], st7b[3+(0)*4], st7b[0+(1)*4], st7b[1+(1)*4], st7b[2+(1)*4], st7b[3+(1)*4], st7b[0+(2)*4], st7b[1+(2)*4], st7b[2+(2)*4], st7b[3+(2)*4], st7b[0+(3)*4], st7b[1+(3)*4], st7b[2+(3)*4], st7b[3+(3)*4] = .1, .4, .31, .72, .1, .4, .03, .95, .1, .4, -.69, -.64, .1, .4, .43, 1.37
			dt8[0+(0+(0)*4)*7], dt8[1+(0+(0)*4)*7], dt8[2+(0+(0)*4)*7], dt8[3+(0+(0)*4)*7], dt8[4+(0+(0)*4)*7], dt8[5+(0+(0)*4)*7], dt8[6+(0+(0)*4)*7], dt8[0+(1+(0)*4)*7], dt8[1+(1+(0)*4)*7], dt8[2+(1+(0)*4)*7], dt8[3+(1+(0)*4)*7], dt8[4+(1+(0)*4)*7], dt8[5+(1+(0)*4)*7], dt8[6+(1+(0)*4)*7], dt8[0+(2+(0)*4)*7], dt8[1+(2+(0)*4)*7], dt8[2+(2+(0)*4)*7], dt8[3+(2+(0)*4)*7], dt8[4+(2+(0)*4)*7], dt8[5+(2+(0)*4)*7], dt8[6+(2+(0)*4)*7], dt8[0+(3+(0)*4)*7], dt8[1+(3+(0)*4)*7], dt8[2+(3+(0)*4)*7], dt8[3+(3+(0)*4)*7], dt8[4+(3+(0)*4)*7], dt8[5+(3+(0)*4)*7], dt8[6+(3+(0)*4)*7], dt8[0+(0+(1)*4)*7], dt8[1+(0+(1)*4)*7], dt8[2+(0+(1)*4)*7], dt8[3+(0+(1)*4)*7], dt8[4+(0+(1)*4)*7], dt8[5+(0+(1)*4)*7], dt8[6+(0+(1)*4)*7], dt8[0+(1+(1)*4)*7], dt8[1+(1+(1)*4)*7], dt8[2+(1+(1)*4)*7], dt8[3+(1+(1)*4)*7], dt8[4+(1+(1)*4)*7], dt8[5+(1+(1)*4)*7], dt8[6+(1+(1)*4)*7], dt8[0+(2+(1)*4)*7], dt8[1+(2+(1)*4)*7], dt8[2+(2+(1)*4)*7], dt8[3+(2+(1)*4)*7], dt8[4+(2+(1)*4)*7], dt8[5+(2+(1)*4)*7], dt8[6+(2+(1)*4)*7], dt8[0+(3+(1)*4)*7], dt8[1+(3+(1)*4)*7], dt8[2+(3+(1)*4)*7], dt8[3+(3+(1)*4)*7], dt8[4+(3+(1)*4)*7], dt8[5+(3+(1)*4)*7], dt8[6+(3+(1)*4)*7], dt8[0+(0+(2)*4)*7], dt8[1+(0+(2)*4)*7], dt8[2+(0+(2)*4)*7], dt8[3+(0+(2)*4)*7], dt8[4+(0+(2)*4)*7], dt8[5+(0+(2)*4)*7], dt8[6+(0+(2)*4)*7], dt8[0+(1+(2)*4)*7], dt8[1+(1+(2)*4)*7], dt8[2+(1+(2)*4)*7], dt8[3+(1+(2)*4)*7], dt8[4+(1+(2)*4)*7], dt8[5+(1+(2)*4)*7], dt8[6+(1+(2)*4)*7], dt8[0+(2+(2)*4)*7], dt8[1+(2+(2)*4)*7], dt8[2+(2+(2)*4)*7], dt8[3+(2+(2)*4)*7], dt8[4+(2+(2)*4)*7], dt8[5+(2+(2)*4)*7], dt8[6+(2+(2)*4)*7], dt8[0+(3+(2)*4)*7], dt8[1+(3+(2)*4)*7], dt8[2+(3+(2)*4)*7], dt8[3+(3+(2)*4)*7], dt8[4+(3+(2)*4)*7], dt8[5+(3+(2)*4)*7], dt8[6+(3+(2)*4)*7], dt8[0+(0+(3)*4)*7], dt8[1+(0+(3)*4)*7], dt8[2+(0+(3)*4)*7], dt8[3+(0+(3)*4)*7], dt8[4+(0+(3)*4)*7], dt8[5+(0+(3)*4)*7], dt8[6+(0+(3)*4)*7], dt8[0+(1+(3)*4)*7], dt8[1+(1+(3)*4)*7], dt8[2+(1+(3)*4)*7], dt8[3+(1+(3)*4)*7], dt8[4+(1+(3)*4)*7], dt8[5+(1+(3)*4)*7], dt8[6+(1+(3)*4)*7], dt8[0+(2+(3)*4)*7], dt8[1+(2+(3)*4)*7], dt8[2+(2+(3)*4)*7], dt8[3+(2+(3)*4)*7], dt8[4+(2+(3)*4)*7], dt8[5+(2+(3)*4)*7], dt8[6+(2+(3)*4)*7], dt8[0+(3+(3)*4)*7], dt8[1+(3+(3)*4)*7], dt8[2+(3+(3)*4)*7], dt8[3+(3+(3)*4)*7], dt8[4+(3+(3)*4)*7], dt8[5+(3+(3)*4)*7], dt8[6+(3+(3)*4)*7] = 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.68, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.68, -0.87, 0.0, 0.0, 0.0, 0.0, 0.0, 0.68, -0.87, 0.15, 0.94, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.68, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.35, -0.9, 0.48, 0.0, 0.0, 0.0, 0.0, 0.38, -0.9, 0.57, 0.7, -0.75, 0.2, 0.98, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.68, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.35, -0.72, 0.0, 0.0, 0.0, 0.0, 0.0, 0.38, -0.63, 0.15, 0.88, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.68, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.68, -0.9, 0.33, 0.0, 0.0, 0.0, 0.0, 0.68, -0.9, 0.33, 0.7, -0.75, 0.2, 1.04
			dt10x[0+(0+(0)*4)*7], dt10x[1+(0+(0)*4)*7], dt10x[2+(0+(0)*4)*7], dt10x[3+(0+(0)*4)*7], dt10x[4+(0+(0)*4)*7], dt10x[5+(0+(0)*4)*7], dt10x[6+(0+(0)*4)*7], dt10x[0+(1+(0)*4)*7], dt10x[1+(1+(0)*4)*7], dt10x[2+(1+(0)*4)*7], dt10x[3+(1+(0)*4)*7], dt10x[4+(1+(0)*4)*7], dt10x[5+(1+(0)*4)*7], dt10x[6+(1+(0)*4)*7], dt10x[0+(2+(0)*4)*7], dt10x[1+(2+(0)*4)*7], dt10x[2+(2+(0)*4)*7], dt10x[3+(2+(0)*4)*7], dt10x[4+(2+(0)*4)*7], dt10x[5+(2+(0)*4)*7], dt10x[6+(2+(0)*4)*7], dt10x[0+(3+(0)*4)*7], dt10x[1+(3+(0)*4)*7], dt10x[2+(3+(0)*4)*7], dt10x[3+(3+(0)*4)*7], dt10x[4+(3+(0)*4)*7], dt10x[5+(3+(0)*4)*7], dt10x[6+(3+(0)*4)*7], dt10x[0+(0+(1)*4)*7], dt10x[1+(0+(1)*4)*7], dt10x[2+(0+(1)*4)*7], dt10x[3+(0+(1)*4)*7], dt10x[4+(0+(1)*4)*7], dt10x[5+(0+(1)*4)*7], dt10x[6+(0+(1)*4)*7], dt10x[0+(1+(1)*4)*7], dt10x[1+(1+(1)*4)*7], dt10x[2+(1+(1)*4)*7], dt10x[3+(1+(1)*4)*7], dt10x[4+(1+(1)*4)*7], dt10x[5+(1+(1)*4)*7], dt10x[6+(1+(1)*4)*7], dt10x[0+(2+(1)*4)*7], dt10x[1+(2+(1)*4)*7], dt10x[2+(2+(1)*4)*7], dt10x[3+(2+(1)*4)*7], dt10x[4+(2+(1)*4)*7], dt10x[5+(2+(1)*4)*7], dt10x[6+(2+(1)*4)*7], dt10x[0+(3+(1)*4)*7], dt10x[1+(3+(1)*4)*7], dt10x[2+(3+(1)*4)*7], dt10x[3+(3+(1)*4)*7], dt10x[4+(3+(1)*4)*7], dt10x[5+(3+(1)*4)*7], dt10x[6+(3+(1)*4)*7], dt10x[0+(0+(2)*4)*7], dt10x[1+(0+(2)*4)*7], dt10x[2+(0+(2)*4)*7], dt10x[3+(0+(2)*4)*7], dt10x[4+(0+(2)*4)*7], dt10x[5+(0+(2)*4)*7], dt10x[6+(0+(2)*4)*7], dt10x[0+(1+(2)*4)*7], dt10x[1+(1+(2)*4)*7], dt10x[2+(1+(2)*4)*7], dt10x[3+(1+(2)*4)*7], dt10x[4+(1+(2)*4)*7], dt10x[5+(1+(2)*4)*7], dt10x[6+(1+(2)*4)*7], dt10x[0+(2+(2)*4)*7], dt10x[1+(2+(2)*4)*7], dt10x[2+(2+(2)*4)*7], dt10x[3+(2+(2)*4)*7], dt10x[4+(2+(2)*4)*7], dt10x[5+(2+(2)*4)*7], dt10x[6+(2+(2)*4)*7], dt10x[0+(3+(2)*4)*7], dt10x[1+(3+(2)*4)*7], dt10x[2+(3+(2)*4)*7], dt10x[3+(3+(2)*4)*7], dt10x[4+(3+(2)*4)*7], dt10x[5+(3+(2)*4)*7], dt10x[6+(3+(2)*4)*7], dt10x[0+(0+(3)*4)*7], dt10x[1+(0+(3)*4)*7], dt10x[2+(0+(3)*4)*7], dt10x[3+(0+(3)*4)*7], dt10x[4+(0+(3)*4)*7], dt10x[5+(0+(3)*4)*7], dt10x[6+(0+(3)*4)*7], dt10x[0+(1+(3)*4)*7], dt10x[1+(1+(3)*4)*7], dt10x[2+(1+(3)*4)*7], dt10x[3+(1+(3)*4)*7], dt10x[4+(1+(3)*4)*7], dt10x[5+(1+(3)*4)*7], dt10x[6+(1+(3)*4)*7], dt10x[0+(2+(3)*4)*7], dt10x[1+(2+(3)*4)*7], dt10x[2+(2+(3)*4)*7], dt10x[3+(2+(3)*4)*7], dt10x[4+(2+(3)*4)*7], dt10x[5+(2+(3)*4)*7], dt10x[6+(2+(3)*4)*7], dt10x[0+(3+(3)*4)*7], dt10x[1+(3+(3)*4)*7], dt10x[2+(3+(3)*4)*7], dt10x[3+(3+(3)*4)*7], dt10x[4+(3+(3)*4)*7], dt10x[5+(3+(3)*4)*7], dt10x[6+(3+(3)*4)*7] = 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, -0.9, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, -0.9, 0.3, 0.7, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.3, 0.1, 0.5, 0.0, 0.0, 0.0, 0.0, 0.8, 0.1, -0.6, 0.8, 0.3, -0.3, 0.5, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.9, 0.1, 0.5, 0.0, 0.0, 0.0, 0.0, 0.7, 0.1, 0.3, 0.8, -0.9, -0.3, 0.5, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.3, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.3, -0.6, 0.8, 0.0, 0.0, 0.0
			dt10y[0+(0+(0)*4)*7], dt10y[1+(0+(0)*4)*7], dt10y[2+(0+(0)*4)*7], dt10y[3+(0+(0)*4)*7], dt10y[4+(0+(0)*4)*7], dt10y[5+(0+(0)*4)*7], dt10y[6+(0+(0)*4)*7], dt10y[0+(1+(0)*4)*7], dt10y[1+(1+(0)*4)*7], dt10y[2+(1+(0)*4)*7], dt10y[3+(1+(0)*4)*7], dt10y[4+(1+(0)*4)*7], dt10y[5+(1+(0)*4)*7], dt10y[6+(1+(0)*4)*7], dt10y[0+(2+(0)*4)*7], dt10y[1+(2+(0)*4)*7], dt10y[2+(2+(0)*4)*7], dt10y[3+(2+(0)*4)*7], dt10y[4+(2+(0)*4)*7], dt10y[5+(2+(0)*4)*7], dt10y[6+(2+(0)*4)*7], dt10y[0+(3+(0)*4)*7], dt10y[1+(3+(0)*4)*7], dt10y[2+(3+(0)*4)*7], dt10y[3+(3+(0)*4)*7], dt10y[4+(3+(0)*4)*7], dt10y[5+(3+(0)*4)*7], dt10y[6+(3+(0)*4)*7], dt10y[0+(0+(1)*4)*7], dt10y[1+(0+(1)*4)*7], dt10y[2+(0+(1)*4)*7], dt10y[3+(0+(1)*4)*7], dt10y[4+(0+(1)*4)*7], dt10y[5+(0+(1)*4)*7], dt10y[6+(0+(1)*4)*7], dt10y[0+(1+(1)*4)*7], dt10y[1+(1+(1)*4)*7], dt10y[2+(1+(1)*4)*7], dt10y[3+(1+(1)*4)*7], dt10y[4+(1+(1)*4)*7], dt10y[5+(1+(1)*4)*7], dt10y[6+(1+(1)*4)*7], dt10y[0+(2+(1)*4)*7], dt10y[1+(2+(1)*4)*7], dt10y[2+(2+(1)*4)*7], dt10y[3+(2+(1)*4)*7], dt10y[4+(2+(1)*4)*7], dt10y[5+(2+(1)*4)*7], dt10y[6+(2+(1)*4)*7], dt10y[0+(3+(1)*4)*7], dt10y[1+(3+(1)*4)*7], dt10y[2+(3+(1)*4)*7], dt10y[3+(3+(1)*4)*7], dt10y[4+(3+(1)*4)*7], dt10y[5+(3+(1)*4)*7], dt10y[6+(3+(1)*4)*7], dt10y[0+(0+(2)*4)*7], dt10y[1+(0+(2)*4)*7], dt10y[2+(0+(2)*4)*7], dt10y[3+(0+(2)*4)*7], dt10y[4+(0+(2)*4)*7], dt10y[5+(0+(2)*4)*7], dt10y[6+(0+(2)*4)*7], dt10y[0+(1+(2)*4)*7], dt10y[1+(1+(2)*4)*7], dt10y[2+(1+(2)*4)*7], dt10y[3+(1+(2)*4)*7], dt10y[4+(1+(2)*4)*7], dt10y[5+(1+(2)*4)*7], dt10y[6+(1+(2)*4)*7], dt10y[0+(2+(2)*4)*7], dt10y[1+(2+(2)*4)*7], dt10y[2+(2+(2)*4)*7], dt10y[3+(2+(2)*4)*7], dt10y[4+(2+(2)*4)*7], dt10y[5+(2+(2)*4)*7], dt10y[6+(2+(2)*4)*7], dt10y[0+(3+(2)*4)*7], dt10y[1+(3+(2)*4)*7], dt10y[2+(3+(2)*4)*7], dt10y[3+(3+(2)*4)*7], dt10y[4+(3+(2)*4)*7], dt10y[5+(3+(2)*4)*7], dt10y[6+(3+(2)*4)*7], dt10y[0+(0+(3)*4)*7], dt10y[1+(0+(3)*4)*7], dt10y[2+(0+(3)*4)*7], dt10y[3+(0+(3)*4)*7], dt10y[4+(0+(3)*4)*7], dt10y[5+(0+(3)*4)*7], dt10y[6+(0+(3)*4)*7], dt10y[0+(1+(3)*4)*7], dt10y[1+(1+(3)*4)*7], dt10y[2+(1+(3)*4)*7], dt10y[3+(1+(3)*4)*7], dt10y[4+(1+(3)*4)*7], dt10y[5+(1+(3)*4)*7], dt10y[6+(1+(3)*4)*7], dt10y[0+(2+(3)*4)*7], dt10y[1+(2+(3)*4)*7], dt10y[2+(2+(3)*4)*7], dt10y[3+(2+(3)*4)*7], dt10y[4+(2+(3)*4)*7], dt10y[5+(2+(3)*4)*7], dt10y[6+(2+(3)*4)*7], dt10y[0+(3+(3)*4)*7], dt10y[1+(3+(3)*4)*7], dt10y[2+(3+(3)*4)*7], dt10y[3+(3+(3)*4)*7], dt10y[4+(3+(3)*4)*7], dt10y[5+(3+(3)*4)*7], dt10y[6+(3+(3)*4)*7] = 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.1, -0.5, 0.8, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5, -0.9, 0.6, 0.0, 0.0, 0.0, 0.0, -0.4, -0.9, 0.9, 0.7, -0.5, 0.2, 0.6, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, -0.4, 0.9, -0.5, 0.6, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, -0.9, 0.1, 0.0, 0.0, 0.0, 0.0, 0.6, -0.9, 0.1, 0.7, -0.5, 0.2, 0.8
			ssize2[0+(0)*14], ssize2[1+(0)*14], ssize2[2+(0)*14], ssize2[3+(0)*14], ssize2[4+(0)*14], ssize2[5+(0)*14], ssize2[6+(0)*14], ssize2[7+(0)*14], ssize2[8+(0)*14], ssize2[9+(0)*14], ssize2[10+(0)*14], ssize2[11+(0)*14], ssize2[12+(0)*14], ssize2[13+(0)*14], ssize2[0+(1)*14], ssize2[1+(1)*14], ssize2[2+(1)*14], ssize2[3+(1)*14], ssize2[4+(1)*14], ssize2[5+(1)*14], ssize2[6+(1)*14], ssize2[7+(1)*14], ssize2[8+(1)*14], ssize2[9+(1)*14], ssize2[10+(1)*14], ssize2[11+(1)*14], ssize2[12+(1)*14], ssize2[13+(1)*14] = 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17

			dpar[0+(0)*5], dpar[1+(0)*5], dpar[2+(0)*5], dpar[3+(0)*5], dpar[4+(0)*5], dpar[0+(1)*5], dpar[1+(1)*5], dpar[2+(1)*5], dpar[3+(1)*5], dpar[4+(1)*5], dpar[0+(2)*5], dpar[1+(2)*5], dpar[2+(2)*5], dpar[3+(2)*5], dpar[4+(2)*5], dpar[0+(3)*5], dpar[1+(3)*5], dpar[2+(3)*5], dpar[3+(3)*5], dpar[4+(3)*5] = -2., 0., 0., 0., 0., -1., 2., -3., -4., 5., 0., 0., 2., -3., 0., 1., 5., 2., 0., -4.

			dt19x[0+(0+(0)*4)*7], dt19x[1+(0+(0)*4)*7], dt19x[2+(0+(0)*4)*7], dt19x[3+(0+(0)*4)*7], dt19x[4+(0+(0)*4)*7], dt19x[5+(0+(0)*4)*7], dt19x[6+(0+(0)*4)*7], dt19x[0+(1+(0)*4)*7], dt19x[1+(1+(0)*4)*7], dt19x[2+(1+(0)*4)*7], dt19x[3+(1+(0)*4)*7], dt19x[4+(1+(0)*4)*7], dt19x[5+(1+(0)*4)*7], dt19x[6+(1+(0)*4)*7], dt19x[0+(2+(0)*4)*7], dt19x[1+(2+(0)*4)*7], dt19x[2+(2+(0)*4)*7], dt19x[3+(2+(0)*4)*7], dt19x[4+(2+(0)*4)*7], dt19x[5+(2+(0)*4)*7], dt19x[6+(2+(0)*4)*7], dt19x[0+(3+(0)*4)*7], dt19x[1+(3+(0)*4)*7], dt19x[2+(3+(0)*4)*7], dt19x[3+(3+(0)*4)*7], dt19x[4+(3+(0)*4)*7], dt19x[5+(3+(0)*4)*7], dt19x[6+(3+(0)*4)*7], dt19x[0+(0+(1)*4)*7], dt19x[1+(0+(1)*4)*7], dt19x[2+(0+(1)*4)*7], dt19x[3+(0+(1)*4)*7], dt19x[4+(0+(1)*4)*7], dt19x[5+(0+(1)*4)*7], dt19x[6+(0+(1)*4)*7], dt19x[0+(1+(1)*4)*7], dt19x[1+(1+(1)*4)*7], dt19x[2+(1+(1)*4)*7], dt19x[3+(1+(1)*4)*7], dt19x[4+(1+(1)*4)*7], dt19x[5+(1+(1)*4)*7], dt19x[6+(1+(1)*4)*7], dt19x[0+(2+(1)*4)*7], dt19x[1+(2+(1)*4)*7], dt19x[2+(2+(1)*4)*7], dt19x[3+(2+(1)*4)*7], dt19x[4+(2+(1)*4)*7], dt19x[5+(2+(1)*4)*7], dt19x[6+(2+(1)*4)*7], dt19x[0+(3+(1)*4)*7], dt19x[1+(3+(1)*4)*7], dt19x[2+(3+(1)*4)*7], dt19x[3+(3+(1)*4)*7], dt19x[4+(3+(1)*4)*7], dt19x[5+(3+(1)*4)*7], dt19x[6+(3+(1)*4)*7], dt19x[0+(0+(2)*4)*7], dt19x[1+(0+(2)*4)*7], dt19x[2+(0+(2)*4)*7], dt19x[3+(0+(2)*4)*7], dt19x[4+(0+(2)*4)*7], dt19x[5+(0+(2)*4)*7], dt19x[6+(0+(2)*4)*7], dt19x[0+(1+(2)*4)*7], dt19x[1+(1+(2)*4)*7], dt19x[2+(1+(2)*4)*7], dt19x[3+(1+(2)*4)*7], dt19x[4+(1+(2)*4)*7], dt19x[5+(1+(2)*4)*7], dt19x[6+(1+(2)*4)*7], dt19x[0+(2+(2)*4)*7], dt19x[1+(2+(2)*4)*7], dt19x[2+(2+(2)*4)*7], dt19x[3+(2+(2)*4)*7], dt19x[4+(2+(2)*4)*7], dt19x[5+(2+(2)*4)*7], dt19x[6+(2+(2)*4)*7], dt19x[0+(3+(2)*4)*7], dt19x[1+(3+(2)*4)*7], dt19x[2+(3+(2)*4)*7], dt19x[3+(3+(2)*4)*7], dt19x[4+(3+(2)*4)*7], dt19x[5+(3+(2)*4)*7], dt19x[6+(3+(2)*4)*7], dt19x[0+(0+(3)*4)*7], dt19x[1+(0+(3)*4)*7], dt19x[2+(0+(3)*4)*7], dt19x[3+(0+(3)*4)*7], dt19x[4+(0+(3)*4)*7], dt19x[5+(0+(3)*4)*7], dt19x[6+(0+(3)*4)*7], dt19x[0+(1+(3)*4)*7], dt19x[1+(1+(3)*4)*7], dt19x[2+(1+(3)*4)*7], dt19x[3+(1+(3)*4)*7], dt19x[4+(1+(3)*4)*7], dt19x[5+(1+(3)*4)*7], dt19x[6+(1+(3)*4)*7], dt19x[0+(2+(3)*4)*7], dt19x[1+(2+(3)*4)*7], dt19x[2+(2+(3)*4)*7], dt19x[3+(2+(3)*4)*7], dt19x[4+(2+(3)*4)*7], dt19x[5+(2+(3)*4)*7], dt19x[6+(2+(3)*4)*7], dt19x[0+(3+(3)*4)*7], dt19x[1+(3+(3)*4)*7], dt19x[2+(3+(3)*4)*7], dt19x[3+(3+(3)*4)*7], dt19x[4+(3+(3)*4)*7], dt19x[5+(3+(3)*4)*7], dt19x[6+(3+(3)*4)*7] = .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., -.8, 0., 0., 0., 0., 0., 0., -.9, 0., 0., 0., 0., 0., 0., 3.5, 0., 0., 0., 0., 0., 0., .6, .1, 0., 0., 0., 0., 0., -.8, 3.8, 0., 0., 0., 0., 0., -.9, 2.8, 0., 0., 0., 0., 0., 3.5, -.4, 0., 0., 0., 0., 0., .6, .1, -.5, .8, 0., 0., 0., -.8, 3.8, -2.2, -1.2, 0., 0., 0., -.9, 2.8, -1.4, -1.3, 0., 0., 0., 3.5, -.4, -2.2, 4.7, 0., 0., 0.
			dt19x[0+(0+(0+4)*4)*7], dt19x[1+(0+(0+4)*4)*7], dt19x[2+(0+(0+4)*4)*7], dt19x[3+(0+(0+4)*4)*7], dt19x[4+(0+(0+4)*4)*7], dt19x[5+(0+(0+4)*4)*7], dt19x[6+(0+(0+4)*4)*7], dt19x[0+(1+(0+4)*4)*7], dt19x[1+(1+(0+4)*4)*7], dt19x[2+(1+(0+4)*4)*7], dt19x[3+(1+(0+4)*4)*7], dt19x[4+(1+(0+4)*4)*7], dt19x[5+(1+(0+4)*4)*7], dt19x[6+(1+(0+4)*4)*7], dt19x[0+(2+(0+4)*4)*7], dt19x[1+(2+(0+4)*4)*7], dt19x[2+(2+(0+4)*4)*7], dt19x[3+(2+(0+4)*4)*7], dt19x[4+(2+(0+4)*4)*7], dt19x[5+(2+(0+4)*4)*7], dt19x[6+(2+(0+4)*4)*7], dt19x[0+(3+(0+4)*4)*7], dt19x[1+(3+(0+4)*4)*7], dt19x[2+(3+(0+4)*4)*7], dt19x[3+(3+(0+4)*4)*7], dt19x[4+(3+(0+4)*4)*7], dt19x[5+(3+(0+4)*4)*7], dt19x[6+(3+(0+4)*4)*7], dt19x[0+(0+(1+4)*4)*7], dt19x[1+(0+(1+4)*4)*7], dt19x[2+(0+(1+4)*4)*7], dt19x[3+(0+(1+4)*4)*7], dt19x[4+(0+(1+4)*4)*7], dt19x[5+(0+(1+4)*4)*7], dt19x[6+(0+(1+4)*4)*7], dt19x[0+(1+(1+4)*4)*7], dt19x[1+(1+(1+4)*4)*7], dt19x[2+(1+(1+4)*4)*7], dt19x[3+(1+(1+4)*4)*7], dt19x[4+(1+(1+4)*4)*7], dt19x[5+(1+(1+4)*4)*7], dt19x[6+(1+(1+4)*4)*7], dt19x[0+(2+(1+4)*4)*7], dt19x[1+(2+(1+4)*4)*7], dt19x[2+(2+(1+4)*4)*7], dt19x[3+(2+(1+4)*4)*7], dt19x[4+(2+(1+4)*4)*7], dt19x[5+(2+(1+4)*4)*7], dt19x[6+(2+(1+4)*4)*7], dt19x[0+(3+(1+4)*4)*7], dt19x[1+(3+(1+4)*4)*7], dt19x[2+(3+(1+4)*4)*7], dt19x[3+(3+(1+4)*4)*7], dt19x[4+(3+(1+4)*4)*7], dt19x[5+(3+(1+4)*4)*7], dt19x[6+(3+(1+4)*4)*7], dt19x[0+(0+(2+4)*4)*7], dt19x[1+(0+(2+4)*4)*7], dt19x[2+(0+(2+4)*4)*7], dt19x[3+(0+(2+4)*4)*7], dt19x[4+(0+(2+4)*4)*7], dt19x[5+(0+(2+4)*4)*7], dt19x[6+(0+(2+4)*4)*7], dt19x[0+(1+(2+4)*4)*7], dt19x[1+(1+(2+4)*4)*7], dt19x[2+(1+(2+4)*4)*7], dt19x[3+(1+(2+4)*4)*7], dt19x[4+(1+(2+4)*4)*7], dt19x[5+(1+(2+4)*4)*7], dt19x[6+(1+(2+4)*4)*7], dt19x[0+(2+(2+4)*4)*7], dt19x[1+(2+(2+4)*4)*7], dt19x[2+(2+(2+4)*4)*7], dt19x[3+(2+(2+4)*4)*7], dt19x[4+(2+(2+4)*4)*7], dt19x[5+(2+(2+4)*4)*7], dt19x[6+(2+(2+4)*4)*7], dt19x[0+(3+(2+4)*4)*7], dt19x[1+(3+(2+4)*4)*7], dt19x[2+(3+(2+4)*4)*7], dt19x[3+(3+(2+4)*4)*7], dt19x[4+(3+(2+4)*4)*7], dt19x[5+(3+(2+4)*4)*7], dt19x[6+(3+(2+4)*4)*7], dt19x[0+(0+(3+4)*4)*7], dt19x[1+(0+(3+4)*4)*7], dt19x[2+(0+(3+4)*4)*7], dt19x[3+(0+(3+4)*4)*7], dt19x[4+(0+(3+4)*4)*7], dt19x[5+(0+(3+4)*4)*7], dt19x[6+(0+(3+4)*4)*7], dt19x[0+(1+(3+4)*4)*7], dt19x[1+(1+(3+4)*4)*7], dt19x[2+(1+(3+4)*4)*7], dt19x[3+(1+(3+4)*4)*7], dt19x[4+(1+(3+4)*4)*7], dt19x[5+(1+(3+4)*4)*7], dt19x[6+(1+(3+4)*4)*7], dt19x[0+(2+(3+4)*4)*7], dt19x[1+(2+(3+4)*4)*7], dt19x[2+(2+(3+4)*4)*7], dt19x[3+(2+(3+4)*4)*7], dt19x[4+(2+(3+4)*4)*7], dt19x[5+(2+(3+4)*4)*7], dt19x[6+(2+(3+4)*4)*7], dt19x[0+(3+(3+4)*4)*7], dt19x[1+(3+(3+4)*4)*7], dt19x[2+(3+(3+4)*4)*7], dt19x[3+(3+(3+4)*4)*7], dt19x[4+(3+(3+4)*4)*7], dt19x[5+(3+(3+4)*4)*7], dt19x[6+(3+(3+4)*4)*7] = .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., -.8, 0., 0., 0., 0., 0., 0., -.9, 0., 0., 0., 0., 0., 0., 3.5, 0., 0., 0., 0., 0., 0., .6, .1, -.5, 0., 0., 0., 0., 0., .1, -3.0, 0., 0., 0., 0., -.3, .1, -2.0, 0., 0., 0., 0., 3.3, .1, -2.0, 0., 0., 0., 0., .6, .1, -.5, .8, .9, -.3, -.4, -2.0, .1, 1.4, .8, .6, -.3, -2.8, -1.8, .1, 1.3, .8, 0., -.3, -1.9, 3.8, .1, -3.1, .8, 4.8, -.3, -1.5
			dt19x[0+(0+(0+8)*4)*7], dt19x[1+(0+(0+8)*4)*7], dt19x[2+(0+(0+8)*4)*7], dt19x[3+(0+(0+8)*4)*7], dt19x[4+(0+(0+8)*4)*7], dt19x[5+(0+(0+8)*4)*7], dt19x[6+(0+(0+8)*4)*7], dt19x[0+(1+(0+8)*4)*7], dt19x[1+(1+(0+8)*4)*7], dt19x[2+(1+(0+8)*4)*7], dt19x[3+(1+(0+8)*4)*7], dt19x[4+(1+(0+8)*4)*7], dt19x[5+(1+(0+8)*4)*7], dt19x[6+(1+(0+8)*4)*7], dt19x[0+(2+(0+8)*4)*7], dt19x[1+(2+(0+8)*4)*7], dt19x[2+(2+(0+8)*4)*7], dt19x[3+(2+(0+8)*4)*7], dt19x[4+(2+(0+8)*4)*7], dt19x[5+(2+(0+8)*4)*7], dt19x[6+(2+(0+8)*4)*7], dt19x[0+(3+(0+8)*4)*7], dt19x[1+(3+(0+8)*4)*7], dt19x[2+(3+(0+8)*4)*7], dt19x[3+(3+(0+8)*4)*7], dt19x[4+(3+(0+8)*4)*7], dt19x[5+(3+(0+8)*4)*7], dt19x[6+(3+(0+8)*4)*7], dt19x[0+(0+(1+8)*4)*7], dt19x[1+(0+(1+8)*4)*7], dt19x[2+(0+(1+8)*4)*7], dt19x[3+(0+(1+8)*4)*7], dt19x[4+(0+(1+8)*4)*7], dt19x[5+(0+(1+8)*4)*7], dt19x[6+(0+(1+8)*4)*7], dt19x[0+(1+(1+8)*4)*7], dt19x[1+(1+(1+8)*4)*7], dt19x[2+(1+(1+8)*4)*7], dt19x[3+(1+(1+8)*4)*7], dt19x[4+(1+(1+8)*4)*7], dt19x[5+(1+(1+8)*4)*7], dt19x[6+(1+(1+8)*4)*7], dt19x[0+(2+(1+8)*4)*7], dt19x[1+(2+(1+8)*4)*7], dt19x[2+(2+(1+8)*4)*7], dt19x[3+(2+(1+8)*4)*7], dt19x[4+(2+(1+8)*4)*7], dt19x[5+(2+(1+8)*4)*7], dt19x[6+(2+(1+8)*4)*7], dt19x[0+(3+(1+8)*4)*7], dt19x[1+(3+(1+8)*4)*7], dt19x[2+(3+(1+8)*4)*7], dt19x[3+(3+(1+8)*4)*7], dt19x[4+(3+(1+8)*4)*7], dt19x[5+(3+(1+8)*4)*7], dt19x[6+(3+(1+8)*4)*7], dt19x[0+(0+(2+8)*4)*7], dt19x[1+(0+(2+8)*4)*7], dt19x[2+(0+(2+8)*4)*7], dt19x[3+(0+(2+8)*4)*7], dt19x[4+(0+(2+8)*4)*7], dt19x[5+(0+(2+8)*4)*7], dt19x[6+(0+(2+8)*4)*7], dt19x[0+(1+(2+8)*4)*7], dt19x[1+(1+(2+8)*4)*7], dt19x[2+(1+(2+8)*4)*7], dt19x[3+(1+(2+8)*4)*7], dt19x[4+(1+(2+8)*4)*7], dt19x[5+(1+(2+8)*4)*7], dt19x[6+(1+(2+8)*4)*7], dt19x[0+(2+(2+8)*4)*7], dt19x[1+(2+(2+8)*4)*7], dt19x[2+(2+(2+8)*4)*7], dt19x[3+(2+(2+8)*4)*7], dt19x[4+(2+(2+8)*4)*7], dt19x[5+(2+(2+8)*4)*7], dt19x[6+(2+(2+8)*4)*7], dt19x[0+(3+(2+8)*4)*7], dt19x[1+(3+(2+8)*4)*7], dt19x[2+(3+(2+8)*4)*7], dt19x[3+(3+(2+8)*4)*7], dt19x[4+(3+(2+8)*4)*7], dt19x[5+(3+(2+8)*4)*7], dt19x[6+(3+(2+8)*4)*7], dt19x[0+(0+(3+8)*4)*7], dt19x[1+(0+(3+8)*4)*7], dt19x[2+(0+(3+8)*4)*7], dt19x[3+(0+(3+8)*4)*7], dt19x[4+(0+(3+8)*4)*7], dt19x[5+(0+(3+8)*4)*7], dt19x[6+(0+(3+8)*4)*7], dt19x[0+(1+(3+8)*4)*7], dt19x[1+(1+(3+8)*4)*7], dt19x[2+(1+(3+8)*4)*7], dt19x[3+(1+(3+8)*4)*7], dt19x[4+(1+(3+8)*4)*7], dt19x[5+(1+(3+8)*4)*7], dt19x[6+(1+(3+8)*4)*7], dt19x[0+(2+(3+8)*4)*7], dt19x[1+(2+(3+8)*4)*7], dt19x[2+(2+(3+8)*4)*7], dt19x[3+(2+(3+8)*4)*7], dt19x[4+(2+(3+8)*4)*7], dt19x[5+(2+(3+8)*4)*7], dt19x[6+(2+(3+8)*4)*7], dt19x[0+(3+(3+8)*4)*7], dt19x[1+(3+(3+8)*4)*7], dt19x[2+(3+(3+8)*4)*7], dt19x[3+(3+(3+8)*4)*7], dt19x[4+(3+(3+8)*4)*7], dt19x[5+(3+(3+8)*4)*7], dt19x[6+(3+(3+8)*4)*7] = .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., -.8, 0., 0., 0., 0., 0., 0., -.9, 0., 0., 0., 0., 0., 0., 3.5, 0., 0., 0., 0., 0., 0., .6, .1, -.5, 0., 0., 0., 0., 4.8, .1, -3.0, 0., 0., 0., 0., 3.3, .1, -2.0, 0., 0., 0., 0., 2.1, .1, -2.0, 0., 0., 0., 0., .6, .1, -.5, .8, .9, -.3, -.4, -1.6, .1, -2.2, .8, 5.4, -.3, -2.8, -1.5, .1, -1.4, .8, 3.6, -.3, -1.9, 3.7, .1, -2.2, .8, 3.6, -.3, -1.5
			dt19x[0+(0+(0+12)*4)*7], dt19x[1+(0+(0+12)*4)*7], dt19x[2+(0+(0+12)*4)*7], dt19x[3+(0+(0+12)*4)*7], dt19x[4+(0+(0+12)*4)*7], dt19x[5+(0+(0+12)*4)*7], dt19x[6+(0+(0+12)*4)*7], dt19x[0+(1+(0+12)*4)*7], dt19x[1+(1+(0+12)*4)*7], dt19x[2+(1+(0+12)*4)*7], dt19x[3+(1+(0+12)*4)*7], dt19x[4+(1+(0+12)*4)*7], dt19x[5+(1+(0+12)*4)*7], dt19x[6+(1+(0+12)*4)*7], dt19x[0+(2+(0+12)*4)*7], dt19x[1+(2+(0+12)*4)*7], dt19x[2+(2+(0+12)*4)*7], dt19x[3+(2+(0+12)*4)*7], dt19x[4+(2+(0+12)*4)*7], dt19x[5+(2+(0+12)*4)*7], dt19x[6+(2+(0+12)*4)*7], dt19x[0+(3+(0+12)*4)*7], dt19x[1+(3+(0+12)*4)*7], dt19x[2+(3+(0+12)*4)*7], dt19x[3+(3+(0+12)*4)*7], dt19x[4+(3+(0+12)*4)*7], dt19x[5+(3+(0+12)*4)*7], dt19x[6+(3+(0+12)*4)*7], dt19x[0+(0+(1+12)*4)*7], dt19x[1+(0+(1+12)*4)*7], dt19x[2+(0+(1+12)*4)*7], dt19x[3+(0+(1+12)*4)*7], dt19x[4+(0+(1+12)*4)*7], dt19x[5+(0+(1+12)*4)*7], dt19x[6+(0+(1+12)*4)*7], dt19x[0+(1+(1+12)*4)*7], dt19x[1+(1+(1+12)*4)*7], dt19x[2+(1+(1+12)*4)*7], dt19x[3+(1+(1+12)*4)*7], dt19x[4+(1+(1+12)*4)*7], dt19x[5+(1+(1+12)*4)*7], dt19x[6+(1+(1+12)*4)*7], dt19x[0+(2+(1+12)*4)*7], dt19x[1+(2+(1+12)*4)*7], dt19x[2+(2+(1+12)*4)*7], dt19x[3+(2+(1+12)*4)*7], dt19x[4+(2+(1+12)*4)*7], dt19x[5+(2+(1+12)*4)*7], dt19x[6+(2+(1+12)*4)*7], dt19x[0+(3+(1+12)*4)*7], dt19x[1+(3+(1+12)*4)*7], dt19x[2+(3+(1+12)*4)*7], dt19x[3+(3+(1+12)*4)*7], dt19x[4+(3+(1+12)*4)*7], dt19x[5+(3+(1+12)*4)*7], dt19x[6+(3+(1+12)*4)*7], dt19x[0+(0+(2+12)*4)*7], dt19x[1+(0+(2+12)*4)*7], dt19x[2+(0+(2+12)*4)*7], dt19x[3+(0+(2+12)*4)*7], dt19x[4+(0+(2+12)*4)*7], dt19x[5+(0+(2+12)*4)*7], dt19x[6+(0+(2+12)*4)*7], dt19x[0+(1+(2+12)*4)*7], dt19x[1+(1+(2+12)*4)*7], dt19x[2+(1+(2+12)*4)*7], dt19x[3+(1+(2+12)*4)*7], dt19x[4+(1+(2+12)*4)*7], dt19x[5+(1+(2+12)*4)*7], dt19x[6+(1+(2+12)*4)*7], dt19x[0+(2+(2+12)*4)*7], dt19x[1+(2+(2+12)*4)*7], dt19x[2+(2+(2+12)*4)*7], dt19x[3+(2+(2+12)*4)*7], dt19x[4+(2+(2+12)*4)*7], dt19x[5+(2+(2+12)*4)*7], dt19x[6+(2+(2+12)*4)*7], dt19x[0+(3+(2+12)*4)*7], dt19x[1+(3+(2+12)*4)*7], dt19x[2+(3+(2+12)*4)*7], dt19x[3+(3+(2+12)*4)*7], dt19x[4+(3+(2+12)*4)*7], dt19x[5+(3+(2+12)*4)*7], dt19x[6+(3+(2+12)*4)*7], dt19x[0+(0+(3+12)*4)*7], dt19x[1+(0+(3+12)*4)*7], dt19x[2+(0+(3+12)*4)*7], dt19x[3+(0+(3+12)*4)*7], dt19x[4+(0+(3+12)*4)*7], dt19x[5+(0+(3+12)*4)*7], dt19x[6+(0+(3+12)*4)*7], dt19x[0+(1+(3+12)*4)*7], dt19x[1+(1+(3+12)*4)*7], dt19x[2+(1+(3+12)*4)*7], dt19x[3+(1+(3+12)*4)*7], dt19x[4+(1+(3+12)*4)*7], dt19x[5+(1+(3+12)*4)*7], dt19x[6+(1+(3+12)*4)*7], dt19x[0+(2+(3+12)*4)*7], dt19x[1+(2+(3+12)*4)*7], dt19x[2+(2+(3+12)*4)*7], dt19x[3+(2+(3+12)*4)*7], dt19x[4+(2+(3+12)*4)*7], dt19x[5+(2+(3+12)*4)*7], dt19x[6+(2+(3+12)*4)*7], dt19x[0+(3+(3+12)*4)*7], dt19x[1+(3+(3+12)*4)*7], dt19x[2+(3+(3+12)*4)*7], dt19x[3+(3+(3+12)*4)*7], dt19x[4+(3+(3+12)*4)*7], dt19x[5+(3+(3+12)*4)*7], dt19x[6+(3+(3+12)*4)*7] = .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., .6, 0., 0., 0., 0., 0., 0., -.8, 0., 0., 0., 0., 0., 0., -.9, 0., 0., 0., 0., 0., 0., 3.5, 0., 0., 0., 0., 0., 0., .6, .1, 0., 0., 0., 0., 0., -.8, -1.0, 0., 0., 0., 0., 0., -.9, -.8, 0., 0., 0., 0., 0., 3.5, .8, 0., 0., 0., 0., 0., .6, .1, -.5, .8, 0., 0., 0., -.8, -1.0, 1.4, -1.6, 0., 0., 0., -.9, -.8, 1.3, -1.6, 0., 0., 0., 3.5, .8, -3.1, 4.8, 0., 0., 0.

			dt19y[0+(0+(0)*4)*7], dt19y[1+(0+(0)*4)*7], dt19y[2+(0+(0)*4)*7], dt19y[3+(0+(0)*4)*7], dt19y[4+(0+(0)*4)*7], dt19y[5+(0+(0)*4)*7], dt19y[6+(0+(0)*4)*7], dt19y[0+(1+(0)*4)*7], dt19y[1+(1+(0)*4)*7], dt19y[2+(1+(0)*4)*7], dt19y[3+(1+(0)*4)*7], dt19y[4+(1+(0)*4)*7], dt19y[5+(1+(0)*4)*7], dt19y[6+(1+(0)*4)*7], dt19y[0+(2+(0)*4)*7], dt19y[1+(2+(0)*4)*7], dt19y[2+(2+(0)*4)*7], dt19y[3+(2+(0)*4)*7], dt19y[4+(2+(0)*4)*7], dt19y[5+(2+(0)*4)*7], dt19y[6+(2+(0)*4)*7], dt19y[0+(3+(0)*4)*7], dt19y[1+(3+(0)*4)*7], dt19y[2+(3+(0)*4)*7], dt19y[3+(3+(0)*4)*7], dt19y[4+(3+(0)*4)*7], dt19y[5+(3+(0)*4)*7], dt19y[6+(3+(0)*4)*7], dt19y[0+(0+(1)*4)*7], dt19y[1+(0+(1)*4)*7], dt19y[2+(0+(1)*4)*7], dt19y[3+(0+(1)*4)*7], dt19y[4+(0+(1)*4)*7], dt19y[5+(0+(1)*4)*7], dt19y[6+(0+(1)*4)*7], dt19y[0+(1+(1)*4)*7], dt19y[1+(1+(1)*4)*7], dt19y[2+(1+(1)*4)*7], dt19y[3+(1+(1)*4)*7], dt19y[4+(1+(1)*4)*7], dt19y[5+(1+(1)*4)*7], dt19y[6+(1+(1)*4)*7], dt19y[0+(2+(1)*4)*7], dt19y[1+(2+(1)*4)*7], dt19y[2+(2+(1)*4)*7], dt19y[3+(2+(1)*4)*7], dt19y[4+(2+(1)*4)*7], dt19y[5+(2+(1)*4)*7], dt19y[6+(2+(1)*4)*7], dt19y[0+(3+(1)*4)*7], dt19y[1+(3+(1)*4)*7], dt19y[2+(3+(1)*4)*7], dt19y[3+(3+(1)*4)*7], dt19y[4+(3+(1)*4)*7], dt19y[5+(3+(1)*4)*7], dt19y[6+(3+(1)*4)*7], dt19y[0+(0+(2)*4)*7], dt19y[1+(0+(2)*4)*7], dt19y[2+(0+(2)*4)*7], dt19y[3+(0+(2)*4)*7], dt19y[4+(0+(2)*4)*7], dt19y[5+(0+(2)*4)*7], dt19y[6+(0+(2)*4)*7], dt19y[0+(1+(2)*4)*7], dt19y[1+(1+(2)*4)*7], dt19y[2+(1+(2)*4)*7], dt19y[3+(1+(2)*4)*7], dt19y[4+(1+(2)*4)*7], dt19y[5+(1+(2)*4)*7], dt19y[6+(1+(2)*4)*7], dt19y[0+(2+(2)*4)*7], dt19y[1+(2+(2)*4)*7], dt19y[2+(2+(2)*4)*7], dt19y[3+(2+(2)*4)*7], dt19y[4+(2+(2)*4)*7], dt19y[5+(2+(2)*4)*7], dt19y[6+(2+(2)*4)*7], dt19y[0+(3+(2)*4)*7], dt19y[1+(3+(2)*4)*7], dt19y[2+(3+(2)*4)*7], dt19y[3+(3+(2)*4)*7], dt19y[4+(3+(2)*4)*7], dt19y[5+(3+(2)*4)*7], dt19y[6+(3+(2)*4)*7], dt19y[0+(0+(3)*4)*7], dt19y[1+(0+(3)*4)*7], dt19y[2+(0+(3)*4)*7], dt19y[3+(0+(3)*4)*7], dt19y[4+(0+(3)*4)*7], dt19y[5+(0+(3)*4)*7], dt19y[6+(0+(3)*4)*7], dt19y[0+(1+(3)*4)*7], dt19y[1+(1+(3)*4)*7], dt19y[2+(1+(3)*4)*7], dt19y[3+(1+(3)*4)*7], dt19y[4+(1+(3)*4)*7], dt19y[5+(1+(3)*4)*7], dt19y[6+(1+(3)*4)*7], dt19y[0+(2+(3)*4)*7], dt19y[1+(2+(3)*4)*7], dt19y[2+(2+(3)*4)*7], dt19y[3+(2+(3)*4)*7], dt19y[4+(2+(3)*4)*7], dt19y[5+(2+(3)*4)*7], dt19y[6+(2+(3)*4)*7], dt19y[0+(3+(3)*4)*7], dt19y[1+(3+(3)*4)*7], dt19y[2+(3+(3)*4)*7], dt19y[3+(3+(3)*4)*7], dt19y[4+(3+(3)*4)*7], dt19y[5+(3+(3)*4)*7], dt19y[6+(3+(3)*4)*7] = .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .7, 0., 0., 0., 0., 0., 0., 1.7, 0., 0., 0., 0., 0., 0., -2.6, 0., 0., 0., 0., 0., 0., .5, -.9, 0., 0., 0., 0., 0., .7, -4.8, 0., 0., 0., 0., 0., 1.7, -.7, 0., 0., 0., 0., 0., -2.6, 3.5, 0., 0., 0., 0., 0., .5, -.9, .3, .7, 0., 0., 0., .7, -4.8, 3.0, 1.1, 0., 0., 0., 1.7, -.7, -.7, 2.3, 0., 0., 0., -2.6, 3.5, -.7, -3.6, 0., 0., 0.
			dt19y[0+(0+(0+4)*4)*7], dt19y[1+(0+(0+4)*4)*7], dt19y[2+(0+(0+4)*4)*7], dt19y[3+(0+(0+4)*4)*7], dt19y[4+(0+(0+4)*4)*7], dt19y[5+(0+(0+4)*4)*7], dt19y[6+(0+(0+4)*4)*7], dt19y[0+(1+(0+4)*4)*7], dt19y[1+(1+(0+4)*4)*7], dt19y[2+(1+(0+4)*4)*7], dt19y[3+(1+(0+4)*4)*7], dt19y[4+(1+(0+4)*4)*7], dt19y[5+(1+(0+4)*4)*7], dt19y[6+(1+(0+4)*4)*7], dt19y[0+(2+(0+4)*4)*7], dt19y[1+(2+(0+4)*4)*7], dt19y[2+(2+(0+4)*4)*7], dt19y[3+(2+(0+4)*4)*7], dt19y[4+(2+(0+4)*4)*7], dt19y[5+(2+(0+4)*4)*7], dt19y[6+(2+(0+4)*4)*7], dt19y[0+(3+(0+4)*4)*7], dt19y[1+(3+(0+4)*4)*7], dt19y[2+(3+(0+4)*4)*7], dt19y[3+(3+(0+4)*4)*7], dt19y[4+(3+(0+4)*4)*7], dt19y[5+(3+(0+4)*4)*7], dt19y[6+(3+(0+4)*4)*7], dt19y[0+(0+(1+4)*4)*7], dt19y[1+(0+(1+4)*4)*7], dt19y[2+(0+(1+4)*4)*7], dt19y[3+(0+(1+4)*4)*7], dt19y[4+(0+(1+4)*4)*7], dt19y[5+(0+(1+4)*4)*7], dt19y[6+(0+(1+4)*4)*7], dt19y[0+(1+(1+4)*4)*7], dt19y[1+(1+(1+4)*4)*7], dt19y[2+(1+(1+4)*4)*7], dt19y[3+(1+(1+4)*4)*7], dt19y[4+(1+(1+4)*4)*7], dt19y[5+(1+(1+4)*4)*7], dt19y[6+(1+(1+4)*4)*7], dt19y[0+(2+(1+4)*4)*7], dt19y[1+(2+(1+4)*4)*7], dt19y[2+(2+(1+4)*4)*7], dt19y[3+(2+(1+4)*4)*7], dt19y[4+(2+(1+4)*4)*7], dt19y[5+(2+(1+4)*4)*7], dt19y[6+(2+(1+4)*4)*7], dt19y[0+(3+(1+4)*4)*7], dt19y[1+(3+(1+4)*4)*7], dt19y[2+(3+(1+4)*4)*7], dt19y[3+(3+(1+4)*4)*7], dt19y[4+(3+(1+4)*4)*7], dt19y[5+(3+(1+4)*4)*7], dt19y[6+(3+(1+4)*4)*7], dt19y[0+(0+(2+4)*4)*7], dt19y[1+(0+(2+4)*4)*7], dt19y[2+(0+(2+4)*4)*7], dt19y[3+(0+(2+4)*4)*7], dt19y[4+(0+(2+4)*4)*7], dt19y[5+(0+(2+4)*4)*7], dt19y[6+(0+(2+4)*4)*7], dt19y[0+(1+(2+4)*4)*7], dt19y[1+(1+(2+4)*4)*7], dt19y[2+(1+(2+4)*4)*7], dt19y[3+(1+(2+4)*4)*7], dt19y[4+(1+(2+4)*4)*7], dt19y[5+(1+(2+4)*4)*7], dt19y[6+(1+(2+4)*4)*7], dt19y[0+(2+(2+4)*4)*7], dt19y[1+(2+(2+4)*4)*7], dt19y[2+(2+(2+4)*4)*7], dt19y[3+(2+(2+4)*4)*7], dt19y[4+(2+(2+4)*4)*7], dt19y[5+(2+(2+4)*4)*7], dt19y[6+(2+(2+4)*4)*7], dt19y[0+(3+(2+4)*4)*7], dt19y[1+(3+(2+4)*4)*7], dt19y[2+(3+(2+4)*4)*7], dt19y[3+(3+(2+4)*4)*7], dt19y[4+(3+(2+4)*4)*7], dt19y[5+(3+(2+4)*4)*7], dt19y[6+(3+(2+4)*4)*7], dt19y[0+(0+(3+4)*4)*7], dt19y[1+(0+(3+4)*4)*7], dt19y[2+(0+(3+4)*4)*7], dt19y[3+(0+(3+4)*4)*7], dt19y[4+(0+(3+4)*4)*7], dt19y[5+(0+(3+4)*4)*7], dt19y[6+(0+(3+4)*4)*7], dt19y[0+(1+(3+4)*4)*7], dt19y[1+(1+(3+4)*4)*7], dt19y[2+(1+(3+4)*4)*7], dt19y[3+(1+(3+4)*4)*7], dt19y[4+(1+(3+4)*4)*7], dt19y[5+(1+(3+4)*4)*7], dt19y[6+(1+(3+4)*4)*7], dt19y[0+(2+(3+4)*4)*7], dt19y[1+(2+(3+4)*4)*7], dt19y[2+(2+(3+4)*4)*7], dt19y[3+(2+(3+4)*4)*7], dt19y[4+(2+(3+4)*4)*7], dt19y[5+(2+(3+4)*4)*7], dt19y[6+(2+(3+4)*4)*7], dt19y[0+(3+(3+4)*4)*7], dt19y[1+(3+(3+4)*4)*7], dt19y[2+(3+(3+4)*4)*7], dt19y[3+(3+(3+4)*4)*7], dt19y[4+(3+(3+4)*4)*7], dt19y[5+(3+(3+4)*4)*7], dt19y[6+(3+(3+4)*4)*7] = .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .7, 0., 0., 0., 0., 0., 0., 1.7, 0., 0., 0., 0., 0., 0., -2.6, 0., 0., 0., 0., 0., 0., .5, -.9, .3, 0., 0., 0., 0., 4.0, -.9, -.3, 0., 0., 0., 0., -.5, -.9, 1.5, 0., 0., 0., 0., -1.5, -.9, -1.8, 0., 0., 0., 0., .5, -.9, .3, .7, -.6, .2, .8, 3.7, -.9, -1.2, .7, -1.5, .2, 2.2, -.3, -.9, 2.1, .7, -1.6, .2, 2.0, -1.6, -.9, -2.1, .7, 2.9, .2, -3.8
			dt19y[0+(0+(0+8)*4)*7], dt19y[1+(0+(0+8)*4)*7], dt19y[2+(0+(0+8)*4)*7], dt19y[3+(0+(0+8)*4)*7], dt19y[4+(0+(0+8)*4)*7], dt19y[5+(0+(0+8)*4)*7], dt19y[6+(0+(0+8)*4)*7], dt19y[0+(1+(0+8)*4)*7], dt19y[1+(1+(0+8)*4)*7], dt19y[2+(1+(0+8)*4)*7], dt19y[3+(1+(0+8)*4)*7], dt19y[4+(1+(0+8)*4)*7], dt19y[5+(1+(0+8)*4)*7], dt19y[6+(1+(0+8)*4)*7], dt19y[0+(2+(0+8)*4)*7], dt19y[1+(2+(0+8)*4)*7], dt19y[2+(2+(0+8)*4)*7], dt19y[3+(2+(0+8)*4)*7], dt19y[4+(2+(0+8)*4)*7], dt19y[5+(2+(0+8)*4)*7], dt19y[6+(2+(0+8)*4)*7], dt19y[0+(3+(0+8)*4)*7], dt19y[1+(3+(0+8)*4)*7], dt19y[2+(3+(0+8)*4)*7], dt19y[3+(3+(0+8)*4)*7], dt19y[4+(3+(0+8)*4)*7], dt19y[5+(3+(0+8)*4)*7], dt19y[6+(3+(0+8)*4)*7], dt19y[0+(0+(1+8)*4)*7], dt19y[1+(0+(1+8)*4)*7], dt19y[2+(0+(1+8)*4)*7], dt19y[3+(0+(1+8)*4)*7], dt19y[4+(0+(1+8)*4)*7], dt19y[5+(0+(1+8)*4)*7], dt19y[6+(0+(1+8)*4)*7], dt19y[0+(1+(1+8)*4)*7], dt19y[1+(1+(1+8)*4)*7], dt19y[2+(1+(1+8)*4)*7], dt19y[3+(1+(1+8)*4)*7], dt19y[4+(1+(1+8)*4)*7], dt19y[5+(1+(1+8)*4)*7], dt19y[6+(1+(1+8)*4)*7], dt19y[0+(2+(1+8)*4)*7], dt19y[1+(2+(1+8)*4)*7], dt19y[2+(2+(1+8)*4)*7], dt19y[3+(2+(1+8)*4)*7], dt19y[4+(2+(1+8)*4)*7], dt19y[5+(2+(1+8)*4)*7], dt19y[6+(2+(1+8)*4)*7], dt19y[0+(3+(1+8)*4)*7], dt19y[1+(3+(1+8)*4)*7], dt19y[2+(3+(1+8)*4)*7], dt19y[3+(3+(1+8)*4)*7], dt19y[4+(3+(1+8)*4)*7], dt19y[5+(3+(1+8)*4)*7], dt19y[6+(3+(1+8)*4)*7], dt19y[0+(0+(2+8)*4)*7], dt19y[1+(0+(2+8)*4)*7], dt19y[2+(0+(2+8)*4)*7], dt19y[3+(0+(2+8)*4)*7], dt19y[4+(0+(2+8)*4)*7], dt19y[5+(0+(2+8)*4)*7], dt19y[6+(0+(2+8)*4)*7], dt19y[0+(1+(2+8)*4)*7], dt19y[1+(1+(2+8)*4)*7], dt19y[2+(1+(2+8)*4)*7], dt19y[3+(1+(2+8)*4)*7], dt19y[4+(1+(2+8)*4)*7], dt19y[5+(1+(2+8)*4)*7], dt19y[6+(1+(2+8)*4)*7], dt19y[0+(2+(2+8)*4)*7], dt19y[1+(2+(2+8)*4)*7], dt19y[2+(2+(2+8)*4)*7], dt19y[3+(2+(2+8)*4)*7], dt19y[4+(2+(2+8)*4)*7], dt19y[5+(2+(2+8)*4)*7], dt19y[6+(2+(2+8)*4)*7], dt19y[0+(3+(2+8)*4)*7], dt19y[1+(3+(2+8)*4)*7], dt19y[2+(3+(2+8)*4)*7], dt19y[3+(3+(2+8)*4)*7], dt19y[4+(3+(2+8)*4)*7], dt19y[5+(3+(2+8)*4)*7], dt19y[6+(3+(2+8)*4)*7], dt19y[0+(0+(3+8)*4)*7], dt19y[1+(0+(3+8)*4)*7], dt19y[2+(0+(3+8)*4)*7], dt19y[3+(0+(3+8)*4)*7], dt19y[4+(0+(3+8)*4)*7], dt19y[5+(0+(3+8)*4)*7], dt19y[6+(0+(3+8)*4)*7], dt19y[0+(1+(3+8)*4)*7], dt19y[1+(1+(3+8)*4)*7], dt19y[2+(1+(3+8)*4)*7], dt19y[3+(1+(3+8)*4)*7], dt19y[4+(1+(3+8)*4)*7], dt19y[5+(1+(3+8)*4)*7], dt19y[6+(1+(3+8)*4)*7], dt19y[0+(2+(3+8)*4)*7], dt19y[1+(2+(3+8)*4)*7], dt19y[2+(2+(3+8)*4)*7], dt19y[3+(2+(3+8)*4)*7], dt19y[4+(2+(3+8)*4)*7], dt19y[5+(2+(3+8)*4)*7], dt19y[6+(2+(3+8)*4)*7], dt19y[0+(3+(3+8)*4)*7], dt19y[1+(3+(3+8)*4)*7], dt19y[2+(3+(3+8)*4)*7], dt19y[3+(3+(3+8)*4)*7], dt19y[4+(3+(3+8)*4)*7], dt19y[5+(3+(3+8)*4)*7], dt19y[6+(3+(3+8)*4)*7] = .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .7, 0., 0., 0., 0., 0., 0., 1.7, 0., 0., 0., 0., 0., 0., -2.6, 0., 0., 0., 0., 0., 0., .5, -.9, 0., 0., 0., 0., 0., 4.0, -6.3, 0., 0., 0., 0., 0., -.5, .3, 0., 0., 0., 0., 0., -1.5, 3.0, 0., 0., 0., 0., 0., .5, -.9, .3, .7, 0., 0., 0., 3.7, -7.2, 3.0, 1.7, 0., 0., 0., -.3, .9, -.7, 1.9, 0., 0., 0., -1.6, 2.7, -.7, -3.4, 0., 0., 0.
			dt19y[0+(0+(0+12)*4)*7], dt19y[1+(0+(0+12)*4)*7], dt19y[2+(0+(0+12)*4)*7], dt19y[3+(0+(0+12)*4)*7], dt19y[4+(0+(0+12)*4)*7], dt19y[5+(0+(0+12)*4)*7], dt19y[6+(0+(0+12)*4)*7], dt19y[0+(1+(0+12)*4)*7], dt19y[1+(1+(0+12)*4)*7], dt19y[2+(1+(0+12)*4)*7], dt19y[3+(1+(0+12)*4)*7], dt19y[4+(1+(0+12)*4)*7], dt19y[5+(1+(0+12)*4)*7], dt19y[6+(1+(0+12)*4)*7], dt19y[0+(2+(0+12)*4)*7], dt19y[1+(2+(0+12)*4)*7], dt19y[2+(2+(0+12)*4)*7], dt19y[3+(2+(0+12)*4)*7], dt19y[4+(2+(0+12)*4)*7], dt19y[5+(2+(0+12)*4)*7], dt19y[6+(2+(0+12)*4)*7], dt19y[0+(3+(0+12)*4)*7], dt19y[1+(3+(0+12)*4)*7], dt19y[2+(3+(0+12)*4)*7], dt19y[3+(3+(0+12)*4)*7], dt19y[4+(3+(0+12)*4)*7], dt19y[5+(3+(0+12)*4)*7], dt19y[6+(3+(0+12)*4)*7], dt19y[0+(0+(1+12)*4)*7], dt19y[1+(0+(1+12)*4)*7], dt19y[2+(0+(1+12)*4)*7], dt19y[3+(0+(1+12)*4)*7], dt19y[4+(0+(1+12)*4)*7], dt19y[5+(0+(1+12)*4)*7], dt19y[6+(0+(1+12)*4)*7], dt19y[0+(1+(1+12)*4)*7], dt19y[1+(1+(1+12)*4)*7], dt19y[2+(1+(1+12)*4)*7], dt19y[3+(1+(1+12)*4)*7], dt19y[4+(1+(1+12)*4)*7], dt19y[5+(1+(1+12)*4)*7], dt19y[6+(1+(1+12)*4)*7], dt19y[0+(2+(1+12)*4)*7], dt19y[1+(2+(1+12)*4)*7], dt19y[2+(2+(1+12)*4)*7], dt19y[3+(2+(1+12)*4)*7], dt19y[4+(2+(1+12)*4)*7], dt19y[5+(2+(1+12)*4)*7], dt19y[6+(2+(1+12)*4)*7], dt19y[0+(3+(1+12)*4)*7], dt19y[1+(3+(1+12)*4)*7], dt19y[2+(3+(1+12)*4)*7], dt19y[3+(3+(1+12)*4)*7], dt19y[4+(3+(1+12)*4)*7], dt19y[5+(3+(1+12)*4)*7], dt19y[6+(3+(1+12)*4)*7], dt19y[0+(0+(2+12)*4)*7], dt19y[1+(0+(2+12)*4)*7], dt19y[2+(0+(2+12)*4)*7], dt19y[3+(0+(2+12)*4)*7], dt19y[4+(0+(2+12)*4)*7], dt19y[5+(0+(2+12)*4)*7], dt19y[6+(0+(2+12)*4)*7], dt19y[0+(1+(2+12)*4)*7], dt19y[1+(1+(2+12)*4)*7], dt19y[2+(1+(2+12)*4)*7], dt19y[3+(1+(2+12)*4)*7], dt19y[4+(1+(2+12)*4)*7], dt19y[5+(1+(2+12)*4)*7], dt19y[6+(1+(2+12)*4)*7], dt19y[0+(2+(2+12)*4)*7], dt19y[1+(2+(2+12)*4)*7], dt19y[2+(2+(2+12)*4)*7], dt19y[3+(2+(2+12)*4)*7], dt19y[4+(2+(2+12)*4)*7], dt19y[5+(2+(2+12)*4)*7], dt19y[6+(2+(2+12)*4)*7], dt19y[0+(3+(2+12)*4)*7], dt19y[1+(3+(2+12)*4)*7], dt19y[2+(3+(2+12)*4)*7], dt19y[3+(3+(2+12)*4)*7], dt19y[4+(3+(2+12)*4)*7], dt19y[5+(3+(2+12)*4)*7], dt19y[6+(3+(2+12)*4)*7], dt19y[0+(0+(3+12)*4)*7], dt19y[1+(0+(3+12)*4)*7], dt19y[2+(0+(3+12)*4)*7], dt19y[3+(0+(3+12)*4)*7], dt19y[4+(0+(3+12)*4)*7], dt19y[5+(0+(3+12)*4)*7], dt19y[6+(0+(3+12)*4)*7], dt19y[0+(1+(3+12)*4)*7], dt19y[1+(1+(3+12)*4)*7], dt19y[2+(1+(3+12)*4)*7], dt19y[3+(1+(3+12)*4)*7], dt19y[4+(1+(3+12)*4)*7], dt19y[5+(1+(3+12)*4)*7], dt19y[6+(1+(3+12)*4)*7], dt19y[0+(2+(3+12)*4)*7], dt19y[1+(2+(3+12)*4)*7], dt19y[2+(2+(3+12)*4)*7], dt19y[3+(2+(3+12)*4)*7], dt19y[4+(2+(3+12)*4)*7], dt19y[5+(2+(3+12)*4)*7], dt19y[6+(2+(3+12)*4)*7], dt19y[0+(3+(3+12)*4)*7], dt19y[1+(3+(3+12)*4)*7], dt19y[2+(3+(3+12)*4)*7], dt19y[3+(3+(3+12)*4)*7], dt19y[4+(3+(3+12)*4)*7], dt19y[5+(3+(3+12)*4)*7], dt19y[6+(3+(3+12)*4)*7] = .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .5, 0., 0., 0., 0., 0., 0., .7, 0., 0., 0., 0., 0., 0., 1.7, 0., 0., 0., 0., 0., 0., -2.6, 0., 0., 0., 0., 0., 0., .5, -.9, .3, 0., 0., 0., 0., .7, -.9, 1.2, 0., 0., 0., 0., 1.7, -.9, .5, 0., 0., 0., 0., -2.6, -.9, -1.3, 0., 0., 0., 0., .5, -.9, .3, .7, -.6, .2, .8, .7, -.9, 1.2, .7, -1.5, .2, 1.6, 1.7, -.9, .5, .7, -1.6, .2, 2.4, -2.6, -.9, -1.3, .7, 2.9, .2, -4.0

			n = 0
			for off = 0; off <= 25; off += 5 {
				for ki = 1; ki <= 4; ki++ {
					incx = incxs[ki-1]
					incy = incys[ki-1]
					mx = absint(incx)
					my = absint(incy)

					for kn = 1; kn <= 4; kn++ {
						n++
						ksize = minint(int(2), kn)
						lenx = lens[kn-1+(mx-1)*4]
						leny = lens[kn-1+(my-1)*4]
						for i = 1; i <= 7; i++ {
							sx[i-1+off] = dx1[i-1]
							sy[i-1+off] = dy1[i-1]
						}

						nc++

						if sname == "Sdot" {
							scompare1(Sdot(&ns[kn-1], &sx, &off, &incx, &sy, &off, &incy), dt7[kn-1+(ki-1)*4], &ssize1, kn-1, sfac, t, sname)
						} else if sname == "Saxpy" {
							Saxpy(&ns[kn-1], &sa, &sx, &off, &incx, &sy, &off, &incy)
							for j = 1; j <= leny; j++ {
								sty[j-1] = dt8[j-1+(kn-1+(ki-1)*4)*7]
							}
							scompare(leny, &sy, off, &sty, 0, &ssize2, ksize-1, sfac, t, sname)
						} else if sname == "Scopy" {
							for i = 1; i <= 7; i++ {
								sty[i-1] = dt10y[i-1+(kn-1+(ki-1)*4)*7]
							}
							Scopy(&ns[kn-1], &sx, &off, &incx, &sy, &off, &incy)
							scompare(leny, &sy, off, &sty, 0, &ssize2, 0, 1.0, t, sname)
						} else if sname == "Sswap" {
							Sswap(&ns[kn-1], &sx, &off, &incx, &sy, &off, &incy)
							for i = 1; i <= 7; i++ {
								stx[i-1] = dt10x[i-1+(kn-1+(ki-1)*4)*7]
								sty[i-1] = dt10y[i-1+(kn-1+(ki-1)*4)*7]
							}
							scompare(lenx, &sx, off, &stx, 0, &ssize2, 0, 1.0, t, sname)
							scompare(leny, &sy, off, &sty, 0, &ssize2, 0, 1.0, t, sname)
						} else if sname == "Srotm" {
							kni = kn + 4*(ki-1)
							for kpar = 1; kpar <= 4; kpar++ {
								for i = 1; i <= 7; i++ {
									sx[i-1+off] = dx1[i-1]
									sy[i-1+off] = dy1[i-1]
									stx[i-1] = dt19x[i-1+(kpar-1+(kni-1)*4)*7]
									sty[i-1] = dt19y[i-1+(kpar-1+(kni-1)*4)*7]
								}

								for i = 1; i <= 5; i++ {
									dtemp[i-1] = dpar[i-1+(kpar-1)*5]
								}

								for i = 1; i <= lenx; i++ {
									ssize[i-1] = stx[i-1]
								}
								//                   SEE REMARK ABOVE ABOUT DT11X(1,2,7)
								//                       AND DT11X(5,3,8).
								if (kpar == 2) && (kni == 7) {
									ssize[0] = 2.4
								}
								if (kpar == 3) && (kni == 8) {
									ssize[4] = 1.8
								}

								Srotm(&ns[kn-1], &sx, &off, &incx, &sy, &off, &incy, &dtemp)
								scompare(lenx, &sx, off, &stx, 0, &ssize, 0, sfac, t, sname)
								scompare(leny, &sy, off, &sty, 0, &sty, 0, sfac, t, sname)
							}
						} else if sname == "Sdsdot" {
							scompare1(Sdsdot(&ns[kn-1], func() *float32 { y := float32(.1); return &y }(), &sx, &off, &incx, &sy, &off, &incy), st7b[kn-1+(ki-1)*4], &ssize3, kn-1, sfac, t, sname)
						}
					}
				}
			}

			t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)

		} else if sname == "Srot" {
			var nc int
			var sc float32 = 0.8
			var ss float32 = 0.6
			copyx := make([]float32, 5*25)
			copyy := make([]float32, 5*25)
			var dx1 []float32 = []float32{0.6, 0.1, -0.5, 0.8, 0.9, -0.3, -0.4}
			var dy1 []float32 = []float32{0.5, -0.9, 0.3, 0.7, -0.6, 0.2, 0.8}
			mwpc := make([]float32, 11)
			mwps := make([]float32, 11)
			mwpstx := make([]float32, 5)
			mwpsty := make([]float32, 5)
			mwpx := make([]float32, 5)
			mwpy := make([]float32, 5)
			stx := make([]float32, 7)
			sty := make([]float32, 7)
			sx := make([]float32, 7*25)
			sy := make([]float32, 7*25)
			var incxs []int = []int{1, 2, -2, -1}
			var incys []int = []int{1, -2, 1, -2}
			mwpinx := make([]int, 11)
			dt9x := make([]float32, 7*4*4)
			dt9y := make([]float32, 7*4*4)
			mwpiny := make([]int, 11)
			mwpn := make([]int, 11)
			var ns []int = []int{0, 1, 2, 4}
			mwptx := make([]float32, 11*5)
			mwpty := make([]float32, 11*5)
			ssize2 := make([]float32, 14*2)
			lens := make([]int, 4*2)

			lens[0+(0)*4], lens[1+(0)*4], lens[2+(0)*4], lens[3+(0)*4], lens[0+(1)*4], lens[1+(1)*4], lens[2+(1)*4], lens[3+(1)*4] = 1, 1, 2, 4, 1, 1, 3, 7
			dt9x[0+(0+(0)*4)*4], dt9x[1+(0+(0)*4)*4], dt9x[2+(0+(0)*4)*4], dt9x[3+(0+(0)*4)*4], dt9x[4+(0+(0)*4)*4], dt9x[5+(0+(0)*4)*4], dt9x[6+(0+(0)*4)*4], dt9x[0+(1+(0)*4)*4], dt9x[1+(1+(0)*4)*4], dt9x[2+(1+(0)*4)*4], dt9x[3+(1+(0)*4)*4], dt9x[4+(1+(0)*4)*4], dt9x[5+(1+(0)*4)*4], dt9x[6+(1+(0)*4)*4], dt9x[0+(2+(0)*4)*4], dt9x[1+(2+(0)*4)*4], dt9x[2+(2+(0)*4)*4], dt9x[3+(2+(0)*4)*4], dt9x[4+(2+(0)*4)*4], dt9x[5+(2+(0)*4)*4], dt9x[6+(2+(0)*4)*4], dt9x[0+(3+(0)*4)*4], dt9x[1+(3+(0)*4)*4], dt9x[2+(3+(0)*4)*4], dt9x[3+(3+(0)*4)*4], dt9x[4+(3+(0)*4)*4], dt9x[5+(3+(0)*4)*4], dt9x[6+(3+(0)*4)*4], dt9x[0+(0+(1)*4)*4], dt9x[1+(0+(1)*4)*4], dt9x[2+(0+(1)*4)*4], dt9x[3+(0+(1)*4)*4], dt9x[4+(0+(1)*4)*4], dt9x[5+(0+(1)*4)*4], dt9x[6+(0+(1)*4)*4], dt9x[0+(1+(1)*4)*4], dt9x[1+(1+(1)*4)*4], dt9x[2+(1+(1)*4)*4], dt9x[3+(1+(1)*4)*4], dt9x[4+(1+(1)*4)*4], dt9x[5+(1+(1)*4)*4], dt9x[6+(1+(1)*4)*4], dt9x[0+(2+(1)*4)*4], dt9x[1+(2+(1)*4)*4], dt9x[2+(2+(1)*4)*4], dt9x[3+(2+(1)*4)*4], dt9x[4+(2+(1)*4)*4], dt9x[5+(2+(1)*4)*4], dt9x[6+(2+(1)*4)*4], dt9x[0+(3+(1)*4)*4], dt9x[1+(3+(1)*4)*4], dt9x[2+(3+(1)*4)*4], dt9x[3+(3+(1)*4)*4], dt9x[4+(3+(1)*4)*4], dt9x[5+(3+(1)*4)*4], dt9x[6+(3+(1)*4)*4], dt9x[0+(0+(2)*4)*4], dt9x[1+(0+(2)*4)*4], dt9x[2+(0+(2)*4)*4], dt9x[3+(0+(2)*4)*4], dt9x[4+(0+(2)*4)*4], dt9x[5+(0+(2)*4)*4], dt9x[6+(0+(2)*4)*4], dt9x[0+(1+(2)*4)*4], dt9x[1+(1+(2)*4)*4], dt9x[2+(1+(2)*4)*4], dt9x[3+(1+(2)*4)*4], dt9x[4+(1+(2)*4)*4], dt9x[5+(1+(2)*4)*4], dt9x[6+(1+(2)*4)*4], dt9x[0+(2+(2)*4)*4], dt9x[1+(2+(2)*4)*4], dt9x[2+(2+(2)*4)*4], dt9x[3+(2+(2)*4)*4], dt9x[4+(2+(2)*4)*4], dt9x[5+(2+(2)*4)*4], dt9x[6+(2+(2)*4)*4], dt9x[0+(3+(2)*4)*4], dt9x[1+(3+(2)*4)*4], dt9x[2+(3+(2)*4)*4], dt9x[3+(3+(2)*4)*4], dt9x[4+(3+(2)*4)*4], dt9x[5+(3+(2)*4)*4], dt9x[6+(3+(2)*4)*4], dt9x[0+(0+(3)*4)*4], dt9x[1+(0+(3)*4)*4], dt9x[2+(0+(3)*4)*4], dt9x[3+(0+(3)*4)*4], dt9x[4+(0+(3)*4)*4], dt9x[5+(0+(3)*4)*4], dt9x[6+(0+(3)*4)*4], dt9x[0+(1+(3)*4)*4], dt9x[1+(1+(3)*4)*4], dt9x[2+(1+(3)*4)*4], dt9x[3+(1+(3)*4)*4], dt9x[4+(1+(3)*4)*4], dt9x[5+(1+(3)*4)*4], dt9x[6+(1+(3)*4)*4], dt9x[0+(2+(3)*4)*4], dt9x[1+(2+(3)*4)*4], dt9x[2+(2+(3)*4)*4], dt9x[3+(2+(3)*4)*4], dt9x[4+(2+(3)*4)*4], dt9x[5+(2+(3)*4)*4], dt9x[6+(2+(3)*4)*4], dt9x[0+(3+(3)*4)*4], dt9x[1+(3+(3)*4)*4], dt9x[2+(3+(3)*4)*4], dt9x[3+(3+(3)*4)*4], dt9x[4+(3+(3)*4)*4], dt9x[5+(3+(3)*4)*4], dt9x[6+(3+(3)*4)*4] = 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.78, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.78, -0.46, 0.0, 0.0, 0.0, 0.0, 0.0, 0.78, -0.46, -0.22, 1.06, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.78, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.66, 0.1, -0.1, 0.0, 0.0, 0.0, 0.0, 0.96, 0.1, -0.76, 0.8, 0.90, -0.3, -0.02, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.78, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.06, 0.1, -0.1, 0.0, 0.0, 0.0, 0.0, 0.90, 0.1, -0.22, 0.8, 0.18, -0.3, -0.02, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.78, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.78, 0.26, 0.0, 0.0, 0.0, 0.0, 0.0, 0.78, 0.26, -0.76, 1.12, 0.0, 0.0, 0.0
			dt9y[0+(0+(0)*4)*4], dt9y[1+(0+(0)*4)*4], dt9y[2+(0+(0)*4)*4], dt9y[3+(0+(0)*4)*4], dt9y[4+(0+(0)*4)*4], dt9y[5+(0+(0)*4)*4], dt9y[6+(0+(0)*4)*4], dt9y[0+(1+(0)*4)*4], dt9y[1+(1+(0)*4)*4], dt9y[2+(1+(0)*4)*4], dt9y[3+(1+(0)*4)*4], dt9y[4+(1+(0)*4)*4], dt9y[5+(1+(0)*4)*4], dt9y[6+(1+(0)*4)*4], dt9y[0+(2+(0)*4)*4], dt9y[1+(2+(0)*4)*4], dt9y[2+(2+(0)*4)*4], dt9y[3+(2+(0)*4)*4], dt9y[4+(2+(0)*4)*4], dt9y[5+(2+(0)*4)*4], dt9y[6+(2+(0)*4)*4], dt9y[0+(3+(0)*4)*4], dt9y[1+(3+(0)*4)*4], dt9y[2+(3+(0)*4)*4], dt9y[3+(3+(0)*4)*4], dt9y[4+(3+(0)*4)*4], dt9y[5+(3+(0)*4)*4], dt9y[6+(3+(0)*4)*4], dt9y[0+(0+(1)*4)*4], dt9y[1+(0+(1)*4)*4], dt9y[2+(0+(1)*4)*4], dt9y[3+(0+(1)*4)*4], dt9y[4+(0+(1)*4)*4], dt9y[5+(0+(1)*4)*4], dt9y[6+(0+(1)*4)*4], dt9y[0+(1+(1)*4)*4], dt9y[1+(1+(1)*4)*4], dt9y[2+(1+(1)*4)*4], dt9y[3+(1+(1)*4)*4], dt9y[4+(1+(1)*4)*4], dt9y[5+(1+(1)*4)*4], dt9y[6+(1+(1)*4)*4], dt9y[0+(2+(1)*4)*4], dt9y[1+(2+(1)*4)*4], dt9y[2+(2+(1)*4)*4], dt9y[3+(2+(1)*4)*4], dt9y[4+(2+(1)*4)*4], dt9y[5+(2+(1)*4)*4], dt9y[6+(2+(1)*4)*4], dt9y[0+(3+(1)*4)*4], dt9y[1+(3+(1)*4)*4], dt9y[2+(3+(1)*4)*4], dt9y[3+(3+(1)*4)*4], dt9y[4+(3+(1)*4)*4], dt9y[5+(3+(1)*4)*4], dt9y[6+(3+(1)*4)*4], dt9y[0+(0+(2)*4)*4], dt9y[1+(0+(2)*4)*4], dt9y[2+(0+(2)*4)*4], dt9y[3+(0+(2)*4)*4], dt9y[4+(0+(2)*4)*4], dt9y[5+(0+(2)*4)*4], dt9y[6+(0+(2)*4)*4], dt9y[0+(1+(2)*4)*4], dt9y[1+(1+(2)*4)*4], dt9y[2+(1+(2)*4)*4], dt9y[3+(1+(2)*4)*4], dt9y[4+(1+(2)*4)*4], dt9y[5+(1+(2)*4)*4], dt9y[6+(1+(2)*4)*4], dt9y[0+(2+(2)*4)*4], dt9y[1+(2+(2)*4)*4], dt9y[2+(2+(2)*4)*4], dt9y[3+(2+(2)*4)*4], dt9y[4+(2+(2)*4)*4], dt9y[5+(2+(2)*4)*4], dt9y[6+(2+(2)*4)*4], dt9y[0+(3+(2)*4)*4], dt9y[1+(3+(2)*4)*4], dt9y[2+(3+(2)*4)*4], dt9y[3+(3+(2)*4)*4], dt9y[4+(3+(2)*4)*4], dt9y[5+(3+(2)*4)*4], dt9y[6+(3+(2)*4)*4], dt9y[0+(0+(3)*4)*4], dt9y[1+(0+(3)*4)*4], dt9y[2+(0+(3)*4)*4], dt9y[3+(0+(3)*4)*4], dt9y[4+(0+(3)*4)*4], dt9y[5+(0+(3)*4)*4], dt9y[6+(0+(3)*4)*4], dt9y[0+(1+(3)*4)*4], dt9y[1+(1+(3)*4)*4], dt9y[2+(1+(3)*4)*4], dt9y[3+(1+(3)*4)*4], dt9y[4+(1+(3)*4)*4], dt9y[5+(1+(3)*4)*4], dt9y[6+(1+(3)*4)*4], dt9y[0+(2+(3)*4)*4], dt9y[1+(2+(3)*4)*4], dt9y[2+(2+(3)*4)*4], dt9y[3+(2+(3)*4)*4], dt9y[4+(2+(3)*4)*4], dt9y[5+(2+(3)*4)*4], dt9y[6+(2+(3)*4)*4], dt9y[0+(3+(3)*4)*4], dt9y[1+(3+(3)*4)*4], dt9y[2+(3+(3)*4)*4], dt9y[3+(3+(3)*4)*4], dt9y[4+(3+(3)*4)*4], dt9y[5+(3+(3)*4)*4], dt9y[6+(3+(3)*4)*4] = 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04, -0.78, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04, -0.78, 0.54, 0.08, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.7, -0.9, -0.12, 0.0, 0.0, 0.0, 0.0, 0.64, -0.9, -0.30, 0.7, -0.18, 0.2, 0.28, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.7, -1.08, 0.0, 0.0, 0.0, 0.0, 0.0, 0.64, -1.26, 0.54, 0.20, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04, -0.9, 0.18, 0.0, 0.0, 0.0, 0.0, 0.04, -0.9, 0.18, 0.7, -0.18, 0.2, 0.16
			ssize2[0+(0)*14], ssize2[1+(0)*14], ssize2[2+(0)*14], ssize2[3+(0)*14], ssize2[4+(0)*14], ssize2[5+(0)*14], ssize2[6+(0)*14], ssize2[7+(0)*14], ssize2[8+(0)*14], ssize2[9+(0)*14], ssize2[10+(0)*14], ssize2[11+(0)*14], ssize2[12+(0)*14], ssize2[13+(0)*14], ssize2[0+(1)*14], ssize2[1+(1)*14], ssize2[2+(1)*14], ssize2[3+(1)*14], ssize2[4+(1)*14], ssize2[5+(1)*14], ssize2[6+(1)*14], ssize2[7+(1)*14], ssize2[8+(1)*14], ssize2[9+(1)*14], ssize2[10+(1)*14], ssize2[11+(1)*14], ssize2[12+(1)*14], ssize2[13+(1)*14] = 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17, 1.17

			n = 0
			for off = 0; off <= 25; off += 5 {
				for ki = 1; ki <= 4; ki++ {
					incx = incxs[ki-1]
					incy = incys[ki-1]
					mx = absint(incx)
					my = absint(incy)

					for kn = 1; kn <= 4; kn++ {
						n++
						ksize = minint(int(2), kn)
						lenx = lens[kn-1+(mx-1)*4]
						leny = lens[kn-1+(my-1)*4]

						for i = 1; i <= 7; i++ {
							sx[i-1+off] = dx1[i-1]
							sy[i-1+off] = dy1[i-1]
							stx[i-1] = dt9x[i-1+(kn-1+(ki-1)*4)*4]
							sty[i-1] = dt9y[i-1+(kn-1+(ki-1)*4)*4]
						}

						nc++

						Srot(&ns[kn-1], &sx, &off, &incx, &sy, &off, &incy, &sc, &ss)
						scompare(lenx, &sx, off, &stx, 0, &ssize2, (ksize-1)*14, sfac, t, sname)
						scompare(leny, &sy, off, &sty, 0, &ssize2, (ksize-1)*14, sfac, t, sname)
					}
				}
			}

			mwpc[0] = 1
			for i = 2; i <= 11; i++ {
				mwpc[i-1] = 0
			}
			mwps[0] = 0
			for i = 2; i <= 6; i++ {
				mwps[i-1] = 1
			}
			for i = 7; i <= 11; i++ {
				mwps[i-1] = -1
			}
			mwpinx[0] = 1
			mwpinx[1] = 1
			mwpinx[2] = 1
			mwpinx[3] = -1
			mwpinx[4] = 1
			mwpinx[5] = -1
			mwpinx[6] = 1
			mwpinx[7] = 1
			mwpinx[8] = -1
			mwpinx[9] = 1
			mwpinx[10] = -1
			mwpiny[0] = 1
			mwpiny[1] = 1
			mwpiny[2] = -1
			mwpiny[3] = -1
			mwpiny[4] = 2
			mwpiny[5] = 1
			mwpiny[6] = 1
			mwpiny[7] = -1
			mwpiny[8] = -1
			mwpiny[9] = 2
			mwpiny[10] = 1
			for i = 1; i <= 11; i++ {
				mwpn[i-1] = 5
			}
			mwpn[4] = 3
			mwpn[9] = 3
			for i = 1; i <= 5; i++ {
				_i := float32(i)
				mwpx[i-1] = _i
				mwpy[i-1] = _i
				mwptx[0+(i-1)*11] = _i
				mwpty[0+(i-1)*11] = _i
				mwptx[1+(i-1)*11] = _i
				mwpty[1+(i-1)*11] = -_i
				mwptx[2+(i-1)*11] = 6 - _i
				mwpty[2+(i-1)*11] = _i - 6
				mwptx[3+(i-1)*11] = _i
				mwpty[3+(i-1)*11] = -_i
				mwptx[5+(i-1)*11] = 6 - _i
				mwpty[5+(i-1)*11] = _i - 6
				mwptx[6+(i-1)*11] = -_i
				mwpty[6+(i-1)*11] = _i
				mwptx[7+(i-1)*11] = _i - 6
				mwpty[7+(i-1)*11] = 6 - _i
				mwptx[8+(i-1)*11] = -_i
				mwpty[8+(i-1)*11] = _i
				mwptx[10+(i-1)*11] = _i - 6
				mwpty[10+(i-1)*11] = 6 - _i
			}
			mwptx[4+(0)*11] = 1
			mwptx[4+(1)*11] = 3
			mwptx[4+(2)*11] = 5
			mwptx[4+(3)*11] = 4
			mwptx[4+(4)*11] = 5
			mwpty[4+(0)*11] = -1
			mwpty[4+(1)*11] = 2
			mwpty[4+(2)*11] = -2
			mwpty[4+(3)*11] = 4
			mwpty[4+(4)*11] = -3
			mwptx[9+(0)*11] = -1
			mwptx[9+(1)*11] = -3
			mwptx[9+(2)*11] = -5
			mwptx[9+(3)*11] = 4
			mwptx[9+(4)*11] = 5
			mwpty[9+(0)*11] = 1
			mwpty[9+(1)*11] = 2
			mwpty[9+(2)*11] = 2
			mwpty[9+(3)*11] = 4
			mwpty[9+(4)*11] = 3
			for off = 0; off <= 25; off += 5 {
				for i = 1; i <= 11; i++ {
					n++
					incx = mwpinx[i-1]
					incy = mwpiny[i-1]
					for k = 1; k <= 5; k++ {
						copyx[k-1+off] = mwpx[k-1]
						copyy[k-1+off] = mwpy[k-1]
						mwpstx[k-1] = mwptx[i-1+(k-1)*11]
						mwpsty[k-1] = mwpty[i-1+(k-1)*11]
					}

					nc++

					Srot(&(mwpn[i-1]), &copyx, &off, &incx, &copyy, &off, &incy, &(mwpc[i-1]), &(mwps[i-1]))
					scompare(5, &copyx, off, &mwpstx, 0, &mwpstx, 0, sfac, t, sname)
					scompare(5, &copyy, off, &mwpsty, 0, &mwpsty, 0, sfac, t, sname)
				}
			}

			t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)

		} else {
			t.Logf(" %6s TEST NOT FOUND\n", sname)
		}
	}
}

func TestSblasLevel2(t *testing.T) {
	var fatal, null, reset, same, tran, upper bool
	var diag, diags, trans, transs, uplo, uplos byte
	var alpha, als, beta, bls, err, errmax, transl float32
	var i, j, n int
	var ok bool = true
	var idim []int = []int{0, 1, 2, 3, 5, 9}
	var kb []int = []int{0, 1, 2, 4}
	var inc []int = []int{1, 2, -1, -2}
	var alf []float32 = []float32{0.0, 1.0, 0.7}
	var bet []float32 = []float32{0.0, 1.0, 0.9}
	var thresh float32 = 16.0
	var eps float32 = epsilonf32()
	var zero float32 = 0.0
	var half float32 = 0.5
	var one float32 = 1.0
	var nmax int = 65
	var incmax int = 2
	var inegone int = -1
	var izero int = 0
	var ione int = 1
	var itwo int = 2
	var snames []string = []string{"SGEMV", "SGBMV", "SSYMV", "SSBMV", "SSPMV", "STRMV", "STBMV", "STPMV", "STRSV", "STBSV", "STPSV", "SGER", "SSYR", "SSPR", "SSYR2", "SSPR2"}
	isame := make([]bool, 13)
	var ichd []byte = []byte{'U', 'N'}
	var icht []byte = []byte{'N', 'T', 'C'}
	var ichu []byte = []byte{'U', 'L'}
	a := make([]float32, nmax*nmax)
	aa := make([]float32, nmax*nmax)
	as := make([]float32, nmax*nmax)
	g := make([]float32, nmax)
	x := make([]float32, nmax)
	xs := make([]float32, nmax*incmax)
	xt := make([]float32, nmax)
	xx := make([]float32, nmax*incmax)
	y := make([]float32, nmax)
	ys := make([]float32, nmax*incmax)
	yt := make([]float32, nmax)
	yy := make([]float32, nmax*incmax)
	z := make([]float32, 2*nmax)

	n = minint(int(32), nmax)
	for j = 1; j <= n; j++ {
		for i = 1; i <= n; i++ {
			a[i-1+(j-1)*nmax] = float32(maxint(i-j+1, 0))
		}
		x[j-1] = float32(j)
		y[j-1] = zero
	}
	for j = 1; j <= n; j++ {
		yy[j-1] = float32(j*((j+1)*j))/2 - float32(((j+1)*j*(j-1)))/3
	}
	//     YY holds the exact result. On exit from SMVCH YT holds
	//     the result computed by SMVCH.
	trans = 'N'
	smvch(trans, &n, &n, &one, &a, &izero, &nmax, &x, &izero, &ione, &zero, &y, &izero, &ione, &yt, &g, &yy, &izero, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lse(&yy, &yt, &izero, &n)
	if !same || err != zero {
		t.Errorf(" ERROR IN SMVCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n SMVCH WAS CALLED WITH TRANS = %c AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", trans, same, err)
	}
	trans = 'T'
	smvch(trans, &n, &n, &one, &a, &izero, &nmax, &x, &izero, &inegone, &zero, &y, &izero, &inegone, &yt, &g, &yy, &izero, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lse(&yy, &yt, &izero, &n)
	if !same || err != zero {
		t.Errorf(" ERROR IN SMVCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n SMVCH WAS CALLED WITH TRANS = %c AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", trans, same, err)
	}
	for _, sname := range snames {
		if sname == "SGEMV" || sname == "SGBMV" {
			var aoff, i, im, incx, incxs, incy, incys, kl, kls, ku, kus, laa, lda, ldas, lx, ly, m, ml, ms, n, nargs, nc, nd, nl, ns, xoff, yoff int
			var full bool = sname[2] == 'E'
			var banded bool = sname[2] == 'B'

			ok = true
			if full {
				nargs = 11
			} else if banded {
				nargs = 13
			}

			nc = 0
			reset = true
			errmax = zero

			for aoff = 0; aoff <= 20; aoff += 10 {
				for xoff = 0; xoff <= 20; xoff += 10 {
					for yoff = 0; yoff <= 20; yoff += 10 {
						for _, n = range idim {
							nd = n/2 + 1

							for im = 1; im <= 2; im++ {
								if im == 1 {
									m = maxint(n-nd, 0)
								}
								if im == 2 {
									m = minint(n+nd, nmax)
								}

								for _, ku = range kb {
									if banded {
										kl = maxint(ku-1, 0)
									} else {
										ku = n - 1
										kl = m - 1
									}
									//              Set LDA to 1 more than minimum value if room.
									if banded {
										lda = kl + ku + 1
									} else {
										lda = m
									}
									if lda < nmax {
										lda++
									}
									//              Skip tests if not enough room.
									if lda > nmax {
										goto label100
									}
									laa = lda * n
									null = n <= 0 || m <= 0
									//
									//              Generate the matrix A.
									//
									transl = zero
									smakeL2(sname[1:3], ' ', ' ', &m, &n, &a, &nmax, &aa, &aoff, &lda, &kl, &ku, &reset, &transl)
									//
									for _, trans = range []byte{'N', 'T', 'C'} {
										tran = trans == 'T' || trans == 'C'
										//
										if tran {
											ml = n
											nl = m
										} else {
											ml = m
											nl = n
										}
										//
										for _, incx = range inc {
											lx = absint(incx) * nl
											//
											//                    Generate the vector X.
											//
											transl = half
											smakeL2("GE", ' ', ' ', &ione, &nl, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := nl - 1; return &y }(), &reset, &transl)
											if nl > 1 {
												x[nl/2-1+xoff] = zero
												xx[1+absint(incx)*(nl/2-1)-1+xoff] = zero
											}
											//
											for _, incy = range inc {
												ly = absint(incy) * ml
												//
												for _, alpha = range alf {
													//
													for _, beta = range bet {
														//
														//                             Generate the vector Y.
														//
														transl = zero
														smakeL2("GE", ' ', ' ', &ione, &ml, &y, &ione, &yy, &yoff, func() *int { y := absint(incy); return &y }(), &izero, func() *int { y := ml - 1; return &y }(), &reset, &transl)
														//
														nc++
														//
														//                             Save every datum before calling the
														//                             subroutine.
														//
														transs = trans
														ms = m
														ns = n
														kls = kl
														kus = ku
														als = alpha
														for i = 1; i <= laa; i++ {
															as[i-1+aoff] = aa[i-1+aoff]
														}
														ldas = lda
														for i = 1; i <= lx; i++ {
															xs[i-1+xoff] = xx[i-1+xoff]
														}
														incxs = incx
														bls = beta
														for i = 1; i <= ly; i++ {
															ys[i-1+yoff] = yy[i-1+yoff]
														}
														incys = incy
														//
														//                             Call the subroutine.
														//
														if full {
															Sgemv(&trans, &m, &n, &alpha, &aa, &aoff, &lda, &xx, &xoff, &incx, &beta, &yy, &yoff, &incy)
														} else if banded {
															Sgbmv(&trans, &m, &n, &kl, &ku, &alpha, &aa, &aoff, &lda, &xx, &xoff, &incx, &beta, &yy, &yoff, &incy)
														}
														//
														//                             Check if error-exit was taken incorrectly.
														//
														if !ok {
															t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
															fatal = true
															goto label130
														}
														//
														//                             See what data changed inside subroutines.
														//
														isame[0] = trans == transs
														isame[1] = ms == m
														isame[2] = ns == n
														if full {
															isame[3] = als == alpha
															isame[4] = lse(&as, &aa, &aoff, &laa)
															isame[5] = ldas == lda
															isame[6] = lse(&xs, &xx, &xoff, &lx)
															isame[7] = incxs == incx
															isame[8] = bls == beta
															if null {
																isame[9] = lse(&ys, &yy, &yoff, &ly)
															} else {
																isame[9] = lseres("GE", ' ', &ione, &ml, &ys, &yy, &yoff, func() *int { y := absint(incy); return &y }())
															}
															isame[10] = incys == incy
														} else if banded {
															isame[3] = kls == kl
															isame[4] = kus == ku
															isame[5] = als == alpha
															isame[6] = lse(&as, &aa, &aoff, &laa)
															isame[7] = ldas == lda
															isame[8] = lse(&xs, &xx, &xoff, &lx)
															isame[9] = incxs == incx
															isame[10] = bls == beta
															if null {
																isame[11] = lse(&ys, &yy, &yoff, &ly)
															} else {
																isame[11] = lseres("GE", ' ', &ione, &ml, &ys, &yy, &yoff, func() *int { y := absint(incy); return &y }())
															}
															isame[12] = incys == incy
														}
														//
														//                             If data was incorrectly changed, report
														//                             and return.
														//
														same = true
														for i = 1; i <= nargs; i++ {
															same = same && isame[i-1]
															if !isame[i-1] {
																t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
															}
														}
														if !same {
															fatal = true
															goto label130
														}

														if !null {
															//
															//                                Check the result.
															//
															smvch(trans, &m, &n, &alpha, &a, &aoff, &nmax, &x, &xoff, &incx, &beta, &y, &yoff, &incy, &yt, &g, &yy, &yoff, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
															errmax = maxf32(errmax, err)
															//                                If got really bad answer, report and
															//                                return.
															if fatal {
																goto label130
															}
														} else {
															//                                Avoid repeating tests with M.le.0 or
															//                                N.le.0.
															goto label110
														}

													}

												}

											}

										}

									}

								label100:
								}

							label110:
							}

						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue
			//
		label130:
			if full {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%3d,%4.1f, A,%3d,%3d, X,%2d,%2d,%4.1f, Y,%2d,%2d)         .\n", sname, nc, sname, trans, m, n, alpha, izero, lda, izero, incx, beta, izero, incy)
			} else if banded {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%3d,%3d,%3d,%4.1f, A,%3d,%3d, X,%2d,%2d,%4.1f, Y,%2d,%2d) .\n", sname, nc, sname, trans, m, n, kl, ku, alpha, izero, lda, izero, incx, beta, izero, incy)
			}
			//
		} else if sname == "SSYMV" || sname == "SSBMV" || sname == "SSPMV" {
			var aoff, i, incx, incxs, incy, incys, k, ks, laa, lda, ldas, lx, ly, n, nargs, nc, ns, xoff, yoff int
			var full bool = sname[2] == 'Y'
			var banded bool = sname[2] == 'B'
			var packed bool = sname[2] == 'P'

			//     Define the number of arguments.
			ok = true
			if full {
				nargs = 10
			} else if banded {
				nargs = 11
			} else if packed {
				nargs = 9
			}

			nc = 0
			reset = true
			errmax = zero

			for aoff = 0; aoff <= 30; aoff += 10 {
				for xoff = 0; xoff <= 30; xoff += 10 {
					for yoff = 0; yoff <= 30; yoff += 10 {
						for _, n = range idim {

							for _, k = range kb {
								if !banded {
									k = n - 1
								}
								//           Set LDA to 1 more than minimum value if room.
								if banded {
									lda = k + 1
								} else {
									lda = n
								}
								if lda < nmax {
									lda++
								}
								//           Skip tests if not enough room.
								if lda > nmax {
									goto label1100
								}
								if packed {
									laa = (n * (n + 1)) / 2
								} else {
									laa = lda * n
								}
								null = n <= 0
								//
								for _, uplo = range ichu {
									//
									//              Generate the matrix A.
									//
									transl = zero
									smakeL2(sname[1:3], uplo, ' ', &n, &n, &a, &nmax, &aa, &aoff, &lda, &k, &k, &reset, &transl)
									//
									for _, incx = range inc {
										lx = absint(incx) * n
										//
										//                 Generate the vector X.
										//
										transl = half
										smakeL2("GE", ' ', ' ', &ione, &n, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
										if n > 1 {
											x[n/2-1+xoff] = zero
											xx[1+absint(incx)*(n/2-1)-1+xoff] = zero
										}

										for _, incy = range inc {
											ly = absint(incy) * n

											for _, alpha = range alf {

												for _, beta = range bet {
													//
													//                          Generate the vector Y.
													//
													transl = zero
													smakeL2("GE", ' ', ' ', &ione, &n, &y, &ione, &yy, &yoff, func() *int { y := absint(incy); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)

													nc++
													//
													//                          Save every datum before calling the
													//                          subroutine.
													//
													uplos = uplo
													ns = n
													ks = k
													als = alpha
													for i = 1; i <= laa; i++ {
														as[i-1+aoff] = aa[i-1+aoff]
													}
													ldas = lda
													for i = 1; i <= lx; i++ {
														xs[i-1+xoff] = xx[i-1+xoff]
													}
													incxs = incx
													bls = beta
													for i = 1; i <= ly; i++ {
														ys[i-1+yoff] = yy[i-1+yoff]
													}
													incys = incy
													//
													//                          Call the subroutine.
													//
													if full {
														Ssymv(&uplo, &n, &alpha, &aa, &aoff, &lda, &xx, &xoff, &incx, &beta, &yy, &yoff, &incy)
													} else if banded {
														Ssbmv(&uplo, &n, &k, &alpha, &aa, &aoff, &lda, &xx, &xoff, &incx, &beta, &yy, &yoff, &incy)
													} else if packed {
														Sspmv(&uplo, &n, &alpha, &aa, &aoff, &xx, &xoff, &incx, &beta, &yy, &yoff, &incy)
													}
													//
													//                          Check if error-exit was taken incorrectly.
													//
													if !ok {
														t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
														fatal = true
														goto label1120
													}
													//
													//                          See what data changed inside subroutines.
													//
													isame[0] = uplo == uplos
													isame[1] = ns == n
													if full {
														isame[2] = als == alpha
														isame[3] = lse(&as, &aa, &aoff, &laa)
														isame[4] = ldas == lda
														isame[5] = lse(&xs, &xx, &xoff, &lx)
														isame[6] = incxs == incx
														isame[7] = bls == beta
														if null {
															isame[8] = lse(&ys, &yy, &yoff, &ly)
														} else {
															isame[8] = lseres("GE", ' ', &ione, &n, &ys, &yy, &yoff, func() *int { y := absint(incy); return &y }())
														}
														isame[9] = incys == incy
													} else if banded {
														isame[2] = ks == k
														isame[3] = als == alpha
														isame[4] = lse(&as, &aa, &aoff, &laa)
														isame[5] = ldas == lda
														isame[6] = lse(&xs, &xx, &xoff, &lx)
														isame[7] = incxs == incx
														isame[8] = bls == beta
														if null {
															isame[9] = lse(&ys, &yy, &yoff, &ly)
														} else {
															isame[9] = lseres("GE", ' ', &ione, &n, &ys, &yy, &yoff, func() *int { y := absint(incy); return &y }())
														}
														isame[10] = incys == incy
													} else if packed {
														isame[2] = als == alpha
														isame[3] = lse(&as, &aa, &aoff, &laa)
														isame[4] = lse(&xs, &xx, &xoff, &lx)
														isame[5] = incxs == incx
														isame[6] = bls == beta
														if null {
															isame[7] = lse(&ys, &yy, &yoff, &ly)
														} else {
															isame[7] = lseres("GE", ' ', &ione, &n, &ys, &yy, &yoff, func() *int { y := absint(incy); return &y }())
														}
														isame[8] = incys == incy
													}
													//
													//                          If data was incorrectly changed, report and
													//                          return.
													//
													same = true
													for i = 1; i <= nargs; i++ {
														same = same && isame[i-1]
														if !isame[i-1] {
															t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
														}
													}
													if !same {
														fatal = true
														goto label1120
													}

													if !null {
														//
														//                             Check the result.
														//
														smvch('N', &n, &n, &alpha, &a, &aoff, &nmax, &x, &xoff, &incx, &beta, &y, &yoff, &incy, &yt, &g, &yy, &yoff, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
														errmax = maxf32(errmax, err)
														//                             If got really bad answer, report and
														//                             return.
														if fatal {
															goto label1120
														}
													} else {
														//                             Avoid repeating tests with N.le.0
														goto label1110
													}

												}

											}

										}
									}

								}

							label1100:
							}

						label1110:
						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label1120:
			;
			if full {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, A,%3d,%3d, X,%2d,%2d,%4.1f, Y,%2d,%2d)             .\n", sname, nc, sname, uplo, n, alpha, aoff, lda, xoff, incx, beta, yoff, incy)
			} else if banded {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%3d,%4.1f, A,%3d,%3d, X,%2d,%2d,%4.1f, Y,%2d,%2d)         .\n", sname, nc, sname, uplo, n, k, alpha, aoff, lda, xoff, incx, beta, yoff, incy)
			} else if packed {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, AP,%3d, X,%2d,%2d,%4.1f, Y,%2d,%2d)                .\n", sname, nc, sname, uplo, n, alpha, aoff, xoff, incx, beta, yoff, incy)
			}

		} else if sname == "STRMV" || sname == "STBMV" || sname == "STPMV" || sname == "STRSV" || sname == "STBSV" || sname == "STPSV" {
			var aoff, i, incx, incxs, k, ks, laa, lda, ldas, lx, n, nargs, nc, ns, xoff int
			var full bool = sname[2] == 'R'
			var banded bool = sname[2] == 'B'
			var packed bool = sname[2] == 'P'

			//     Define the number of arguments.
			ok = true
			if full {
				nargs = 8
			} else if banded {
				nargs = 9
			} else if packed {
				nargs = 7
			}

			nc = 0
			reset = true
			errmax = zero
			//     Set up zero vector for SMVCH.
			for i = 1; i <= nmax; i++ {
				z[i-1] = zero
			}

			for aoff = 0; aoff <= 30; aoff += 10 {
				for xoff = 0; xoff <= 30; xoff += 10 {
					for _, n = range idim {

						for _, k = range kb {
							if !banded {
								k = n - 1
							}
							//           Set LDA to 1 more than minimum value if room.
							if banded {
								lda = k + 1
							} else {
								lda = n
							}
							if lda < nmax {
								lda++
							}
							//           Skip tests if not enough room.
							if lda > nmax {
								goto label2100
							}
							if packed {
								laa = (n * (n + 1)) / 2
							} else {
								laa = lda * n
							}
							null = n <= 0

							for _, uplo = range ichu {

								for _, trans = range icht {

									for _, diag = range ichd {
										//
										//                    Generate the matrix A.
										//
										transl = zero
										smakeL2(sname[1:3], uplo, diag, &n, &n, &a, &nmax, &aa, &aoff, &lda, &k, &k, &reset, &transl)

										for _, incx = range inc {
											lx = absint(incx) * n
											//
											//                       Generate the vector X.
											//
											transl = half
											smakeL2("GE", ' ', ' ', &ione, &n, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
											if n > 1 {
												x[n/2-1+xoff] = zero
												xx[1+absint(incx)*(n/2-1)-1+xoff] = zero
											}

											nc++
											//
											//                       Save every datum before calling the subroutine.
											//
											uplos = uplo
											transs = trans
											diags = diag
											ns = n
											ks = k
											for i = 1; i <= laa; i++ {
												as[i-1+aoff] = aa[i-1+aoff]
											}
											ldas = lda
											for i = 1; i <= lx; i++ {
												xs[i-1+xoff] = xx[i-1+xoff]
											}
											incxs = incx
											//
											//                       Call the subroutine.
											//
											if sname[3:5] == "MV" {
												if full {
													Strmv(&uplo, &trans, &diag, &n, &aa, &aoff, &lda, &xx, &xoff, &incx)
												} else if banded {
													Stbmv(&uplo, &trans, &diag, &n, &k, &aa, &aoff, &lda, &xx, &xoff, &incx)
												} else if packed {
													Stpmv(&uplo, &trans, &diag, &n, &aa, &aoff, &xx, &xoff, &incx)
												}
											} else if sname[3:5] == "SV" {
												if full {
													Strsv(&uplo, &trans, &diag, &n, &aa, &aoff, &lda, &xx, &xoff, &incx)
												} else if banded {
													Stbsv(&uplo, &trans, &diag, &n, &k, &aa, &aoff, &lda, &xx, &xoff, &incx)
												} else if packed {
													Stpsv(&uplo, &trans, &diag, &n, &aa, &aoff, &xx, &xoff, &incx)
												}
											}
											//
											//                       Check if error-exit was taken incorrectly.
											//
											if !ok {
												t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
												fatal = true
												goto label2120
											}
											//
											//                       See what data changed inside subroutines.
											//
											isame[0] = uplo == uplos
											isame[1] = trans == transs
											isame[2] = diag == diags
											isame[3] = ns == n
											if full {
												isame[4] = lse(&as, &aa, &aoff, &laa)
												isame[5] = ldas == lda
												if null {
													isame[6] = lse(&xs, &xx, &xoff, &lx)
												} else {
													isame[6] = lseres("GE", ' ', &ione, &n, &xs, &xx, &xoff, func() *int { y := absint(incx); return &y }())
												}
												isame[7] = incxs == incx
											} else if banded {
												isame[4] = ks == k
												isame[5] = lse(&as, &aa, &aoff, &laa)
												isame[6] = ldas == lda
												if null {
													isame[7] = lse(&xs, &xx, &xoff, &lx)
												} else {
													isame[7] = lseres("GE", ' ', &ione, &n, &xs, &xx, &xoff, func() *int { y := absint(incx); return &y }())
												}
												isame[8] = incxs == incx
											} else if packed {
												isame[4] = lse(&as, &aa, &aoff, &laa)
												if null {
													isame[5] = lse(&xs, &xx, &xoff, &lx)
												} else {
													isame[5] = lseres("GE", ' ', &ione, &n, &xs, &xx, &xoff, func() *int { y := absint(incx); return &y }())
												}
												isame[6] = incxs == incx
											}
											//
											//                       If data was incorrectly changed, report and
											//                       return.
											//
											same = true
											for i = 1; i <= nargs; i++ {
												same = same && isame[i-1]
												if !isame[i-1] {
													t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
												}
											}
											if !same {
												fatal = true
												goto label2120
											}

											if !null {
												if sname[3:5] == "MV" {
													//
													//                             Check the result.
													//
													smvch(trans, &n, &n, &one, &a, &aoff, &nmax, &x, &xoff, &incx, &zero, &z, &izero, &incx, &xt, &g, &xx, &xoff, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
												} else if sname[3:5] == "SV" {
													//
													//                             Compute approximation to original vector.
													//
													for i = 1; i <= n; i++ {
														z[i-1] = xx[1+(i-1)*absint(incx)-1+xoff]
														xx[1+(i-1)*absint(incx)-1+xoff] = x[i-1+xoff]
													}
													smvch(trans, &n, &n, &one, &a, &aoff, &nmax, &z, &izero, &incx, &zero, &x, &xoff, &incx, &xt, &g, &xx, &xoff, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
												}
												errmax = maxf32(errmax, err)
												//                          If got really bad answer, report and return.
												if fatal {
													goto label2120
												}
											} else {
												//                          Avoid repeating tests with N.le.0.
												goto label2110
											}

										}

									}

								}

							}

						label2100:
						}

					label2110:
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label2120:
			;
			if full {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c','%c',%3d, A,%3d,%3d, X,%2d,%2d)                     .\n", sname, nc, sname, uplo, trans, diag, n, aoff, lda, xoff, incx)
			} else if banded {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c','%c',%3d,%3d, A,%3d,%3d, X,%2d,%2d)                 .\n", sname, nc, sname, uplo, trans, diag, n, k, aoff, lda, xoff, incx)
			} else if packed {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c','%c',%3d, AP,%3d, X,%2d,%2d)                        .\n", sname, nc, sname, uplo, trans, diag, n, aoff, xoff, incx)
			}

		} else if sname == "SGER" {
			var aoff, i, im, incx, incxs, incy, incys, j, laa, lda, ldas, lx, ly, m, ms, n, nd, ns, xoff, yoff int
			w := make([]float32, 1)
			var nargs int = 9
			var nc int = 0

			errmax = zero
			ok = true
			for aoff = 0; aoff <= 30; aoff += 10 {
				for xoff = 0; xoff <= 30; xoff += 10 {
					for yoff = 0; yoff <= 30; yoff += 10 {
						for _, n = range idim {
							nd = n/2 + 1

							for im = 1; im <= 2; im++ {
								if im == 1 {
									m = maxint(n-nd, 0)
								}
								if im == 2 {
									m = minint(n+nd, nmax)
								}
								//
								//           Set LDA to 1 more than minimum value if room.
								lda = m
								if lda < nmax {
									lda++
								}
								//           Skip tests if not enough room.
								if lda > nmax {
									goto label3110
								}
								laa = lda * n
								null = n <= 0 || m <= 0

								for _, incx = range inc {
									lx = absint(incx) * m
									//
									//              Generate the vector X.
									//
									transl = half
									smakeL2("GE", ' ', ' ', &ione, &m, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := m - 1; return &y }(), &reset, &transl)
									if m > 1 {
										x[m/2-1+xoff] = zero
										xx[1+absint(incx)*(m/2-1)-1+xoff] = zero
									}

									for _, incy = range inc {
										ly = absint(incy) * n
										//
										//                 Generate the vector Y.
										//
										transl = zero
										smakeL2("GE", ' ', ' ', &ione, &n, &y, &ione, &yy, &yoff, func() *int { y := absint(incy); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
										if n > 1 {
											y[n/2-1+yoff] = zero
											yy[1+absint(incy)*(n/2-1)-1+yoff] = zero
										}

										for _, alpha = range alf {
											//
											//                    Generate the matrix A.
											//
											transl = zero
											smakeL2(sname[1:3], ' ', ' ', &m, &n, &a, &nmax, &aa, &aoff, &lda, func() *int { y := m - 1; return &y }(), func() *int { y := n - 1; return &y }(), &reset, &transl)

											nc++
											//
											//                    Save every datum before calling the subroutine.
											//
											ms = m
											ns = n
											als = alpha
											for i = 1; i <= laa; i++ {
												as[i-1+aoff] = aa[i-1+aoff]
											}
											ldas = lda
											for i = 1; i <= lx; i++ {
												xs[i-1+xoff] = xx[i-1+xoff]
											}
											incxs = incx
											for i = 1; i <= ly; i++ {
												ys[i-1+yoff] = yy[i-1+yoff]
											}
											incys = incy
											//
											//                    Call the subroutine.
											//
											Sger(&m, &n, &alpha, &xx, &xoff, &incx, &yy, &yoff, &incy, &aa, &aoff, &lda)
											//
											//                    Check if error-exit was taken incorrectly.
											//
											if !ok {
												t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
												fatal = true
												goto label3140
											}
											//
											//                    See what data changed inside subroutine.
											//
											isame[0] = ms == m
											isame[1] = ns == n
											isame[2] = als == alpha
											isame[3] = lse(&xs, &xx, &xoff, &lx)
											isame[4] = incxs == incx
											isame[5] = lse(&ys, &yy, &yoff, &ly)
											isame[6] = incys == incy
											if null {
												isame[7] = lse(&as, &aa, &aoff, &laa)
											} else {
												isame[7] = lseres("GE", ' ', &m, &n, &as, &aa, &aoff, &lda)
											}
											isame[8] = ldas == lda
											//
											//                    If data was incorrectly changed, report and return.
											//
											same = true
											for i = 1; i <= nargs; i++ {
												same = same && isame[i-1]
												if !isame[i-1] {
													t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
												}
											}
											if !same {
												fatal = true
												goto label3140
											}

											if !null {
												//
												//                       Check the result column by column.
												//
												if incx > 0 {
													for i = 1; i <= m; i++ {
														z[i-1] = x[i-1+xoff]
													}
												} else {
													for i = 1; i <= m; i++ {
														z[i-1] = x[m-i+1-1+xoff]
													}
												}
												for j = 1; j <= n; j++ {
													if incy > 0 {
														w[0] = y[j-1+yoff]
													} else {
														w[0] = y[n-j+1-1+yoff]
													}
													smvch('N', &m, &ione, &alpha, &z, &izero, &nmax, &w, &izero, &ione, &one, &a, func() *int { y := 0 + (j-1)*nmax + aoff; return &y }(), &ione, &yt, &g, &aa, func() *int { y := 1 + (j-1)*lda - 1 + aoff; return &y }(), &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													errmax = maxf32(errmax, err)
													//                          If got really bad answer, report and return.
													if fatal {
														goto label3130
													}

												}
											} else {
												//                       Avoid repeating tests with M.le.0 or N.le.0.
												goto label3110
											}

										}

									}

								}

							label3110:
							}

						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label3130:
			;
			t.Errorf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)

		label3140:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s(%3d,%3d,%4.1f, X,%2d,%2d, Y,%2d,%2d, A,%3d,%3d)                  .\n", sname, nc, sname, m, n, alpha, xoff, incx, yoff, incy, aoff, lda)

		} else if sname == "SSYR" || sname == "SSPR" {
			var aoff, i, incx, incxs, j, ja, jj, laa, lda, ldas, lj, lx, n, nargs, nc, ns, xoff int
			w := make([]float32, 1)
			var full bool = sname[2] == 'Y'
			var packed bool = sname[2] == 'P'

			//     Define the number of arguments.
			ok = true
			if full {
				nargs = 7
			} else if packed {
				nargs = 6
			}

			nc = 0
			reset = true
			errmax = zero

			for aoff = 0; aoff <= 30; aoff += 10 {
				for xoff = 0; xoff <= 30; xoff += 10 {
					for _, n = range idim {
						//        Set LDA to 1 more than minimum value if room.
						lda = n
						if lda < nmax {
							lda++
						}
						//        Skip tests if not enough room.
						if lda > nmax {
							goto label4100
						}
						if packed {
							laa = (n * (n + 1)) / 2
						} else {
							laa = lda * n
						}

						for _, uplo = range ichu {
							upper = uplo == 'U'

							for _, incx = range inc {
								lx = absint(incx) * n
								//
								//              Generate the vector X.
								//
								transl = half
								smakeL2("GE", ' ', ' ', &ione, &n, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
								if n > 1 {
									x[n/2-1+xoff] = zero
									xx[1+absint(incx)*(n/2-1)-1+xoff] = zero
								}

								for _, alpha = range alf {
									null = n <= 0 || alpha == zero
									//
									//                 Generate the matrix A.
									//
									transl = zero
									smakeL2(sname[1:3], uplo, ' ', &n, &n, &a, &nmax, &aa, &aoff, &lda, func() *int { y := n - 1; return &y }(), func() *int { y := n - 1; return &y }(), &reset, &transl)

									nc++
									//
									//                 Save every datum before calling the subroutine.
									//
									uplos = uplo
									ns = n
									als = alpha
									for i = 1; i <= laa; i++ {
										as[i-1+aoff] = aa[i-1+aoff]
									}
									ldas = lda
									for i = 1; i <= lx; i++ {
										xs[i-1+xoff] = xx[i-1+xoff]
									}
									incxs = incx
									//
									//                 Call the subroutine.
									//
									if full {
										Ssyr(&uplo, &n, &alpha, &xx, &xoff, &incx, &aa, &aoff, &lda)
									} else if packed {
										Sspr(&uplo, &n, &alpha, &xx, &xoff, &incx, &aa, &aoff)
									}
									//
									//                 Check if error-exit was taken incorrectly.
									//
									if !ok {
										t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
										fatal = true
										goto label4120
									}
									//
									//                 See what data changed inside subroutines.
									//
									isame[0] = uplo == uplos
									isame[1] = ns == n
									isame[2] = als == alpha
									isame[3] = lse(&xs, &xx, &xoff, &lx)
									isame[4] = incxs == incx
									if null {
										isame[5] = lse(&as, &aa, &aoff, &laa)
									} else {
										isame[5] = lseres(sname[1:3], uplo, &n, &n, &as, &aa, &aoff, &lda)
									}
									if !packed {
										isame[6] = ldas == lda
									}
									//
									//                 If data was incorrectly changed, report and return.
									//
									same = true
									for i = 1; i <= nargs; i++ {
										same = same && isame[i-1]
										if !isame[i-1] {
											t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
										}
									}
									if !same {
										fatal = true
										goto label4120
									}
									//
									if !null {
										//
										//                    Check the result column by column.
										//
										if incx > 0 {
											for i = 1; i <= n; i++ {
												z[i-1] = x[i-1+xoff]
											}
										} else {
											for i = 1; i <= n; i++ {
												z[i-1] = x[n-i+1-1+xoff]
											}
										}
										ja = 1
										for j = 1; j <= n; j++ {
											w[0] = z[j-1]
											if upper {
												jj = 1
												lj = j
											} else {
												jj = j
												lj = n - j + 1
											}
											smvch('N', &lj, &ione, &alpha, &z, func() *int { y := jj - 1; return &y }(), &lj, &w, &izero, &ione, &one, &a, func() *int { y := jj - 1 + (j-1)*nmax + aoff; return &y }(), &ione, &yt, &g, &aa, func() *int { y := ja - 1 + aoff; return &y }(), &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
											if full {
												if upper {
													ja = ja + lda
												} else {
													ja = ja + lda + 1
												}
											} else {
												ja = ja + lj
											}
											errmax = maxf32(errmax, err)
											//                       If got really bad answer, report and return.
											if fatal {
												goto label4110
											}
										}
									} else {
										//                    Avoid repeating tests if N.le.0.
										if n <= 0 {
											goto label4100
										}
									}

								}

							}
						}

					label4100:
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label4110:
			;
			t.Errorf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)

		label4120:
			;
			if full {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, X,%2d,%2d, A,%3d,%3d)                        .\n", sname, nc, sname, uplo, n, alpha, xoff, incx, aoff, lda)
			} else if packed {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, X,%2d,%2d, AP,%3d)                           .\n", sname, nc, sname, uplo, n, alpha, xoff, incx, aoff)
			}

		} else if sname == "SSYR2" || sname == "SSPR2" {
			var aoff, i, incx, incxs, incy, incys, j, ja, jj, laa, lda, ldas, lj, lx, ly, n, nargs, nc, ns, xoff, yoff int
			w := make([]float32, 2)
			var full = sname[2] == 'Y'
			var packed = sname[2] == 'P'

			//     Define the number of arguments.
			ok = true
			if full {
				nargs = 9
			} else if packed {
				nargs = 8
			}

			nc = 0
			reset = true
			errmax = zero

			for aoff = 0; aoff <= 30; aoff += 10 {
				for xoff = 0; xoff <= 30; xoff += 10 {
					for yoff = 0; yoff <= 30; yoff += 10 {
						for _, n = range idim {
							//        Set LDA to 1 more than minimum value if room.
							lda = n
							if lda < nmax {
								lda++
							}
							//        Skip tests if not enough room.
							if lda > nmax {
								goto label5140
							}
							if packed {
								laa = (n * (n + 1)) / 2
							} else {
								laa = lda * n
							}

							for _, uplo = range ichu {
								upper = uplo == 'U'

								for _, incx = range inc {
									lx = absint(incx) * n
									//
									//              Generate the vector X.
									//
									transl = half
									smakeL2("GE", ' ', ' ', &ione, &n, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
									if n > 1 {
										x[n/2-1+xoff] = zero
										xx[1+absint(incx)*(n/2-1)-1+xoff] = zero
									}

									for _, incy = range inc {
										ly = absint(incy) * n
										//
										//                 Generate the vector Y.
										//
										transl = zero
										smakeL2("GE", ' ', ' ', &ione, &n, &y, &ione, &yy, &yoff, func() *int { y := absint(incy); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
										if n > 1 {
											y[n/2-1+yoff] = zero
											yy[1+absint(incy)*(n/2-1)-1+yoff] = zero
										}

										for _, alpha = range alf {
											null = n <= 0 || alpha == zero
											//
											//                    Generate the matrix A.
											//
											transl = zero
											smakeL2(sname[1:3], uplo, ' ', &n, &n, &a, &nmax, &aa, &aoff, &lda, func() *int { y := n - 1; return &y }(), func() *int { y := n - 1; return &y }(), &reset, &transl)

											nc++
											//
											//                    Save every datum before calling the subroutine.
											//
											uplos = uplo
											ns = n
											als = alpha
											for i = 1; i <= laa; i++ {
												as[i-1+aoff] = aa[i-1+aoff]
											}
											ldas = lda
											for i = 1; i <= lx; i++ {
												xs[i-1+xoff] = xx[i-1+xoff]
											}
											incxs = incx
											for i = 1; i <= ly; i++ {
												ys[i-1+yoff] = yy[i-1+yoff]
											}
											incys = incy
											//
											//                    Call the subroutine.
											//
											if full {
												Ssyr2(&uplo, &n, &alpha, &xx, &xoff, &incx, &yy, &yoff, &incy, &aa, &aoff, &lda)
											} else if packed {
												Sspr2(&uplo, &n, &alpha, &xx, &xoff, &incx, &yy, &yoff, &incy, &aa, &aoff)
											}
											//
											//                    Check if error-exit was taken incorrectly.
											//
											if !ok {
												t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
												fatal = true
												goto label5160
											}
											//
											//                    See what data changed inside subroutines.
											//
											isame[0] = uplo == uplos
											isame[1] = ns == n
											isame[2] = als == alpha
											isame[3] = lse(&xs, &xx, &xoff, &lx)
											isame[4] = incxs == incx
											isame[5] = lse(&ys, &yy, &yoff, &ly)
											isame[6] = incys == incy
											if null {
												isame[7] = lse(&as, &aa, &aoff, &laa)
											} else {
												isame[7] = lseres(sname[1:3], uplo, &n, &n, &as, &aa, &aoff, &lda)
											}
											if !packed {
												isame[8] = ldas == lda
											}
											//
											//                    If data was incorrectly changed, report and return.
											//
											same = true
											for i = 1; i <= nargs; i++ {
												same = same && isame[i-1]
												if !isame[i-1] {
													t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
												}
											}
											if !same {
												fatal = true
												goto label5160
											}

											if !null {
												//
												//                       Check the result column by column.
												//
												if incx > 0 {
													for i = 1; i <= n; i++ {
														z[i-1+0*nmax] = x[i-1+xoff]
													}
												} else {
													for i = 1; i <= n; i++ {
														z[i-1+0*nmax] = x[n-i+1-1+xoff]
													}
												}
												if incy > 0 {
													for i = 1; i <= n; i++ {
														z[i-1+1*nmax] = y[i-1+yoff]
													}
												} else {
													for i = 1; i <= n; i++ {
														z[i-1+1*nmax] = y[n-i+1-1+yoff]
													}
												}
												ja = 1
												for j = 1; j <= n; j++ {
													w[0] = z[j-1+1*nmax]
													w[1] = z[j-1+0*nmax]
													if upper {
														jj = 1
														lj = j
													} else {
														jj = j
														lj = n - j + 1
													}
													smvch('N', &lj, &itwo, &alpha, &z, func() *int { y := jj - 1 + 0*nmax; return &y }(), &nmax, &w, &izero, &ione, &one, &a, func() *int { y := jj - 1 + (j-1)*nmax + aoff; return &y }(), &ione, &yt, &g, &aa, func() *int { y := ja - 1 + aoff; return &y }(), &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													if full {
														if upper {
															ja = ja + lda
														} else {
															ja = ja + lda + 1
														}
													} else {
														ja = ja + lj
													}
													errmax = maxf32(errmax, err)
													//                          If got really bad answer, report and return.
													if fatal {
														goto label5150
													}
												}
											} else {
												//                       Avoid repeating tests with N.le.0.
												if n <= 0 {
													goto label5140
												}
											}

										}

									}

								}

							}

						label5140:
						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label5150:
			;
			t.Errorf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)

		label5160:
			;
			if full {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, X,%2d, Y,%2d, A,%3d)                  .\n", sname, nc, sname, uplo, n, alpha, incx, incy, lda)
			} else if packed {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, X,%2d, Y,%2d, AP)                     .\n", sname, nc, sname, uplo, n, alpha, incx, incy)
			}
		} else {
			t.Logf(" %6s TEST NOT FOUND\n", sname)
		}
	}
}

func TestSblasLevel3(t *testing.T) {
	var diag, diags, side, sides, tranas, tranbs, transa, transb, uplo, uplos byte
	var fatal, left, null, tran, same, upper bool
	var alpha, als, beta, bls, bets, err float32
	var i, j, n int
	var ok bool = true
	var reset bool = true
	var zero float32 = 0.0
	var one float32 = 1.0
	var eps float32 = epsilonf32()
	var thresh float32 = 16.0
	var errmax float32 = zero
	var nmax int = 65
	var izero int = 0
	var idim []int = []int{0, 1, 2, 3, 5, 9}
	var alf []float32 = []float32{0.0, 1.0, 0.7}
	var bet []float32 = []float32{0.0, 1.0, 1.3}
	isame := make([]bool, 13)
	var ichd []byte = []byte{'U', 'N'}
	var ichs []byte = []byte{'L', 'R'}
	var icht []byte = []byte{'N', 'T', 'C'}
	var ichu []byte = []byte{'U', 'L'}
	a := make([]float32, nmax*2*nmax)
	aa := make([]float32, nmax*nmax)
	ab := make([]float32, nmax*2*nmax)
	as := make([]float32, nmax*nmax)
	b := make([]float32, nmax*2*nmax)
	bb := make([]float32, nmax*nmax)
	bs := make([]float32, nmax*nmax)
	c := make([]float32, nmax*nmax)
	cc := make([]float32, nmax*nmax)
	cs := make([]float32, nmax*nmax)
	ct := make([]float32, nmax)
	g := make([]float32, nmax)
	w := make([]float32, 2*nmax)
	var snames []string = []string{"SGEMM", "SSYMM", "STRMM", "STRSM", "SSYRK", "SSYR2K"}

	n = minint(int(32), nmax)
	for j = 1; j <= n; j++ {
		for i = 1; i <= n; i++ {
			a[i-1+(j-1)*nmax] = float32(maxint(i-j+1, 0))
			ab[i-1+(j-1)*nmax] = float32(maxint(i-j+1, 0))
			b[i-1+(j-1)*nmax] = float32(maxint(i-j+1, 0))
		}
		a[j-1+(nmax)*nmax] = float32(j)
		a[0+(nmax+j-1)*nmax] = float32(j)
		ab[j-1+(nmax)*nmax] = float32(j)
		ab[0+(nmax+j-1)*nmax] = float32(j)
		b[j-1+(nmax)*nmax] = float32(j)
		b[0+(nmax+j-1)*nmax] = float32(j)
		c[j-1+0*nmax] = zero
	}
	for j = 1; j <= n; j++ {
		cc[j-1] = float32(j*((j+1)*j))/2 - float32((j+1)*j*(j-1))/3
	}
	//     CC holds the exact result. On exit from SMMCH CT holds
	//     the result computed by SMMCH.
	transa = byte('N')
	transb = byte('N')
	smmch(transa, transb, &n, func() *int { y := 1; return &y }(), &n, &one, &a, &izero, &nmax, &a, func() *int { y := nmax * nmax; return &y }(), &nmax, &zero, &c, &izero, &nmax, &ct, &g, &cc, &izero, &nmax, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lse(&cc, &ct, &izero, &n)
	if !same || err != zero {
		t.Errorf(" ERROR IN SMMCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n SMMCH WAS CALLED WITH TRANSA = %c AND TRANSB = %c\n AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", transa, transb, same, err)
	}
	transb = byte('T')
	smmch(transa, transb, &n, func() *int { y := 1; return &y }(), &n, &one, &a, &izero, &nmax, &a, func() *int { y := nmax * nmax; return &y }(), &nmax, &zero, &c, &izero, &nmax, &ct, &g, &cc, &izero, &nmax, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lse(&cc, &ct, &izero, &n)
	if !same || err != zero {
		t.Errorf(" ERROR IN SMMCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n SMMCH WAS CALLED WITH TRANSA = %c AND TRANSB = %c\n AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", transa, transb, same, err)
	}
	for j = 1; j <= n; j++ {
		a[j-1+(nmax)*nmax] = float32(n - j + 1)
		a[0+(nmax+j-1)*nmax] = float32(n - j + 1)
		ab[j-1+(nmax)*nmax] = float32(n - j + 1)
		ab[0+(nmax+j-1)*nmax] = float32(n - j + 1)
		b[j-1+(nmax)*nmax] = float32(n - j + 1)
		b[0+(nmax+j-1)*nmax] = float32(n - j + 1)
	}
	for j = 1; j <= n; j++ {
		cc[n-j+1-1] = float32(j*((j+1)*j))/2 - float32((j+1)*j*(j-1))/3
	}
	transa = byte('T')
	transb = byte('N')
	smmch(transa, transb, &n, func() *int { y := 1; return &y }(), &n, &one, &a, &izero, &nmax, &a, func() *int { y := nmax * nmax; return &y }(), &nmax, &zero, &c, &izero, &nmax, &ct, &g, &cc, &izero, &nmax, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lse(&cc, &ct, &izero, &n)
	if !same || err != zero {
		t.Errorf(" ERROR IN SMMCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n SMMCH WAS CALLED WITH TRANSA = %c AND TRANSB = %c\n AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", transa, transb, same, err)
	}
	transb = byte('T')
	smmch(transa, transb, &n, func() *int { y := 1; return &y }(), &n, &one, &a, &izero, &nmax, &a, func() *int { y := nmax * nmax; return &y }(), &nmax, &zero, &c, &izero, &nmax, &ct, &g, &cc, &izero, &nmax, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lse(&cc, &ct, &izero, &n)
	if !same || err != zero {
		t.Errorf(" ERROR IN SMMCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n SMMCH WAS CALLED WITH TRANSA = %c AND TRANSB = %c\n AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", transa, transb, same, err)
	}

	for _, sname := range snames {
		if sname == "SGEMM" {
			var trana, tranb bool
			var aoff, boff, coff, i, k, ks, laa, lbb, lcc, lda, ldas, ldb, ldbs, ldc, ldcs, m, ma, mb, ms, n, na, nb, ns int
			var nargs int = 13
			var nc int = 0

			ok = true
			for aoff = 0; aoff <= 25; aoff += 25 {
				for boff = 0; boff <= 25; boff += 25 {
					for coff = 0; coff <= 25; coff += 25 {
						for _, m = range idim {

							for _, n = range idim {
								//           Set LDC to 1 more than minimum value if room.
								ldc = m
								if ldc < nmax {
									ldc = ldc + 1
								}
								//           Skip tests if not enough room.
								if ldc > nmax {
									goto label1100
								}
								lcc = ldc * n
								null = n <= 0 || m <= 0

								for _, k = range idim {

									for _, transa = range icht {
										trana = transa == 'T' || transa == 'C'

										if trana {
											ma = k
											na = m
										} else {
											ma = m
											na = k
										}
										//                 Set LDA to 1 more than minimum value if room.
										lda = ma
										if lda < nmax {
											lda = lda + 1
										}
										//                 Skip tests if not enough room.
										if lda > nmax {
											goto label180
										}
										laa = lda * na
										//
										//                 Generate the matrix A.
										//
										smakeL3("GE", ' ', ' ', &ma, &na, &a, &nmax, &aa, &aoff, &lda, &reset, &zero)

										for _, transb = range icht {
											tranb = transb == 'T' || transb == 'C'

											if tranb {
												mb = n
												nb = k
											} else {
												mb = k
												nb = n
											}
											//                    Set LDB to 1 more than minimum value if room.
											ldb = mb
											if ldb < nmax {
												ldb = ldb + 1
											}
											//                    Skip tests if not enough room.
											if ldb > nmax {
												goto label170
											}
											lbb = ldb * nb
											//
											//                    Generate the matrix B.
											//
											smakeL3("GE", ' ', ' ', &mb, &nb, &b, &nmax, &bb, &boff, &ldb, &reset, &zero)

											for _, alpha = range alf {

												for _, beta = range bet {
													//
													//                          Generate the matrix C.
													//
													smakeL3("GE", ' ', ' ', &m, &n, &c, &nmax, &cc, &coff, &ldc, &reset, &zero)

													nc++
													//
													//                          Save every datum before calling the
													//                          subroutine.
													//
													tranas = transa
													tranbs = transb
													ms = m
													ns = n
													ks = k
													als = alpha
													for i = 1; i <= laa; i++ {
														as[i-1+aoff] = aa[i-1+aoff]
													}
													ldas = lda
													for i = 1; i <= lbb; i++ {
														bs[i-1+boff] = bb[i-1+boff]
													}
													ldbs = ldb
													bls = beta
													for i = 1; i <= lcc; i++ {
														cs[i-1+coff] = cc[i-1+coff]
													}
													ldcs = ldc
													//
													//                          Call the subroutine.
													//
													Sgemm(&transa, &transb, &m, &n, &k, &alpha, &aa, &aoff, &lda, &bb, &boff, &ldb, &beta, &cc, &coff, &ldc)
													//
													//                          Check if error-exit was taken incorrectly.
													//
													if !ok {
														t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
														fatal = true
														goto label1120
													}
													//
													//                          See what data changed inside subroutines.
													//
													isame[0] = transa == tranas
													isame[1] = transb == tranbs
													isame[2] = ms == m
													isame[3] = ns == n
													isame[4] = ks == k
													isame[5] = als == alpha
													isame[6] = lse(&as, &aa, &aoff, &laa)
													isame[7] = ldas == lda
													isame[8] = lse(&bs, &bb, &boff, &lbb)
													isame[9] = ldbs == ldb
													isame[10] = bls == beta
													if null {
														isame[11] = lse(&cs, &cc, &coff, &lcc)
													} else {
														isame[11] = lseres("GE", ' ', &m, &n, &cs, &cc, &coff, &ldc)
													}
													isame[12] = ldcs == ldc
													//
													//                          If data was incorrectly changed, report
													//                          and return.
													//
													same = true
													for i = 1; i <= nargs; i++ {
														same = same && isame[i-1]
														if !isame[i-1] {
															t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
														}
													}
													if !same {
														fatal = true
														goto label1120
													}

													if !null {
														//
														//                             Check the result.
														//
														smmch(transa, transb, &m, &n, &k, &alpha, &a, &aoff, &nmax, &b, &boff, &nmax, &beta, &c, &coff, &nmax, &ct, &g, &cc, &coff, &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
														errmax = maxf32(errmax, err)
														//                             If got really bad answer, report and
														//                             return.
														if fatal {
															goto label1120
														}
													}

												}

											}

										label170:
										}

									label180:
									}

								}

							label1100:
							}

						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label1120:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c',%3d,%3d,%3d,%4.1f, A,%3d,%3d, B,%3d,%3d,%4.1f, C,%3d,%3d).\n", sname, nc, sname, transa, transb, m, n, k, alpha, aoff, lda, boff, ldb, beta, coff, ldc)

		} else if sname == "SSYMM" {
			var aoff, boff, coff, i, laa, lbb, lcc, lda, ldas, ldb, ldbs, ldc, ldcs, m, ms, n, na, ns int
			var nargs int = 12
			var nc int = 0

			ok = true
			for aoff = 0; aoff <= 30; aoff += 10 {
				for boff = 0; boff <= 30; boff += 10 {
					for coff = 0; coff <= 30; coff += 10 {
						for _, m = range idim {

							for _, n = range idim {
								//           Set LDC to 1 more than minimum value if room.
								ldc = m
								if ldc < nmax {
									ldc = ldc + 1
								}
								//           Skip tests if not enough room.
								if ldc > nmax {
									goto label290
								}
								lcc = ldc * n
								null = n <= 0 || m <= 0
								//
								//           Set LDB to 1 more than minimum value if room.
								ldb = m
								if ldb < nmax {
									ldb = ldb + 1
								}
								//           Skip tests if not enough room.
								if ldb > nmax {
									goto label290
								}
								lbb = ldb * n
								//
								//           Generate the matrix B.
								//
								smakeL3("GE", ' ', ' ', &m, &n, &b, &nmax, &bb, &boff, &ldb, &reset, &zero)

								for _, side = range ichs {
									left = side == 'L'

									if left {
										na = m
									} else {
										na = n
									}
									//              Set LDA to 1 more than minimum value if room.
									lda = na
									if lda < nmax {
										lda = lda + 1
									}
									//              Skip tests if not enough room.
									if lda > nmax {
										goto label280
									}
									laa = lda * na

									for _, uplo = range ichu {
										//
										//                 Generate the symmetric matrix A.
										//
										smakeL3("SY", uplo, ' ', &na, &na, &a, &nmax, &aa, &aoff, &lda, &reset, &zero)

										for _, alpha = range alf {

											for _, beta = range bet {
												//
												//                       Generate the matrix C.
												//
												smakeL3("GE", ' ', ' ', &m, &n, &c, &nmax, &cc, &coff, &ldc, &reset, &zero)

												nc++
												//
												//                       Save every datum before calling the
												//                       subroutine.
												//
												sides = side
												uplos = uplo
												ms = m
												ns = n
												als = alpha
												for i = 1; i <= laa; i++ {
													as[i-1+aoff] = aa[i-1+aoff]
												}
												ldas = lda
												for i = 1; i <= lbb; i++ {
													bs[i-1+boff] = bb[i-1+boff]
												}
												ldbs = ldb
												bls = beta
												for i = 1; i <= lcc; i++ {
													cs[i-1+coff] = cc[i-1+coff]
												}
												ldcs = ldc
												//
												//                       Call the subroutine.
												//
												Ssymm(&side, &uplo, &m, &n, &alpha, &aa, &aoff, &lda, &bb, &boff, &ldb, &beta, &cc, &coff, &ldc)
												//
												//                       Check if error-exit was taken incorrectly.
												//
												if !ok {
													t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
													fatal = true
													goto label2110
												}
												//
												//                       See what data changed inside subroutines.
												//
												isame[0] = sides == side
												isame[1] = uplos == uplo
												isame[2] = ms == m
												isame[3] = ns == n
												isame[4] = als == alpha
												isame[5] = lse(&as, &aa, &aoff, &laa)
												isame[6] = ldas == lda
												isame[7] = lse(&bs, &bb, &boff, &lbb)
												isame[8] = ldbs == ldb
												isame[9] = bls == beta
												if null {
													isame[10] = lse(&cs, &cc, &coff, &lcc)
												} else {
													isame[10] = lseres("GE", ' ', &m, &n, &cs, &cc, &coff, &ldc)
												}
												isame[11] = ldcs == ldc
												//
												//                       If data was incorrectly changed, report and
												//                       return.
												//
												same = true
												for i = 1; i <= nargs; i++ {
													same = same && isame[i-1]
													if !isame[i-1] {
														t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
													}
												}
												if !same {
													fatal = true
													goto label2110
												}

												if !null {
													//
													//                          Check the result.
													//
													if left {
														smmch('N', 'N', &m, &n, &m, &alpha, &a, &aoff, &nmax, &b, &boff, &nmax, &beta, &c, &coff, &nmax, &ct, &g, &cc, &coff, &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													} else {
														smmch('N', 'N', &m, &n, &n, &alpha, &b, &boff, &nmax, &a, &aoff, &nmax, &beta, &c, &coff, &nmax, &ct, &g, &cc, &coff, &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													}
													errmax = maxf32(errmax, err)
													//                          If got really bad answer, report and
													//                          return.
													if fatal {
														goto label2110
													}
												}

											}

										}

									}

								label280:
								}

							label290:
							}
						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label2110:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c',%3d,%3d,%4.1f, A,%3d,%3d, B,%3d,%3d,%4.1f, C,%3d,%3d)    .\n", sname, nc, sname, side, uplo, m, n, alpha, aoff, lda, boff, ldb, beta, coff, ldc)

		} else if sname == "STRMM" || sname == "STRSM" {
			var aoff, boff, i, j, laa, lbb, lda, ldas, ldb, ldbs, m, ms, n, na, ns int
			var nargs int = 11
			var nc int = 0

			ok = true
			//
			//     Set up zero matrix for SMMCH.
			for j = 1; j <= nmax; j++ {
				for i = 1; i <= nmax; i++ {
					c[i-1+(j-1)*nmax] = zero
				}
			}

			for aoff = 0; aoff <= 30; aoff += 10 {
				for boff = 0; boff <= 30; boff += 10 {
					for _, m = range idim {

						for _, n = range idim {
							//           Set LDB to 1 more than minimum value if room.
							ldb = m
							if ldb < nmax {
								ldb = ldb + 1
							}
							//           Skip tests if not enough room.
							if ldb > nmax {
								goto label3130
							}
							lbb = ldb * n
							null = m <= 0 || n <= 0

							for _, side = range ichs {
								left = side == 'L'
								if left {
									na = m
								} else {
									na = n
								}
								//              Set LDA to 1 more than minimum value if room.
								lda = na
								if lda < nmax {
									lda = lda + 1
								}
								//              Skip tests if not enough room.
								if lda > nmax {
									goto label3130
								}
								laa = lda * na

								for _, uplo = range ichu {

									for _, transa = range icht {

										for _, diag = range ichd {

											for _, alpha = range alf {
												//
												//                          Generate the matrix A.
												//
												smakeL3("TR", uplo, diag, &na, &na, &a, &nmax, &aa, &aoff, &lda, &reset, &zero)
												//
												//                          Generate the matrix B.
												//
												smakeL3("GE", ' ', ' ', &m, &n, &b, &nmax, &bb, &boff, &ldb, &reset, &zero)

												nc++
												//
												//                          Save every datum before calling the
												//                          subroutine.
												//
												sides = side
												uplos = uplo
												tranas = transa
												diags = diag
												ms = m
												ns = n
												als = alpha
												for i = 1; i <= laa; i++ {
													as[i-1+aoff] = aa[i-1+aoff]
												}
												ldas = lda
												for i = 1; i <= lbb; i++ {
													bs[i-1+boff] = bb[i-1+boff]
												}
												ldbs = ldb
												//
												//                          Call the subroutine.
												//
												if sname[3:5] == "MM" {
													Strmm(&side, &uplo, &transa, &diag, &m, &n, &alpha, &aa, &aoff, &lda, &bb, &boff, &ldb)
												} else if sname[3:5] == "SM" {
													Strsm(&side, &uplo, &transa, &diag, &m, &n, &alpha, &aa, &aoff, &lda, &bb, &boff, &ldb)
												}
												//
												//                          Check if error-exit was taken incorrectly.
												//
												if !ok {
													t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
													fatal = true
													goto label3150
												}
												//
												//                          See what data changed inside subroutines.
												//
												isame[0] = sides == side
												isame[1] = uplos == uplo
												isame[2] = tranas == transa
												isame[3] = diags == diag
												isame[4] = ms == m
												isame[5] = ns == n
												isame[6] = als == alpha
												isame[7] = lse(&as, &aa, &aoff, &laa)
												isame[8] = ldas == lda
												if null {
													isame[9] = lse(&bs, &bb, &boff, &lbb)
												} else {
													isame[9] = lseres("GE", ' ', &m, &n, &bs, &bb, &boff, &ldb)
												}
												isame[10] = ldbs == ldb
												//
												//                          If data was incorrectly changed, report and
												//                          return.
												//
												same = true
												for i = 1; i <= nargs; i++ {
													same = same && isame[i-1]
													if !isame[i-1] {
														t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
													}
												}
												if !same {
													fatal = true
													goto label3150
												}

												if !null {
													if sname[3:5] == "MM" {
														//
														//                                Check the result.
														//
														if left {
															smmch(transa, 'N', &m, &n, &m, &alpha, &a, &aoff, &nmax, &b, &boff, &nmax, &zero, &c, &izero, &nmax, &ct, &g, &bb, &boff, &ldb, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
														} else {
															smmch('N', transa, &m, &n, &n, &alpha, &b, &boff, &nmax, &a, &aoff, &nmax, &zero, &c, &izero, &nmax, &ct, &g, &bb, &boff, &ldb, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
														}
													} else if sname[3:5] == "SM" {
														//
														//                                Compute approximation to original
														//                                matrix.
														//
														for j = 1; j <= n; j++ {
															for i = 1; i <= m; i++ {
																c[i-1+(j-1)*nmax] = bb[i+(j-1)*ldb-1+boff]
																bb[i+(j-1)*ldb-1+boff] = alpha * b[i-1+(j-1)*nmax+boff]
															}
														}

														if left {
															smmch(transa, 'N', &m, &n, &m, &one, &a, &aoff, &nmax, &c, &izero, &nmax, &zero, &b, &boff, &nmax, &ct, &g, &bb, &boff, &ldb, &eps, &err, &fatal, func() *bool { y := false; return &y }(), t)
														} else {
															smmch('N', transa, &m, &n, &n, &one, &c, &izero, &nmax, &a, &aoff, &nmax, &zero, &b, &boff, &nmax, &ct, &g, &bb, &boff, &ldb, &eps, &err, &fatal, func() *bool { y := false; return &y }(), t)
														}
													}
													errmax = maxf32(errmax, err)
													//                             If got really bad answer, report and
													//                             return.
													if fatal {
														goto label3150
													}
												}

											}

										}

									}

								}

							}

						label3130:
						}

					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label3150:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c','%c','%c',%3d,%3d,%4.1f, A,%3d,%3d, B,%3d,%3d)        .\n", sname, nc, sname, side, uplo, transa, diag, m, n, alpha, aoff, lda, boff, ldb)

		} else if sname == "SSYRK" {
			var trans, transs byte
			var aoff, coff, i, j, jc, jj, k, ks, laa, lcc, lda, ldas, ldc, ldcs, lj, ma, n, na, ns int
			var nargs int = 10
			var nc int = 0

			ok = true
			for aoff = 0; aoff <= 30; aoff += 10 {
				for coff = 0; coff <= 30; coff += 10 {
					for _, n = range idim {
						//        Set LDC to 1 more than minimum value if room.
						ldc = n
						if ldc < nmax {
							ldc = ldc + 1
						}
						//        Skip tests if not enough room.
						if ldc > nmax {
							goto label4100
						}
						lcc = ldc * n
						null = n <= 0

						for _, k = range idim {

							for _, trans = range icht {
								tran = trans == 'T' || trans == 'C'
								if tran {
									ma = k
									na = n
								} else {
									ma = n
									na = k
								}
								//              Set LDA to 1 more than minimum value if room.
								lda = ma
								if lda < nmax {
									lda = lda + 1
								}
								//              Skip tests if not enough room.
								if lda > nmax {
									goto label480
								}
								laa = lda * na
								//
								//              Generate the matrix A.
								//
								smakeL3("GE", ' ', ' ', &ma, &na, &a, &nmax, &aa, &aoff, &lda, &reset, &zero)

								for _, uplo = range ichu {
									upper = uplo == 'U'

									for _, alpha = range alf {

										for _, beta = range bet {
											//
											//                       Generate the matrix C.
											//
											smakeL3("SY", uplo, ' ', &n, &n, &c, &nmax, &cc, &coff, &ldc, &reset, &zero)

											nc++
											//
											//                       Save every datum before calling the subroutine.
											//
											uplos = uplo
											transs = trans
											ns = n
											ks = k
											als = alpha
											for i = 1; i <= laa; i++ {
												as[i-1+aoff] = aa[i-1+aoff]
											}
											ldas = lda
											bets = beta
											for i = 1; i <= lcc; i++ {
												cs[i-1+coff] = cc[i-1+coff]
											}
											ldcs = ldc
											//
											//                       Call the subroutine.
											//
											Ssyrk(&uplo, &trans, &n, &k, &alpha, &aa, &aoff, &lda, &beta, &cc, &coff, &ldc)
											//
											//                       Check if error-exit was taken incorrectly.
											//
											if !ok {
												t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
												fatal = true
												goto label4120
											}
											//
											//                       See what data changed inside subroutines.
											//
											isame[0] = uplos == uplo
											isame[1] = transs == trans
											isame[2] = ns == n
											isame[3] = ks == k
											isame[4] = als == alpha
											isame[5] = lse(&as, &aa, &aoff, &laa)
											isame[6] = ldas == lda
											isame[7] = bets == beta
											if null {
												isame[8] = lse(&cs, &cc, &coff, &lcc)
											} else {
												isame[8] = lseres("SY", uplo, &n, &n, &cs, &cc, &coff, &ldc)
											}
											isame[9] = ldcs == ldc
											//
											//                       If data was incorrectly changed, report and
											//                       return.
											//
											same = true
											for i = 1; i <= nargs; i++ {
												same = same && isame[i-1]
												if !isame[i-1] {
													t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
												}
											}
											if !same {
												fatal = true
												goto label4120
											}

											if !null {
												//
												//                          Check the result column by column.
												//
												jc = 1
												for j = 1; j <= n; j++ {
													if upper {
														jj = 1
														lj = j
													} else {
														jj = j
														lj = n - j + 1
													}
													if tran {
														smmch('T', 'N', &lj, func() *int { y := 1; return &y }(), &k, &alpha, &a, func() *int { y := 0 + (jj-1)*nmax + aoff; return &y }(), &nmax, &a, func() *int { y := 0 + (j-1)*nmax + aoff; return &y }(), &nmax, &beta, &c, func() *int { y := jj - 1 + (j-1)*nmax + coff; return &y }(), &nmax, &ct, &g, &cc, func() *int { y := jc - 1 + coff; return &y }(), &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													} else {
														smmch('N', 'T', &lj, func() *int { y := 1; return &y }(), &k, &alpha, &a, func() *int { y := jj - 1 + (0)*nmax + aoff; return &y }(), &nmax, &a, func() *int { y := j - 1 + (0)*nmax + aoff; return &y }(), &nmax, &beta, &c, func() *int { y := jj - 1 + (j-1)*nmax + coff; return &y }(), &nmax, &ct, &g, &cc, func() *int { y := jc - 1 + coff; return &y }(), &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													}
													if upper {
														jc = jc + ldc
													} else {
														jc = jc + ldc + 1
													}
													errmax = maxf32(errmax, err)
													//                             If got really bad answer, report and
													//                             return.
													if fatal {
														goto label4110
													}
												}
											}

										}

									}

								}

							label480:
							}

						}

					label4100:
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label4110:
			;
			if n > 1 {
				t.Errorf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)
			}

		label4120:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c',%3d,%3d,%4.1f, A,%3d,%4.1f, C,%3d)           .\n", sname, nc, sname, uplo, trans, n, k, alpha, lda, beta, ldc)

		} else if sname == "SSYR2K" {
			var trans, transs byte
			var aoff, boff, coff, i, j, jc, jj, jjab, k, ks, laa, lbb, lcc, lda, ldas, ldb, ldbs, ldc, ldcs, lj, ma, n, na, ns int
			var nargs int = 12
			var nc int = 0

			ok = true
			for coff = 0; coff <= 30; coff += 10 {
				for _, n = range idim {
					//        Set LDC to 1 more than minimum value if room.
					ldc = n
					if ldc < nmax {
						ldc = ldc + 1
					}
					//        Skip tests if not enough room.
					if ldc > nmax {
						goto label5130
					}
					lcc = ldc * n
					null = n <= 0
					//
					for _, k = range idim {

						for _, trans = range icht {
							tran = trans == 'T' || trans == 'C'
							if tran {
								ma = k
								na = n
							} else {
								ma = n
								na = k
							}
							//              Set LDA to 1 more than minimum value if room.
							lda = ma
							if lda < nmax {
								lda = lda + 1
							}
							//              Skip tests if not enough room.
							if lda > nmax {
								goto label5110
							}
							laa = lda * na
							//
							//              Generate the matrix A.
							//
							if tran {
								smakeL3("GE", ' ', ' ', &ma, &na, &ab, func() *int { y := 2 * nmax; return &y }(), &aa, &izero, &lda, &reset, &zero)
							} else {
								smakeL3("GE", ' ', ' ', &ma, &na, &ab, &nmax, &aa, &izero, &lda, &reset, &zero)
							}
							//
							//              Generate the matrix B.
							//
							ldb = lda
							lbb = laa
							if tran {
								smakeL3("GE", ' ', ' ', &ma, &na, func() *[]float32 { y := ab[k+1-1:]; return &y }(), func() *int { y := 2 * nmax; return &y }(), &bb, &izero, &ldb, &reset, &zero)
							} else {
								smakeL3("GE", ' ', ' ', &ma, &na, func() *[]float32 { y := ab[k*nmax+1-1:]; return &y }(), &nmax, &bb, &izero, &ldb, &reset, &zero)
							}

							for _, uplo = range ichu {
								upper = uplo == 'U'

								for _, alpha = range alf {

									for _, beta = range bet {
										//
										//                       Generate the matrix C.
										//
										smakeL3("SY", uplo, ' ', &n, &n, &c, &nmax, &cc, &coff, &ldc, &reset, &zero)

										nc++
										//
										//                       Save every datum before calling the subroutine.
										//
										uplos = uplo
										transs = trans
										ns = n
										ks = k
										als = alpha
										for i = 1; i <= laa; i++ {
											as[i-1] = aa[i-1]
										}
										ldas = lda
										for i = 1; i <= lbb; i++ {
											bs[i-1] = bb[i-1]
										}
										ldbs = ldb
										bets = beta
										for i = 1; i <= lcc; i++ {
											cs[i-1+coff] = cc[i-1+coff]
										}
										ldcs = ldc
										//
										//                       Call the subroutine.
										//
										Ssyr2k(&uplo, &trans, &n, &k, &alpha, &aa, &izero, &lda, &bb, &izero, &ldb, &beta, &cc, &coff, &ldc)
										//
										//                       Check if error-exit was taken incorrectly.
										//
										if !ok {
											t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
											fatal = true
											goto label5150
										}
										//
										//                       See what data changed inside subroutines.
										//
										isame[0] = uplos == uplo
										isame[1] = transs == trans
										isame[2] = ns == n
										isame[3] = ks == k
										isame[4] = als == alpha
										isame[5] = lse(&as, &aa, &izero, &laa)
										isame[6] = ldas == lda
										isame[7] = lse(&bs, &bb, &izero, &lbb)
										isame[8] = ldbs == ldb
										isame[9] = bets == beta
										if null {
											isame[10] = lse(&cs, &cc, &coff, &lcc)
										} else {
											isame[10] = lseres("SY", uplo, &n, &n, &cs, &cc, &coff, &ldc)
										}
										isame[11] = ldcs == ldc
										//
										//                       If data was incorrectly changed, report and
										//                       return.
										//
										same = true
										for i = 1; i <= nargs; i++ {
											same = same && isame[i-1]
											if !isame[i-1] {
												t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
											}
										}
										if !same {
											fatal = true
											goto label5150
										}

										if !null {
											//
											//                          Check the result column by column.
											//
											jjab = 1
											jc = 1
											for j = 1; j <= n; j++ {
												if upper {
													jj = 1
													lj = j
												} else {
													jj = j
													lj = n - j + 1
												}
												if tran {
													for i = 1; i <= k; i++ {
														w[i-1] = ab[(j-1)*2*nmax+k+i-1]
														w[k+i-1] = ab[(j-1)*2*nmax+i-1]
													}
													smmch('T', 'N', &lj, func() *int { y := 1; return &y }(), func() *int { y := 2 * k; return &y }(), &alpha, &ab, func() *int { y := jjab - 1; return &y }(), func() *int { y := 2 * nmax; return &y }(), &w, &izero, func() *int { y := 2 * nmax; return &y }(), &beta, &c, func() *int { y := jj - 1 + (j-1)*nmax + coff; return &y }(), &nmax, &ct, &g, &cc, func() *int { y := jc - 1 + coff; return &y }(), &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
												} else {
													for i = 1; i <= k; i++ {
														w[i-1] = ab[(k+i-1)*nmax+j-1]
														w[k+i-1] = ab[(i-1)*nmax+j-1]
													}
													smmch('N', 'N', &lj, func() *int { y := 1; return &y }(), func() *int { y := 2 * k; return &y }(), &alpha, &ab, func() *int { y := jj - 1; return &y }(), &nmax, &w, &izero, func() *int { y := 2 * nmax; return &y }(), &beta, &c, func() *int { y := jj - 1 + (j-1)*nmax + coff; return &y }(), &nmax, &ct, &g, &cc, func() *int { y := jc - 1 + coff; return &y }(), &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
												}
												if upper {
													jc = jc + ldc
												} else {
													jc = jc + ldc + 1
													if tran {
														jjab = jjab + 2*nmax
													}
												}
												errmax = maxf32(errmax, err)
												//                             If got really bad answer, report and
												//                             return.
												if fatal {
													goto label5140
												}
											}
										}

									}

								}

							}

						label5110:
						}

					}

				label5130:
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label5140:
			;
			if n > 1 {
				t.Errorf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)
			}

		label5150:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c',%3d,%3d,%4.1f, A,%3d,%3d, B,%3d,%3d,%4.1f, C,%3d,%3d)    .\n", sname, nc, sname, uplo, trans, n, k, alpha, aoff, lda, boff, ldb, beta, coff, ldc)
		} else {
			t.Logf(" %6s TEST NOT FOUND\n", sname)
		}
	}
}

func scompare1(scomp1 float32, strue1 float32, ssize *[]float32, ssizeoff int, sfac float32, t *testing.T, fname string) {
	var scomp []float32 = []float32{scomp1}
	var strue []float32 = []float32{strue1}

	scompare(1, &scomp, 0, &strue, 0, ssize, ssizeoff, sfac, t, fname)
}

func scompare(len int, scomp *[]float32, scompoff int, strue *[]float32, strueoff int, ssize *[]float32, ssizeoff int, sfac float32, t *testing.T, fname string) {
	var sd float32
	var i int

	for i = 1; i <= len; i++ {
		sd = (*scomp)[i-1+scompoff] - (*strue)[i-1+strueoff]
		if absf32(sfac*sd) <= absf32((*ssize)[i-1+ssizeoff])*epsilonf32() {
			return
		}
		//
		//                             HERE    SCOMP(I) IS NOT CLOSE TO STRUE(I).
		//
		t.Logf("%s\n", fname)
		t.Logf("                                       FAIL\n")
		t.Logf("\n NAME I                             COMP(I)                             TRUE(I)  DIFFERENCE     SIZE(I)\n \n")
		t.Errorf(" %6s %4d%36.24f%36.24f%12.8f%12.8f\n", fname, i, (*scomp)[i-1+scompoff], (*strue)[i-1+strueoff], sd, (*ssize)[i-1+ssizeoff])
	}
}

func icompare1(icomp int, itrue int, t *testing.T, fname string) {
	var id int

	if icomp == itrue {
		return
	}
	//
	//                            HERE ICOMP IS NOT EQUAL TO ITRUE.
	//
	t.Logf("%s\n", fname)
	t.Logf("                                       FAIL\n")
	t.Logf("\n NAME                                COMP                                TRUE     DIFFERENCE\n \n")
	id = icomp - itrue
	t.Logf(" %6s %36d%36d%12d\n", fname, icomp, itrue, id)
}

func sbeg(reset *bool) (sbegReturn float32) {
	var i *int = &common.begc.i
	var ic *int = &common.begc.ic
	var mi *int = &common.begc.mi

	if *reset {
		//        Initialize local variables.
		*mi = 891
		*i = 7
		*ic = 0
		(*reset) = false
	}
	//
	//     The sequence of values of I is bounded between 1 and 999.
	//     If initial I = 1,2,3,6,7 or 9, the period will be 50.
	//     If initial I = 4 or 8, the period will be 25.
	//     If initial I = 5, the period will be 10.
	//     IC is used to break up the period by skipping 1 value of I in 6.
	//
	*ic++
label10:
	;
	*i = (*i) * (*mi)
	*i = (*i) - 1000*((*i)/1000)
	if *ic >= 5 {
		*ic = 0
		goto label10
	}
	sbegReturn = float32((*i)-500) / 1001.0
	return
}

func lse(ri *[]float32, rj *[]float32, roff, lr *int) bool {
	var i int

	for i = 1; i <= (*lr); i++ {
		if (*ri)[i-1+(*roff)] != (*rj)[i-1+(*roff)] {
			return false
		}
	}
	return true
}

func lseres(_type string, uplo byte, m *int, n *int, aa *[]float32, as *[]float32, aoff *int, lda *int) bool {
	var upper bool
	var i, ibeg, iend, j int

	upper = uplo == 'U'
	if _type == "GE" {
		for j = 1; j <= (*n); j++ {
			for i = (*m) + 1; i <= (*lda); i++ {
				if (*aa)[i+(j-1)*(*lda)-1+(*aoff)] != (*as)[i+(j-1)*(*lda)-1+(*aoff)] {
					return false
				}
			}
		}
	} else if _type == "SY" {
		for j = 1; j <= (*n); j++ {
			if upper {
				ibeg = 1
				iend = j
			} else {
				ibeg = j
				iend = (*n)
			}
			for i = 1; i <= ibeg-1; i++ {
				if (*aa)[i+(j-1)*(*lda)-1+(*aoff)] != (*as)[i+(j-1)*(*lda)-1+(*aoff)] {
					return false
				}
			}
			for i = iend + 1; i <= (*lda); i++ {
				if (*aa)[i+(j-1)*(*lda)-1+(*aoff)] != (*as)[i+(j-1)*(*lda)-1+(*aoff)] {
					return false
				}
			}
		}
	}
	return true
}

func smvch(trans byte, m *int, n *int, alpha *float32, a *[]float32, aoff, nmax *int, x *[]float32, xoff, incx *int, beta *float32, y *[]float32, yoff, incy *int, yt *[]float32, g *[]float32, yy *[]float32, yyoff *int, eps *float32, err *float32, fatal *bool, mv *bool, t *testing.T) {
	var tran bool
	var erri float32
	var i, incxl, incyl, iy, j, jx, kx, ky, ml, nl int
	var zero float32 = 0.0
	var one float32 = 1.0

	tran = trans == 'T' || trans == 'C'
	if tran {
		ml = (*n)
		nl = (*m)
	} else {
		ml = (*m)
		nl = (*n)
	}
	if (*incx) < 0 {
		kx = nl
		incxl = -1
	} else {
		kx = 1
		incxl = 1
	}
	if (*incy) < 0 {
		ky = ml
		incyl = -1
	} else {
		ky = 1
		incyl = 1
	}
	//
	//     Compute expected result in YT using data in A, X and Y.
	//     Compute gauges in G.
	//
	iy = ky
	for i = 1; i <= ml; i++ {
		(*yt)[iy-1] = zero
		(*g)[iy-1] = zero
		jx = kx
		if tran {
			for j = 1; j <= nl; j++ {
				(*yt)[iy-1] = (*yt)[iy-1] + (*a)[j-1+(i-1)*(*nmax)+(*aoff)]*(*x)[jx-1+(*xoff)]
				(*g)[iy-1] = (*g)[iy-1] + absf32((*a)[j-1+(i-1)*(*nmax)+(*aoff)]*(*x)[jx-1+(*xoff)])
				jx = jx + incxl
			}
		} else {
			for j = 1; j <= nl; j++ {
				(*yt)[iy-1] = (*yt)[iy-1] + (*a)[i-1+(j-1)*(*nmax)+(*aoff)]*(*x)[jx-1+(*xoff)]
				(*g)[iy-1] = (*g)[iy-1] + absf32((*a)[i-1+(j-1)*(*nmax)+(*aoff)]*(*x)[jx-1+(*xoff)])
				jx = jx + incxl
			}
		}
		(*yt)[iy-1] = (*alpha)*(*yt)[iy-1] + (*beta)*(*y)[iy-1+(*yoff)]
		(*g)[iy-1] = absf32(*alpha)*(*g)[iy-1] + absf32((*beta)*(*y)[iy-1+(*yoff)])
		iy = iy + incyl
	}
	//
	//     Compute the error ratio for this result.
	//
	(*err) = zero
	for i = 1; i <= ml; i++ {
		erri = absf32((*yt)[i-1]-(*yy)[1+(i-1)*absint(*incy)-1+(*yyoff)]) / (*eps)
		if (*g)[i-1] != zero {
			erri = erri / (*g)[i-1]
		}
		(*err) = maxf32(*err, erri)
		if (*err)*sqrtf32(*eps) >= one {
			goto label50
		}
	}
	//     If the loop completes, all results are at least half accurate.
	return
	//
	//     Report fatal error.
	//
label50:
	;
	(*fatal) = true
	t.Errorf(" ******* FATAL ERROR - COMPUTED RESULT IS LESS THAN HALF ACCURATE *******\n           EXPECTED RESULT   COMPUTED RESULT\n")
	for i = 1; i <= ml; i++ {
		if *mv {
			t.Errorf(" %7d%18.6f%18.6f\n", i, (*yt)[i-1], (*yy)[1+(i-1)*absint(*incy)-1+(*yyoff)])
		} else {
			t.Errorf(" %7d%18.6f%18.6f\n", i, (*yy)[1+(i-1)*absint(*incy)-1+(*yyoff)], (*yt)[i-1])
		}
	}
}

func smmch(transa byte, transb byte, m *int, n *int, kk *int, alpha *float32, a *[]float32, aoff, lda *int, b *[]float32, boff, ldb *int, beta *float32, c *[]float32, coff, ldc *int, ct *[]float32, g *[]float32, cc *[]float32, ccoff, ldcc *int, eps *float32, err *float32, fatal *bool, mv *bool, t *testing.T) {
	var erri float32
	var i, j, k int
	var zero float32 = 0.0
	var one float32 = 1.0
	var trana bool = transa == 'T' || transa == 'C'
	var tranb bool = transb == 'T' || transb == 'C'

	//
	//     Compute expected result, one column at a time, in CT using data
	//     in A, B and C.
	//     Compute gauges in G.
	//
	for j = 1; j <= (*n); j++ {

		for i = 1; i <= (*m); i++ {
			(*ct)[i-1] = zero
			(*g)[i-1] = zero
		}
		if !trana && !tranb {
			for k = 1; k <= (*kk); k++ {
				for i = 1; i <= (*m); i++ {
					(*ct)[i-1] = (*ct)[i-1] + (*a)[i-1+(k-1)*(*lda)+(*aoff)]*(*b)[k-1+(j-1)*(*ldb)+(*boff)]
					(*g)[i-1] = (*g)[i-1] + absf32((*a)[i-1+(k-1)*(*lda)+(*aoff)])*absf32((*b)[k-1+(j-1)*(*ldb)+(*boff)])
				}
			}
		} else if trana && !tranb {
			for k = 1; k <= (*kk); k++ {
				for i = 1; i <= (*m); i++ {
					(*ct)[i-1] = (*ct)[i-1] + (*a)[k-1+(i-1)*(*lda)+(*aoff)]*(*b)[k-1+(j-1)*(*ldb)+(*boff)]
					(*g)[i-1] = (*g)[i-1] + absf32((*a)[k-1+(i-1)*(*lda)+(*aoff)])*absf32((*b)[k-1+(j-1)*(*ldb)+(*boff)])
				}
			}
		} else if !trana && tranb {
			for k = 1; k <= (*kk); k++ {
				for i = 1; i <= (*m); i++ {
					(*ct)[i-1] = (*ct)[i-1] + (*a)[i-1+(k-1)*(*lda)+(*aoff)]*(*b)[j-1+(k-1)*(*ldb)+(*boff)]
					(*g)[i-1] = (*g)[i-1] + absf32((*a)[i-1+(k-1)*(*lda)+(*aoff)])*absf32((*b)[j-1+(k-1)*(*ldb)+(*boff)])
				}
			}
		} else if trana && tranb {
			for k = 1; k <= (*kk); k++ {
				for i = 1; i <= (*m); i++ {
					(*ct)[i-1] = (*ct)[i-1] + (*a)[k-1+(i-1)*(*lda)+(*aoff)]*(*b)[j-1+(k-1)*(*ldb)+(*boff)]
					(*g)[i-1] = (*g)[i-1] + absf32((*a)[k-1+(i-1)*(*lda)+(*aoff)])*absf32((*b)[j-1+(k-1)*(*ldb)+(*boff)])
				}
			}
		}
		for i = 1; i <= (*m); i++ {
			(*ct)[i-1] = (*alpha)*(*ct)[i-1] + (*beta)*(*c)[i-1+(j-1)*(*ldc)+(*coff)]
			(*g)[i-1] = absf32(*alpha)*(*g)[i-1] + absf32(*beta)*absf32((*c)[i-1+(j-1)*(*ldc)+(*coff)])
		}
		//
		//        Compute the error ratio for this result.
		//
		(*err) = zero
		for i = 1; i <= (*m); i++ {
			erri = absf32((*ct)[i-1]-(*cc)[i-1+(j-1)*(*ldcc)+(*ccoff)]) / (*eps)
			if (*g)[i-1] != zero {
				erri = erri / (*g)[i-1]
			}
			(*err) = maxf32(*err, erri)
			if (*err)*sqrtf32(*eps) >= one {
				goto label130
			}
		}
	}
	//
	//     If the loop completes, all results are at least half accurate.
	return
	//
	//     Report fatal error.
	//
label130:
	;
	*fatal = true
	t.Errorf(" ******* FATAL ERROR - COMPUTED RESULT IS LESS THAN HALF ACCURATE *******\n           EXPECTED RESULT   COMPUTED RESULT\n")
	for i = 1; i <= (*m); i++ {
		if *mv {
			t.Errorf(" %7d%18.6f%18.6f\n", i, (*ct)[i-1], (*cc)[i-1+(j-1)*(*ldc)])
		} else {
			t.Errorf(" %7d%18.6f%18.6f\n", i, (*cc)[i-1+(j-1)*(*ldc)], (*ct)[i-1])
		}
	}
	if (*n) > 1 {
		t.Errorf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)
	}
}

func smakeL2(_type string, uplo byte, diag byte, m *int, n *int, a *[]float32, nmax *int, aa *[]float32, aoff, lda *int, kl *int, ku *int, reset *bool, transl *float32) {
	var i, i1, i2, i3, ibeg, iend, ioff, j, kk int
	var zero float32 = 0.0
	var one float32 = 1.0
	var rogue float32 = -1.0e10
	var gen bool = _type[0] == 'G'
	var sym bool = _type[0] == 'S'
	var tri bool = _type[0] == 'T'
	var upper bool = (sym || tri) && uplo == 'U'
	var lower bool = (sym || tri) && uplo == 'L'
	var unit bool = tri && diag == 'U'

	//
	//     Generate data in array A.
	//
	for j = 1; j <= (*n); j++ {
		for i = 1; i <= (*m); i++ {
			if gen || (upper && i <= j) || (lower && i >= j) {
				if (i <= j && j-i <= (*ku)) || (i >= j && i-j <= (*kl)) {
					(*a)[i+(j-1)*(*nmax)-1+(*aoff)] = sbeg(reset) + (*transl)
				} else {
					(*a)[i+(j-1)*(*nmax)-1+(*aoff)] = zero
				}
				if i != j {
					if sym {
						(*a)[j-1+(i-1)*(*nmax)+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
					} else if tri {
						(*a)[j-1+(i-1)*(*nmax)+(*aoff)] = zero
					}
				}
			}
		}
		if tri {
			(*a)[j-1+(j-1)*(*nmax)+(*aoff)] = (*a)[j-1+(j-1)*(*nmax)+(*aoff)] + one
		}
		if unit {
			(*a)[j-1+(j-1)*(*nmax)+(*aoff)] = one
		}
	}
	//
	//     Store elements in array AS in data structure required by routine.
	//
	if _type == "GE" {
		for j = 1; j <= (*n); j++ {
			for i = 1; i <= (*m); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i = (*m) + 1; i <= (*lda); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
		}
	} else if _type == "GB" {
		for j = 1; j <= (*n); j++ {
			for i1 = 1; i1 <= (*ku)+1-j; i1++ {
				(*aa)[i1+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
			for i2 = i1; i2 <= minint((*kl)+(*ku)+1, (*ku)+1+(*m)-j); i2++ {
				(*aa)[i2+(j-1)*(*lda)-1+(*aoff)] = (*a)[i2+j-(*ku)-1-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i3 = i2; i3 <= (*lda); i3++ {
				(*aa)[i3+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
		}
	} else if _type == "SY" || _type == "TR" {
		for j = 1; j <= (*n); j++ {
			if upper {
				ibeg = 1
				if unit {
					iend = j - 1
				} else {
					iend = j
				}
			} else {
				if unit {
					ibeg = j + 1
				} else {
					ibeg = j
				}
				iend = (*n)
			}
			for i = 1; i <= ibeg-1; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
			for i = ibeg; i <= iend; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i = iend + 1; i <= (*lda); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
		}
	} else if _type == "SB" || _type == "TB" {
		for j = 1; j <= (*n); j++ {
			if upper {
				kk = (*kl) + 1
				ibeg = maxint(1, (*kl)+2-j)
				if unit {
					iend = (*kl)
				} else {
					iend = (*kl) + 1
				}
			} else {
				kk = 1
				if unit {
					ibeg = 2
				} else {
					ibeg = 1
				}
				iend = minint((*kl)+1, 1+(*m)-j)
			}
			for i = 1; i <= ibeg-1; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
			for i = ibeg; i <= iend; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = (*a)[i+j-kk-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i = iend + 1; i <= (*lda); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
		}
	} else if _type == "SP" || _type == "TP" {
		ioff = 0
		for j = 1; j <= (*n); j++ {
			if upper {
				ibeg = 1
				iend = j
			} else {
				ibeg = j
				iend = (*n)
			}
			for i = ibeg; i <= iend; i++ {
				ioff = ioff + 1
				(*aa)[ioff-1+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
				if i == j {
					if unit {
						(*aa)[ioff-1+(*aoff)] = rogue
					}
				}
			}
		}
	}
}

func smakeL3(_type string, uplo byte, diag byte, m *int, n *int, a *[]float32, nmax *int, aa *[]float32, aoff, lda *int, reset *bool, transl *float32) {
	var i, ibeg, iend, j int
	var zero float32 = 0.0
	var one float32 = 1.0
	var rogue float32 = -1.0e10
	var gen bool = _type == "GE"
	var sym bool = _type == "SY"
	var tri bool = _type == "TR"
	var upper bool = (sym || tri) && uplo == 'U'
	var lower bool = (sym || tri) && uplo == 'L'
	var unit bool = tri && diag == 'U'

	//
	//     Generate data in array A.
	//
	for j = 1; j <= (*n); j++ {
		for i = 1; i <= (*m); i++ {
			if gen || (upper && i <= j) || (lower && i >= j) {
				(*a)[i-1+(j-1)*(*nmax)+(*aoff)] = sbeg(reset) + (*transl)
				if i != j {
					//                 Set some elements to zero
					if (*n) > 3 && j == (*n)/2 {
						(*a)[i-1+(j-1)*(*nmax)+(*aoff)] = zero
					}
					if sym {
						(*a)[j-1+(i-1)*(*nmax)+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
					} else if tri {
						(*a)[j-1+(i-1)*(*nmax)+(*aoff)] = zero
					}
				}
			}
		}
		if tri {
			(*a)[j-1+(j-1)*(*nmax)+(*aoff)] = (*a)[j-1+(j-1)*(*nmax)+(*aoff)] + one
		}
		if unit {
			(*a)[j-1+(j-1)*(*nmax)+(*aoff)] = one
		}
	}
	//
	//     Store elements in array AS in data structure required by routine.
	//
	if _type == "GE" {
		for j = 1; j <= (*n); j++ {
			for i = 1; i <= (*m); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i = (*m) + 1; i <= (*lda); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
		}
	} else if _type == "SY" || _type == "TR" {
		for j = 1; j <= (*n); j++ {
			if upper {
				ibeg = 1
				if unit {
					iend = j - 1
				} else {
					iend = j
				}
			} else {
				if unit {
					ibeg = j + 1
				} else {
					ibeg = j
				}
				iend = (*n)
			}
			for i = 1; i <= ibeg-1; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
			for i = ibeg; i <= iend; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i = iend + 1; i <= (*lda); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
		}
	}
}

func BenchmarkSrot(b *testing.B) {
	n := new(int)
	off := new(int)
	incx := new(int)
	incy := new(int)
	sc := new(float32)
	ss := new(float32)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*n = 7
	*off = 0
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 1
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = 1
	*sc = 0.8
	*ss = 0.6

	for i := 0; i < b.N; i++ {
		Srot(n, sx, off, incx, sy, off, incy, sc, ss)
	}
}

func BenchmarkSdsdot(b *testing.B) {
	n := new(int)
	off := new(int)
	incx := new(int)
	incy := new(int)
	sa := new(float32)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*n = 4
	*off = 0
	*sa = 0.1
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		_ = Sdsdot(n, sa, sx, off, incx, sy, off, incy)
	}
}

func BenchmarkSrotm(b *testing.B) {
	n := new(int)
	off := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	dtemp := func() *[]float32 { y := make([]float32, 5); return &y }()
	*n = 4
	*off = 0
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2
	*dtemp = []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}

	for i := 0; i < b.N; i++ {
		Srotm(n, sx, off, incx, sy, off, incy, dtemp)
	}
}

func BenchmarkSswap(b *testing.B) {
	n := new(int)
	off := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*n = 4
	*off = 0
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Sswap(n, sx, off, incx, sy, off, incy)
	}
}

func BenchmarkScopy(b *testing.B) {
	n := new(int)
	off := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*n = 4
	*off = 0
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Scopy(n, sx, off, incx, sy, off, incy)
	}
}

func BenchmarkSaxpy(b *testing.B) {
	n := new(int)
	off := new(int)
	incx := new(int)
	incy := new(int)
	sa := new(float32)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*n = 4
	*off = 0
	*sa = 0.3
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = -1
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Saxpy(n, sa, sx, off, incx, sy, off, incy)
	}
}

func BenchmarkSdot(b *testing.B) {
	n := new(int)
	off := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*n = 4
	*off = 0
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		_ = Sdot(n, sx, off, incx, sy, off, incy)
	}
}

func BenchmarkSrotg(b *testing.B) {
	sa := new(float32)
	sb := new(float32)
	sc := new(float32)
	ss := new(float32)
	*sa = -0.3
	*sb = 0.4
	*sc = -0.6
	*ss = 0.8

	for i := 0; i < b.N; i++ {
		Srotg(sa, sb, sc, ss)
	}
}

func BenchmarkSrotmg(b *testing.B) {
	off := new(int)
	d1 := new(float32)
	d2 := new(float32)
	x := new(float32)
	y := new(float32)
	sparam := func() *[]float32 {
		y := make([]float32, 5)
		return &y
	}()
	*off = 0
	*d1 = 0.1
	*d2 = 0.3
	*x = 1.2
	*y = 0.2

	for i := 0; i < b.N; i++ {
		Srotmg(d1, d2, x, y, sparam, off)
	}
}

func BenchmarkSnrm2(b *testing.B) {
	off := new(int)
	*off = 0
	n := new(int)
	incx := new(int)
	sx := func() *[]float32 { y := make([]float32, 8); return &y }()
	*n = 0
	*incx = 1
	*sx = []float32{0.1, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0}

	for i := 0; i < b.N; i++ {
		_ = Snrm2(n, sx, off, incx)
	}
}

func BenchmarkSasum(b *testing.B) {
	off := new(int)
	*off = 0
	n := new(int)
	incx := new(int)
	sx := func() *[]float32 { y := make([]float32, 8); return &y }()
	*n = 4
	*incx = 2
	*sx = []float32{0.1, 4.0, -0.3, 6.0, -0.5, 7.0, -0.1, 3.0}

	for i := 0; i < b.N; i++ {
		_ = Sasum(n, sx, off, incx)
	}
}

func BenchmarkSscal(b *testing.B) {
	off := new(int)
	*off = 0
	n := new(int)
	incx := new(int)
	sa := new(float32)
	sx := func() *[]float32 { y := make([]float32, 8); return &y }()
	*n = 4
	*incx = 1
	*sa = 0.3
	*sx = []float32{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}

	for i := 0; i < b.N; i++ {
		Sscal(n, sa, sx, off, incx)
	}
}

func BenchmarkIsamax(b *testing.B) {
	off := new(int)
	*off = 0
	n := new(int)
	incx := new(int)
	sx := func() *[]float32 { y := make([]float32, 8); return &y }()
	*n = 4
	*incx = 1
	*sx = []float32{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}

	for i := 0; i < b.N; i++ {
		_ = Isamax(n, sx, off, incx)
	}
}

func BenchmarkSgemv(b *testing.B) {
	var incmax int = 2
	var nmax int = 65
	off := new(int)
	*off = 0
	alpha := new(float32)
	beta := new(float32)
	m := new(int)
	n := new(int)
	lda := new(int)
	incx := new(int)
	incy := new(int)
	trans := new(byte)

	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*trans = 'C'
	*m = 14
	*n = 9
	*alpha = 0.70
	*aa = []float32{-0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -10000000000.0000, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -0.4525, 0.3766, -10000000000.0000, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, -10000000000.0000, 0.0170, 0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, 0.3067, -0.4625, 0.4665, -10000000000.0000, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, -0.0929, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -0.2927, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, -10000000000.0000}
	*lda = 15
	*xx = []float32{0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.1274, -10000000000.0000, 0.1573, -10000000000.0000, 0.0000, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float32{-0.1728, -10000000000.0000, -0.1429, -10000000000.0000, -0.4126, -10000000000.0000, 0.0170, -10000000000.0000, 0.1469, -10000000000.0000, -0.4925, -10000000000.0000, -0.2627, -10000000000.0000, -0.3327, -10000000000.0000, 0.2967, -10000000000.0000, -0.5402, -10000000000.0000, -0.6307, -10000000000.0000, 0.4639, -10000000000.0000, 0.1913, -10000000000.0000, 0.0281, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Sgemv(trans, m, n, alpha, aa, off, lda, xx, off, incx, beta, yy, off, incy)
	}
}

func BenchmarkSgbmv(b *testing.B) {
	var incmax int = 2
	var nmax int = 65
	off := new(int)
	*off = 0
	alpha := new(float32)
	beta := new(float32)
	m := new(int)
	n := new(int)
	kl := new(int)
	ku := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	trans := new(byte)

	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*trans = 'C'
	*m = 14
	*n = 9
	*kl = 3
	*ku = 4
	*alpha = 0.70
	*aa = []float32{-10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -0.2627, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, -10000000000.0000, 0.2268, 0.2567, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0270, 0.0569, -0.2128, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, -10000000000.0000, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -0.0230, -0.4925, -0.3327, -10000000000.0000, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, 0.3067, -0.4625, -10000000000.0000, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, 0.3367, -10000000000.0000}
	*lda = 9
	*xx = []float32{0.7667, -10000000000.0000, 0.3971, -10000000000.0000, 0.7268, -10000000000.0000, 0.4870, -10000000000.0000, 0.9166, -10000000000.0000, 0.0475, -10000000000.0000, 0.0000, -10000000000.0000, 0.4071, -10000000000.0000, 0.5669, -10000000000.0000, 0.1973, -10000000000.0000, 0.5270, -10000000000.0000, 0.5569, -10000000000.0000, 0.2872, -10000000000.0000, 0.8467, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float32{0.1768, -10000000000.0000, -0.2927, -10000000000.0000, -0.0629, -10000000000.0000, -0.1329, -10000000000.0000, -0.1728, -10000000000.0000, -0.1429, -10000000000.0000, -0.4126, -10000000000.0000, 0.0170, -10000000000.0000, 0.1469, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Sgbmv(trans, m, n, kl, ku, alpha, aa, off, lda, xx, off, incx, beta, yy, off, incy)
	}
}

func BenchmarkSsymv(b *testing.B) {
	var incmax int = 2
	var nmax int = 65
	off := new(int)
	*off = 0
	alpha := new(float32)
	beta := new(float32)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)

	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.3726, -10000000000.0000}
	*lda = 10
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float32{0.1868, -10000000000.0000, -0.3826, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.2667, -10000000000.0000, -0.1029, -10000000000.0000, 0.2268, -10000000000.0000, 0.2567, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Ssymv(uplo, n, alpha, aa, off, lda, xx, off, incx, beta, yy, off, incy)
	}
}

func BenchmarkSsbmv(b *testing.B) {
	var incmax int = 2
	var nmax int = 65
	off := new(int)
	*off = 0
	alpha := new(float32)
	beta := new(float32)
	n := new(int)
	k := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*k = 4
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -10000000000.0000, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -10000000000.0000, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, -10000000000.0000, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, -10000000000.0000, 0.1369, 0.0669, -0.3027, 0.0270, -10000000000.0000, -10000000000.0000, -0.2128, 0.2168, 0.3467, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1768, -0.2927, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000}
	*lda = 6
	*xx = []float32{0.9965, -10000000000.0000, 0.3272, -10000000000.0000, 0.3571, -10000000000.0000, 0.0000, -10000000000.0000, 0.6469, -10000000000.0000, 0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float32{-0.3726, -10000000000.0000, -0.3427, -10000000000.0000, 0.3866, -10000000000.0000, -0.1828, -10000000000.0000, -0.0529, -10000000000.0000, 0.3067, -10000000000.0000, -0.4625, -10000000000.0000, 0.4665, -10000000000.0000, 0.0969, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Ssbmv(uplo, n, k, alpha, aa, off, lda, xx, off, incx, beta, yy, off, incy)
	}
}

func BenchmarkSspmv(b *testing.B) {
	var incmax int = 2
	var nmax int = 65
	off := new(int)
	*off = 0
	alpha := new(float32)
	beta := new(float32)
	n := new(int)
	incx := new(int)
	incy := new(int)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726}
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float32{0.1868, -10000000000.0000, -0.3826, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.2667, -10000000000.0000, -0.1029, -10000000000.0000, 0.2268, -10000000000.0000, 0.2567, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Sspmv(uplo, n, alpha, aa, off, xx, off, incx, beta, yy, off, incy)
	}
}

func BenchmarkStrmv(b *testing.B) {
	var incmax int = 2
	var nmax int = 65
	off := new(int)
	*off = 0
	n := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.6274, -10000000000.0000}
	*lda = 10
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		Strmv(uplo, trans, diag, n, aa, off, lda, xx, off, incx)
	}
}

func BenchmarkStbmv(b *testing.B) {
	var incmax int = 2
	var nmax int = 65
	off := new(int)
	*off = 0
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*k = 4
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -10000000000.0000, 0.8172, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 1.0969, 0.4266, 0.4565, 0.1868, -0.2527, -10000000000.0000, 0.5774, 0.1069, 0.3367, 0.2667, 0.2268, -10000000000.0000, 1.2567, -0.0130, 0.4166, -0.4525, -0.0929, -10000000000.0000, 1.1369, 0.0669, -0.3027, 0.0270, -10000000000.0000, -10000000000.0000, 0.7872, 0.2168, 0.3467, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1768, -0.2927, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.8671, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000}
	*lda = 6
	*xx = []float32{0.9965, -10000000000.0000, 0.3272, -10000000000.0000, 0.3571, -10000000000.0000, 0.0000, -10000000000.0000, 0.6469, -10000000000.0000, 0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		Stbmv(uplo, trans, diag, n, k, aa, off, lda, xx, off, incx)
	}
}

func BenchmarkStpmv(b *testing.B) {
	var incmax int = 2
	var nmax int = 65
	off := new(int)
	*off = 0
	n := new(int)
	incx := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, 1.4965, -0.1728, -0.1429, -0.4126, 1.1469, -0.0230, -0.4925, 0.7373, -0.3327, 0.6274}
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		Stpmv(uplo, trans, diag, n, aa, off, xx, off, incx)
	}
}

func BenchmarkStrsv(b *testing.B) {
	var incmax int = 2
	var nmax int = 65
	off := new(int)
	*off = 0
	n := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.6274, -10000000000.0000}
	*lda = 10
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		Strsv(uplo, trans, diag, n, aa, off, lda, xx, off, incx)
	}
}

func BenchmarkStbsv(b *testing.B) {
	var incmax int = 2
	var nmax int = 65
	off := new(int)
	*off = 0
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*k = 4
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -10000000000.0000, 0.8172, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 1.0969, 0.4266, 0.4565, 0.1868, -0.2527, -10000000000.0000, 0.5774, 0.1069, 0.3367, 0.2667, 0.2268, -10000000000.0000, 1.2567, -0.0130, 0.4166, -0.4525, -0.0929, -10000000000.0000, 1.1369, 0.0669, -0.3027, 0.0270, -10000000000.0000, -10000000000.0000, 0.7872, 0.2168, 0.3467, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1768, -0.2927, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.8671, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000}
	*lda = 6
	*xx = []float32{0.9965, -10000000000.0000, 0.3272, -10000000000.0000, 0.3571, -10000000000.0000, 0.0000, -10000000000.0000, 0.6469, -10000000000.0000, 0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		Stbsv(uplo, trans, diag, n, k, aa, off, lda, xx, off, incx)
	}
}

func BenchmarkStpsv(b *testing.B) {
	var incmax int = 2
	var nmax int = 65
	off := new(int)
	*off = 0
	n := new(int)
	incx := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, 1.4965, -0.1728, -0.1429, -0.4126, 1.1469, -0.0230, -0.4925, 0.7373, -0.3327, 0.6274}
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		Stpsv(uplo, trans, diag, n, aa, off, xx, off, incx)
	}
}

func BenchmarkSger(b *testing.B) {
	var incmax int = 2
	var nmax int = 65
	off := new(int)
	*off = 0
	alpha := new(float32)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*m = 14
	*n = 9
	*alpha = 0.70
	*xx = []float32{0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.6868, -10000000000.0000, 0.0000, -10000000000.0000, 0.2473, -10000000000.0000, 0.0774, -10000000000.0000, 0.6069, -10000000000.0000, 0.7667, -10000000000.0000, 0.3971, -10000000000.0000, 0.7268, -10000000000.0000, 0.7567, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*yy = []float32{-0.0130, -10000000000.0000, -0.4525, -10000000000.0000, 0.3766, -10000000000.0000, 0.0000, -10000000000.0000, 0.1369, -10000000000.0000, 0.0669, -10000000000.0000, 0.0270, -10000000000.0000, 0.0569, -10000000000.0000, -0.2128, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	*aa = []float32{0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -10000000000.0000, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, -10000000000.0000, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -0.0929, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.3467, 0.1768, -0.2927, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -0.3327, 0.2967, -10000000000.0000, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, -10000000000.0000, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, -10000000000.0000, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, -10000000000.0000}
	*lda = 15

	for i := 0; i < b.N; i++ {
		Sger(m, n, alpha, xx, off, incx, yy, off, incy, aa, off, lda)
	}
}

func BenchmarkSsyr(b *testing.B) {
	var incmax int = 2
	var nmax int = 65
	off := new(int)
	*off = 0
	alpha := new(float32)
	n := new(int)
	incx := new(int)
	lda := new(int)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float32{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*aa = []float32{0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.3726, -0.3427, 0.3866, -0.1828, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0529, 0.3067, -0.4625, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4665, 0.0969, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4266, -10000000000.0000}
	*lda = 10

	for i := 0; i < b.N; i++ {
		Ssyr(uplo, n, alpha, xx, off, incx, aa, off, lda)
	}
}

func BenchmarkSspr(b *testing.B) {
	var incmax int = 2
	var nmax int = 65
	off := new(int)
	*off = 0
	alpha := new(float32)
	n := new(int)
	incx := new(int)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float32{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*aa = []float32{0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266}

	for i := 0; i < b.N; i++ {
		Sspr(uplo, n, alpha, xx, off, incx, aa, off)
	}
}

func BenchmarkSsyr2(b *testing.B) {
	var incmax int = 2
	var nmax int = 65
	off := new(int)
	*off = 0
	alpha := new(float32)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float32{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*yy = []float32{0.4665, -10000000000.0000, 0.0969, -10000000000.0000, 0.4266, -10000000000.0000, 0.0000, -10000000000.0000, 0.1868, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.3367, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	*aa = []float32{0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, -10000000000.0000, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4266, 0.1868, -0.3826, -0.2527, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.4226, 0.1069, 0.2667, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1029, 0.2268, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2567, -10000000000.0000}
	*lda = 10

	for i := 0; i < b.N; i++ {
		Ssyr2(uplo, n, alpha, xx, off, incx, yy, off, incy, aa, off, lda)
	}
}

func BenchmarkSspr2(b *testing.B) {
	var incmax int = 2
	var nmax int = 65
	off := new(int)
	*off = 0
	alpha := new(float32)
	n := new(int)
	incx := new(int)
	incy := new(int)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float32{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*yy = []float32{0.4665, -10000000000.0000, 0.0969, -10000000000.0000, 0.4266, -10000000000.0000, 0.0000, -10000000000.0000, 0.1868, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.3367, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	*aa = []float32{0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266}

	for i := 0; i < b.N; i++ {
		Sspr2(uplo, n, alpha, xx, off, incx, yy, off, incy, aa, off)
	}
}

func BenchmarkSgemm(b *testing.B) {
	var nmax int = 65
	off := new(int)
	*off = 0
	alpha := new(float32)
	beta := new(float32)
	k := new(int)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	transa := new(byte)
	transb := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	cc := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*transa = 'C'
	*transb = 'C'
	*m = 9
	*n = 9
	*k = 9
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*lda = 10
	*bb = []float32{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, -10000000000.0000, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0270, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -10000000000.0000, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -10000000000.0000}
	*ldb = 10
	*beta = 1.30
	*cc = []float32{-0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -10000000000.0000, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.1369, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -10000000000.0000, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, -10000000000.0000, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, -10000000000.0000, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -0.0929, -10000000000.0000, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -0.2927, -0.0629, -10000000000.0000}
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Sgemm(transa, transb, m, n, k, alpha, aa, off, lda, bb, off, ldb, beta, cc, off, ldc)
	}
}

func BenchmarkSsymm(b *testing.B) {
	var nmax int = 65
	off := new(int)
	*off = 0
	alpha := new(float32)
	beta := new(float32)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	side := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	cc := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*side = 'R'
	*uplo = 'L'
	*m = 9
	*n = 9
	*alpha = 0.70
	*aa = []float32{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2527, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4166, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2927, -0.0629, -0.1329, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1429, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -10000000000.0000}
	*lda = 10
	*bb = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*ldb = 10
	*beta = 1.30
	*cc = []float32{-0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.3467, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -10000000000.0000, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -10000000000.0000, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, -10000000000.0000, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -10000000000.0000}
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Ssymm(side, uplo, m, n, alpha, aa, off, lda, bb, off, ldb, beta, cc, off, ldc)
	}
}

func BenchmarkStrmm(b *testing.B) {
	var nmax int = 65
	off := new(int)
	*off = 0
	alpha := new(float32)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'N'
	*m = 9
	*n = 9
	*alpha = 0.70
	*aa = []float32{1.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -10000000000.0000, 0.7772, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7473, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4166, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.0270, 0.0569, -0.2128, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7073, -0.0629, -0.1329, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.8571, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -10000000000.0000}
	*lda = 10
	*bb = []float32{-0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.3467, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -10000000000.0000, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -10000000000.0000, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, -10000000000.0000, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -10000000000.0000}
	*ldb = 10

	for i := 0; i < b.N; i++ {
		Strmm(side, uplo, transa, diag, m, n, alpha, aa, off, lda, bb, off, ldb)
	}
}

func BenchmarkStrsm(b *testing.B) {
	var nmax int = 65
	off := new(int)
	*off = 0
	alpha := new(float32)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'N'
	*m = 9
	*n = 9
	*alpha = 0.70
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.9071, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.6274, -10000000000.0000}
	*lda = 10
	*bb = []float32{-0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.0000, 0.0000, 0.0000, -0.0629, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, -10000000000.0000, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, -0.0929, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -0.2927, -10000000000.0000, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -10000000000.0000}
	*ldb = 10

	for i := 0; i < b.N; i++ {
		Strsm(side, uplo, transa, diag, m, n, alpha, aa, off, lda, bb, off, ldb)
	}
}

func BenchmarkSsyrk(b *testing.B) {
	var nmax int = 65
	off := new(int)
	*off = 0
	alpha := new(float32)
	beta := new(float32)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	cc := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*lda = 10
	*beta = 1.30
	*cc = []float32{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2527, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4166, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2927, -0.0629, -0.1329, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1429, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -10000000000.0000}
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Ssyrk(uplo, trans, n, k, alpha, aa, off, lda, beta, cc, off, ldc)
	}
}

func BenchmarkSsyr2k(b *testing.B) {
	var nmax int = 65
	off := new(int)
	*off = 0
	alpha := new(float32)
	beta := new(float32)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	cc := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*lda = 10
	*bb = []float32{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, -10000000000.0000, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0270, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -10000000000.0000, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -10000000000.0000}
	*ldb = 10
	*beta = 1.30
	*cc = []float32{-0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2268, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1329, 0.4965, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -10000000000.0000}
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Ssyr2k(uplo, trans, n, k, alpha, aa, off, lda, bb, off, ldb, beta, cc, off, ldc)
	}
}
