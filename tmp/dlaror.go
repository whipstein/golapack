package goblas

import (
	"github.com/whipstein/golapack/blas"
)

// Dlaror pre- or post-multiplies an M by N matrix A by a random
// orthogonal matrix U, overwriting A.  A may optionally be initialized
// to the identity matrix before multiplying by U.  U is generated using
// the method of G.W. Stewart (SIAM J. Numer. Anal. 17, 1980, 403-409).
//
//  =========== DOCUMENTATION ===========
//
// Online html documentation available at
//            http://www.netlib.org/lapack/explore-html/
//
//  Definition:
//  ===========
//
//       SUBROUTinE Dlaror( side, init, m, n, a, lda, iseed, x, info)
//
//       .. Scalar Arguments ..
//       CHARACTER          init, side
//       intEGER            info, lda, m, N
//       ..
//       .. Array Arguments ..
//       intEGER            iseed( 4)
//       DOUBLE PRECISION   a( lda, *), X(*)
//       ..
//
//
// \par Purpose:
//  =============
//
// \verbatim
//
// Dlaror pre- or post-multiplies an M by N matrix A by a random
// orthogonal matrix U, overwriting A.  A may optionally be initialized
// to the identity matrix before multiplying by U.  U is generated using
// the method of G.W. Stewart (SIAM J. Numer. Anal. 17, 1980, 403-409).
// \endverbatim
//
//  Arguments:
//  ==========
//
// \param[in] side
// \verbatim
//          side is CHARACTER*1
//          Specifies whether A is multiplied on the left or right by U.
//          = 'L':         Multiply A on the left (premultiply) by U
//          = 'R':         Multiply A on the right (postmultiply) by U'
//          = 'C' or 'T':  Multiply A on the left by U and the right
//                          by U' (Here, U' means U-transpose.)
// \endverbatim
//
// \param[in] init
// \verbatim
//          init is CHARACTER*1
//          Specifies whether or not A should be initialized to the
//          identity matrix.
//          = 'I':  Initialize A to (a section of) the identity matrix
//                   before applying U.
//          = 'N':  No initialization.  Apply U to the input matrix A.
//
//          init = 'I' may be used to generate square or rectangular
//          orthogonal matrices:
//
//          For M = N and side = 'L' or 'R', the rows will be orthogonal
//          to each other, as will the columns.
//
//          If M < n, side = 'R' produces a dense matrix whose rows are
//          orthogonal and whose columns are not, while side = 'L'
//          produces a matrix whose rows are orthogonal, and whose first
//          M columns are orthogonal, and whose remaining columns are
//          zero.
//
//          If M > n, side = 'L' produces a dense matrix whose columns
//          are orthogonal and whose rows are not, while side = 'R'
//          produces a matrix whose columns are orthogonal, and whose
//          first M rows are orthogonal, and whose remaining rows are
//          zero.
// \endverbatim
//
// \param[in] M
// \verbatim
//          M is intEGER
//          The number of rows of A.
// \endverbatim
//
// \param[in] N
// \verbatim
//          N is intEGER
//          The number of columns of A.
// \endverbatim
//
// \param[in,out] A
// \verbatim
//          A is DOUBLE PRECISION array, dimension (lda, N)
//          On entry, the array A.
//          On exit, overwritten by U A ( if side = 'L'),
//           or by A U ( if side = 'R'),
//           or by U A U' ( if side = 'C' or 'T').
// \endverbatim
//
// \param[in] lda
// \verbatim
//          lda is intEGER
//          The leading dimension of the array A.  lda >= max(1,M).
// \endverbatim
//
// \param[in,out] iseed
// \verbatim
//          iseed is intEGER array, dimension (4)
//          On entry iseed specifies the seed of the random number
//          generator. The array elements should be between 0 and 4095;
//          if not they will be reduced mod 4096.  Also, iseed(4) must
//          be odd.  The random number generator uses a linear
//          congruential sequence limited to small integers, and so
//          should produce machine independent random numbers. The
//          values of iseed are changed on exit, and can be used in the
//          next call to Dlaror to continue the same random number
//          sequence.
// \endverbatim
//
// \param[out] X
// \verbatim
//          X is DOUBLE PRECISION array, dimension (3*MAX( m, N))
//          workspace of length
//              2*m + N if side = 'L',
//              2*n + M if side = 'R',
//              3*n     if side = 'C' or 'T'.
// \endverbatim
//
// \param[out] info
// \verbatim
//          info is intEGER
//          An error flag.  It is set to:
//          = 0:  normal return
//          < 0:  if info = -k, the k-th argument had an illegal value
//          = 1:  if the random numbers generated by Dlarnd are bad.
// \endverbatim
//
//  Authors:
//  ========
//
// \author Univ. of Tennessee
// \author Univ. of California Berkeley
// \author Univ. of Colorado Denver
// \author NAG Ltd.
//
// \date December 2016
//
// \ingroup double_matgen
//
//  =====================================================================
func Dlaror(side *byte, init *byte, m *int, n *int, a *[][]float64, lda *int, iseed *[]int, x *[]float64, info *int) {
	zero := new(float64)
	one := new(float64)
	toosml := new(float64)
	irow := new(int)
	itype := new(int)
	ixfrm := new(int)
	j := new(int)
	jcol := new(int)
	kbeg := new(int)
	nxfrm := new(int)
	factor := new(float64)
	xnorm := new(float64)
	xnorms := new(float64)
	//
	//  -- lapACK auxiliary routine (version 3.7.0) --
	//  -- lapACK is a software package provided by Univ. of Tennessee,    --
	//  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
	//     December 2016
	//
	//     .. Scalar Arguments ..
	//     ..
	//     .. Array Arguments ..
	//     ..
	//
	//  =====================================================================
	//
	//     .. Parameters ..
	(*zero) = 0.0e+0
	(*one) = 1.0e+0
	(*toosml) = 1.0e-20
	//     ..
	//     .. Local Scalars ..
	//     ..
	//     .. External Functions ..
	//     ..
	//     .. External Subroutines ..
	//     ..
	//     .. Intrinsic Functions ..
	//     ..
	//     .. Executable Statements ..
	//
	(*(info)) = 0
	if (*(n)) == 0 || (*(m)) == 0 {
		return
	}
	//
	(*itype) = 0
	if blas.Lsame((side), func() *byte {y := byte('L'); return &y }()) {
		(*itype) = 1
	} else if blas.Lsame((side), func() *byte {y := byte('R'); return &y }()) {
		(*itype) = 2
	} else if (*blas.Lsame((side), func() *byte {y := byte('C'); return &y }())) || (*blas.Lsame((side), func() *byte {y := byte('T'); return &y }())) {
		(*itype) = 3
	}
	//
	//     Check for argument errors.
	//
	if (*itype) == 0 {
		(*(info)) = -1
	} else if (*(m)) < 0 {
		(*(info)) = -3
	} else if (*(n)) < 0 || ((*itype) == 3 && (*(n)) != (*(m))) {
		(*(info)) = -4
	} else if (*(lda)) < (*(m)) {
		(*(info)) = -6
	}
	if (*(info)) != 0 {
		Xerbla(func() *[]byte {y := []byte("Dlaror"); return &y }(), -(*(info)))
		return
	}
	//
	if (*itype) == 1 {
		(*nxfrm) = (*(m))
	} else {
		(*nxfrm) = (*(n))
	}
	//
	//     Initialize A to the identity matrix if desired
	//
	if blas.Lsame((init), func() *byte {y := byte('I'); return &y }()) {
		Dlaset(func() *[]byte {y := []byte("Full"); return &y }(), (m), (n), zero, one, (a), (lda))
	}
	//
	//     If no rotation possible, multiply by random +/-1
	//
	//     Compute rotation by computing Householder transformations
	//     H(2), H(3), ..., H(nhouse)
	//
	for (*j) = 1; (*j) <= (*nxfrm); (*j)++ {
		(*(x))[(*j)-1] = (*zero)
		//Label10:
	}
	//
	for (*ixfrm) = 2; (*ixfrm) <= (*nxfrm); (*ixfrm)++ {
		(*kbeg) = (*nxfrm) - (*ixfrm) + 1
		//
		//        Generate independent normal( 0, 1) random numbers
		//
		for (*j) = (*kbeg); (*j) <= (*nxfrm); (*j)++ {
			(*(x))[(*j)-1] = (*Dlarnd(func() *int {y := 3; return &y }(), (iseed)))
			//Label20:
		}
		//
		//        Generate a Householder transformation from the random vector X
		//
		(*xnorm) = (*Dnrm2(ixfrm, &((*(x))[(*kbeg)-1]), func() *int {y := 1; return &y }()))
		(*xnorms) = (*SIGN(xnorm, &((*(x))[(*kbeg)-1])))
		(*(x))[(*kbeg)+(*nxfrm)-1] = (*SIGN(one, -(*(x))[(*kbeg)-1]))
		(*factor) = (*xnorms) * ((*xnorms) + (*(x))[(*kbeg)-1])
		if (ABS((*factor))) < (*toosml) {
			(*(info)) = 1
			Xerbla(func() *[]byte {y := []byte("Dlaror"); return &y }(), (info))
			return
		} else {
			(*factor) = (*one) / (*factor)
		}
		(*(x))[(*kbeg)-1] = (*(x))[(*kbeg)-1] + (*xnorms)
		//
		//        Apply Householder transformation to A
		//
		if (*itype) == 1 || (*itype) == 3 {
			//
			//           Apply H(k) from the left.
			//
			Dgemv(func() *byte {y := byte('T'); return &y }(), ixfrm, (n), one, &((*(a))[(*kbeg)-1][0]), (lda), &((*(x))[(*kbeg)-1]), func() *int {y := 1; return &y }(), zero, &((*(x))[2*(*nxfrm)+0]), func() *int {y := 1; return &y }())
			Dger(ixfrm, (n), -(*factor), &((*(x))[(*kbeg)-1]), func() *int {y := 1; return &y }(), &((*(x))[2*(*nxfrm)+0]), func() *int {y := 1; return &y }(), &((*(a))[(*kbeg)-1][0]), (lda))
			//
		}
		//
		if (*itype) == 2 || (*itype) == 3 {
			//
			//           Apply H(k) from the right.
			//
			Dgemv(func() *byte {y := byte('N'); return &y }(), (m), ixfrm, one, &((*(a))[0][(*kbeg)-1]), (lda), &((*(x))[(*kbeg)-1]), func() *int {y := 1; return &y }(), zero, &((*(x))[2*(*nxfrm)+0]), func() *int {y := 1; return &y }())
			Dger((m), ixfrm, -(*factor), &((*(x))[2*(*nxfrm)+0]), func() *int {y := 1; return &y }(), &((*(x))[(*kbeg)-1]), func() *int {y := 1; return &y }(), &((*(a))[0][(*kbeg)-1]), (lda))
			//
		}
		//Label30:
	}
	//
	(*(x))[2*(*nxfrm)-1] = (*SIGN(one, Dlarnd(func() *int {y := 3; return &y }(), (iseed))))
	//
	//     Scale the matrix A by D.
	//
	if (*itype) == 1 || (*itype) == 3 {
		for (*irow) = 1; (*irow) <= (*(m)); (*irow)++ {
			Dscal((n), &((*(x))[(*nxfrm)+(*irow)-1]), &((*(a))[(*irow)-1][0]), (lda))
			//Label40:
		}
	}
	//
	if (*itype) == 2 || (*itype) == 3 {
		for (*jcOL) = 1; (*jcOL) <= (*(n)); (*jcOL)++ {
			Dscal((m), &((*(x))[(*nxfrm)+(*jcOL)-1]), &((*(a))[0][(*jcOL)-1]), func() *int {y := 1; return &y }())
			//Label50:
		}
	}
	return
	//
	//     End of Dlaror
	//
}
