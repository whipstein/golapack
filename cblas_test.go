package golapack

import (
	"testing"
)

func TestCblasLevel1(t *testing.T) {
	var sfac float32 = 9.765625e-4
	var ifive int = 5
	var incx int
	var incy int
	var n int
	var off int
	var snames []string = []string{
		"Cdotc",
		"Cdotu",
		"Caxpy",
		"Ccopy",
		"Cswap",
		"Scnrm2",
		"Scasum",
		"Cscal",
		"Csscal",
		"Icamax",
	}

	for _, sname := range snames {
		if sname == "Scnrm2" || sname == "Scasum" || sname == "Cscal" || sname == "Csscal" {
			var i, len, nc, np1 int
			var sa float32 = 0.3
			var sb float32 = 0.0
			var ca complex64 = complex(0.4, -0.7)
			var cb complex64 = complex(0, 0)
			cx := make([]complex64, 8+50)
			mwpcs := make([]complex64, 5)
			mwpct := make([]complex64, 5)
			strue2 := make([]float32, 5)
			strue4 := make([]float32, 5)
			itrue3 := make([]int, 5)
			ctrue5 := make([]complex64, 8*5*2)
			ctrue6 := make([]complex64, 8*5*2)
			cv := make([]complex64, 8*5*2)

			cv[0+(0+(0)*5)*8], cv[1+(0+(0)*5)*8], cv[2+(0+(0)*5)*8], cv[3+(0+(0)*5)*8], cv[4+(0+(0)*5)*8], cv[5+(0+(0)*5)*8], cv[6+(0+(0)*5)*8], cv[7+(0+(0)*5)*8], cv[0+(1+(0)*5)*8], cv[1+(1+(0)*5)*8], cv[2+(1+(0)*5)*8], cv[3+(1+(0)*5)*8], cv[4+(1+(0)*5)*8], cv[5+(1+(0)*5)*8], cv[6+(1+(0)*5)*8], cv[7+(1+(0)*5)*8], cv[0+(2+(0)*5)*8], cv[1+(2+(0)*5)*8], cv[2+(2+(0)*5)*8], cv[3+(2+(0)*5)*8], cv[4+(2+(0)*5)*8], cv[5+(2+(0)*5)*8], cv[6+(2+(0)*5)*8], cv[7+(2+(0)*5)*8], cv[0+(3+(0)*5)*8], cv[1+(3+(0)*5)*8], cv[2+(3+(0)*5)*8], cv[3+(3+(0)*5)*8], cv[4+(3+(0)*5)*8], cv[5+(3+(0)*5)*8], cv[6+(3+(0)*5)*8], cv[7+(3+(0)*5)*8], cv[0+(4+(0)*5)*8], cv[1+(4+(0)*5)*8], cv[2+(4+(0)*5)*8], cv[3+(4+(0)*5)*8], cv[4+(4+(0)*5)*8], cv[5+(4+(0)*5)*8], cv[6+(4+(0)*5)*8], cv[7+(4+(0)*5)*8] = (0.1 + 0.1*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (0.3 + (-0.4)*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (0.1 + (-0.3)*1i), (0.5 + (-0.1)*1i), (5.0 + 6.0*1i), (5.0 + 6.0*1i), (5.0 + 6.0*1i), (5.0 + 6.0*1i), (5.0 + 6.0*1i), (5.0 + 6.0*1i), (0.1 + 0.1*1i), (-0.6 + 0.1*1i), (0.1 + (-0.3)*1i), (7.0 + 8.0*1i), (7.0 + 8.0*1i), (7.0 + 8.0*1i), (7.0 + 8.0*1i), (7.0 + 8.0*1i), (0.3 + 0.1*1i), (0.5 + 0.0*1i), (0.0 + 0.5*1i), (0.0 + 0.2*1i), (2.0 + 3.0*1i), (2.0 + 3.0*1i), (2.0 + 3.0*1i), (2.0 + 3.0*1i)
			cv[0+(0+(1)*5)*8], cv[1+(0+(1)*5)*8], cv[2+(0+(1)*5)*8], cv[3+(0+(1)*5)*8], cv[4+(0+(1)*5)*8], cv[5+(0+(1)*5)*8], cv[6+(0+(1)*5)*8], cv[7+(0+(1)*5)*8], cv[0+(1+(1)*5)*8], cv[1+(1+(1)*5)*8], cv[2+(1+(1)*5)*8], cv[3+(1+(1)*5)*8], cv[4+(1+(1)*5)*8], cv[5+(1+(1)*5)*8], cv[6+(1+(1)*5)*8], cv[7+(1+(1)*5)*8], cv[0+(2+(1)*5)*8], cv[1+(2+(1)*5)*8], cv[2+(2+(1)*5)*8], cv[3+(2+(1)*5)*8], cv[4+(2+(1)*5)*8], cv[5+(2+(1)*5)*8], cv[6+(2+(1)*5)*8], cv[7+(2+(1)*5)*8], cv[0+(3+(1)*5)*8], cv[1+(3+(1)*5)*8], cv[2+(3+(1)*5)*8], cv[3+(3+(1)*5)*8], cv[4+(3+(1)*5)*8], cv[5+(3+(1)*5)*8], cv[6+(3+(1)*5)*8], cv[7+(3+(1)*5)*8], cv[0+(4+(1)*5)*8], cv[1+(4+(1)*5)*8], cv[2+(4+(1)*5)*8], cv[3+(4+(1)*5)*8], cv[4+(4+(1)*5)*8], cv[5+(4+(1)*5)*8], cv[6+(4+(1)*5)*8], cv[7+(4+(1)*5)*8] = (0.1 + 0.1*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (0.3 + (-0.4)*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (0.1 + (-0.3)*1i), (8.0 + 9.0*1i), (0.5 + (-0.1)*1i), (2.0 + 5.0*1i), (2.0 + 5.0*1i), (2.0 + 5.0*1i), (2.0 + 5.0*1i), (2.0 + 5.0*1i), (0.1 + 0.1*1i), (3.0 + 6.0*1i), (-0.6 + 0.1*1i), (4.0 + 7.0*1i), (0.1 + (-0.3)*1i), (7.0 + 2.0*1i), (7.0 + 2.0*1i), (7.0 + 2.0*1i), (0.3 + 0.1*1i), (5.0 + 8.0*1i), (0.5 + 0.0*1i), (6.0 + 9.0*1i), (0.0 + 0.5*1i), (8.0 + 3.0*1i), (0.0 + 0.2*1i), (9.0 + 4.0*1i)
			strue2[0], strue2[1], strue2[2], strue2[3], strue2[4] = 0.0, 0.5, 0.6, 0.7, 0.8
			strue4[0], strue4[1], strue4[2], strue4[3], strue4[4] = 0.0, 0.7, 1.0, 1.3, 1.6
			ctrue5[0+(0+(0)*5)*8], ctrue5[1+(0+(0)*5)*8], ctrue5[2+(0+(0)*5)*8], ctrue5[3+(0+(0)*5)*8], ctrue5[4+(0+(0)*5)*8], ctrue5[5+(0+(0)*5)*8], ctrue5[6+(0+(0)*5)*8], ctrue5[7+(0+(0)*5)*8], ctrue5[0+(1+(0)*5)*8], ctrue5[1+(1+(0)*5)*8], ctrue5[2+(1+(0)*5)*8], ctrue5[3+(1+(0)*5)*8], ctrue5[4+(1+(0)*5)*8], ctrue5[5+(1+(0)*5)*8], ctrue5[6+(1+(0)*5)*8], ctrue5[7+(1+(0)*5)*8], ctrue5[0+(2+(0)*5)*8], ctrue5[1+(2+(0)*5)*8], ctrue5[2+(2+(0)*5)*8], ctrue5[3+(2+(0)*5)*8], ctrue5[4+(2+(0)*5)*8], ctrue5[5+(2+(0)*5)*8], ctrue5[6+(2+(0)*5)*8], ctrue5[7+(2+(0)*5)*8], ctrue5[0+(3+(0)*5)*8], ctrue5[1+(3+(0)*5)*8], ctrue5[2+(3+(0)*5)*8], ctrue5[3+(3+(0)*5)*8], ctrue5[4+(3+(0)*5)*8], ctrue5[5+(3+(0)*5)*8], ctrue5[6+(3+(0)*5)*8], ctrue5[7+(3+(0)*5)*8], ctrue5[0+(4+(0)*5)*8], ctrue5[1+(4+(0)*5)*8], ctrue5[2+(4+(0)*5)*8], ctrue5[3+(4+(0)*5)*8], ctrue5[4+(4+(0)*5)*8], ctrue5[5+(4+(0)*5)*8], ctrue5[6+(4+(0)*5)*8], ctrue5[7+(4+(0)*5)*8] = (0.1 + 0.1*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (-0.16 + (-0.37)*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (-0.17 + (-0.19)*1i), (0.13 + (-0.39)*1i), (5.0 + 6.0*1i), (5.0 + 6.0*1i), (5.0 + 6.0*1i), (5.0 + 6.0*1i), (5.0 + 6.0*1i), (5.0 + 6.0*1i), (0.11 + (-0.03)*1i), (-0.17 + 0.46*1i), (-0.17 + (-0.19)*1i), (7.0 + 8.0*1i), (7.0 + 8.0*1i), (7.0 + 8.0*1i), (7.0 + 8.0*1i), (7.0 + 8.0*1i), (0.19 + (-0.17)*1i), (0.20 + (-0.35)*1i), (0.35 + 0.20*1i), (0.14 + 0.08*1i), (2.0 + 3.0*1i), (2.0 + 3.0*1i), (2.0 + 3.0*1i), (2.0 + 3.0*1i)
			ctrue5[0+(0+(1)*5)*8], ctrue5[1+(0+(1)*5)*8], ctrue5[2+(0+(1)*5)*8], ctrue5[3+(0+(1)*5)*8], ctrue5[4+(0+(1)*5)*8], ctrue5[5+(0+(1)*5)*8], ctrue5[6+(0+(1)*5)*8], ctrue5[7+(0+(1)*5)*8], ctrue5[0+(1+(1)*5)*8], ctrue5[1+(1+(1)*5)*8], ctrue5[2+(1+(1)*5)*8], ctrue5[3+(1+(1)*5)*8], ctrue5[4+(1+(1)*5)*8], ctrue5[5+(1+(1)*5)*8], ctrue5[6+(1+(1)*5)*8], ctrue5[7+(1+(1)*5)*8], ctrue5[0+(2+(1)*5)*8], ctrue5[1+(2+(1)*5)*8], ctrue5[2+(2+(1)*5)*8], ctrue5[3+(2+(1)*5)*8], ctrue5[4+(2+(1)*5)*8], ctrue5[5+(2+(1)*5)*8], ctrue5[6+(2+(1)*5)*8], ctrue5[7+(2+(1)*5)*8], ctrue5[0+(3+(1)*5)*8], ctrue5[1+(3+(1)*5)*8], ctrue5[2+(3+(1)*5)*8], ctrue5[3+(3+(1)*5)*8], ctrue5[4+(3+(1)*5)*8], ctrue5[5+(3+(1)*5)*8], ctrue5[6+(3+(1)*5)*8], ctrue5[7+(3+(1)*5)*8], ctrue5[0+(4+(1)*5)*8], ctrue5[1+(4+(1)*5)*8], ctrue5[2+(4+(1)*5)*8], ctrue5[3+(4+(1)*5)*8], ctrue5[4+(4+(1)*5)*8], ctrue5[5+(4+(1)*5)*8], ctrue5[6+(4+(1)*5)*8], ctrue5[7+(4+(1)*5)*8] = (0.1 + 0.1*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (-0.16 + (-0.37)*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (-0.17 + (-0.19)*1i), (8.0 + 9.0*1i), (0.13 + (-0.39)*1i), (2.0 + 5.0*1i), (2.0 + 5.0*1i), (2.0 + 5.0*1i), (2.0 + 5.0*1i), (2.0 + 5.0*1i), (0.11 + (-0.03)*1i), (3.0 + 6.0*1i), (-0.17 + 0.46*1i), (4.0 + 7.0*1i), (-0.17 + (-0.19)*1i), (7.0 + 2.0*1i), (7.0 + 2.0*1i), (7.0 + 2.0*1i), (0.19 + (-0.17)*1i), (5.0 + 8.0*1i), (0.20 + (-0.35)*1i), (6.0 + 9.0*1i), (0.35 + 0.20*1i), (8.0 + 3.0*1i), (0.14 + 0.08*1i), (9.0 + 4.0*1i)
			ctrue6[0+(0+(0)*5)*8], ctrue6[1+(0+(0)*5)*8], ctrue6[2+(0+(0)*5)*8], ctrue6[3+(0+(0)*5)*8], ctrue6[4+(0+(0)*5)*8], ctrue6[5+(0+(0)*5)*8], ctrue6[6+(0+(0)*5)*8], ctrue6[7+(0+(0)*5)*8], ctrue6[0+(1+(0)*5)*8], ctrue6[1+(1+(0)*5)*8], ctrue6[2+(1+(0)*5)*8], ctrue6[3+(1+(0)*5)*8], ctrue6[4+(1+(0)*5)*8], ctrue6[5+(1+(0)*5)*8], ctrue6[6+(1+(0)*5)*8], ctrue6[7+(1+(0)*5)*8], ctrue6[0+(2+(0)*5)*8], ctrue6[1+(2+(0)*5)*8], ctrue6[2+(2+(0)*5)*8], ctrue6[3+(2+(0)*5)*8], ctrue6[4+(2+(0)*5)*8], ctrue6[5+(2+(0)*5)*8], ctrue6[6+(2+(0)*5)*8], ctrue6[7+(2+(0)*5)*8], ctrue6[0+(3+(0)*5)*8], ctrue6[1+(3+(0)*5)*8], ctrue6[2+(3+(0)*5)*8], ctrue6[3+(3+(0)*5)*8], ctrue6[4+(3+(0)*5)*8], ctrue6[5+(3+(0)*5)*8], ctrue6[6+(3+(0)*5)*8], ctrue6[7+(3+(0)*5)*8], ctrue6[0+(4+(0)*5)*8], ctrue6[1+(4+(0)*5)*8], ctrue6[2+(4+(0)*5)*8], ctrue6[3+(4+(0)*5)*8], ctrue6[4+(4+(0)*5)*8], ctrue6[5+(4+(0)*5)*8], ctrue6[6+(4+(0)*5)*8], ctrue6[7+(4+(0)*5)*8] = (0.1 + 0.1*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (1.0 + 2.0*1i), (0.09 + (-0.12)*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (3.0 + 4.0*1i), (0.03 + (-0.09)*1i), (0.15 + (-0.03)*1i), (5.0 + 6.0*1i), (5.0 + 6.0*1i), (5.0 + 6.0*1i), (5.0 + 6.0*1i), (5.0 + 6.0*1i), (5.0 + 6.0*1i), (0.03 + 0.03*1i), (-0.18 + 0.03*1i), (0.03 + (-0.09)*1i), (7.0 + 8.0*1i), (7.0 + 8.0*1i), (7.0 + 8.0*1i), (7.0 + 8.0*1i), (7.0 + 8.0*1i), (0.09 + 0.03*1i), (0.15 + 0.00*1i), (0.00 + 0.15*1i), (0.00 + 0.06*1i), (2.0 + 3.0*1i), (2.0 + 3.0*1i), (2.0 + 3.0*1i), (2.0 + 3.0*1i)
			ctrue6[0+(0+(1)*5)*8], ctrue6[1+(0+(1)*5)*8], ctrue6[2+(0+(1)*5)*8], ctrue6[3+(0+(1)*5)*8], ctrue6[4+(0+(1)*5)*8], ctrue6[5+(0+(1)*5)*8], ctrue6[6+(0+(1)*5)*8], ctrue6[7+(0+(1)*5)*8], ctrue6[0+(1+(1)*5)*8], ctrue6[1+(1+(1)*5)*8], ctrue6[2+(1+(1)*5)*8], ctrue6[3+(1+(1)*5)*8], ctrue6[4+(1+(1)*5)*8], ctrue6[5+(1+(1)*5)*8], ctrue6[6+(1+(1)*5)*8], ctrue6[7+(1+(1)*5)*8], ctrue6[0+(2+(1)*5)*8], ctrue6[1+(2+(1)*5)*8], ctrue6[2+(2+(1)*5)*8], ctrue6[3+(2+(1)*5)*8], ctrue6[4+(2+(1)*5)*8], ctrue6[5+(2+(1)*5)*8], ctrue6[6+(2+(1)*5)*8], ctrue6[7+(2+(1)*5)*8], ctrue6[0+(3+(1)*5)*8], ctrue6[1+(3+(1)*5)*8], ctrue6[2+(3+(1)*5)*8], ctrue6[3+(3+(1)*5)*8], ctrue6[4+(3+(1)*5)*8], ctrue6[5+(3+(1)*5)*8], ctrue6[6+(3+(1)*5)*8], ctrue6[7+(3+(1)*5)*8], ctrue6[0+(4+(1)*5)*8], ctrue6[1+(4+(1)*5)*8], ctrue6[2+(4+(1)*5)*8], ctrue6[3+(4+(1)*5)*8], ctrue6[4+(4+(1)*5)*8], ctrue6[5+(4+(1)*5)*8], ctrue6[6+(4+(1)*5)*8], ctrue6[7+(4+(1)*5)*8] = (0.1 + 0.1*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (4.0 + 5.0*1i), (0.09 + (-0.12)*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (6.0 + 7.0*1i), (0.03 + (-0.09)*1i), (8.0 + 9.0*1i), (0.15 + (-0.03)*1i), (2.0 + 5.0*1i), (2.0 + 5.0*1i), (2.0 + 5.0*1i), (2.0 + 5.0*1i), (2.0 + 5.0*1i), (0.03 + 0.03*1i), (3.0 + 6.0*1i), (-0.18 + 0.03*1i), (4.0 + 7.0*1i), (0.03 + (-0.09)*1i), (7.0 + 2.0*1i), (7.0 + 2.0*1i), (7.0 + 2.0*1i), (0.09 + 0.03*1i), (5.0 + 8.0*1i), (0.15 + 0.00*1i), (6.0 + 9.0*1i), (0.00 + 0.15*1i), (8.0 + 3.0*1i), (0.00 + 0.06*1i), (9.0 + 4.0*1i)
			itrue3[0], itrue3[1], itrue3[2], itrue3[3], itrue3[4] = 0, 1, 2, 2, 2

			for off = 0; off <= 25; off += 5 {
				for incx = 1; incx <= 2; incx++ {
					for np1 = 1; np1 <= 5; np1++ {
						n = np1 - 1
						len = 2 * maxint(n, 1)
						for i = 1; i <= len; i++ {
							cx[i-1+off] = cv[i-1+(np1-1+(incx-1)*5)*8]
						}

						nc++

						if sname == "Scnrm2" {
							scompare1(Scnrm2(&n, &cx, &off, &incx), strue2[np1-1], &strue2, np1-1, sfac, t, sname)
						} else if sname == "Scasum" {
							scompare1(Scasum(&n, &cx, &off, &incx), strue4[np1-1], &strue4, np1-1, sfac, t, sname)
						} else if sname == "Cscal" {
							Cscal(&n, &ca, &cx, &off, &incx)
							ccompare(len, &cx, off, &ctrue5, 0+(np1-1+(incx-1)*5)*8, &ctrue5, 0+(np1-1+(incx-1)*5)*8, sfac, t, sname)
							for i = 1; i <= 5; i++ {
								mwpct[i-1] = (0.0 + 0.0*1i)
								mwpcs[i-1] = (1.0 + 1.0*1i)
							}
							Cscal(&ifive, &cb, &cx, &off, &incx)
							ccompare(5, &cx, off, &mwpct, 0, &mwpcs, 0, sfac, t, sname)
						} else if sname == "Csscal" {
							Csscal(&n, &sa, &cx, &off, &incx)
							ccompare(len, &cx, off, &ctrue6, 0+(np1-1+(incx-1)*5)*8, &ctrue6, 0+(np1-1+(incx-1)*5)*8, sfac, t, sname)
							sb = 0.0
							for i = 1; i <= 5; i++ {
								mwpct[i-1] = (0.0 + 0.0*1i)
								mwpcs[i-1] = (1.0 + 1.0*1i)
							}
							Csscal(&ifive, &sb, &cx, &off, &incx)
							ccompare(5, &cx, off, &mwpct, 0, &mwpcs, 0, sfac, t, sname)
							//        Add a test for alpha equal to one.
							sb = 1.0
							for i = 1; i <= 5; i++ {
								mwpct[i-1] = cx[i-1]
								mwpcs[i-1] = cx[i-1]
							}
							Csscal(&ifive, &sb, &cx, &off, &incx)
							ccompare(5, &cx, off, &mwpct, 0, &mwpcs, 0, sfac, t, sname)
							//        Add a test for alpha equal to minus one.
							sb = -1.0
							for i = 1; i <= 5; i++ {
								mwpct[i-1] = -cx[i-1]
								mwpcs[i-1] = -cx[i-1]
							}
							Csscal(&ifive, &sb, &cx, &off, &incx)
							ccompare(5, &cx, off, &mwpct, 0, &mwpcs, 0, sfac, t, sname)
						} else if sname == "Icamax" {
							icompare1(Icamax(&n, &cx, &off, &incx), itrue3[np1-1], t, sname)
						}
					}
				}
			}

			t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)

		} else if sname == "Cdotc" || sname == "Cdotu" || sname == "Caxpy" || sname == "Ccopy" || sname == "Cswap" {
			var i, ki, kn, ksize, lenx, leny, mx, my, nc int
			var ca complex64 = complex(0.4, -0.7)
			cdot := make([]complex64, 1)
			csize1 := make([]complex64, 4)
			csize3 := make([]complex64, 14)
			cx := make([]complex64, 7+50)
			cx1 := make([]complex64, 7)
			cy := make([]complex64, 7+50)
			cy1 := make([]complex64, 7)
			incxs := make([]int, 4)
			incys := make([]int, 4)
			ns := make([]int, 4)
			csize2 := make([]complex64, 7*2)
			ct6 := make([]complex64, 4*4)
			ct7 := make([]complex64, 4*4)
			lens := make([]int, 4*2)
			ct10x := make([]complex64, 7*4*4)
			ct10y := make([]complex64, 7*4*4)
			ct8 := make([]complex64, 7*4*4)

			incxs[0], incxs[1], incxs[2], incxs[3] = 1, 2, -2, -1
			incys[0], incys[1], incys[2], incys[3] = 1, -2, 1, -2
			lens[0+(0)*4], lens[1+(0)*4], lens[2+(0)*4], lens[3+(0)*4], lens[0+(1)*4], lens[1+(1)*4], lens[2+(1)*4], lens[3+(1)*4] = 1, 1, 2, 4, 1, 1, 3, 7
			ns[0], ns[1], ns[2], ns[3] = 0, 1, 2, 4
			cx1[0], cx1[1], cx1[2], cx1[3], cx1[4], cx1[5], cx1[6] = (0.7 + (-0.8)*1i), (-0.4 + (-0.7)*1i), (-0.1 + (-0.9)*1i), (0.2 + (-0.8)*1i), (-0.9 + (-0.4)*1i), (0.1 + 0.4*1i), (-0.6 + 0.6*1i)
			cy1[0], cy1[1], cy1[2], cy1[3], cy1[4], cy1[5], cy1[6] = (0.6 + (-0.6)*1i), (-0.9 + 0.5*1i), (0.7 + (-0.6)*1i), (0.1 + (-0.5)*1i), (-0.1 + (-0.2)*1i), (-0.5 + (-0.3)*1i), (0.8 + (-0.7)*1i)
			ct8[0+(0+(0)*4)*7], ct8[1+(0+(0)*4)*7], ct8[2+(0+(0)*4)*7], ct8[3+(0+(0)*4)*7], ct8[4+(0+(0)*4)*7], ct8[5+(0+(0)*4)*7], ct8[6+(0+(0)*4)*7], ct8[0+(1+(0)*4)*7], ct8[1+(1+(0)*4)*7], ct8[2+(1+(0)*4)*7], ct8[3+(1+(0)*4)*7], ct8[4+(1+(0)*4)*7], ct8[5+(1+(0)*4)*7], ct8[6+(1+(0)*4)*7], ct8[0+(2+(0)*4)*7], ct8[1+(2+(0)*4)*7], ct8[2+(2+(0)*4)*7], ct8[3+(2+(0)*4)*7], ct8[4+(2+(0)*4)*7], ct8[5+(2+(0)*4)*7], ct8[6+(2+(0)*4)*7], ct8[0+(3+(0)*4)*7], ct8[1+(3+(0)*4)*7], ct8[2+(3+(0)*4)*7], ct8[3+(3+(0)*4)*7], ct8[4+(3+(0)*4)*7], ct8[5+(3+(0)*4)*7], ct8[6+(3+(0)*4)*7] = (0.6 + (-0.6)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.32 + (-1.41)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.32 + (-1.41)*1i), (-1.55 + 0.5*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.32 + (-1.41)*1i), (-1.55 + 0.5*1i), (0.03 + (-0.89)*1i), (-0.38 + (-0.96)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i)
			ct8[0+(0+(1)*4)*7], ct8[1+(0+(1)*4)*7], ct8[2+(0+(1)*4)*7], ct8[3+(0+(1)*4)*7], ct8[4+(0+(1)*4)*7], ct8[5+(0+(1)*4)*7], ct8[6+(0+(1)*4)*7], ct8[0+(1+(1)*4)*7], ct8[1+(1+(1)*4)*7], ct8[2+(1+(1)*4)*7], ct8[3+(1+(1)*4)*7], ct8[4+(1+(1)*4)*7], ct8[5+(1+(1)*4)*7], ct8[6+(1+(1)*4)*7], ct8[0+(2+(1)*4)*7], ct8[1+(2+(1)*4)*7], ct8[2+(2+(1)*4)*7], ct8[3+(2+(1)*4)*7], ct8[4+(2+(1)*4)*7], ct8[5+(2+(1)*4)*7], ct8[6+(2+(1)*4)*7], ct8[0+(3+(1)*4)*7], ct8[1+(3+(1)*4)*7], ct8[2+(3+(1)*4)*7], ct8[3+(3+(1)*4)*7], ct8[4+(3+(1)*4)*7], ct8[5+(3+(1)*4)*7], ct8[6+(3+(1)*4)*7] = (0.6 + (-0.6)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.32 + (-1.41)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (-0.07 + (-0.89)*1i), (-0.9 + 0.5*1i), (0.42 + (-1.41)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.78 + 0.06*1i), (-0.9 + 0.5*1i), (0.06 + (-0.13)*1i), (0.1 + (-0.5)*1i), (-0.77 + (-0.49)*1i), (-0.5 + (-0.3)*1i), (0.52 + (-1.51)*1i)
			ct8[0+(0+(2)*4)*7], ct8[1+(0+(2)*4)*7], ct8[2+(0+(2)*4)*7], ct8[3+(0+(2)*4)*7], ct8[4+(0+(2)*4)*7], ct8[5+(0+(2)*4)*7], ct8[6+(0+(2)*4)*7], ct8[0+(1+(2)*4)*7], ct8[1+(1+(2)*4)*7], ct8[2+(1+(2)*4)*7], ct8[3+(1+(2)*4)*7], ct8[4+(1+(2)*4)*7], ct8[5+(1+(2)*4)*7], ct8[6+(1+(2)*4)*7], ct8[0+(2+(2)*4)*7], ct8[1+(2+(2)*4)*7], ct8[2+(2+(2)*4)*7], ct8[3+(2+(2)*4)*7], ct8[4+(2+(2)*4)*7], ct8[5+(2+(2)*4)*7], ct8[6+(2+(2)*4)*7], ct8[0+(3+(2)*4)*7], ct8[1+(3+(2)*4)*7], ct8[2+(3+(2)*4)*7], ct8[3+(3+(2)*4)*7], ct8[4+(3+(2)*4)*7], ct8[5+(3+(2)*4)*7], ct8[6+(3+(2)*4)*7] = (0.6 + (-0.6)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.32 + (-1.41)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (-0.07 + (-0.89)*1i), (-1.18 + (-0.31)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.78 + 0.06*1i), (-1.54 + 0.97*1i), (0.03 + (-0.89)*1i), (-0.18 + (-1.31)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i)
			ct8[0+(0+(3)*4)*7], ct8[1+(0+(3)*4)*7], ct8[2+(0+(3)*4)*7], ct8[3+(0+(3)*4)*7], ct8[4+(0+(3)*4)*7], ct8[5+(0+(3)*4)*7], ct8[6+(0+(3)*4)*7], ct8[0+(1+(3)*4)*7], ct8[1+(1+(3)*4)*7], ct8[2+(1+(3)*4)*7], ct8[3+(1+(3)*4)*7], ct8[4+(1+(3)*4)*7], ct8[5+(1+(3)*4)*7], ct8[6+(1+(3)*4)*7], ct8[0+(2+(3)*4)*7], ct8[1+(2+(3)*4)*7], ct8[2+(2+(3)*4)*7], ct8[3+(2+(3)*4)*7], ct8[4+(2+(3)*4)*7], ct8[5+(2+(3)*4)*7], ct8[6+(2+(3)*4)*7], ct8[0+(3+(3)*4)*7], ct8[1+(3+(3)*4)*7], ct8[2+(3+(3)*4)*7], ct8[3+(3+(3)*4)*7], ct8[4+(3+(3)*4)*7], ct8[5+(3+(3)*4)*7], ct8[6+(3+(3)*4)*7] = (0.6 + (-0.6)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.32 + (-1.41)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.32 + (-1.41)*1i), (-0.9 + 0.5*1i), (0.05 + (-0.6)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.32 + (-1.41)*1i), (-0.9 + 0.5*1i), (0.05 + (-0.6)*1i), (0.1 + (-0.5)*1i), (-0.77 + (-0.49)*1i), (-0.5 + (-0.3)*1i), (0.32 + (-1.16)*1i)
			ct7[0+(0)*4], ct7[1+(0)*4], ct7[2+(0)*4], ct7[3+(0)*4], ct7[0+(1)*4], ct7[1+(1)*4], ct7[2+(1)*4], ct7[3+(1)*4], ct7[0+(2)*4], ct7[1+(2)*4], ct7[2+(2)*4], ct7[3+(2)*4], ct7[0+(3)*4], ct7[1+(3)*4], ct7[2+(3)*4], ct7[3+(3)*4] = (0.0 + 0.0*1i), (-0.06 + (-0.90)*1i), (0.65 + (-0.47)*1i), (-0.34 + (-1.22)*1i), (0.0 + 0.0*1i), (-0.06 + (-0.90)*1i), (-0.59 + (-1.46)*1i), (-1.04 + (-0.04)*1i), (0.0 + 0.0*1i), (-0.06 + (-0.90)*1i), (-0.83 + 0.59*1i), (0.07 + (-0.37)*1i), (0.0 + 0.0*1i), (-0.06 + (-0.90)*1i), (-0.76 + (-1.15)*1i), (-1.33 + (-1.82)*1i)
			ct6[0+(0)*4], ct6[1+(0)*4], ct6[2+(0)*4], ct6[3+(0)*4], ct6[0+(1)*4], ct6[1+(1)*4], ct6[2+(1)*4], ct6[3+(1)*4], ct6[0+(2)*4], ct6[1+(2)*4], ct6[2+(2)*4], ct6[3+(2)*4], ct6[0+(3)*4], ct6[1+(3)*4], ct6[2+(3)*4], ct6[3+(3)*4] = (0.0 + 0.0*1i), (0.90 + 0.06*1i), (0.91 + (-0.77)*1i), (1.80 + (-0.10)*1i), (0.0 + 0.0*1i), (0.90 + 0.06*1i), (1.45 + 0.74*1i), (0.20 + 0.90*1i), (0.0 + 0.0*1i), (0.90 + 0.06*1i), (-0.55 + 0.23*1i), (0.83 + (-0.39)*1i), (0.0 + 0.0*1i), (0.90 + 0.06*1i), (1.04 + 0.79*1i), (1.95 + 1.22*1i)
			ct10x[0+(0+(0)*4)*7], ct10x[1+(0+(0)*4)*7], ct10x[2+(0+(0)*4)*7], ct10x[3+(0+(0)*4)*7], ct10x[4+(0+(0)*4)*7], ct10x[5+(0+(0)*4)*7], ct10x[6+(0+(0)*4)*7], ct10x[0+(1+(0)*4)*7], ct10x[1+(1+(0)*4)*7], ct10x[2+(1+(0)*4)*7], ct10x[3+(1+(0)*4)*7], ct10x[4+(1+(0)*4)*7], ct10x[5+(1+(0)*4)*7], ct10x[6+(1+(0)*4)*7], ct10x[0+(2+(0)*4)*7], ct10x[1+(2+(0)*4)*7], ct10x[2+(2+(0)*4)*7], ct10x[3+(2+(0)*4)*7], ct10x[4+(2+(0)*4)*7], ct10x[5+(2+(0)*4)*7], ct10x[6+(2+(0)*4)*7], ct10x[0+(3+(0)*4)*7], ct10x[1+(3+(0)*4)*7], ct10x[2+(3+(0)*4)*7], ct10x[3+(3+(0)*4)*7], ct10x[4+(3+(0)*4)*7], ct10x[5+(3+(0)*4)*7], ct10x[6+(3+(0)*4)*7] = (0.7 + (-0.8)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.6 + (-0.6)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.6 + (-0.6)*1i), (-0.9 + 0.5*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.6 + (-0.6)*1i), (-0.9 + 0.5*1i), (0.7 + (-0.6)*1i), (0.1 + (-0.5)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i)
			ct10x[0+(0+(1)*4)*7], ct10x[1+(0+(1)*4)*7], ct10x[2+(0+(1)*4)*7], ct10x[3+(0+(1)*4)*7], ct10x[4+(0+(1)*4)*7], ct10x[5+(0+(1)*4)*7], ct10x[6+(0+(1)*4)*7], ct10x[0+(1+(1)*4)*7], ct10x[1+(1+(1)*4)*7], ct10x[2+(1+(1)*4)*7], ct10x[3+(1+(1)*4)*7], ct10x[4+(1+(1)*4)*7], ct10x[5+(1+(1)*4)*7], ct10x[6+(1+(1)*4)*7], ct10x[0+(2+(1)*4)*7], ct10x[1+(2+(1)*4)*7], ct10x[2+(2+(1)*4)*7], ct10x[3+(2+(1)*4)*7], ct10x[4+(2+(1)*4)*7], ct10x[5+(2+(1)*4)*7], ct10x[6+(2+(1)*4)*7], ct10x[0+(3+(1)*4)*7], ct10x[1+(3+(1)*4)*7], ct10x[2+(3+(1)*4)*7], ct10x[3+(3+(1)*4)*7], ct10x[4+(3+(1)*4)*7], ct10x[5+(3+(1)*4)*7], ct10x[6+(3+(1)*4)*7] = (0.7 + (-0.8)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.6 + (-0.6)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.7 + (-0.6)*1i), (-0.4 + (-0.7)*1i), (0.6 + (-0.6)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.8 + (-0.7)*1i), (-0.4 + (-0.7)*1i), (-0.1 + (-0.2)*1i), (0.2 + (-0.8)*1i), (0.7 + (-0.6)*1i), (0.1 + 0.4*1i), (0.6 + (-0.6)*1i)
			ct10x[0+(0+(2)*4)*7], ct10x[1+(0+(2)*4)*7], ct10x[2+(0+(2)*4)*7], ct10x[3+(0+(2)*4)*7], ct10x[4+(0+(2)*4)*7], ct10x[5+(0+(2)*4)*7], ct10x[6+(0+(2)*4)*7], ct10x[0+(1+(2)*4)*7], ct10x[1+(1+(2)*4)*7], ct10x[2+(1+(2)*4)*7], ct10x[3+(1+(2)*4)*7], ct10x[4+(1+(2)*4)*7], ct10x[5+(1+(2)*4)*7], ct10x[6+(1+(2)*4)*7], ct10x[0+(2+(2)*4)*7], ct10x[1+(2+(2)*4)*7], ct10x[2+(2+(2)*4)*7], ct10x[3+(2+(2)*4)*7], ct10x[4+(2+(2)*4)*7], ct10x[5+(2+(2)*4)*7], ct10x[6+(2+(2)*4)*7], ct10x[0+(3+(2)*4)*7], ct10x[1+(3+(2)*4)*7], ct10x[2+(3+(2)*4)*7], ct10x[3+(3+(2)*4)*7], ct10x[4+(3+(2)*4)*7], ct10x[5+(3+(2)*4)*7], ct10x[6+(3+(2)*4)*7] = (0.7 + (-0.8)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.6 + (-0.6)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (-0.9 + 0.5*1i), (-0.4 + (-0.7)*1i), (0.6 + (-0.6)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.1 + (-0.5)*1i), (-0.4 + (-0.7)*1i), (0.7 + (-0.6)*1i), (0.2 + (-0.8)*1i), (-0.9 + 0.5*1i), (0.1 + 0.4*1i), (0.6 + (-0.6)*1i)
			ct10x[0+(0+(3)*4)*7], ct10x[1+(0+(3)*4)*7], ct10x[2+(0+(3)*4)*7], ct10x[3+(0+(3)*4)*7], ct10x[4+(0+(3)*4)*7], ct10x[5+(0+(3)*4)*7], ct10x[6+(0+(3)*4)*7], ct10x[0+(1+(3)*4)*7], ct10x[1+(1+(3)*4)*7], ct10x[2+(1+(3)*4)*7], ct10x[3+(1+(3)*4)*7], ct10x[4+(1+(3)*4)*7], ct10x[5+(1+(3)*4)*7], ct10x[6+(1+(3)*4)*7], ct10x[0+(2+(3)*4)*7], ct10x[1+(2+(3)*4)*7], ct10x[2+(2+(3)*4)*7], ct10x[3+(2+(3)*4)*7], ct10x[4+(2+(3)*4)*7], ct10x[5+(2+(3)*4)*7], ct10x[6+(2+(3)*4)*7], ct10x[0+(3+(3)*4)*7], ct10x[1+(3+(3)*4)*7], ct10x[2+(3+(3)*4)*7], ct10x[3+(3+(3)*4)*7], ct10x[4+(3+(3)*4)*7], ct10x[5+(3+(3)*4)*7], ct10x[6+(3+(3)*4)*7] = (0.7 + (-0.8)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.6 + (-0.6)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.6 + (-0.6)*1i), (0.7 + (-0.6)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.6 + (-0.6)*1i), (0.7 + (-0.6)*1i), (-0.1 + (-0.2)*1i), (0.8 + (-0.7)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i)
			ct10y[0+(0+(0)*4)*7], ct10y[1+(0+(0)*4)*7], ct10y[2+(0+(0)*4)*7], ct10y[3+(0+(0)*4)*7], ct10y[4+(0+(0)*4)*7], ct10y[5+(0+(0)*4)*7], ct10y[6+(0+(0)*4)*7], ct10y[0+(1+(0)*4)*7], ct10y[1+(1+(0)*4)*7], ct10y[2+(1+(0)*4)*7], ct10y[3+(1+(0)*4)*7], ct10y[4+(1+(0)*4)*7], ct10y[5+(1+(0)*4)*7], ct10y[6+(1+(0)*4)*7], ct10y[0+(2+(0)*4)*7], ct10y[1+(2+(0)*4)*7], ct10y[2+(2+(0)*4)*7], ct10y[3+(2+(0)*4)*7], ct10y[4+(2+(0)*4)*7], ct10y[5+(2+(0)*4)*7], ct10y[6+(2+(0)*4)*7], ct10y[0+(3+(0)*4)*7], ct10y[1+(3+(0)*4)*7], ct10y[2+(3+(0)*4)*7], ct10y[3+(3+(0)*4)*7], ct10y[4+(3+(0)*4)*7], ct10y[5+(3+(0)*4)*7], ct10y[6+(3+(0)*4)*7] = (0.6 + (-0.6)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.7 + (-0.8)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.7 + (-0.8)*1i), (-0.4 + (-0.7)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.7 + (-0.8)*1i), (-0.4 + (-0.7)*1i), (-0.1 + (-0.9)*1i), (0.2 + (-0.8)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i)
			ct10y[0+(0+(1)*4)*7], ct10y[1+(0+(1)*4)*7], ct10y[2+(0+(1)*4)*7], ct10y[3+(0+(1)*4)*7], ct10y[4+(0+(1)*4)*7], ct10y[5+(0+(1)*4)*7], ct10y[6+(0+(1)*4)*7], ct10y[0+(1+(1)*4)*7], ct10y[1+(1+(1)*4)*7], ct10y[2+(1+(1)*4)*7], ct10y[3+(1+(1)*4)*7], ct10y[4+(1+(1)*4)*7], ct10y[5+(1+(1)*4)*7], ct10y[6+(1+(1)*4)*7], ct10y[0+(2+(1)*4)*7], ct10y[1+(2+(1)*4)*7], ct10y[2+(2+(1)*4)*7], ct10y[3+(2+(1)*4)*7], ct10y[4+(2+(1)*4)*7], ct10y[5+(2+(1)*4)*7], ct10y[6+(2+(1)*4)*7], ct10y[0+(3+(1)*4)*7], ct10y[1+(3+(1)*4)*7], ct10y[2+(3+(1)*4)*7], ct10y[3+(3+(1)*4)*7], ct10y[4+(3+(1)*4)*7], ct10y[5+(3+(1)*4)*7], ct10y[6+(3+(1)*4)*7] = (0.6 + (-0.6)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.7 + (-0.8)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (-0.1 + (-0.9)*1i), (-0.9 + 0.5*1i), (0.7 + (-0.8)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (-0.6 + 0.6*1i), (-0.9 + 0.5*1i), (-0.9 + (-0.4)*1i), (0.1 + (-0.5)*1i), (-0.1 + (-0.9)*1i), (-0.5 + (-0.3)*1i), (0.7 + (-0.8)*1i)
			ct10y[0+(0+(2)*4)*7], ct10y[1+(0+(2)*4)*7], ct10y[2+(0+(2)*4)*7], ct10y[3+(0+(2)*4)*7], ct10y[4+(0+(2)*4)*7], ct10y[5+(0+(2)*4)*7], ct10y[6+(0+(2)*4)*7], ct10y[0+(1+(2)*4)*7], ct10y[1+(1+(2)*4)*7], ct10y[2+(1+(2)*4)*7], ct10y[3+(1+(2)*4)*7], ct10y[4+(1+(2)*4)*7], ct10y[5+(1+(2)*4)*7], ct10y[6+(1+(2)*4)*7], ct10y[0+(2+(2)*4)*7], ct10y[1+(2+(2)*4)*7], ct10y[2+(2+(2)*4)*7], ct10y[3+(2+(2)*4)*7], ct10y[4+(2+(2)*4)*7], ct10y[5+(2+(2)*4)*7], ct10y[6+(2+(2)*4)*7], ct10y[0+(3+(2)*4)*7], ct10y[1+(3+(2)*4)*7], ct10y[2+(3+(2)*4)*7], ct10y[3+(3+(2)*4)*7], ct10y[4+(3+(2)*4)*7], ct10y[5+(3+(2)*4)*7], ct10y[6+(3+(2)*4)*7] = (0.6 + (-0.6)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.7 + (-0.8)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (-0.1 + (-0.9)*1i), (0.7 + (-0.8)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (-0.6 + 0.6*1i), (-0.9 + (-0.4)*1i), (-0.1 + (-0.9)*1i), (0.7 + (-0.8)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i)
			ct10y[0+(0+(3)*4)*7], ct10y[1+(0+(3)*4)*7], ct10y[2+(0+(3)*4)*7], ct10y[3+(0+(3)*4)*7], ct10y[4+(0+(3)*4)*7], ct10y[5+(0+(3)*4)*7], ct10y[6+(0+(3)*4)*7], ct10y[0+(1+(3)*4)*7], ct10y[1+(1+(3)*4)*7], ct10y[2+(1+(3)*4)*7], ct10y[3+(1+(3)*4)*7], ct10y[4+(1+(3)*4)*7], ct10y[5+(1+(3)*4)*7], ct10y[6+(1+(3)*4)*7], ct10y[0+(2+(3)*4)*7], ct10y[1+(2+(3)*4)*7], ct10y[2+(2+(3)*4)*7], ct10y[3+(2+(3)*4)*7], ct10y[4+(2+(3)*4)*7], ct10y[5+(2+(3)*4)*7], ct10y[6+(2+(3)*4)*7], ct10y[0+(3+(3)*4)*7], ct10y[1+(3+(3)*4)*7], ct10y[2+(3+(3)*4)*7], ct10y[3+(3+(3)*4)*7], ct10y[4+(3+(3)*4)*7], ct10y[5+(3+(3)*4)*7], ct10y[6+(3+(3)*4)*7] = (0.6 + (-0.6)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.7 + (-0.8)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.7 + (-0.8)*1i), (-0.9 + 0.5*1i), (-0.4 + (-0.7)*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.7 + (-0.8)*1i), (-0.9 + 0.5*1i), (-0.4 + (-0.7)*1i), (0.1 + (-0.5)*1i), (-0.1 + (-0.9)*1i), (-0.5 + (-0.3)*1i), (0.2 + (-0.8)*1i)
			csize1[0], csize1[1], csize1[2], csize1[3] = (0.0 + 0.0*1i), (0.9 + 0.9*1i), (1.63 + 1.73*1i), (2.90 + 2.78*1i)
			csize3[0], csize3[1], csize3[2], csize3[3], csize3[4], csize3[5], csize3[6], csize3[7], csize3[8], csize3[9], csize3[10], csize3[11], csize3[12], csize3[13] = (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (1.17 + 1.17*1i), (1.17 + 1.17*1i), (1.17 + 1.17*1i), (1.17 + 1.17*1i), (1.17 + 1.17*1i), (1.17 + 1.17*1i), (1.17 + 1.17*1i)
			csize2[0+(0)*7], csize2[1+(0)*7], csize2[2+(0)*7], csize2[3+(0)*7], csize2[4+(0)*7], csize2[5+(0)*7], csize2[6+(0)*7], csize2[0+(1)*7], csize2[1+(1)*7], csize2[2+(1)*7], csize2[3+(1)*7], csize2[4+(1)*7], csize2[5+(1)*7], csize2[6+(1)*7] = (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (0.0 + 0.0*1i), (1.54 + 1.54*1i), (1.54 + 1.54*1i), (1.54 + 1.54*1i), (1.54 + 1.54*1i), (1.54 + 1.54*1i), (1.54 + 1.54*1i), (1.54 + 1.54*1i)

			for off = 0; off <= 25; off += 5 {
				for ki = 1; ki <= 4; ki++ {
					incx = incxs[ki-1]
					incy = incys[ki-1]
					mx = absint(incx)
					my = absint(incy)

					for kn = 1; kn <= 4; kn++ {
						n = ns[kn-1]
						ksize = minint(int(2), kn)
						lenx = lens[kn-1+(mx-1)*4]
						leny = lens[kn-1+(my-1)*4]
						for i = 1; i <= 7; i++ {
							cx[i-1+off] = cx1[i-1]
							cy[i-1+off] = cy1[i-1]
						}

						nc++

						if sname == "Cdotc" {
							cdot[0] = Cdotc(&n, &cx, &off, &incx, &cy, &off, &incy)
							ccompare(1, &cdot, 0, &ct6, kn-1+(ki-1)*4, &csize1, kn-1, sfac, t, sname)
						} else if sname == "Cdotu" {
							cdot[0] = Cdotu(&n, &cx, &off, &incx, &cy, &off, &incy)
							ccompare(1, &cdot, 0, &ct7, kn-1+(ki-1)*4, &csize1, kn-1, sfac, t, sname)
						} else if sname == "Caxpy" {
							Caxpy(&n, &ca, &cx, &off, &incx, &cy, &off, &incy)
							ccompare(leny, &cy, off, &ct8, 0+(kn-1+(ki-1)*4)*7, &csize2, 0+(ksize-1)*7, sfac, t, sname)
						} else if sname == "Ccopy" {
							Ccopy(&n, &cx, &off, &incx, &cy, &off, &incy)
							ccompare(leny, &cy, off, &ct10y, 0+(kn-1+(ki-1)*4)*7, &csize2, 0, 1.0, t, sname)
						} else if sname == "Cswap" {
							Cswap(&n, &cx, &off, &incx, &cy, &off, &incy)
							ccompare(lenx, &cx, off, &ct10x, 0+(kn-1+(ki-1)*4)*7, &csize3, 0, 1.0, t, sname)
							ccompare(leny, &cy, off, &ct10y, 0+(kn-1+(ki-1)*4)*7, &csize3, 0, 1.0, t, sname)
						}
					}
				}
			}

			t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)

		} else {
			t.Logf(" %6s TEST NOT FOUND\n", sname)
		}
	}
}

func TestCblasLevel2(t *testing.T) {
	var fatal, null, reset, same, tran, upper bool
	var diag, diags, trans, transs, uplo, uplos byte
	var alpha, als, beta, bls, transl complex64
	var err, errmax, ralpha, rals float32
	var i, j, n int
	var ok bool = true
	var idim []int = []int{0, 1, 2, 3, 5, 9}
	var kb []int = []int{0, 1, 2, 4}
	var inc []int = []int{1, 2, -1, -2}
	var alf []complex64 = []complex64{complex(0.0, 0.0), complex(1.0, 0.0), complex(0.7, -0.9)}
	var bet []complex64 = []complex64{complex(0.0, 0.0), complex(1.0, 0.0), complex(1.3, -1.1)}
	var ralf []float32 = []float32{0.0, 1.0, 0.7}
	var thresh float32 = 16.0
	var eps float32 = epsilonf32()
	var rzero float32 = 0.0
	var zero complex64 = complex(0.0, 0.0)
	var half complex64 = complex(0.5, 0.0)
	var one complex64 = complex(1.0, 0.0)
	var nmax int = 65
	var incmax int = 2
	var inegone int = -1
	var izero int = 0
	var ione int = 1
	var itwo int = 2
	var snames []string = []string{"CGEMV", "CGBMV", "CHEMV", "CHBMV", "CHPMV", "CTRMV", "CTBMV", "CTPMV", "CTRSV", "CTBSV", "CTPSV", "CGERC", "CGERU", "CHER", "CHPR", "CHER2", "CHPR2"}
	isame := make([]bool, 13)
	var ichd []byte = []byte{'U', 'N'}
	var icht []byte = []byte{'N', 'T', 'C'}
	var ichu []byte = []byte{'U', 'L'}
	a := make([]complex64, nmax*nmax)
	aa := make([]complex64, nmax*nmax)
	as := make([]complex64, nmax*nmax)
	g := make([]float32, nmax)
	x := make([]complex64, nmax)
	xs := make([]complex64, nmax*incmax)
	xt := make([]complex64, nmax)
	xx := make([]complex64, nmax*incmax)
	y := make([]complex64, nmax)
	ys := make([]complex64, nmax*incmax)
	yt := make([]complex64, nmax)
	yy := make([]complex64, nmax*incmax)
	z := make([]complex64, 2*nmax)

	n = minint(int(32), nmax)
	for j = 1; j <= n; j++ {
		for i = 1; i <= n; i++ {
			a[i-1+(j-1)*nmax] = complex(float32(maxint(i-j+1, 0)), 0.0)
		}
		x[j-1] = complex(float32(j), 0.0)
		y[j-1] = zero
	}
	for j = 1; j <= n; j++ {
		yy[j-1] = complex(float32(j*((j+1)*j))/2-float32(((j+1)*j*(j-1)))/3, 0.0)
	}
	//     YY holds the exact result. On exit from SMVCH YT holds
	//     the result computed by SMVCH.
	trans = 'N'
	cmvch(trans, &n, &n, &one, &a, &izero, &nmax, &x, &izero, &ione, &zero, &y, &izero, &ione, &yt, &g, &yy, &izero, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lce(&yy, &yt, &izero, &n)
	if !same || err != rzero {
		t.Errorf(" ERROR IN CMVCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n CMVCH WAS CALLED WITH TRANS = %c AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", trans, same, err)
	}
	trans = 'T'
	cmvch(trans, &n, &n, &one, &a, &izero, &nmax, &x, &izero, &inegone, &zero, &y, &izero, &inegone, &yt, &g, &yy, &izero, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lce(&yy, &yt, &izero, &n)
	if !same || err != rzero {
		t.Errorf(" ERROR IN CMVCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n CMVCH WAS CALLED WITH TRANS = %c AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", trans, same, err)
	}
	for _, sname := range snames {
		if sname == "CGEMV" || sname == "CGBMV" {
			var aoff, i, im, incx, incxs, incy, incys, kl, kls, ku, kus, laa, lda, ldas, lx, ly, m, ml, ms, n, nargs, nc, nd, nl, ns, xoff, yoff int
			var full bool = sname[2] == 'E'
			var banded bool = sname[2] == 'B'

			ok = true
			if full {
				nargs = 11
			} else if banded {
				nargs = 13
			}

			nc = 0
			reset = true
			errmax = rzero

			for aoff = 0; aoff <= 20; aoff += 10 {
				for xoff = 0; xoff <= 20; xoff += 10 {
					for yoff = 0; yoff <= 20; yoff += 10 {
						for _, n = range idim {
							nd = n/2 + 1

							for im = 1; im <= 2; im++ {
								if im == 1 {
									m = maxint(n-nd, 0)
								}
								if im == 2 {
									m = minint(n+nd, nmax)
								}

								for _, ku = range kb {
									if banded {
										kl = maxint(ku-1, 0)
									} else {
										ku = n - 1
										kl = m - 1
									}
									//              Set LDA to 1 more than minimum value if room.
									if banded {
										lda = kl + ku + 1
									} else {
										lda = m
									}
									if lda < nmax {
										lda++
									}
									//              Skip tests if not enough room.
									if lda > nmax {
										goto label100
									}
									laa = lda * n
									null = n <= 0 || m <= 0
									//
									//              Generate the matrix A.
									//
									transl = zero
									cmakeL2(sname[1:3], ' ', ' ', &m, &n, &a, &nmax, &aa, &aoff, &lda, &kl, &ku, &reset, &transl)

									for _, trans = range []byte{'N', 'T', 'C'} {
										tran = trans == 'T' || trans == 'C'

										if tran {
											ml = n
											nl = m
										} else {
											ml = m
											nl = n
										}

										for _, incx = range inc {
											lx = absint(incx) * nl
											//
											//                    Generate the vector X.
											//
											transl = half
											cmakeL2("GE", ' ', ' ', &ione, &nl, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := nl - 1; return &y }(), &reset, &transl)
											if nl > 1 {
												x[nl/2-1+xoff] = zero
												xx[1+absint(incx)*(nl/2-1)-1+xoff] = zero
											}

											for _, incy = range inc {
												ly = absint(incy) * ml

												for _, alpha = range alf {

													for _, beta = range bet {
														//
														//                             Generate the vector Y.
														//
														transl = zero
														cmakeL2("GE", ' ', ' ', &ione, &ml, &y, &ione, &yy, &yoff, func() *int { y := absint(incy); return &y }(), &izero, func() *int { y := ml - 1; return &y }(), &reset, &transl)

														nc++
														//
														//                             Save every datum before calling the
														//                             subroutine.
														//
														transs = trans
														ms = m
														ns = n
														kls = kl
														kus = ku
														als = alpha
														for i = 1; i <= laa; i++ {
															as[i-1+aoff] = aa[i-1+aoff]
														}
														ldas = lda
														for i = 1; i <= lx; i++ {
															xs[i-1+xoff] = xx[i-1+xoff]
														}
														incxs = incx
														bls = beta
														for i = 1; i <= ly; i++ {
															ys[i-1+yoff] = yy[i-1+yoff]
														}
														incys = incy
														//
														//                             Call the subroutine.
														//
														if full {
															Cgemv(&trans, &m, &n, &alpha, &aa, &aoff, &lda, &xx, &xoff, &incx, &beta, &yy, &yoff, &incy)
														} else if banded {
															Cgbmv(&trans, &m, &n, &kl, &ku, &alpha, &aa, &aoff, &lda, &xx, &xoff, &incx, &beta, &yy, &yoff, &incy)
														}
														//
														//                             Check if error-exit was taken incorrectly.
														//
														if !ok {
															t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
															fatal = true
															goto label130
														}
														//
														//                             See what data changed inside subroutines.
														//
														isame[0] = trans == transs
														isame[1] = ms == m
														isame[2] = ns == n
														if full {
															isame[3] = als == alpha
															isame[4] = lce(&as, &aa, &aoff, &laa)
															isame[5] = ldas == lda
															isame[6] = lce(&xs, &xx, &xoff, &lx)
															isame[7] = incxs == incx
															isame[8] = bls == beta
															if null {
																isame[9] = lce(&ys, &yy, &yoff, &ly)
															} else {
																isame[9] = lceres("GE", ' ', &ione, &ml, &ys, &yy, &yoff, func() *int { y := absint(incy); return &y }())
															}
															isame[10] = incys == incy
														} else if banded {
															isame[3] = kls == kl
															isame[4] = kus == ku
															isame[5] = als == alpha
															isame[6] = lce(&as, &aa, &aoff, &laa)
															isame[7] = ldas == lda
															isame[8] = lce(&xs, &xx, &xoff, &lx)
															isame[9] = incxs == incx
															isame[10] = bls == beta
															if null {
																isame[11] = lce(&ys, &yy, &yoff, &ly)
															} else {
																isame[11] = lceres("GE", ' ', &ione, &ml, &ys, &yy, &yoff, func() *int { y := absint(incy); return &y }())
															}
															isame[12] = incys == incy
														}
														//
														//                             If data was incorrectly changed, report
														//                             and return.
														//
														same = true
														for i = 1; i <= nargs; i++ {
															same = same && isame[i-1]
															if !isame[i-1] {
																t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
															}
														}
														if !same {
															fatal = true
															goto label130
														}

														if !null {
															//
															//                                Check the result.
															//
															cmvch(trans, &m, &n, &alpha, &a, &aoff, &nmax, &x, &xoff, &incx, &beta, &y, &yoff, &incy, &yt, &g, &yy, &yoff, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
															errmax = maxf32(errmax, err)
															//                                If got really bad answer, report and
															//                                return.
															if fatal {
																goto label130
															}
														} else {
															//                                Avoid repeating tests with M.le.0 or
															//                                N.le.0.
															goto label110
														}

													}

												}

											}

										}

									}

								label100:
								}

							label110:
							}

						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label130:
			if full {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%3d,%4.1f, A,%3d,%3d, X,%2d,%2d,%4.1f, Y,%2d,%2d)         .\n", sname, nc, sname, trans, m, n, alpha, izero, lda, izero, incx, beta, izero, incy)
			} else if banded {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%3d,%3d,%3d,%4.1f, A,%3d,%3d, X,%2d,%2d,%4.1f, Y,%2d,%2d) .\n", sname, nc, sname, trans, m, n, kl, ku, alpha, izero, lda, izero, incx, beta, izero, incy)
			}

		} else if sname == "CHEMV" || sname == "CHBMV" || sname == "CHPMV" {
			var aoff, i, incx, incxs, incy, incys, k, ks, laa, lda, ldas, lx, ly, n, nargs, nc, ns, xoff, yoff int
			var full bool = sname[2] == 'E'
			var banded bool = sname[2] == 'B'
			var packed bool = sname[2] == 'P'

			//     Define the number of arguments.
			ok = true
			if full {
				nargs = 10
			} else if banded {
				nargs = 11
			} else if packed {
				nargs = 9
			}

			nc = 0
			reset = true
			errmax = rzero

			for aoff = 0; aoff <= 30; aoff += 10 {
				for xoff = 0; xoff <= 30; xoff += 10 {
					for yoff = 0; yoff <= 30; yoff += 10 {
						for _, n = range idim {

							for _, k = range kb {
								if !banded {
									k = n - 1
								}
								//           Set LDA to 1 more than minimum value if room.
								if banded {
									lda = k + 1
								} else {
									lda = n
								}
								if lda < nmax {
									lda++
								}
								//           Skip tests if not enough room.
								if lda > nmax {
									goto label1100
								}
								if packed {
									laa = (n * (n + 1)) / 2
								} else {
									laa = lda * n
								}
								null = n <= 0

								for _, uplo = range ichu {
									//
									//              Generate the matrix A.
									//
									transl = zero
									cmakeL2(sname[1:3], uplo, ' ', &n, &n, &a, &nmax, &aa, &aoff, &lda, &k, &k, &reset, &transl)
									//
									for _, incx = range inc {
										lx = absint(incx) * n
										//
										//                 Generate the vector X.
										//
										transl = half
										cmakeL2("GE", ' ', ' ', &ione, &n, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
										if n > 1 {
											x[n/2-1+xoff] = zero
											xx[1+absint(incx)*(n/2-1)-1+xoff] = zero
										}

										for _, incy = range inc {
											ly = absint(incy) * n

											for _, alpha = range alf {

												for _, beta = range bet {
													//
													//                          Generate the vector Y.
													//
													transl = zero
													cmakeL2("GE", ' ', ' ', &ione, &n, &y, &ione, &yy, &yoff, func() *int { y := absint(incy); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
													//
													nc++
													//
													//                          Save every datum before calling the
													//                          subroutine.
													//
													uplos = uplo
													ns = n
													ks = k
													als = alpha
													for i = 1; i <= laa; i++ {
														as[i-1+aoff] = aa[i-1+aoff]
													}
													ldas = lda
													for i = 1; i <= lx; i++ {
														xs[i-1+xoff] = xx[i-1+xoff]
													}
													incxs = incx
													bls = beta
													for i = 1; i <= ly; i++ {
														ys[i-1+yoff] = yy[i-1+yoff]
													}
													incys = incy
													//
													//                          Call the subroutine.
													//
													if full {
														Chemv(&uplo, &n, &alpha, &aa, &aoff, &lda, &xx, &xoff, &incx, &beta, &yy, &yoff, &incy)
													} else if banded {
														Chbmv(&uplo, &n, &k, &alpha, &aa, &aoff, &lda, &xx, &xoff, &incx, &beta, &yy, &yoff, &incy)
													} else if packed {
														Chpmv(&uplo, &n, &alpha, &aa, &aoff, &xx, &xoff, &incx, &beta, &yy, &yoff, &incy)
													}
													//
													//                          Check if error-exit was taken incorrectly.
													//
													if !ok {
														t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
														fatal = true
														goto label1120
													}
													//
													//                          See what data changed inside subroutines.
													//
													isame[0] = uplo == uplos
													isame[1] = ns == n
													if full {
														isame[2] = als == alpha
														isame[3] = lce(&as, &aa, &aoff, &laa)
														isame[4] = ldas == lda
														isame[5] = lce(&xs, &xx, &xoff, &lx)
														isame[6] = incxs == incx
														isame[7] = bls == beta
														if null {
															isame[8] = lce(&ys, &yy, &yoff, &ly)
														} else {
															isame[8] = lceres("GE", ' ', &ione, &n, &ys, &yy, &yoff, func() *int { y := absint(incy); return &y }())
														}
														isame[9] = incys == incy
													} else if banded {
														isame[2] = ks == k
														isame[3] = als == alpha
														isame[4] = lce(&as, &aa, &aoff, &laa)
														isame[5] = ldas == lda
														isame[6] = lce(&xs, &xx, &xoff, &lx)
														isame[7] = incxs == incx
														isame[8] = bls == beta
														if null {
															isame[9] = lce(&ys, &yy, &yoff, &ly)
														} else {
															isame[9] = lceres("GE", ' ', &ione, &n, &ys, &yy, &yoff, func() *int { y := absint(incy); return &y }())
														}
														isame[10] = incys == incy
													} else if packed {
														isame[2] = als == alpha
														isame[3] = lce(&as, &aa, &aoff, &laa)
														isame[4] = lce(&xs, &xx, &xoff, &lx)
														isame[5] = incxs == incx
														isame[6] = bls == beta
														if null {
															isame[7] = lce(&ys, &yy, &yoff, &ly)
														} else {
															isame[7] = lceres("GE", ' ', &ione, &n, &ys, &yy, &yoff, func() *int { y := absint(incy); return &y }())
														}
														isame[8] = incys == incy
													}
													//
													//                          If data was incorrectly changed, report and
													//                          return.
													//
													same = true
													for i = 1; i <= nargs; i++ {
														same = same && isame[i-1]
														if !isame[i-1] {
															t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
														}
													}
													if !same {
														fatal = true
														goto label1120
													}

													if !null {
														//
														//                             Check the result.
														//
														cmvch('N', &n, &n, &alpha, &a, &aoff, &nmax, &x, &xoff, &incx, &beta, &y, &yoff, &incy, &yt, &g, &yy, &yoff, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
														errmax = maxf32(errmax, err)
														//                             If got really bad answer, report and
														//                             return.
														if fatal {
															goto label1120
														}
													} else {
														//                             Avoid repeating tests with N.le.0
														goto label1110
													}

												}

											}

										}
									}

								}

							label1100:
							}

						label1110:
						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label1120:
			;
			if full {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, A,%3d,%3d, X,%2d,%2d,%4.1f, Y,%2d,%2d)             .\n", sname, nc, sname, uplo, n, alpha, aoff, lda, xoff, incx, beta, yoff, incy)
			} else if banded {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%3d,%4.1f, A,%3d,%3d, X,%2d,%2d,%4.1f, Y,%2d,%2d)         .\n", sname, nc, sname, uplo, n, k, alpha, aoff, lda, xoff, incx, beta, yoff, incy)
			} else if packed {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, AP,%3d, X,%2d,%2d,%4.1f, Y,%2d,%2d)                .\n", sname, nc, sname, uplo, n, alpha, aoff, xoff, incx, beta, yoff, incy)
			}

		} else if sname == "CTRMV" || sname == "CTBMV" || sname == "CTPMV" || sname == "CTRSV" || sname == "CTBSV" || sname == "CTPSV" {
			var aoff, i, incx, incxs, k, ks, laa, lda, ldas, lx, n, nargs, nc, ns, xoff int
			var full bool = sname[2] == 'R'
			var banded bool = sname[2] == 'B'
			var packed bool = sname[2] == 'P'

			//     Define the number of arguments.
			ok = true
			if full {
				nargs = 8
			} else if banded {
				nargs = 9
			} else if packed {
				nargs = 7
			}

			nc = 0
			reset = true
			errmax = rzero
			//     Set up zero vector for SMVCH.
			for i = 1; i <= nmax; i++ {
				z[i-1] = zero
			}

			for aoff = 0; aoff <= 30; aoff += 10 {
				for xoff = 0; xoff <= 30; xoff += 10 {
					for _, n = range idim {

						for _, k = range kb {
							if !banded {
								k = n - 1
							}
							//           Set LDA to 1 more than minimum value if room.
							if banded {
								lda = k + 1
							} else {
								lda = n
							}
							if lda < nmax {
								lda++
							}
							//           Skip tests if not enough room.
							if lda > nmax {
								goto label2100
							}
							if packed {
								laa = (n * (n + 1)) / 2
							} else {
								laa = lda * n
							}
							null = n <= 0

							for _, uplo = range ichu {

								for _, trans = range icht {

									for _, diag = range ichd {
										//
										//                    Generate the matrix A.
										//
										transl = zero
										cmakeL2(sname[1:3], uplo, diag, &n, &n, &a, &nmax, &aa, &aoff, &lda, &k, &k, &reset, &transl)

										for _, incx = range inc {
											lx = absint(incx) * n
											//
											//                       Generate the vector X.
											//
											transl = half
											cmakeL2("GE", ' ', ' ', &ione, &n, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
											if n > 1 {
												x[n/2-1+xoff] = zero
												xx[1+absint(incx)*(n/2-1)-1+xoff] = zero
											}

											nc++
											//
											//                       Save every datum before calling the subroutine.
											//
											uplos = uplo
											transs = trans
											diags = diag
											ns = n
											ks = k
											for i = 1; i <= laa; i++ {
												as[i-1+aoff] = aa[i-1+aoff]
											}
											ldas = lda
											for i = 1; i <= lx; i++ {
												xs[i-1+xoff] = xx[i-1+xoff]
											}
											incxs = incx
											//
											//                       Call the subroutine.
											//
											if sname[3:5] == "MV" {
												if full {
													Ctrmv(&uplo, &trans, &diag, &n, &aa, &aoff, &lda, &xx, &xoff, &incx)
												} else if banded {
													Ctbmv(&uplo, &trans, &diag, &n, &k, &aa, &aoff, &lda, &xx, &xoff, &incx)
												} else if packed {
													Ctpmv(&uplo, &trans, &diag, &n, &aa, &aoff, &xx, &xoff, &incx)
												}
											} else if sname[3:5] == "SV" {
												if full {
													Ctrsv(&uplo, &trans, &diag, &n, &aa, &aoff, &lda, &xx, &xoff, &incx)
												} else if banded {
													Ctbsv(&uplo, &trans, &diag, &n, &k, &aa, &aoff, &lda, &xx, &xoff, &incx)
												} else if packed {
													Ctpsv(&uplo, &trans, &diag, &n, &aa, &aoff, &xx, &xoff, &incx)
												}
											}
											//
											//                       Check if error-exit was taken incorrectly.
											//
											if !ok {
												t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
												fatal = true
												goto label2120
											}
											//
											//                       See what data changed inside subroutines.
											//
											isame[0] = uplo == uplos
											isame[1] = trans == transs
											isame[2] = diag == diags
											isame[3] = ns == n
											if full {
												isame[4] = lce(&as, &aa, &aoff, &laa)
												isame[5] = ldas == lda
												if null {
													isame[6] = lce(&xs, &xx, &xoff, &lx)
												} else {
													isame[6] = lceres("GE", ' ', &ione, &n, &xs, &xx, &xoff, func() *int { y := absint(incx); return &y }())
												}
												isame[7] = incxs == incx
											} else if banded {
												isame[4] = ks == k
												isame[5] = lce(&as, &aa, &aoff, &laa)
												isame[6] = ldas == lda
												if null {
													isame[7] = lce(&xs, &xx, &xoff, &lx)
												} else {
													isame[7] = lceres("GE", ' ', &ione, &n, &xs, &xx, &xoff, func() *int { y := absint(incx); return &y }())
												}
												isame[8] = incxs == incx
											} else if packed {
												isame[4] = lce(&as, &aa, &aoff, &laa)
												if null {
													isame[5] = lce(&xs, &xx, &xoff, &lx)
												} else {
													isame[5] = lceres("GE", ' ', &ione, &n, &xs, &xx, &xoff, func() *int { y := absint(incx); return &y }())
												}
												isame[6] = incxs == incx
											}
											//
											//                       If data was incorrectly changed, report and
											//                       return.
											//
											same = true
											for i = 1; i <= nargs; i++ {
												same = same && isame[i-1]
												if !isame[i-1] {
													t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
												}
											}
											if !same {
												fatal = true
												goto label2120
											}

											if !null {
												if sname[3:5] == "MV" {
													//
													//                             Check the result.
													//
													cmvch(trans, &n, &n, &one, &a, &aoff, &nmax, &x, &xoff, &incx, &zero, &z, &izero, &incx, &xt, &g, &xx, &xoff, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
												} else if sname[3:5] == "SV" {
													//
													//                             Compute approximation to original vector.
													//
													for i = 1; i <= n; i++ {
														z[i-1] = xx[1+(i-1)*absint(incx)-1+xoff]
														xx[1+(i-1)*absint(incx)-1+xoff] = x[i-1+xoff]
													}
													cmvch(trans, &n, &n, &one, &a, &aoff, &nmax, &z, &izero, &incx, &zero, &x, &xoff, &incx, &xt, &g, &xx, &xoff, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
												}
												errmax = maxf32(errmax, err)
												//                          If got really bad answer, report and return.
												if fatal {
													goto label2120
												}
											} else {
												//                          Avoid repeating tests with N.le.0.
												goto label2110
											}

										}

									}

								}

							}

						label2100:
						}

					label2110:
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label2120:
			;
			if full {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c','%c',%3d, A,%3d,%3d, X,%2d,%2d)                     .\n", sname, nc, sname, uplo, trans, diag, n, aoff, lda, xoff, incx)
			} else if banded {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c','%c',%3d,%3d, A,%3d,%3d, X,%2d,%2d)                 .\n", sname, nc, sname, uplo, trans, diag, n, k, aoff, lda, xoff, incx)
			} else if packed {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c','%c',%3d, AP,%3d, X,%2d,%2d)                        .\n", sname, nc, sname, uplo, trans, diag, n, aoff, xoff, incx)
			}

		} else if sname == "CGERC" || sname == "CGERU" {
			var aoff, i, im, incx, incxs, incy, incys, j, laa, lda, ldas, lx, ly, m, ms, n, nd, ns, xoff, yoff int
			w := make([]complex64, 1)
			var nargs int = 9
			var nc int = 0
			var conj bool = sname[4] == 'C'

			errmax = rzero
			ok = true
			for aoff = 0; aoff <= 30; aoff += 10 {
				for xoff = 0; xoff <= 30; xoff += 10 {
					for yoff = 0; yoff <= 30; yoff += 10 {
						for _, n = range idim {
							nd = n/2 + 1

							for im = 1; im <= 2; im++ {
								if im == 1 {
									m = maxint(n-nd, 0)
								}
								if im == 2 {
									m = minint(n+nd, nmax)
								}
								//
								//           Set LDA to 1 more than minimum value if room.
								lda = m
								if lda < nmax {
									lda++
								}
								//           Skip tests if not enough room.
								if lda > nmax {
									goto label3110
								}
								laa = lda * n
								null = n <= 0 || m <= 0

								for _, incx = range inc {
									lx = absint(incx) * m
									//
									//              Generate the vector X.
									//
									transl = half
									cmakeL2("GE", ' ', ' ', &ione, &m, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := m - 1; return &y }(), &reset, &transl)
									if m > 1 {
										x[m/2-1+xoff] = zero
										xx[1+absint(incx)*(m/2-1)-1+xoff] = zero
									}

									for _, incy = range inc {
										ly = absint(incy) * n
										//
										//                 Generate the vector Y.
										//
										transl = zero
										cmakeL2("GE", ' ', ' ', &ione, &n, &y, &ione, &yy, &yoff, func() *int { y := absint(incy); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
										if n > 1 {
											y[n/2-1+yoff] = zero
											yy[1+absint(incy)*(n/2-1)-1+yoff] = zero
										}

										for _, alpha = range alf {
											//
											//                    Generate the matrix A.
											//
											transl = zero
											cmakeL2(sname[1:3], ' ', ' ', &m, &n, &a, &nmax, &aa, &aoff, &lda, func() *int { y := m - 1; return &y }(), func() *int { y := n - 1; return &y }(), &reset, &transl)

											nc++
											//
											//                    Save every datum before calling the subroutine.
											//
											ms = m
											ns = n
											als = alpha
											for i = 1; i <= laa; i++ {
												as[i-1+aoff] = aa[i-1+aoff]
											}
											ldas = lda
											for i = 1; i <= lx; i++ {
												xs[i-1+xoff] = xx[i-1+xoff]
											}
											incxs = incx
											for i = 1; i <= ly; i++ {
												ys[i-1+yoff] = yy[i-1+yoff]
											}
											incys = incy
											//
											//                    Call the subroutine.
											//
											if conj {
												Cgerc(&m, &n, &alpha, &xx, &xoff, &incx, &yy, &yoff, &incy, &aa, &aoff, &lda)
											} else {
												Cgeru(&m, &n, &alpha, &xx, &xoff, &incx, &yy, &yoff, &incy, &aa, &aoff, &lda)
											}
											//
											//                    Check if error-exit was taken incorrectly.
											//
											if !ok {
												t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
												fatal = true
												goto label3140
											}
											//
											//                    See what data changed inside subroutine.
											//
											isame[0] = ms == m
											isame[1] = ns == n
											isame[2] = als == alpha
											isame[3] = lce(&xs, &xx, &xoff, &lx)
											isame[4] = incxs == incx
											isame[5] = lce(&ys, &yy, &yoff, &ly)
											isame[6] = incys == incy
											if null {
												isame[7] = lce(&as, &aa, &aoff, &laa)
											} else {
												isame[7] = lceres("GE", ' ', &m, &n, &as, &aa, &aoff, &lda)
											}
											isame[8] = ldas == lda
											//
											//                    If data was incorrectly changed, report and return.
											//
											same = true
											for i = 1; i <= nargs; i++ {
												same = same && isame[i-1]
												if !isame[i-1] {
													t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
												}
											}
											if !same {
												fatal = true
												goto label3140
											}

											if !null {
												//
												//                       Check the result column by column.
												//
												if incx > 0 {
													for i = 1; i <= m; i++ {
														z[i-1] = x[i-1+xoff]
													}
												} else {
													for i = 1; i <= m; i++ {
														z[i-1] = x[m-i+1-1+xoff]
													}
												}
												for j = 1; j <= n; j++ {
													if incy > 0 {
														w[0] = y[j-1+yoff]
													} else {
														w[0] = y[n-j+1-1+yoff]
													}
													if conj {
														w[0] = conjc64(w[0])
													}
													cmvch('N', &m, &ione, &alpha, &z, &izero, &nmax, &w, &izero, &ione, &one, &a, func() *int { y := 0 + (j-1)*nmax + aoff; return &y }(), &ione, &yt, &g, &aa, func() *int { y := 1 + (j-1)*lda - 1 + aoff; return &y }(), &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													errmax = maxf32(errmax, err)
													//                          If got really bad answer, report and return.
													if fatal {
														goto label3130
													}

												}
											} else {
												//                       Avoid repeating tests with M.le.0 or N.le.0.
												goto label3110
											}

										}

									}

								}

							label3110:
							}

						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label3130:
			;
			t.Errorf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)

		label3140:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s(%3d,%3d,%4.1f, X,%2d,%2d, Y,%2d,%2d, A,%3d,%3d)                  .\n", sname, nc, sname, m, n, alpha, xoff, incx, yoff, incy, aoff, lda)

		} else if sname == "CHER" || sname == "CHPR" {
			var aoff, i, incx, incxs, j, ja, jj, laa, lda, ldas, lj, lx, n, nargs, nc, ns, xoff int
			w := make([]complex64, 1)
			var full bool = sname[2] == 'E'
			var packed bool = sname[2] == 'P'

			//     Define the number of arguments.
			ok = true
			if full {
				nargs = 7
			} else if packed {
				nargs = 6
			}

			nc = 0
			reset = true
			errmax = rzero

			for aoff = 0; aoff <= 30; aoff += 10 {
				for xoff = 0; xoff <= 30; xoff += 10 {
					for _, n = range idim {
						//        Set LDA to 1 more than minimum value if room.
						lda = n
						if lda < nmax {
							lda++
						}
						//        Skip tests if not enough room.
						if lda > nmax {
							goto label4100
						}
						if packed {
							laa = (n * (n + 1)) / 2
						} else {
							laa = lda * n
						}

						for _, uplo = range ichu {
							upper = uplo == 'U'

							for _, incx = range inc {
								lx = absint(incx) * n
								//
								//              Generate the vector X.
								//
								transl = half
								cmakeL2("GE", ' ', ' ', &ione, &n, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
								if n > 1 {
									x[n/2-1+xoff] = zero
									xx[1+absint(incx)*(n/2-1)-1+xoff] = zero
								}

								for _, ralpha = range ralf {
									alpha = complex(ralpha, 0.0)
									null = n <= 0 || ralpha == rzero
									//
									//                 Generate the matrix A.
									//
									transl = zero
									cmakeL2(sname[1:3], uplo, ' ', &n, &n, &a, &nmax, &aa, &aoff, &lda, func() *int { y := n - 1; return &y }(), func() *int { y := n - 1; return &y }(), &reset, &transl)

									nc++
									//
									//                 Save every datum before calling the subroutine.
									//
									uplos = uplo
									ns = n
									rals = ralpha
									for i = 1; i <= laa; i++ {
										as[i-1+aoff] = aa[i-1+aoff]
									}
									ldas = lda
									for i = 1; i <= lx; i++ {
										xs[i-1+xoff] = xx[i-1+xoff]
									}
									incxs = incx
									//
									//                 Call the subroutine.
									//
									if full {
										Cher(&uplo, &n, &ralpha, &xx, &xoff, &incx, &aa, &aoff, &lda)
									} else if packed {
										Chpr(&uplo, &n, &ralpha, &xx, &xoff, &incx, &aa, &aoff)
									}
									//
									//                 Check if error-exit was taken incorrectly.
									//
									if !ok {
										t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
										fatal = true
										goto label4120
									}
									//
									//                 See what data changed inside subroutines.
									//
									isame[0] = uplo == uplos
									isame[1] = ns == n
									isame[2] = rals == ralpha
									isame[3] = lce(&xs, &xx, &xoff, &lx)
									isame[4] = incxs == incx
									if null {
										isame[5] = lce(&as, &aa, &aoff, &laa)
									} else {
										isame[5] = lceres(sname[1:3], uplo, &n, &n, &as, &aa, &aoff, &lda)
									}
									if !packed {
										isame[6] = ldas == lda
									}
									//
									//                 If data was incorrectly changed, report and return.
									//
									same = true
									for i = 1; i <= nargs; i++ {
										same = same && isame[i-1]
										if !isame[i-1] {
											t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
										}
									}
									if !same {
										fatal = true
										goto label4120
									}

									if !null {
										//
										//                    Check the result column by column.
										//
										if incx > 0 {
											for i = 1; i <= n; i++ {
												z[i-1] = x[i-1+xoff]
											}
										} else {
											for i = 1; i <= n; i++ {
												z[i-1] = x[n-i+1-1+xoff]
											}
										}
										ja = 1
										for j = 1; j <= n; j++ {
											w[0] = conjc64(z[j-1])
											if upper {
												jj = 1
												lj = j
											} else {
												jj = j
												lj = n - j + 1
											}
											cmvch('N', &lj, &ione, &alpha, &z, func() *int { y := jj - 1; return &y }(), &lj, &w, &izero, &ione, &one, &a, func() *int { y := jj - 1 + (j-1)*nmax + aoff; return &y }(), &ione, &yt, &g, &aa, func() *int { y := ja - 1 + aoff; return &y }(), &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
											if full {
												if upper {
													ja = ja + lda
												} else {
													ja = ja + lda + 1
												}
											} else {
												ja = ja + lj
											}
											errmax = maxf32(errmax, err)
											//                       If got really bad answer, report and return.
											if fatal {
												goto label4110
											}
										}
									} else {
										//                    Avoid repeating tests if N.le.0.
										if n <= 0 {
											goto label4100
										}
									}

								}

							}
						}

					label4100:
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label4110:
			;
			t.Errorf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)

		label4120:
			;
			if full {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, X,%2d,%2d, A,%3d,%3d)                        .\n", sname, nc, sname, uplo, n, alpha, xoff, incx, aoff, lda)
			} else if packed {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, X,%2d,%2d, AP,%3d)                           .\n", sname, nc, sname, uplo, n, alpha, xoff, incx, aoff)
			}

		} else if sname == "CHER2" || sname == "CHPR2" {
			var aoff, i, incx, incxs, incy, incys, j, ja, jj, laa, lda, ldas, lj, lx, ly, n, nargs, nc, ns, xoff, yoff int
			w := make([]complex64, 2)
			var full = sname[2] == 'E'
			var packed = sname[2] == 'P'

			//     Define the number of arguments.
			ok = true
			if full {
				nargs = 9
			} else if packed {
				nargs = 8
			}

			nc = 0
			reset = true
			errmax = rzero

			for aoff = 0; aoff <= 30; aoff += 10 {
				for xoff = 0; xoff <= 30; xoff += 10 {
					for yoff = 0; yoff <= 30; yoff += 10 {
						for _, n = range idim {
							//        Set LDA to 1 more than minimum value if room.
							lda = n
							if lda < nmax {
								lda++
							}
							//        Skip tests if not enough room.
							if lda > nmax {
								goto label5140
							}
							if packed {
								laa = (n * (n + 1)) / 2
							} else {
								laa = lda * n
							}

							for _, uplo = range ichu {
								upper = uplo == 'U'

								for _, incx = range inc {
									lx = absint(incx) * n
									//
									//              Generate the vector X.
									//
									transl = half
									cmakeL2("GE", ' ', ' ', &ione, &n, &x, &ione, &xx, &xoff, func() *int { y := absint(incx); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
									if n > 1 {
										x[n/2-1+xoff] = zero
										xx[1+absint(incx)*(n/2-1)-1+xoff] = zero
									}

									for _, incy = range inc {
										ly = absint(incy) * n
										//
										//                 Generate the vector Y.
										//
										transl = zero
										cmakeL2("GE", ' ', ' ', &ione, &n, &y, &ione, &yy, &yoff, func() *int { y := absint(incy); return &y }(), &izero, func() *int { y := n - 1; return &y }(), &reset, &transl)
										if n > 1 {
											y[n/2-1+yoff] = zero
											yy[1+absint(incy)*(n/2-1)-1+yoff] = zero
										}

										for _, alpha = range alf {
											null = n <= 0 || alpha == zero
											//
											//                    Generate the matrix A.
											//
											transl = zero
											cmakeL2(sname[1:3], uplo, ' ', &n, &n, &a, &nmax, &aa, &aoff, &lda, func() *int { y := n - 1; return &y }(), func() *int { y := n - 1; return &y }(), &reset, &transl)
											//
											nc++
											//
											//                    Save every datum before calling the subroutine.
											//
											uplos = uplo
											ns = n
											als = alpha
											for i = 1; i <= laa; i++ {
												as[i-1+aoff] = aa[i-1+aoff]
											}
											ldas = lda
											for i = 1; i <= lx; i++ {
												xs[i-1+xoff] = xx[i-1+xoff]
											}
											incxs = incx
											for i = 1; i <= ly; i++ {
												ys[i-1+yoff] = yy[i-1+yoff]
											}
											incys = incy
											//
											//                    Call the subroutine.
											//
											if full {
												Cher2(&uplo, &n, &alpha, &xx, &xoff, &incx, &yy, &yoff, &incy, &aa, &aoff, &lda)
											} else if packed {
												Chpr2(&uplo, &n, &alpha, &xx, &xoff, &incx, &yy, &yoff, &incy, &aa, &aoff)
											}
											//
											//                    Check if error-exit was taken incorrectly.
											//
											if !ok {
												t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
												fatal = true
												goto label5160
											}
											//
											//                    See what data changed inside subroutines.
											//
											isame[0] = uplo == uplos
											isame[1] = ns == n
											isame[2] = als == alpha
											isame[3] = lce(&xs, &xx, &xoff, &lx)
											isame[4] = incxs == incx
											isame[5] = lce(&ys, &yy, &yoff, &ly)
											isame[6] = incys == incy
											if null {
												isame[7] = lce(&as, &aa, &aoff, &laa)
											} else {
												isame[7] = lceres(sname[1:3], uplo, &n, &n, &as, &aa, &aoff, &lda)
											}
											if !packed {
												isame[8] = ldas == lda
											}
											//
											//                    If data was incorrectly changed, report and return.
											//
											same = true
											for i = 1; i <= nargs; i++ {
												same = same && isame[i-1]
												if !isame[i-1] {
													t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
												}
											}
											if !same {
												fatal = true
												goto label5160
											}

											if !null {
												//
												//                       Check the result column by column.
												//
												if incx > 0 {
													for i = 1; i <= n; i++ {
														z[i-1+0*nmax] = x[i-1+xoff]
													}
												} else {
													for i = 1; i <= n; i++ {
														z[i-1+0*nmax] = x[n-i+1-1+xoff]
													}
												}
												if incy > 0 {
													for i = 1; i <= n; i++ {
														z[i-1+1*nmax] = y[i-1+yoff]
													}
												} else {
													for i = 1; i <= n; i++ {
														z[i-1+1*nmax] = y[n-i+1-1+yoff]
													}
												}
												ja = 1
												for j = 1; j <= n; j++ {
													w[0] = alpha * conjc64(z[j-1+1*nmax])
													w[1] = conjc64(alpha) * conjc64(z[j-1+0*nmax])
													if upper {
														jj = 1
														lj = j
													} else {
														jj = j
														lj = n - j + 1
													}
													cmvch('N', &lj, &itwo, &one, &z, func() *int { y := jj - 1 + 0*nmax; return &y }(), &nmax, &w, &izero, &ione, &one, &a, func() *int { y := jj - 1 + (j-1)*nmax + aoff; return &y }(), &ione, &yt, &g, &aa, func() *int { y := ja - 1 + aoff; return &y }(), &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													if full {
														if upper {
															ja = ja + lda
														} else {
															ja = ja + lda + 1
														}
													} else {
														ja = ja + lj
													}
													errmax = maxf32(errmax, err)
													//                          If got really bad answer, report and return.
													if fatal {
														goto label5150
													}
												}
											} else {
												//                       Avoid repeating tests with N.le.0.
												if n <= 0 {
													goto label5140
												}
											}

										}

									}

								}

							}

						label5140:
						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label5150:
			;
			t.Errorf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)

		label5160:
			;
			if full {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, X,%2d, Y,%2d, A,%3d)                  .\n", sname, nc, sname, uplo, n, alpha, incx, incy, lda)
			} else if packed {
				t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c',%3d,%4.1f, X,%2d, Y,%2d, AP)                     .\n", sname, nc, sname, uplo, n, alpha, incx, incy)
			}
		} else {
			t.Logf(" %6s TEST NOT FOUND\n", sname)
		}
	}
}

func TestCblasLevel3(t *testing.T) {
	var diag, diags, side, sides, tranas, tranbs, transa, transb, transt, uplo, uplos byte
	var fatal, left, null, tran, same, upper bool
	var alpha, als, beta, bets, bls complex64
	var err, ralpha, rals, rbeta, rbets, rbls float32
	var i, j, n int
	var ok bool = true
	var reset bool = true
	var rzero float32 = 0.0
	var rone float32 = 1.0
	var zero complex64 = complex(0.0, 0.0)
	var one complex64 = complex(1.0, 0.0)
	var eps float32 = epsilonf32()
	var thresh float32 = 16.0
	var errmax float32 = rzero
	var nmax int = 65
	var izero int = 0
	var idim []int = []int{0, 1, 2, 3, 5, 9}
	var alf []complex64 = []complex64{complex(0.0, 0.0), complex(1.0, 0.0), complex(0.7, -0.9)}
	var bet []complex64 = []complex64{complex(0.0, 0.0), complex(1.0, 0.0), complex(1.3, -1.1)}
	isame := make([]bool, 13)
	var ichd []byte = []byte{'U', 'N'}
	var ichs []byte = []byte{'L', 'R'}
	var icht []byte = []byte{'N', 'C'}
	var ichu []byte = []byte{'U', 'L'}
	a := make([]complex64, nmax*2*nmax)
	aa := make([]complex64, nmax*nmax)
	ab := make([]complex64, nmax*2*nmax)
	as := make([]complex64, nmax*nmax)
	b := make([]complex64, nmax*2*nmax)
	bb := make([]complex64, nmax*nmax)
	bs := make([]complex64, nmax*nmax)
	c := make([]complex64, nmax*nmax)
	cc := make([]complex64, nmax*nmax)
	cs := make([]complex64, nmax*nmax)
	ct := make([]complex64, nmax)
	g := make([]float32, nmax)
	w := make([]complex64, 2*nmax)
	var snames []string = []string{"CGEMM", "CHEMM", "CSYMM", "CTRMM", "CTRSM", "CHERK", "CSYRK", "CHER2K", "CSYR2K"}

	n = minint(int(32), nmax)
	for j = 1; j <= n; j++ {
		for i = 1; i <= n; i++ {
			a[i-1+(j-1)*nmax] = complex(float32(maxint(i-j+1, 0)), 0.0)
			ab[i-1+(j-1)*nmax] = a[i-1+(j-1)*nmax]
			b[i-1+(j-1)*nmax] = a[i-1+(j-1)*nmax]
		}
		a[j-1+(nmax)*nmax] = complex(float32(j), 0.0)
		a[0+(nmax+j-1)*nmax] = complex(float32(j), 0.0)
		ab[j-1+(nmax)*nmax] = a[j-1+(nmax)*nmax]
		ab[0+(nmax+j-1)*nmax] = a[0+(nmax+j-1)*nmax]
		b[j-1+(nmax)*nmax] = a[j-1+(nmax)*nmax]
		b[0+(nmax+j-1)*nmax] = a[0+(nmax+j-1)*nmax]
		c[j-1+0*nmax] = zero
	}
	for j = 1; j <= n; j++ {
		cc[j-1] = complex(float32(j*((j+1)*j))/2-float32((j+1)*j*(j-1))/3, 0.0)
	}
	//     CC holds the exact result. On exit from SMMCH CT holds
	//     the result computed by SMMCH.
	transa = byte('N')
	transb = byte('N')
	cmmch(transa, transb, &n, func() *int { y := 1; return &y }(), &n, &one, &a, &izero, &nmax, &a, func() *int { y := nmax * nmax; return &y }(), &nmax, &zero, &c, &izero, &nmax, &ct, &g, &cc, &izero, &nmax, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lce(&cc, &ct, &izero, &n)
	if !same || err != rzero {
		t.Errorf(" ERROR IN CMMCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n CMMCH WAS CALLED WITH TRANSA = %c AND TRANSB = %c\n AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", transa, transb, same, err)
	}
	transb = byte('C')
	cmmch(transa, transb, &n, func() *int { y := 1; return &y }(), &n, &one, &a, &izero, &nmax, &a, func() *int { y := nmax * nmax; return &y }(), &nmax, &zero, &c, &izero, &nmax, &ct, &g, &cc, &izero, &nmax, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lce(&cc, &ct, &izero, &n)
	if !same || err != rzero {
		t.Errorf(" ERROR IN CMMCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n CMMCH WAS CALLED WITH TRANSA = %c AND TRANSB = %c\n AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", transa, transb, same, err)
	}
	for j = 1; j <= n; j++ {
		a[j-1+(nmax)*nmax] = complex(float32(n-j+1), 0.0)
		a[0+(nmax+j-1)*nmax] = complex(float32(n-j+1), 0.0)
		ab[j-1+(nmax)*nmax] = a[j-1+(nmax)*nmax]
		ab[0+(nmax+j-1)*nmax] = a[0+(nmax+j-1)*nmax]
		b[j-1+(nmax)*nmax] = a[j-1+(nmax)*nmax]
		b[0+(nmax+j-1)*nmax] = a[0+(nmax+j-1)*nmax]
	}
	for j = 1; j <= n; j++ {
		cc[n-j+1-1] = complex(float32(j*((j+1)*j))/2-float32((j+1)*j*(j-1))/3, 0.0)
	}
	transa = byte('C')
	transb = byte('N')
	cmmch(transa, transb, &n, func() *int { y := 1; return &y }(), &n, &one, &ab, &izero, &nmax, &ab, func() *int { y := nmax * nmax; return &y }(), &nmax, &zero, &c, &izero, &nmax, &ct, &g, &cc, &izero, &nmax, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lce(&cc, &ct, &izero, &n)
	if !same || err != rzero {
		t.Errorf(" ERROR IN CMMCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n CMMCH WAS CALLED WITH TRANSA = %c AND TRANSB = %c\n AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", transa, transb, same, err)
	}
	transb = byte('C')
	cmmch(transa, transb, &n, func() *int { y := 1; return &y }(), &n, &one, &ab, &izero, &nmax, &ab, func() *int { y := nmax * nmax; return &y }(), &nmax, &zero, &c, &izero, &nmax, &ct, &g, &cc, &izero, &nmax, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
	same = lce(&cc, &ct, &izero, &n)
	if !same || err != rzero {
		t.Errorf(" ERROR IN CMMCH -  IN-LINE DOT PRODUCTS ARE BEING EVALUATED WRONGLY.\n CMMCH WAS CALLED WITH TRANSA = %c AND TRANSB = %c\n AND RETURNED SAME =  %t AND ERR = %12.3f.\n THIS MAY BE DUE TO FAULTS IN THE ARITHMETIC OR THE COMPILER.\n ******* TESTS ABANDONED *******\n", transa, transb, same, err)
	}

	for _, sname := range snames {
		if string(sname) == "CGEMM" {
			var trana, tranb bool
			var aoff, boff, coff, i, k, ks, laa, lbb, lcc, lda, ldas, ldb, ldbs, ldc, ldcs, m, ma, mb, ms, n, na, nb, ns int
			var nargs int = 13
			var nc int = 0

			ok = true
			for aoff = 0; aoff <= 25; aoff += 25 {
				for boff = 0; boff <= 25; boff += 25 {
					for coff = 0; coff <= 25; coff += 25 {
						for _, m = range idim {

							for _, n = range idim {
								//           Set LDC to 1 more than minimum value if room.
								ldc = m
								if ldc < nmax {
									ldc = ldc + 1
								}
								//           Skip tests if not enough room.
								if ldc > nmax {
									goto label1100
								}
								lcc = ldc * n
								null = n <= 0 || m <= 0

								for _, k = range idim {

									for _, transa = range icht {
										trana = transa == 'T' || transa == 'C'

										if trana {
											ma = k
											na = m
										} else {
											ma = m
											na = k
										}
										//                 Set LDA to 1 more than minimum value if room.
										lda = ma
										if lda < nmax {
											lda = lda + 1
										}
										//                 Skip tests if not enough room.
										if lda > nmax {
											goto label180
										}
										laa = lda * na
										//
										//                 Generate the matrix A.
										//
										cmakeL3("GE", ' ', ' ', &ma, &na, &a, &aoff, &nmax, &aa, &aoff, &lda, &reset, &zero)

										for _, transb = range icht {
											tranb = transb == 'T' || transb == 'C'

											if tranb {
												mb = n
												nb = k
											} else {
												mb = k
												nb = n
											}
											//                    Set LDB to 1 more than minimum value if room.
											ldb = mb
											if ldb < nmax {
												ldb = ldb + 1
											}
											//                    Skip tests if not enough room.
											if ldb > nmax {
												goto label170
											}
											lbb = ldb * nb
											//
											//                    Generate the matrix B.
											//
											cmakeL3("GE", ' ', ' ', &mb, &nb, &b, &boff, &nmax, &bb, &boff, &ldb, &reset, &zero)

											for _, alpha = range alf {

												for _, beta = range bet {
													//
													//                          Generate the matrix C.
													//
													cmakeL3("GE", ' ', ' ', &m, &n, &c, &coff, &nmax, &cc, &coff, &ldc, &reset, &zero)

													nc++
													//
													//                          Save every datum before calling the
													//                          subroutine.
													//
													tranas = transa
													tranbs = transb
													ms = m
													ns = n
													ks = k
													als = alpha
													for i = 1; i <= laa; i++ {
														as[i-1+aoff] = aa[i-1+aoff]
													}
													ldas = lda
													for i = 1; i <= lbb; i++ {
														bs[i-1+boff] = bb[i-1+boff]
													}
													ldbs = ldb
													bls = beta
													for i = 1; i <= lcc; i++ {
														cs[i-1+coff] = cc[i-1+coff]
													}
													ldcs = ldc
													//
													//                          Call the subroutine.
													//
													Cgemm(&transa, &transb, &m, &n, &k, &alpha, &aa, &aoff, &lda, &bb, &boff, &ldb, &beta, &cc, &coff, &ldc)
													//
													//                          Check if error-exit was taken incorrectly.
													//
													if !ok {
														t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
														fatal = true
														goto label1120
													}
													//
													//                          See what data changed inside subroutines.
													//
													isame[0] = transa == tranas
													isame[1] = transb == tranbs
													isame[2] = ms == m
													isame[3] = ns == n
													isame[4] = ks == k
													isame[5] = als == alpha
													isame[6] = lce(&as, &aa, &aoff, &laa)
													isame[7] = ldas == lda
													isame[8] = lce(&bs, &bb, &boff, &lbb)
													isame[9] = ldbs == ldb
													isame[10] = bls == beta
													if null {
														isame[11] = lce(&cs, &cc, &coff, &lcc)
													} else {
														isame[11] = lceres("GE", ' ', &m, &n, &cs, &cc, &coff, &ldc)
													}
													isame[12] = ldcs == ldc
													//
													//                          If data was incorrectly changed, report
													//                          and return.
													//
													same = true
													for i = 1; i <= nargs; i++ {
														same = same && isame[i-1]
														if !isame[i-1] {
															t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
														}
													}
													if !same {
														fatal = true
														goto label1120
													}

													if !null {
														//
														//                             Check the result.
														//
														cmmch(transa, transb, &m, &n, &k, &alpha, &a, &aoff, &nmax, &b, &boff, &nmax, &beta, &c, &coff, &nmax, &ct, &g, &cc, &coff, &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
														errmax = maxf32(errmax, err)
														//                             If got really bad answer, report and
														//                             return.
														if fatal {
															goto label1120
														}
													}

												}

											}

										label170:
										}

									label180:
									}

								}

							label1100:
							}

						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label1120:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c',%3d,%3d,%3d,%4.1f, A,%3d,%3d, B,%3d,%3d,%4.1f, C,%3d,%3d).\n", sname, nc, sname, transa, transb, m, n, k, alpha, aoff, lda, boff, ldb, beta, coff, ldc)

		} else if sname == "CHEMM" || sname == "CSYMM" {
			var aoff, boff, coff, i, laa, lbb, lcc, lda, ldas, ldb, ldbs, ldc, ldcs, m, ms, n, na, ns int
			var nargs int = 12
			var nc int = 0
			var conj bool = sname[1:3] == "HE"

			ok = true
			for aoff = 0; aoff <= 30; aoff += 10 {
				for boff = 0; boff <= 30; boff += 10 {
					for coff = 0; coff <= 30; coff += 10 {
						for _, m = range idim {

							for _, n = range idim {
								//           Set LDC to 1 more than minimum value if room.
								ldc = m
								if ldc < nmax {
									ldc = ldc + 1
								}
								//           Skip tests if not enough room.
								if ldc > nmax {
									goto label290
								}
								lcc = ldc * n
								null = n <= 0 || m <= 0
								//
								//           Set LDB to 1 more than minimum value if room.
								ldb = m
								if ldb < nmax {
									ldb = ldb + 1
								}
								//           Skip tests if not enough room.
								if ldb > nmax {
									goto label290
								}
								lbb = ldb * n
								//
								//           Generate the matrix B.
								//
								cmakeL3("GE", ' ', ' ', &m, &n, &b, &boff, &nmax, &bb, &boff, &ldb, &reset, &zero)

								for _, side = range ichs {
									left = side == 'L'

									if left {
										na = m
									} else {
										na = n
									}
									//              Set LDA to 1 more than minimum value if room.
									lda = na
									if lda < nmax {
										lda = lda + 1
									}
									//              Skip tests if not enough room.
									if lda > nmax {
										goto label280
									}
									laa = lda * na

									for _, uplo = range ichu {
										//
										//                 Generate the symmetric matrix A.
										//
										cmakeL3(sname[1:3], uplo, ' ', &na, &na, &a, &aoff, &nmax, &aa, &aoff, &lda, &reset, &zero)

										for _, alpha = range alf {

											for _, beta = range bet {
												//
												//                       Generate the matrix C.
												//
												cmakeL3("GE", ' ', ' ', &m, &n, &c, &coff, &nmax, &cc, &coff, &ldc, &reset, &zero)

												nc++
												//
												//                       Save every datum before calling the
												//                       subroutine.
												//
												sides = side
												uplos = uplo
												ms = m
												ns = n
												als = alpha
												for i = 1; i <= laa; i++ {
													as[i-1+aoff] = aa[i-1+aoff]
												}
												ldas = lda
												for i = 1; i <= lbb; i++ {
													bs[i-1+boff] = bb[i-1+boff]
												}
												ldbs = ldb
												bls = beta
												for i = 1; i <= lcc; i++ {
													cs[i-1+coff] = cc[i-1+coff]
												}
												ldcs = ldc
												//
												//                       Call the subroutine.
												//
												if conj {
													Chemm(&side, &uplo, &m, &n, &alpha, &aa, &aoff, &lda, &bb, &boff, &ldb, &beta, &cc, &coff, &ldc)
												} else {
													Csymm(&side, &uplo, &m, &n, &alpha, &aa, &aoff, &lda, &bb, &boff, &ldb, &beta, &cc, &coff, &ldc)
												}
												//
												//                       Check if error-exit was taken incorrectly.
												//
												if !ok {
													t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
													fatal = true
													goto label2110
												}
												//
												//                       See what data changed inside subroutines.
												//
												isame[0] = sides == side
												isame[1] = uplos == uplo
												isame[2] = ms == m
												isame[3] = ns == n
												isame[4] = als == alpha
												isame[5] = lce(&as, &aa, &aoff, &laa)
												isame[6] = ldas == lda
												isame[7] = lce(&bs, &bb, &boff, &lbb)
												isame[8] = ldbs == ldb
												isame[9] = bls == beta
												if null {
													isame[10] = lce(&cs, &cc, &coff, &lcc)
												} else {
													isame[10] = lceres("GE", ' ', &m, &n, &cs, &cc, &coff, &ldc)
												}
												isame[11] = ldcs == ldc
												//
												//                       If data was incorrectly changed, report and
												//                       return.
												//
												same = true
												for i = 1; i <= nargs; i++ {
													same = same && isame[i-1]
													if !isame[i-1] {
														t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
													}
												}
												if !same {
													fatal = true
													goto label2110
												}

												if !null {
													//
													//                          Check the result.
													//
													if left {
														cmmch('N', 'N', &m, &n, &m, &alpha, &a, &aoff, &nmax, &b, &boff, &nmax, &beta, &c, &coff, &nmax, &ct, &g, &cc, &coff, &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													} else {
														cmmch('N', 'N', &m, &n, &n, &alpha, &b, &boff, &nmax, &a, &aoff, &nmax, &beta, &c, &coff, &nmax, &ct, &g, &cc, &coff, &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													}
													errmax = maxf32(errmax, err)
													//                          If got really bad answer, report and
													//                          return.
													if fatal {
														goto label2110
													}
												}

											}

										}

									}

								label280:
								}

							label290:
							}
						}
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label2110:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c',%3d,%3d,%4.1f, A,%3d,%3d, B,%3d,%3d,%4.1f, C,%3d,%3d)    .\n", sname, nc, sname, side, uplo, m, n, alpha, aoff, lda, boff, ldb, beta, coff, ldc)

		} else if sname == "CTRMM" || sname == "CTRSM" {
			var aoff, boff, i, j, laa, lbb, lda, ldas, ldb, ldbs, m, ms, n, na, ns int
			var nargs int = 11
			var nc int = 0

			ok = true
			//
			//     Set up zero matrix for SMMCH.
			for j = 1; j <= nmax; j++ {
				for i = 1; i <= nmax; i++ {
					c[i-1+(j-1)*nmax] = zero
				}
			}

			for aoff = 0; aoff <= 30; aoff += 10 {
				for boff = 0; boff <= 30; boff += 10 {
					for _, m = range idim {

						for _, n = range idim {
							//           Set LDB to 1 more than minimum value if room.
							ldb = m
							if ldb < nmax {
								ldb = ldb + 1
							}
							//           Skip tests if not enough room.
							if ldb > nmax {
								goto label3130
							}
							lbb = ldb * n
							null = m <= 0 || n <= 0

							for _, side = range ichs {
								left = side == 'L'
								if left {
									na = m
								} else {
									na = n
								}
								//              Set LDA to 1 more than minimum value if room.
								lda = na
								if lda < nmax {
									lda = lda + 1
								}
								//              Skip tests if not enough room.
								if lda > nmax {
									goto label3130
								}
								laa = lda * na

								for _, uplo = range ichu {

									for _, transa = range icht {

										for _, diag = range ichd {

											for _, alpha = range alf {
												//
												//                          Generate the matrix A.
												//
												cmakeL3("TR", uplo, diag, &na, &na, &a, &aoff, &nmax, &aa, &aoff, &lda, &reset, &zero)
												//
												//                          Generate the matrix B.
												//
												cmakeL3("GE", ' ', ' ', &m, &n, &b, &boff, &nmax, &bb, &boff, &ldb, &reset, &zero)

												nc++
												//
												//                          Save every datum before calling the
												//                          subroutine.
												//
												sides = side
												uplos = uplo
												tranas = transa
												diags = diag
												ms = m
												ns = n
												als = alpha
												for i = 1; i <= laa; i++ {
													as[i-1+aoff] = aa[i-1+aoff]
												}
												ldas = lda
												for i = 1; i <= lbb; i++ {
													bs[i-1+boff] = bb[i-1+boff]
												}
												ldbs = ldb
												//
												//                          Call the subroutine.
												//
												if sname[3:5] == "MM" {
													Ctrmm(&side, &uplo, &transa, &diag, &m, &n, &alpha, &aa, &aoff, &lda, &bb, &boff, &ldb)
												} else if sname[3:5] == "SM" {
													Ctrsm(&side, &uplo, &transa, &diag, &m, &n, &alpha, &aa, &aoff, &lda, &bb, &boff, &ldb)
												}
												//
												//                          Check if error-exit was taken incorrectly.
												//
												if !ok {
													t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
													fatal = true
													goto label3150
												}
												//
												//                          See what data changed inside subroutines.
												//
												isame[0] = sides == side
												isame[1] = uplos == uplo
												isame[2] = tranas == transa
												isame[3] = diags == diag
												isame[4] = ms == m
												isame[5] = ns == n
												isame[6] = als == alpha
												isame[7] = lce(&as, &aa, &aoff, &laa)
												isame[8] = ldas == lda
												if null {
													isame[9] = lce(&bs, &bb, &boff, &lbb)
												} else {
													isame[9] = lceres("GE", ' ', &m, &n, &bs, &bb, &boff, &ldb)
												}
												isame[10] = ldbs == ldb
												//
												//                          If data was incorrectly changed, report and
												//                          return.
												//
												same = true
												for i = 1; i <= nargs; i++ {
													same = same && isame[i-1]
													if !isame[i-1] {
														t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
													}
												}
												if !same {
													fatal = true
													goto label3150
												}

												if !null {
													if string(sname[3:5]) == "MM" {
														//
														//                                Check the result.
														//
														if left {
															cmmch(transa, 'N', &m, &n, &m, &alpha, &a, &aoff, &nmax, &b, &boff, &nmax, &zero, &c, &izero, &nmax, &ct, &g, &bb, &boff, &ldb, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
														} else {
															cmmch('N', transa, &m, &n, &n, &alpha, &b, &boff, &nmax, &a, &aoff, &nmax, &zero, &c, &izero, &nmax, &ct, &g, &bb, &boff, &ldb, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
														}
													} else if sname[3:5] == "SM" {
														//
														//                                Compute approximation to original
														//                                matrix.
														//
														for j = 1; j <= n; j++ {
															for i = 1; i <= m; i++ {
																c[i-1+(j-1)*nmax] = bb[i+(j-1)*ldb-1+boff]
																bb[i+(j-1)*ldb-1+boff] = alpha * b[i-1+(j-1)*nmax+boff]
															}
														}

														if left {
															cmmch(transa, 'N', &m, &n, &m, &one, &a, &aoff, &nmax, &c, &izero, &nmax, &zero, &b, &boff, &nmax, &ct, &g, &bb, &boff, &ldb, &eps, &err, &fatal, func() *bool { y := false; return &y }(), t)
														} else {
															cmmch('N', transa, &m, &n, &n, &one, &c, &izero, &nmax, &a, &aoff, &nmax, &zero, &b, &boff, &nmax, &ct, &g, &bb, &boff, &ldb, &eps, &err, &fatal, func() *bool { y := false; return &y }(), t)
														}
													}
													errmax = maxf32(errmax, err)
													//                             If got really bad answer, report and
													//                             return.
													if fatal {
														goto label3150
													}
												}

											}

										}

									}

								}

							}

						label3130:
						}

					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label3150:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c','%c','%c',%3d,%3d,%4.1f, A,%3d,%3d, B,%3d,%3d)        .\n", sname, nc, sname, side, uplo, transa, diag, m, n, alpha, aoff, lda, boff, ldb)

		} else if sname == "CHERK" || sname == "CSYRK" {
			var trans, transs byte
			var aoff, coff, i, j, jc, jj, k, ks, laa, lcc, lda, ldas, ldc, ldcs, lj, ma, n, na, ns int
			var nargs int = 10
			var nc int = 0
			var conj bool = sname[1:3] == "HE"

			ok = true
			for aoff = 0; aoff <= 30; aoff += 10 {
				for coff = 0; coff <= 30; coff += 10 {
					for _, n = range idim {
						//        Set LDC to 1 more than minimum value if room.
						ldc = n
						if ldc < nmax {
							ldc = ldc + 1
						}
						//        Skip tests if not enough room.
						if ldc > nmax {
							goto label4100
						}
						lcc = ldc * n

						for _, k = range idim {

							for _, trans = range icht {
								tran = trans == 'T' || trans == 'C'
								if tran && !conj {
									trans = 'T'
								}
								if tran {
									ma = k
									na = n
								} else {
									ma = n
									na = k
								}
								//              Set LDA to 1 more than minimum value if room.
								lda = ma
								if lda < nmax {
									lda = lda + 1
								}
								//              Skip tests if not enough room.
								if lda > nmax {
									goto label480
								}
								laa = lda * na
								//
								//              Generate the matrix A.
								//
								cmakeL3("GE", ' ', ' ', &ma, &na, &a, &aoff, &nmax, &aa, &aoff, &lda, &reset, &zero)

								for _, uplo = range ichu {
									upper = uplo == 'U'

									for _, alpha = range alf {
										if conj {
											ralpha = real(alpha)
											alpha = complex(ralpha, 0.0)
										}

										for _, beta = range bet {
											if conj {
												rbeta = real(beta)
												beta = complex(rbeta, 0.0)
											}
											null = n <= 0
											if conj {
												null = null || ((k <= 0 || ralpha == rzero) && rbeta == rone)
											}

											//
											//                       Generate the matrix C.
											//
											cmakeL3(sname[1:3], uplo, ' ', &n, &n, &c, &coff, &nmax, &cc, &coff, &ldc, &reset, &zero)

											nc++
											//
											//                       Save every datum before calling the subroutine.
											//
											uplos = uplo
											transs = trans
											ns = n
											ks = k
											if conj {
												rals = ralpha
											} else {
												als = alpha
											}
											for i = 1; i <= laa; i++ {
												as[i-1+aoff] = aa[i-1+aoff]
											}
											ldas = lda
											if conj {
												rbls = rbeta
											} else {
												bls = beta
											}
											for i = 1; i <= lcc; i++ {
												cs[i-1+coff] = cc[i-1+coff]
											}
											ldcs = ldc
											//
											//                       Call the subroutine.
											//
											if conj {
												Cherk(&uplo, &trans, &n, &k, &ralpha, &aa, &aoff, &lda, &rbeta, &cc, &coff, &ldc)
											} else {
												Csyrk(&uplo, &trans, &n, &k, &alpha, &aa, &aoff, &lda, &beta, &cc, &coff, &ldc)
											}
											//
											//                       Check if error-exit was taken incorrectly.
											//
											if !ok {
												t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
												fatal = true
												goto label4120
											}
											//
											//                       See what data changed inside subroutines.
											//
											isame[0] = uplos == uplo
											isame[1] = transs == trans
											isame[2] = ns == n
											isame[3] = ks == k
											if conj {
												isame[4] = rals == ralpha
											} else {
												isame[4] = als == alpha
											}
											isame[5] = lce(&as, &aa, &aoff, &laa)
											isame[6] = ldas == lda
											if conj {
												isame[7] = rbls == rbeta
											} else {
												isame[7] = bls == beta
											}
											if null {
												isame[8] = lce(&cs, &cc, &coff, &lcc)
											} else {
												isame[8] = lceres(sname[1:3], uplo, &n, &n, &cs, &cc, &coff, &ldc)
											}
											isame[9] = ldcs == ldc
											//
											//                       If data was incorrectly changed, report and
											//                       return.
											//
											same = true
											for i = 1; i <= nargs; i++ {
												same = same && isame[i-1]
												if !isame[i-1] {
													t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
												}
											}
											if !same {
												fatal = true
												goto label4120
											}

											if !null {
												//
												//                          Check the result column by column.
												//
												if conj {
													transt = 'C'
												} else {
													transt = 'T'
												}
												jc = 1
												for j = 1; j <= n; j++ {
													if upper {
														jj = 1
														lj = j
													} else {
														jj = j
														lj = n - j + 1
													}
													if tran {
														cmmch(transt, 'N', &lj, func() *int { y := 1; return &y }(), &k, &alpha, &a, func() *int { y := 0 + (jj-1)*nmax + aoff; return &y }(), &nmax, &a, func() *int { y := 0 + (j-1)*nmax + aoff; return &y }(), &nmax, &beta, &c, func() *int { y := jj - 1 + (j-1)*nmax + coff; return &y }(), &nmax, &ct, &g, &cc, func() *int { y := jc - 1 + coff; return &y }(), &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													} else {
														cmmch('N', transt, &lj, func() *int { y := 1; return &y }(), &k, &alpha, &a, func() *int { y := jj - 1 + (0)*nmax + aoff; return &y }(), &nmax, &a, func() *int { y := j - 1 + (0)*nmax + aoff; return &y }(), &nmax, &beta, &c, func() *int { y := jj - 1 + (j-1)*nmax + coff; return &y }(), &nmax, &ct, &g, &cc, func() *int { y := jc - 1 + coff; return &y }(), &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
													}
													if upper {
														jc = jc + ldc
													} else {
														jc = jc + ldc + 1
													}
													errmax = maxf32(errmax, err)
													//                             If got really bad answer, report and
													//                             return.
													if fatal {
														goto label4110
													}
												}
											}

										}

									}

								}

							label480:
							}

						}

					label4100:
					}
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue

		label4110:
			;
			if n > 1 {
				t.Errorf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)
			}
			//
		label4120:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c',%3d,%3d,%4.1f, A,%3d,%4.1f, C,%3d)           .\n", sname, nc, sname, uplo, trans, n, k, alpha, lda, beta, ldc)

		} else if sname == "CHER2K" || sname == "CSYR2K" {
			var trans, transs byte
			var aoff, boff, coff, i, j, jc, jj, jjab, k, ks, laa, lbb, lcc, lda, ldas, ldb, ldbs, ldc, ldcs, lj, ma, n, na, ns int
			_ = aoff
			_ = boff
			var nargs int = 12
			var nc int = 0
			var conj bool = sname[1:3] == "HE"

			ok = true
			for coff = 0; coff <= 30; coff += 10 {
				for _, n = range idim {
					//        Set LDC to 1 more than minimum value if room.
					ldc = n
					if ldc < nmax {
						ldc = ldc + 1
					}
					//        Skip tests if not enough room.
					if ldc > nmax {
						goto label5130
					}
					lcc = ldc * n

					for _, k = range idim {

						for _, trans = range icht {
							tran = trans == 'C'
							if tran && !conj {
								trans = 'T'
							}
							if tran {
								ma = k
								na = n
							} else {
								ma = n
								na = k
							}
							//              Set LDA to 1 more than minimum value if room.
							lda = ma
							if lda < nmax {
								lda = lda + 1
							}
							//              Skip tests if not enough room.
							if lda > nmax {
								goto label5110
							}
							laa = lda * na
							//
							//              Generate the matrix A.
							//
							if tran {
								cmakeL3("GE", ' ', ' ', &ma, &na, &ab, &izero, func() *int { y := 2 * nmax; return &y }(), &aa, &izero, &lda, &reset, &zero)
							} else {
								cmakeL3("GE", ' ', ' ', &ma, &na, &ab, &izero, &nmax, &aa, &izero, &lda, &reset, &zero)
							}
							//
							//              Generate the matrix B.
							//
							ldb = lda
							lbb = laa
							if tran {
								cmakeL3("GE", ' ', ' ', &ma, &na, &ab, &k, func() *int { y := 2 * nmax; return &y }(), &bb, &izero, &ldb, &reset, &zero)
							} else {
								cmakeL3("GE", ' ', ' ', &ma, &na, &ab, func() *int { y := k * nmax; return &y }(), &nmax, &bb, &izero, &ldb, &reset, &zero)
							}

							for _, uplo = range ichu {
								upper = uplo == 'U'

								for _, alpha = range alf {

									for _, beta = range bet {
										if conj {
											rbeta = real(beta)
											beta = complex(rbeta, rzero)
										}
										null = n <= 0
										if conj {
											null = null || ((k <= 0 || alpha == zero) && rbeta == rone)
										}
										//
										//                       Generate the matrix C.
										//
										cmakeL3(sname[1:3], uplo, ' ', &n, &n, &c, &coff, &nmax, &cc, &coff, &ldc, &reset, &zero)
										//
										nc++
										//
										//                       Save every datum before calling the subroutine.
										//
										uplos = uplo
										transs = trans
										ns = n
										ks = k
										als = alpha
										for i = 1; i <= laa; i++ {
											as[i-1] = aa[i-1]
										}
										ldas = lda
										for i = 1; i <= lbb; i++ {
											bs[i-1] = bb[i-1]
										}
										ldbs = ldb
										if conj {
											rbets = rbeta
										} else {
											bets = beta
										}
										for i = 1; i <= lcc; i++ {
											cs[i-1+coff] = cc[i-1+coff]
										}
										ldcs = ldc
										//
										//                       Call the subroutine.
										//
										if conj {
											Cher2k(&uplo, &trans, &n, &k, &alpha, &aa, &izero, &lda, &bb, &izero, &ldb, &rbeta, &cc, &coff, &ldc)
										} else {
											Csyr2k(&uplo, &trans, &n, &k, &alpha, &aa, &izero, &lda, &bb, &izero, &ldb, &beta, &cc, &coff, &ldc)
										}
										//
										//                       Check if error-exit was taken incorrectly.
										//
										if !ok {
											t.Errorf(" ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *******\n")
											fatal = true
											goto label5150
										}
										//
										//                       See what data changed inside subroutines.
										//
										isame[0] = uplos == uplo
										isame[1] = transs == trans
										isame[2] = ns == n
										isame[3] = ks == k
										isame[4] = als == alpha
										isame[5] = lce(&as, &aa, &izero, &laa)
										isame[6] = ldas == lda
										isame[7] = lce(&bs, &bb, &izero, &lbb)
										isame[8] = ldbs == ldb
										if conj {
											isame[9] = rbets == rbeta
										} else {
											isame[9] = bets == beta
										}
										if null {
											isame[10] = lce(&cs, &cc, &coff, &lcc)
										} else {
											isame[10] = lceres("HE", uplo, &n, &n, &cs, &cc, &coff, &ldc)
										}
										isame[11] = ldcs == ldc
										//
										//                       If data was incorrectly changed, report and
										//                       return.
										//
										same = true
										for i = 1; i <= nargs; i++ {
											same = same && isame[i-1]
											if !isame[i-1] {
												t.Errorf(" ******* FATAL ERROR - PARAMETER NUMBER %2d WAS CHANGED INCORRECTLY *******\n", i)
											}
										}
										if !same {
											fatal = true
											goto label5150
										}

										if !null {
											//
											//                          Check the result column by column.
											//
											if conj {
												transt = 'C'
											} else {
												transt = 'T'
											}
											jjab = 1
											jc = 1
											for j = 1; j <= n; j++ {
												if upper {
													jj = 1
													lj = j
												} else {
													jj = j
													lj = n - j + 1
												}
												if tran {
													for i = 1; i <= k; i++ {
														w[i-1] = alpha * ab[(j-1)*2*nmax+k+i-1]
														if conj {
															w[k+i-1] = conjc64(alpha) * ab[(j-1)*2*nmax+i-1]
														} else {
															w[k+i-1] = alpha * ab[(j-1)*2*nmax+i-1]
														}
													}
													cmmch(transt, 'N', &lj, func() *int { y := 1; return &y }(), func() *int { y := 2 * k; return &y }(), &one, &ab, func() *int { y := jjab - 1; return &y }(), func() *int { y := 2 * nmax; return &y }(), &w, &izero, func() *int { y := 2 * nmax; return &y }(), &beta, &c, func() *int { y := jj - 1 + (j-1)*nmax + coff; return &y }(), &nmax, &ct, &g, &cc, func() *int { y := jc - 1 + coff; return &y }(), &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
												} else {
													for i = 1; i <= k; i++ {
														if conj {
															w[i-1] = alpha * conjc64(ab[(k+i-1)*nmax+j-1])
															w[k+i-1] = conjc64(alpha * ab[(i-1)*nmax+j-1])
														} else {
															w[i-1] = alpha * ab[(k+i-1)*nmax+j-1]
															w[k+i-1] = alpha * ab[(i-1)*nmax+j-1]
														}
													}
													cmmch('N', 'N', &lj, func() *int { y := 1; return &y }(), func() *int { y := 2 * k; return &y }(), &one, &ab, func() *int { y := jj - 1; return &y }(), &nmax, &w, &izero, func() *int { y := 2 * nmax; return &y }(), &beta, &c, func() *int { y := jj - 1 + (j-1)*nmax + coff; return &y }(), &nmax, &ct, &g, &cc, func() *int { y := jc - 1 + coff; return &y }(), &ldc, &eps, &err, &fatal, func() *bool { y := true; return &y }(), t)
												}
												if upper {
													jc = jc + ldc
												} else {
													jc = jc + ldc + 1
													if tran {
														jjab = jjab + 2*nmax
													}
												}
												errmax = maxf32(errmax, err)
												//                             If got really bad answer, report and
												//                             return.
												if fatal {
													goto label5140
												}
											}
										}

									}

								}

							}

						label5110:
						}

					}

				label5130:
				}
			}
			//
			//     Report result.
			//
			if errmax < thresh {
				t.Logf(" %6s PASSED THE COMPUTATIONAL TESTS (%6d CALLS)\n", sname, nc)
			} else {
				t.Logf(" %6s COMPLETED THE COMPUTATIONAL TESTS (%6d CALLS)\n ******* BUT WITH MAXIMUM TEST RATIO %8.2f - SUSPECT *******\n", sname, nc, errmax)
			}
			continue
			//
		label5140:
			;
			if n > 1 {
				t.Errorf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)
			}
			//
		label5150:
			;
			t.Errorf(" ******* %6s FAILED ON CALL NUMBER:\n %6d: %6s('%c','%c',%3d,%3d,%4.1f, A,%3d,%3d, B,%3d,%3d,%4.1f, C,%3d,%3d)    .\n", sname, nc, sname, uplo, trans, n, k, alpha, izero, lda, izero, ldb, beta, coff, ldc)
		} else {
			t.Logf(" %6s TEST NOT FOUND\n", sname)
		}
	}
}

func ccompare(len int, ccomp *[]complex64, ccompoff int, ctrue *[]complex64, ctrueoff int, csize *[]complex64, csizeoff int, sfac float32, t *testing.T, fname string) {
	var i int
	scomp := make([]float32, 20)
	ssize := make([]float32, 20)
	strue := make([]float32, 20)

	for i = 1; i <= len; i++ {
		scomp[2*i-1-1] = real((*ccomp)[i-1+ccompoff])
		scomp[2*i-1] = imag((*ccomp)[i-1+ccompoff])
		strue[2*i-1-1] = real((*ctrue)[i-1+ctrueoff])
		strue[2*i-1] = imag((*ctrue)[i-1+ctrueoff])
		ssize[2*i-1-1] = real((*csize)[i-1+csizeoff])
		ssize[2*i-1] = imag((*csize)[i-1+csizeoff])
	}

	scompare(2*len, &scomp, 0, &strue, 0, &ssize, 0, sfac, t, fname)
}

func cbeg(reset *bool) (cbegReturn complex64) {
	var i *int = &common.begc.i
	var ic *int = &common.begc.ic
	var j *int = &common.begc.j
	var mi *int = &common.begc.mi
	var mj *int = &common.begc.mj

	if *reset {
		//        Initialize local variables.
		*mi = 891
		*mj = 457
		*i = 7
		*j = 7
		*ic = 0
		*reset = false
	}
	//
	//     The sequence of values of I or J is bounded between 1 and 999.
	//     If initial I or J = 1,2,3,6,7 or 9, the period will be 50.
	//     If initial I or J = 4 or 8, the period will be 25.
	//     If initial I or J = 5, the period will be 10.
	//     IC is used to break up the period by skipping 1 value of I or J
	//     in 6.
	//
	*ic++
label10:
	;
	*i = (*i) * (*mi)
	*j = (*j) * (*mj)
	*i = (*i) - 1000*((*i)/1000)
	*j = (*j) - 1000*((*j)/1000)
	if *ic >= 5 {
		*ic = 0
		goto label10
	}
	cbegReturn = complex((float32(*i)-500)/1001.0, (float32(*j)-500)/1001.0)
	return
}

func lce(ri *[]complex64, rj *[]complex64, roff, lr *int) bool {
	var i int

	for i = 1; i <= (*lr); i++ {
		if (*ri)[i-1+(*roff)] != (*rj)[i-1+(*roff)] {
			return false
		}
	}
	return true
}

func lceres(_type string, uplo byte, m *int, n *int, aa *[]complex64, as *[]complex64, aoff, lda *int) bool {
	var upper bool
	var i, ibeg, iend, j int

	upper = uplo == 'U'
	if _type == "GE" {
		for j = 1; j <= (*n); j++ {
			for i = (*m) + 1; i <= (*lda); i++ {
				if (*aa)[i-1+(j-1)*(*lda)+(*aoff)] != (*as)[i-1+(j-1)*(*lda)+(*aoff)] {
					return false
				}
			}
		}
	} else if _type == "HE" {
		for j = 1; j <= (*n); j++ {
			if upper {
				ibeg = 1
				iend = j
			} else {
				ibeg = j
				iend = (*n)
			}
			for i = 1; i <= ibeg-1; i++ {
				if (*aa)[i-1+(j-1)*(*lda)+(*aoff)] != (*as)[i-1+(j-1)*(*lda)+(*aoff)] {
					return false
				}
			}
			for i = iend + 1; i <= (*lda); i++ {
				if (*aa)[i-1+(j-1)*(*lda)+(*aoff)] != (*as)[i-1+(j-1)*(*lda)+(*aoff)] {
					return false
				}
			}
		}
	}
	return true
}

func cmakeL2(_type string, uplo byte, diag byte, m *int, n *int, a *[]complex64, nmax *int, aa *[]complex64, aoff, lda *int, kl *int, ku *int, reset *bool, transl *complex64) {
	var i, i1, i2, i3, ibeg, iend, ioff, j, jj, kk int
	var zero complex64 = complex(0.0, 0.0)
	var one complex64 = complex(1.0, 0.0)
	var rogue complex64 = complex(-1e10, 1e10)
	var rzero float32 = 0.0
	var rrogue float32 = -1e10
	var gen bool = _type[0] == 'G'
	var sym bool = _type[0] == 'H'
	var tri bool = _type[0] == 'T'
	var upper bool = (sym || tri) && uplo == 'U'
	var lower bool = (sym || tri) && uplo == 'L'
	var unit bool = tri && diag == 'U'

	//
	//     Generate data in array A.
	//
	for j = 1; j <= (*n); j++ {
		for i = 1; i <= (*m); i++ {
			if gen || (upper && i <= j) || (lower && i >= j) {
				if (i <= j && j-i <= (*ku)) || (i >= j && i-j <= (*kl)) {
					(*a)[i-1+(j-1)*(*nmax)+(*aoff)] = cbeg(reset) + (*transl)
				} else {
					(*a)[i-1+(j-1)*(*nmax)+(*aoff)] = zero
				}
				if i != j {
					if sym {
						(*a)[j-1+(i-1)*(*nmax)+(*aoff)] = conjc64((*a)[i-1+(j-1)*(*nmax)+(*aoff)])
					} else if tri {
						(*a)[j-1+(i-1)*(*nmax)+(*aoff)] = zero
					}
				}
			}
		}
		if sym {
			(*a)[j-1+(j-1)*(*nmax)+(*aoff)] = complex(real((*a)[j-1+(j-1)*(*nmax)+(*aoff)]), rzero)
		}
		if tri {
			(*a)[j-1+(j-1)*(*nmax)+(*aoff)] = (*a)[j-1+(j-1)*(*nmax)+(*aoff)] + one
		}
		if unit {
			(*a)[j-1+(j-1)*(*nmax)+(*aoff)] = one
		}
	}
	//
	//     Store elements in array AS in data structure required by routine.
	//
	if _type == "GE" {
		for j = 1; j <= (*n); j++ {
			for i = 1; i <= (*m); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i = (*m) + 1; i <= (*lda); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
		}
	} else if _type == "GB" {
		for j = 1; j <= (*n); j++ {
			for i1 = 1; i1 <= (*ku)+1-j; i1++ {
				(*aa)[i1+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
			for i2 = i1; i2 <= minint((*kl)+(*ku)+1, (*ku)+1+(*m)-j); i2++ {
				(*aa)[i2+(j-1)*(*lda)-1+(*aoff)] = (*a)[i2+j-(*ku)-1-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i3 = i2; i3 <= (*lda); i3++ {
				(*aa)[i3+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
		}
	} else if _type == "HE" || _type == "TR" {
		for j = 1; j <= (*n); j++ {
			if upper {
				ibeg = 1
				if unit {
					iend = j - 1
				} else {
					iend = j
				}
			} else {
				if unit {
					ibeg = j + 1
				} else {
					ibeg = j
				}
				iend = (*n)
			}
			for i = 1; i <= ibeg-1; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
			for i = ibeg; i <= iend; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i = iend + 1; i <= (*lda); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
			if sym {
				jj = j + (j-1)*(*lda)
				(*aa)[jj-1+(*aoff)] = complex(real((*aa)[jj-1+(*aoff)]), rrogue)
			}
		}
	} else if _type == "HB" || _type == "TB" {
		for j = 1; j <= (*n); j++ {
			if upper {
				kk = (*kl) + 1
				ibeg = maxint(1, (*kl)+2-j)
				if unit {
					iend = (*kl)
				} else {
					iend = (*kl) + 1
				}
			} else {
				kk = 1
				if unit {
					ibeg = 2
				} else {
					ibeg = 1
				}
				iend = minint((*kl)+1, 1+(*m)-j)
			}
			for i = 1; i <= ibeg-1; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
			for i = ibeg; i <= iend; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = (*a)[i+j-kk-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i = iend + 1; i <= (*lda); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aoff)] = rogue
			}
			if sym {
				jj = kk + (j-1)*(*lda)
				(*aa)[jj-1+(*aoff)] = complex(real((*aa)[jj-1+(*aoff)]), rrogue)
			}
		}
	} else if _type == "HP" || _type == "TP" {
		ioff = 0
		for j = 1; j <= (*n); j++ {
			if upper {
				ibeg = 1
				iend = j
			} else {
				ibeg = j
				iend = (*n)
			}
			for i = ibeg; i <= iend; i++ {
				ioff = ioff + 1
				(*aa)[ioff-1+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
				if i == j {
					if unit {
						(*aa)[ioff-1+(*aoff)] = rogue
					}
					if sym {
						(*aa)[ioff-1+(*aoff)] = complex(real((*aa)[ioff-1+(*aoff)]), rrogue)
					}
				}
			}
		}
	}
}

func cmakeL3(_type string, uplo byte, diag byte, m *int, n *int, a *[]complex64, aoff, nmax *int, aa *[]complex64, aaoff, lda *int, reset *bool, transl *complex64) {
	var i, ibeg, iend, j, jj int
	var zero complex64 = (0.0 + 0.0*1i)
	var one complex64 = (1.0 + 0.0*1i)
	var rogue complex64 = (-1e10 + 1e10*1i)
	var rzero float32 = 0.0
	var rrogue float32 = -1e10
	var gen bool = _type == "GE"
	var her bool = _type == "HE"
	var sym bool = _type == "SY"
	var tri bool = _type == "TR"
	var upper bool = (her || sym || tri) && uplo == 'U'
	var lower bool = (her || sym || tri) && uplo == 'L'
	var unit bool = tri && diag == 'U'

	//
	//     Generate data in array A.
	//
	for j = 1; j <= (*n); j++ {
		for i = 1; i <= (*m); i++ {
			if gen || (upper && i <= j) || (lower && i >= j) {
				(*a)[i-1+(j-1)*(*nmax)+(*aoff)] = cbeg(reset) + (*transl)
				if i != j {
					//                 Set some elements to zero
					if (*n) > 3 && j == (*n)/2 {
						(*a)[i-1+(j-1)*(*nmax)+(*aoff)] = zero
					}
					if her {
						(*a)[j-1+(i-1)*(*nmax)+(*aoff)] = conjc64((*a)[i-1+(j-1)*(*nmax)+(*aoff)])
					} else if sym {
						(*a)[j-1+(i-1)*(*nmax)+(*aoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
					} else if tri {
						(*a)[j-1+(i-1)*(*nmax)+(*aoff)] = zero
					}
				}
			}
		}
		if her {
			(*a)[j-1+(j-1)*(*nmax)+(*aoff)] = complex(real((*a)[j-1+(j-1)*(*nmax)+(*aoff)]), rzero)
		}
		if tri {
			(*a)[j-1+(j-1)*(*nmax)+(*aoff)] = (*a)[j-1+(j-1)*(*nmax)+(*aoff)] + one
		}
		if unit {
			(*a)[j-1+(j-1)*(*nmax)+(*aoff)] = one
		}
	}
	//
	//     Store elements in array AS in data structure required by routine.
	//
	if _type == "GE" {
		for j = 1; j <= (*n); j++ {
			for i = 1; i <= (*m); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aaoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i = (*m) + 1; i <= (*lda); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aaoff)] = rogue
			}
		}
	} else if _type == "HE" || _type == "SY" || _type == "TR" {
		for j = 1; j <= (*n); j++ {
			if upper {
				ibeg = 1
				if unit {
					iend = j - 1
				} else {
					iend = j
				}
			} else {
				if unit {
					ibeg = j + 1
				} else {
					ibeg = j
				}
				iend = (*n)
			}
			for i = 1; i <= ibeg-1; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aaoff)] = rogue
			}
			for i = ibeg; i <= iend; i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aaoff)] = (*a)[i-1+(j-1)*(*nmax)+(*aoff)]
			}
			for i = iend + 1; i <= (*lda); i++ {
				(*aa)[i+(j-1)*(*lda)-1+(*aaoff)] = rogue
			}
			if her {
				jj = j + (j-1)*(*lda)
				(*aa)[jj-1+(*aaoff)] = complex(real((*aa)[jj-1+(*aaoff)]), rrogue)
			}
		}
	}
}

func cmmch(transa byte, transb byte, m *int, n *int, kk *int, alpha *complex64, a *[]complex64, aoff, lda *int, b *[]complex64, boff, ldb *int, beta *complex64, c *[]complex64, coff, ldc *int, ct *[]complex64, g *[]float32, cc *[]complex64, ccoff, ldcc *int, eps *float32, err *float32, fatal *bool, mv *bool, t *testing.T) {
	var erri float32
	var i, j, k int
	var zero complex64 = (0.0 + 0.0*1i)
	var rzero float32 = 0.0
	var rone float32 = 1.0
	var trana bool = transa == 'T' || transa == 'C'
	var tranb bool = transb == 'T' || transb == 'C'
	var ctrana bool = transa == 'C'
	var ctranb bool = transb == 'C'

	//
	//     Compute expected result, one column at a time, in CT using data
	//     in A, B and C.
	//     Compute gauges in G.
	//
	for j = 1; j <= (*n); j++ {

		for i = 1; i <= (*m); i++ {
			(*ct)[i-1] = zero
			(*g)[i-1] = rzero
		}
		if !trana && !tranb {
			for k = 1; k <= (*kk); k++ {
				for i = 1; i <= (*m); i++ {
					(*ct)[i-1] = (*ct)[i-1] + (*a)[i-1+(k-1)*(*lda)+(*aoff)]*(*b)[k-1+(j-1)*(*ldb)+(*boff)]
					(*g)[i-1] = (*g)[i-1] + abssumc64((*a)[i-1+(k-1)*(*lda)+(*aoff)])*abssumc64((*b)[k-1+(j-1)*(*ldb)+(*boff)])
				}
			}
		} else if trana && !tranb {
			if ctrana {
				for k = 1; k <= (*kk); k++ {
					for i = 1; i <= (*m); i++ {
						(*ct)[i-1] = (*ct)[i-1] + conjc64((*a)[k-1+(i-1)*(*lda)+(*aoff)])*(*b)[k-1+(j-1)*(*ldb)+(*boff)]
						(*g)[i-1] = (*g)[i-1] + abssumc64((*a)[k-1+(i-1)*(*lda)+(*aoff)])*abssumc64((*b)[k-1+(j-1)*(*ldb)+(*boff)])
					}
				}
			} else {
				for k = 1; k <= (*kk); k++ {
					for i = 1; i <= (*m); i++ {
						(*ct)[i-1] = (*ct)[i-1] + (*a)[k-1+(i-1)*(*lda)+(*aoff)]*(*b)[k-1+(j-1)*(*ldb)+(*boff)]
						(*g)[i-1] = (*g)[i-1] + abssumc64((*a)[k-1+(i-1)*(*lda)+(*aoff)])*abssumc64((*b)[k-1+(j-1)*(*ldb)+(*boff)])
					}
				}
			}
		} else if !trana && tranb {
			if ctranb {
				for k = 1; k <= (*kk); k++ {
					for i = 1; i <= (*m); i++ {
						(*ct)[i-1] = (*ct)[i-1] + (*a)[i-1+(k-1)*(*lda)+(*aoff)]*conjc64((*b)[j-1+(k-1)*(*ldb)+(*boff)])
						(*g)[i-1] = (*g)[i-1] + abssumc64((*a)[i-1+(k-1)*(*lda)+(*aoff)])*abssumc64((*b)[j-1+(k-1)*(*ldb)+(*boff)])
					}
				}
			} else {
				for k = 1; k <= (*kk); k++ {
					for i = 1; i <= (*m); i++ {
						(*ct)[i-1] = (*ct)[i-1] + (*a)[i-1+(k-1)*(*lda)+(*aoff)]*(*b)[j-1+(k-1)*(*ldb)+(*boff)]
						(*g)[i-1] = (*g)[i-1] + abssumc64((*a)[i-1+(k-1)*(*lda)+(*aoff)])*abssumc64((*b)[j-1+(k-1)*(*ldb)+(*boff)])
					}
				}
			}
		} else if trana && tranb {
			if ctrana {
				if ctranb {
					for k = 1; k <= (*kk); k++ {
						for i = 1; i <= (*m); i++ {
							(*ct)[i-1] = (*ct)[i-1] + conjc64((*a)[k-1+(i-1)*(*lda)+(*aoff)])*conjc64((*b)[j-1+(k-1)*(*ldb)+(*boff)])
							(*g)[i-1] = (*g)[i-1] + abssumc64((*a)[k-1+(i-1)*(*lda)+(*aoff)])*abssumc64((*b)[j-1+(k-1)*(*ldb)+(*boff)])
						}
					}
				} else {
					for k = 1; k <= (*kk); k++ {
						for i = 1; i <= (*m); i++ {
							(*ct)[i-1] = (*ct)[i-1] + conjc64((*a)[k-1+(i-1)*(*lda)+(*aoff)])*(*b)[j-1+(k-1)*(*ldb)+(*boff)]
							(*g)[i-1] = (*g)[i-1] + abssumc64((*a)[k-1+(i-1)*(*lda)+(*aoff)])*abssumc64((*b)[j-1+(k-1)*(*ldb)+(*boff)])
						}
					}
				}
			} else {
				if ctranb {
					for k = 1; k <= (*kk); k++ {
						for i = 1; i <= (*m); i++ {
							(*ct)[i-1] = (*ct)[i-1] + (*a)[k-1+(i-1)*(*lda)+(*aoff)]*conjc64((*b)[j-1+(k-1)*(*ldb)+(*boff)])
							(*g)[i-1] = (*g)[i-1] + abssumc64((*a)[k-1+(i-1)*(*lda)+(*aoff)])*abssumc64((*b)[j-1+(k-1)*(*ldb)+(*boff)])
						}
					}
				} else {
					for k = 1; k <= (*kk); k++ {
						for i = 1; i <= (*m); i++ {
							(*ct)[i-1] = (*ct)[i-1] + (*a)[k-1+(i-1)*(*lda)+(*aoff)]*(*b)[j-1+(k-1)*(*ldb)+(*boff)]
							(*g)[i-1] = (*g)[i-1] + abssumc64((*a)[k-1+(i-1)*(*lda)+(*aoff)])*abssumc64((*b)[j-1+(k-1)*(*ldb)+(*boff)])
						}
					}
				}
			}
		}
		for i = 1; i <= (*m); i++ {
			(*ct)[i-1] = (*alpha)*(*ct)[i-1] + (*beta)*(*c)[i-1+(j-1)*(*ldc)+(*coff)]
			(*g)[i-1] = abssumc64(*alpha)*(*g)[i-1] + abssumc64(*beta)*abssumc64((*c)[i-1+(j-1)*(*ldc)+(*coff)])
		}
		//
		//        Compute the error ratio for this result.
		//
		(*err) = rzero
		for i = 1; i <= (*m); i++ {
			erri = abssumc64((*ct)[i-1]-(*cc)[i-1+(j-1)*(*ldcc)+(*ccoff)]) / (*eps)
			if (*g)[i-1] != rzero {
				erri = erri / (*g)[i-1]
			}
			(*err) = maxf32(*err, erri)
			if (*err)*sqrtf32(*eps) >= rone {
				goto label230
			}
		}

	}
	//
	//     If the loop completes, all results are at least half accurate.
	goto label250
	//
	//     Report fatal error.
	//
label230:
	;
	(*fatal) = true
	for i = 1; i <= (*m); i++ {
		if *mv {
			t.Errorf(" ******* FATAL ERROR - COMPUTED RESULT IS LESS THAN HALF ACCURATE *******\n                       EXPECTED RESULT                    COMPUTED RESULT\n %7d  (%15.6f,%15.6f)\n", i, (*ct)[i-1], (*cc)[i-1+(j-1)*(*ldcc)+(*ccoff)])
		} else {
			t.Errorf(" ******* FATAL ERROR - COMPUTED RESULT IS LESS THAN HALF ACCURATE *******\n                       EXPECTED RESULT                    COMPUTED RESULT\n %7d  (%15.6f,%15.6f)\n", i, (*cc)[i-1+(j-1)*(*ldcc)+(*ccoff)], (*ct)[i-1])
		}
	}
	if (*n) > 1 {
		t.Logf("      THESE ARE THE RESULTS FOR COLUMN %3d\n", j)
	}

label250:
}

func cmvch(trans byte, m *int, n *int, alpha *complex64, a *[]complex64, aoff, nmax *int, x *[]complex64, xoff, incx *int, beta *complex64, y *[]complex64, yoff, incy *int, yt *[]complex64, g *[]float32, yy *[]complex64, yyoff *int, eps *float32, err *float32, fatal *bool, mv *bool, t *testing.T) {
	var ctran, tran bool
	var erri float32
	var i, incxl, incyl, iy, j, jx, kx, ky, ml, nl int
	var zero complex64 = complex(0.0, 0.0)
	var rzero float32 = 0.0
	var rone float32 = 1.0
	var ione int = 1

	tran = trans == 'T'
	ctran = trans == 'C'
	if tran || ctran {
		ml = (*n)
		nl = (*m)
	} else {
		ml = (*m)
		nl = (*n)
	}
	if (*incx) < 0 {
		kx = nl
		incxl = -1
	} else {
		kx = 1
		incxl = 1
	}
	if (*incy) < 0 {
		ky = ml
		incyl = -1
	} else {
		ky = 1
		incyl = 1
	}
	//
	//     Compute expected result in YT using data in A, X and Y.
	//     Compute gauges in G.
	//
	iy = ky
	for i = 1; i <= ml; i++ {
		(*yt)[iy-1] = zero
		(*g)[iy-1] = rzero
		jx = kx
		if tran {
			for j = 1; j <= nl; j++ {
				(*yt)[iy-1] = (*yt)[iy-1] + (*a)[j-1+(i-1)*(*nmax)+(*aoff)]*(*x)[jx-1+(*xoff)]
				(*g)[iy-1] = (*g)[iy-1] + Scasum(&ione, a, func() *int { y := j - 1 + (i-1)*(*nmax) + (*aoff); return &y }(), &ione)*Scasum(&ione, x, func() *int { y := jx - 1 + (*xoff); return &y }(), &ione)
				jx = jx + incxl
				//Label10:
			}
		} else if ctran {
			for j = 1; j <= nl; j++ {
				(*yt)[iy-1] = (*yt)[iy-1] + conjc64((*a)[j-1+(i-1)*(*nmax)+(*aoff)])*(*x)[jx-1+(*xoff)]
				(*g)[iy-1] = (*g)[iy-1] + Scasum(&ione, a, func() *int { y := j - 1 + (i-1)*(*nmax) + (*aoff); return &y }(), &ione)*Scasum(&ione, x, func() *int { y := jx - 1 + (*xoff); return &y }(), &ione)
				jx = jx + incxl
				//Label20:
			}
		} else {
			for j = 1; j <= nl; j++ {
				(*yt)[iy-1] = (*yt)[iy-1] + (*a)[i-1+(j-1)*(*nmax)+(*aoff)]*(*x)[jx-1+(*xoff)]
				(*g)[iy-1] = (*g)[iy-1] + Scasum(&ione, a, func() *int { y := i - 1 + (j-1)*(*nmax) + (*aoff); return &y }(), &ione)*Scasum(&ione, x, func() *int { y := jx - 1 + (*xoff); return &y }(), &ione)
				jx = jx + incxl
				//Label30:
			}
		}
		(*yt)[iy-1] = (*alpha)*(*yt)[iy-1] + (*beta)*(*y)[iy-1+(*yoff)]
		(*g)[iy-1] = (absf32(real(*alpha))+absf32(imag(*alpha)))*(*g)[iy-1] + (absf32(real(*beta))+absf32(imag(*beta)))*Scasum(&ione, y, func() *int { y := iy - 1 + (*yoff); return &y }(), &ione)
		iy = iy + incyl
		//Label40:
	}
	//
	//     Compute the error ratio for this result.
	//
	(*err) = rzero
	for i = 1; i <= ml; i++ {
		erri = absc64((*yt)[i-1]-(*yy)[1+(i-1)*absint(*incy)-1+(*yyoff)]) / (*eps)
		if (*g)[i-1] != rzero {
			erri = erri / (*g)[i-1]
		}
		(*err) = maxf32(*err, erri)
		if (*err)*sqrtf32(*eps) >= rone {
			goto label60
		}
	}
	//     If the loop completes, all results are at least half accurate.
	return
	//
	//     Report fatal error.
	//
label60:
	;
	(*fatal) = true
	for i = 1; i <= ml; i++ {
		if *mv {
			t.Errorf(" ******* FATAL ERROR - COMPUTED RESULT IS LESS THAN HALF ACCURATE *******\n           EXPECTED RESULT   COMPUTED RESULT\n %7d%18.6f%18.6f\n", i, (*yt)[i-1], (*yy)[1+(i-1)*absint(*incy)-1+(*yyoff)])
		} else {
			t.Errorf(" ******* FATAL ERROR - COMPUTED RESULT IS LESS THAN HALF ACCURATE *******\n           EXPECTED RESULT   COMPUTED RESULT\n %7d%18.6f%18.6f\n", i, (*yy)[1+(i-1)*absint(*incy)-1+(*yyoff)], (*yt)[i-1])
		}
	}
}
