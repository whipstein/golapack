package goblas

import (
	"fmt"
	"testing"
)

var dglobal float64
var resglobal float64
var res2global int

// BLAS Level 1
func TestDrotg(t *testing.T) {
	tname := "Drotg"
	sa := new(float64)
	sb := new(float64)
	sc := new(float64)
	ss := new(float64)
	var n, nc int
	var drotgTests = []struct {
		sa     float64
		sb     float64
		satrue float64
		sbtrue float64
		sc     float64
		ss     float64
	}{
		{0.3000, 0.4000, 0.5000, 1.0 / 0.6, 0.6000, 0.8000},
		{0.4000, 0.3000, 0.5000, 0.6000, 0.8000, 0.6000},
		{-0.3000, 0.4000, 0.5000, -1.0 / 0.6, -0.6000, 0.8000},
		{-0.4000, 0.3000, -0.5000, -0.6000, 0.8000, -0.6000},
		{-0.3000, -0.4000, -0.5000, 1.0 / 0.6, 0.6000, 0.8000},
		{0.0000, 0.0000, 0.0000, 0.0000, 1.0000, 0.0000},
		{0.0000, 1.0000, 1.0000, 1.0000, 0.0000, 1.0000},
		{1.0000, 0.0000, 1.0000, 0.0000, 1.0000, 0.0000},
	}

	for _, test := range drotgTests {
		n++
		*sa = test.sa
		*sb = test.sb
		*sc = test.sc
		*ss = test.ss
		nc++
		Drotg(_C, sa, sb, sc, ss)
		if absf64(dfac*((*sa)-test.satrue)) > absf64(test.satrue)*epsilonf64()+1e-9 {
			t.Errorf("Test Failed: sa: test %d: {%10.8f} input, {%10.8f} output, {%10.8f} expected", n, test.sa, *sa, test.satrue)
		}
		if absf64(dfac*((*sb)-test.sbtrue)) > absf64(test.sbtrue)*epsilonf64()+1e-9 {
			t.Errorf("Test Failed: sb: test %d: {%10.8f} input, {%10.8f} output, {%10.8f} expected", n, test.sb, *sb, test.sbtrue)
		}
		if absf64(dfac*((*sc)-test.sc)) > absf64(test.sc)*epsilonf64()+1e-9 {
			t.Errorf("Test Failed: sc: test %d: {%10.8f} output, {%10.8f} expected", n, *sc, test.sc)
		}
		if absf64(dfac*((*ss)-test.ss)) > absf64(test.ss)*epsilonf64()+1e-9 {
			t.Errorf("Test Failed: ss: test %d: {%10.8f} output, {%10.8f} expected", n, *ss, test.ss)
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDrotg(b *testing.B) {
	sa := new(float64)
	sb := new(float64)
	sc := new(float64)
	ss := new(float64)
	*sa = -0.3
	*sb = 0.4
	*sc = -0.6
	*ss = 0.8

	for i := 0; i < b.N; i++ {
		Drotg(_C, sa, sb, sc, ss)
	}
}

func BenchmarkDrotgFortran(b *testing.B) {
	sa := new(float64)
	sb := new(float64)
	sc := new(float64)
	ss := new(float64)
	*sa = -0.3
	*sb = 0.4
	*sc = -0.6
	*ss = 0.8

	for i := 0; i < b.N; i++ {
		drotgWrapper(sa, sb, sc, ss)
	}
}

func TestDrotmg(t *testing.T) {
	tname := "Drotmg"
	var nc int
	d1 := new(float64)
	d2 := new(float64)
	x := new(float64)
	y := new(float64)
	sparam := func() *[]float64 {
		y := make([]float64, 5)
		return &y
	}()
	var n int
	var drotmgTests = []struct {
		d1         float64
		d2         float64
		x          float64
		y          float64
		d1true     float64
		d2true     float64
		xtrue      float64
		ytrue      float64
		sparamtrue []float64
	}{
		{0.1, 0.3, 1.2, 0.2, 12.0 / 130.0, 36.0 / 130.0, 1.3, 0.2, []float64{0.0, 0.0, -1.0 / 6.0, 0.5, 0.0}},
		{0.7, 0.2, 0.6, 4.2, 14.0 / 75.0, 49.0 / 75.0, 4.5, 4.2, []float64{1.0, 0.5, 0.0, 0.0, 1.0 / 7.0}},
		{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, []float64{-2.0, 0.0, 0.0, 0.0, 0.0}},
		{4.0, -1.0, 2.0, 4.0, 0.0, 0.0, 0.0, 4.0, []float64{-1.0, 0.0, 0.0, 0.0, 0.0}},
		{6e-10, 2e-2, 1e5, 10.0, 45e-11 * (4096.0 * 4096.0), 15e-3, 4e5 / (3.0 * 4096.0), 10.0, []float64{-1.0, 1.0 / 4096.0, -1e-4, 1e4 / (3.0 * 4096.0), 1.0}},
		{4e10, 2e-2, 1e-5, 10.0, 4e10 / (1.5 * 4096.0 * 4096.0), 2e-2 / 1.5, 6144e-5, 10.0, []float64{-1.0, 4096.0, -1e6, 5e-7 * 4096.0, 1.0}},
		{2e-10, 4e-2, 1e5, 10.0, 4.0 / 150.0, (2e-10 / 1.5) * (4096.0 * 4096.0), 15.0, 10.0, []float64{-1.0, 5e-5, -1.0 / 4096.0, 1.0, 1e4 / 4096.0}},
		{2e10, 4e-2, 1e-5, 10.0, 4.0 / 150.0, 2e10 / (1.5 * 4096.0 * 4096.0), 15.0, 10.0, []float64{-1.0, 5e5, -4096.0, 1.0, 4096e-6}},
		{4.0, -2.0, 8.0, 4.0, 32.0 / 7.0, -16.0 / 7.0, 7.0, 4.0, []float64{0.0, 0.0, -.5, -.25, 0.0}},
	}

	for _, test := range drotmgTests {
		n++
		*d1 = test.d1
		*d2 = test.d2
		*x = test.x
		*y = test.y
		*sparam = []float64{0.0, 0.0, 0.0, 0.0, 0.0}
		nc++
		Drotmg(_C, d1, d2, x, y, sparam)
		if absf64(dfac*((*d1)-test.d1true)) > absf64(test.d1true)*epsilonf64()+1e-9 {
			t.Errorf("Test Failed: d1: test %d: {%10.8f} input, {%10.8f} output, {%10.8f} expected", n, test.d1, *d1, test.d1true)
		}
		if absf64(dfac*((*d2)-test.d2true)) > absf64(test.d2true)*epsilonf64()+1e-9 {
			t.Errorf("Test Failed: d2: test %d: {%10.8f} input, {%10.8f} output, {%10.8f} expected", n, test.d2, *d2, test.d2true)
		}
		if absf64(dfac*((*x)-test.xtrue)) > absf64(test.xtrue)*epsilonf64()+1e-9 {
			t.Errorf("Test Failed: x: test %d: {%10.8f} input, {%10.8f} output, {%10.8f} expected", n, test.x, *x, test.xtrue)
		}
		if absf64(dfac*((*y)-test.ytrue)) > absf64(test.ytrue)*epsilonf64()+1e-9 {
			t.Errorf("Test Failed: y: test %d: {%10.8f} input, {%10.8f} output, {%10.8f} expected", n, test.y, *y, test.ytrue)
		}
		for j, val := range test.sparamtrue {
			if absf64(dfac*((*sparam)[j]-val)) > absf64(val)*epsilonf64()+1e-9 {
				t.Errorf("Test Failed: sparam[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, n, (*sparam)[j], val)
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDrotmg(b *testing.B) {
	d1 := new(float64)
	d2 := new(float64)
	x := new(float64)
	y := new(float64)
	sparam := func() *[]float64 {
		y := make([]float64, 5)
		return &y
	}()
	*d1 = 0.1
	*d2 = 0.3
	*x = 1.2
	*y = 0.2

	for i := 0; i < b.N; i++ {
		Drotmg(_C, d1, d2, x, y, sparam)
	}
}

func BenchmarkDrotmgFortran(b *testing.B) {
	d1 := new(float64)
	d2 := new(float64)
	x := new(float64)
	y := new(float64)
	sparam := func() *[]float64 {
		y := make([]float64, 5)
		return &y
	}()
	*d1 = 0.1
	*d2 = 0.3
	*x = 1.2
	*y = 0.2

	for i := 0; i < b.N; i++ {
		drotmgWrapper(d1, d2, x, y, sparam)
	}
}

func TestDnrm2(t *testing.T) {
	tname := "Dnrm2"
	var nc int
	var res float64
	n := new(int)
	incx := new(int)
	sx := func() *[]float64 { y := make([]float64, 8); return &y }()
	var dnrm2Tests = []struct {
		n      int
		incx   int
		len    int
		sa     float64
		sx     []float64
		result float64
	}{
		{0, 1, 2, 0.3, []float64{0.1, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0}, 0.0},
		{0, 2, 2, 0.3, []float64{0.1, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0}, 0.0},
		{1, 1, 2, -1.0, []float64{0.3, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0}, 0.3},
		{1, 2, 2, 0.3, []float64{0.3, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0}, 0.3},
		{2, 1, 4, 0.0, []float64{0.3, -0.4, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0}, 0.5},
		{2, 2, 4, 0.3, []float64{0.3, 2.0, -0.4, 2.0, 2.0, 2.0, 2.0, 2.0}, 0.5},
		{3, 1, 6, 1.0, []float64{0.2, -0.6, 0.3, 5.0, 5.0, 5.0, 5.0, 5.0}, 0.7},
		{3, 2, 6, 0.3, []float64{0.2, 3.0, -0.6, 5.0, 0.3, 2.0, 2.0, 2.0}, 0.7},
		{4, 1, 8, 0.3, []float64{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}, 0.6},
		{4, 2, 8, 0.3, []float64{0.1, 4.0, -0.3, 6.0, -0.5, 7.0, -0.1, 3.0}, 0.6},
	}

	for _, test := range dnrm2Tests {
		*n = test.n
		*incx = test.incx
		for j := 0; j < 8; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		res = Dnrm2(_C, n, sx, incx)
		if absf64(dfac*(res-test.result)) > absf64(test.result)*epsilonf64()+1e-9 {
			t.Errorf("Test Failed: result: test %d: {%10.8f} output, {%10.8f} expected", test.n, res, test.result)
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDnrm2(b *testing.B) {
	var res float64
	n := new(int)
	incx := new(int)
	sx := func() *[]float64 { y := make([]float64, 8); return &y }()
	*n = 0
	*incx = 1
	*sx = []float64{0.1, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0}

	for i := 0; i < b.N; i++ {
		res = Dnrm2(_C, n, sx, incx)
	}
	resglobal = res
}

func BenchmarkDnrm2Fortran(b *testing.B) {
	var res float64
	n := new(int)
	incx := new(int)
	sx := func() *[]float64 { y := make([]float64, 8); return &y }()
	*n = 0
	*incx = 1
	*sx = []float64{0.1, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0}

	for i := 0; i < b.N; i++ {
		res = dnrm2Wrapper(n, sx, incx)
	}
	resglobal = res
}

func TestDasum(t *testing.T) {
	tname := "Dasum"
	var nc int
	var res float64
	n := new(int)
	incx := new(int)
	sx := func() *[]float64 { y := make([]float64, 8); return &y }()
	var dasumTests = []struct {
		n      int
		incx   int
		len    int
		sa     float64
		sx     []float64
		result float64
	}{
		{0, 1, 2, 0.3, []float64{0.1, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0}, 0.0},
		{0, 2, 2, 0.3, []float64{0.1, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0}, 0.0},
		{1, 1, 2, -1.0, []float64{0.3, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0}, 0.3},
		{1, 2, 2, 0.3, []float64{0.3, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0}, 0.3},
		{2, 1, 4, 0.0, []float64{0.3, -0.4, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0}, 0.7},
		{2, 2, 4, 0.3, []float64{0.3, 2.0, -0.4, 2.0, 2.0, 2.0, 2.0, 2.0}, 0.7},
		{3, 1, 6, 1.0, []float64{0.2, -0.6, 0.3, 5.0, 5.0, 5.0, 5.0, 5.0}, 1.1},
		{3, 2, 6, 0.3, []float64{0.2, 3.0, -0.6, 5.0, 0.3, 2.0, 2.0, 2.0}, 1.1},
		{4, 1, 8, 0.3, []float64{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}, 1.0},
		{4, 2, 8, 0.3, []float64{0.1, 4.0, -0.3, 6.0, -0.5, 7.0, -0.1, 3.0}, 1.0},
	}

	for _, test := range dasumTests {
		*n = test.n
		*incx = test.incx
		for j := 0; j < 8; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		res = Dasum(_C, n, sx, incx)
		if absf64(dfac*(res-test.result)) > absf64(test.result)*epsilonf64()+1e-9 {
			t.Errorf("Test Failed: result: test %d: {%10.8f} output, {%10.8f} expected", test.n, res, test.result)
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDasum(b *testing.B) {
	var res float64
	n := new(int)
	incx := new(int)
	sx := func() *[]float64 { y := make([]float64, 8); return &y }()
	*n = 4
	*incx = 2
	*sx = []float64{0.1, 4.0, -0.3, 6.0, -0.5, 7.0, -0.1, 3.0}

	for i := 0; i < b.N; i++ {
		res = Dasum(_C, n, sx, incx)
	}
	resglobal = res
}

func BenchmarkDasumFortran(b *testing.B) {
	var res float64
	n := new(int)
	incx := new(int)
	sx := func() *[]float64 { y := make([]float64, 8); return &y }()
	*n = 4
	*incx = 2
	*sx = []float64{0.1, 4.0, -0.3, 6.0, -0.5, 7.0, -0.1, 3.0}

	for i := 0; i < b.N; i++ {
		res = dasumWrapper(n, sx, incx)
	}
	resglobal = res
}

func TestDscal(t *testing.T) {
	tname := "Dscal"
	var nc int
	n := new(int)
	incx := new(int)
	sa := new(float64)
	sx := func() *[]float64 { y := make([]float64, 8); return &y }()
	var dscalTests = []struct {
		n      int
		incx   int
		len    int
		sa     float64
		sx     []float64
		sxtrue []float64
	}{
		{0, 1, 2, 0.3, []float64{0.1, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0}, []float64{0.10, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0}},
		{0, 2, 2, 0.3, []float64{0.1, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0}, []float64{0.10, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0}},
		{1, 1, 2, -1.0, []float64{0.3, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0}, []float64{-0.3, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0}},
		{1, 2, 2, 0.3, []float64{0.3, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0}, []float64{0.09, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0}},
		{2, 1, 4, 0.0, []float64{0.3, -0.4, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0}, []float64{0.0, 0.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0}},
		{2, 2, 4, 0.3, []float64{0.3, 2.0, -0.4, 2.0, 2.0, 2.0, 2.0, 2.0}, []float64{0.09, 2.0, -0.12, 2.0, 2.0, 2.0, 2.0, 2.0}},
		{3, 1, 6, 1.0, []float64{0.2, -0.6, 0.3, 5.0, 5.0, 5.0, 5.0, 5.0}, []float64{0.20, -0.60, 0.30, 5.0, 5.0, 5.0, 5.0, 5.0}},
		{3, 2, 6, 0.3, []float64{0.2, 3.0, -0.6, 5.0, 0.3, 2.0, 2.0, 2.0}, []float64{0.06, 3.0, -0.18, 5.0, 0.09, 2.0, 2.0, 2.0}},
		{4, 1, 8, 0.3, []float64{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}, []float64{0.03, -0.09, 0.15, -0.03, 6.0, 6.0, 6.0, 6.0}},
		{4, 2, 8, 0.3, []float64{0.1, 4.0, -0.3, 6.0, -0.5, 7.0, -0.1, 3.0}, []float64{0.03, 4.0, -0.09, 6.0, -0.15, 7.0, -0.03, 3.0}},
	}

	for _, test := range dscalTests {
		*n = test.n
		*incx = test.incx
		*sa = test.sa
		for j := 0; j < 8; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		Dscal(_C, n, sa, sx, incx)
		for j, val := range test.sxtrue {
			if absf64(dfac*((*sx)[j]-val)) > absf64(val)*epsilonf64()+1e-9 {
				t.Errorf("Test Failed: sx[%d]: test %d: {%10.8f} input, {%10.8f} output, {%10.8f} expected", j, n, test.sx, *sx, val)
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDscal(b *testing.B) {
	n := new(int)
	incx := new(int)
	sa := new(float64)
	sx := func() *[]float64 { y := make([]float64, 8); return &y }()
	*n = 4
	*incx = 1
	*sa = 0.3
	*sx = []float64{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}

	for i := 0; i < b.N; i++ {
		Dscal(_C, n, sa, sx, incx)
	}
}

func BenchmarkDscalFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	sa := new(float64)
	sx := func() *[]float64 { y := make([]float64, 8); return &y }()
	*n = 4
	*incx = 1
	*sa = 0.3
	*sx = []float64{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}

	for i := 0; i < b.N; i++ {
		dscalWrapper(n, sa, sx, incx)
	}
}

func TestIdamax(t *testing.T) {
	tname := "Idamax"
	var nc, res int
	n := new(int)
	incx := new(int)
	sx := func() *[]float64 { y := make([]float64, 8); return &y }()
	var isamaxTests = []struct {
		n     int
		incx  int
		len   int
		sa    float64
		sx    []float64
		ntrue int
	}{
		{0, 1, 2, 0.3, []float64{0.1, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0}, 0},
		{0, 2, 2, 0.3, []float64{0.1, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0}, 0},
		{1, 1, 2, -1.0, []float64{0.3, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0}, 1},
		{1, 2, 2, 0.3, []float64{0.3, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0}, 1},
		{2, 1, 4, 0.0, []float64{0.3, -0.4, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0}, 2},
		{2, 2, 4, 0.3, []float64{0.3, 2.0, -0.4, 2.0, 2.0, 2.0, 2.0, 2.0}, 2},
		{3, 1, 6, 1.0, []float64{0.2, -0.6, 0.3, 5.0, 5.0, 5.0, 5.0, 5.0}, 2},
		{3, 2, 6, 0.3, []float64{0.2, 3.0, -0.6, 5.0, 0.3, 2.0, 2.0, 2.0}, 2},
		{4, 1, 8, 0.3, []float64{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}, 3},
		{4, 2, 8, 0.3, []float64{0.1, 4.0, -0.3, 6.0, -0.5, 7.0, -0.1, 3.0}, 3},
	}

	for _, test := range isamaxTests {
		*n = test.n
		*incx = test.incx
		for j := 0; j < 8; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		res = Idamax(_C, n, sx, incx)
		if res != test.ntrue {
			t.Errorf("Test Failed: result: test %d: {%d} output, {%d} expected", test.n, res, test.ntrue)
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkIdamax(b *testing.B) {
	var res int
	n := new(int)
	incx := new(int)
	sx := func() *[]float64 { y := make([]float64, 8); return &y }()
	*n = 4
	*incx = 1
	*sx = []float64{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}

	for i := 0; i < b.N; i++ {
		res = Idamax(_C, n, sx, incx)
	}
	res2global = res
}

func BenchmarkIdamaxFortran(b *testing.B) {
	var res int
	n := new(int)
	incx := new(int)
	sx := func() *[]float64 { y := make([]float64, 8); return &y }()
	*n = 4
	*incx = 1
	*sx = []float64{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}

	for i := 0; i < b.N; i++ {
		res = idamaxWrapper(n, sx, incx)
	}
	res2global = res
}

func TestDdot(t *testing.T) {
	tname := "Ddot"
	var nc int
	var res float64
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float64 { y := make([]float64, 7); return &y }()
	sy := func() *[]float64 { y := make([]float64, 7); return &y }()
	var ddotTests = []struct {
		n      int
		lenx   int
		leny   int
		sa     float64
		sx     []float64
		incx   int
		sy     []float64
		incy   int
		result float64
		size   float64
	}{
		{0, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.0000, 0.0000},
		{1, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.3000, 0.3000},
		{2, 2, 2, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.2100, 1.6000},
		{4, 4, 4, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.6200, 3.2000},
		{0, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.0000, 0.0000},
		{1, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.3000, 0.3000},
		{2, 3, 3, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, -0.0700, 1.6000},
		{4, 7, 7, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8500, 3.2000},
		{0, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.0000, 0.0000},
		{1, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.3000, 0.3000},
		{2, 3, 2, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, -0.7900, 1.6000},
		{4, 7, 4, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, -0.7400, 3.2000},
		{0, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.0000, 0.0000},
		{1, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.3000, 0.3000},
		{2, 2, 3, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.3300, 1.6000},
		{4, 4, 7, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 1.2700, 3.2000},
	}

	for _, test := range ddotTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		res = Ddot(_C, n, sx, incx, sy, incy)
		if absf64(dfac*(res-test.result)) > absf64(test.size)*epsilonf64()+1e-9 {
			t.Errorf("Test Failed: result: test %d: {%10.8f} output, {%10.8f} expected", test.n, res, test.result)
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDdot(b *testing.B) {
	var res float64
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float64 { y := make([]float64, 7); return &y }()
	sy := func() *[]float64 { y := make([]float64, 7); return &y }()
	*n = 4
	*sx = []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		res = Ddot(_C, n, sx, incx, sy, incy)
	}
	resglobal = res
}

func BenchmarkDdotFortran(b *testing.B) {
	var res float64
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float64 { y := make([]float64, 7); return &y }()
	sy := func() *[]float64 { y := make([]float64, 7); return &y }()
	*n = 4
	*sx = []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		res = ddotWrapper(n, sx, incx, sy, incy)
	}
	resglobal = res
}

func TestDaxpy(t *testing.T) {
	tname := "Daxpy"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	sa := new(float64)
	sx := func() *[]float64 { y := make([]float64, 7); return &y }()
	sy := func() *[]float64 { y := make([]float64, 7); return &y }()
	var daxpyTests = []struct {
		n     int
		lenx  int
		leny  int
		sa    float64
		sx    []float64
		incx  int
		sy    []float64
		incy  int
		strue []float64
		size  []float64
	}{
		{0, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.6800, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 2, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.6800, -0.8700, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 4, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.6800, -0.8700, 0.1500, 0.9400, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.5000, -0.8700, 0.1500, 0.9400, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.6800, -0.8700, 0.1500, 0.9400, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 3, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.3500, -0.9000, 0.4800, 0.9400, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 7, 7, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.3800, -0.9000, 0.5700, 0.7000, -0.7500, 0.2000, 0.9800}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.5000, -0.9000, 0.5700, 0.7000, -0.7500, 0.2000, 0.9800}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.6800, -0.9000, 0.5700, 0.7000, -0.7500, 0.2000, 0.9800}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 2, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.3500, -0.7200, 0.5700, 0.7000, -0.7500, 0.2000, 0.9800}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 7, 4, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.3800, -0.6300, 0.1500, 0.8800, -0.7500, 0.2000, 0.9800}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.5000, -0.6300, 0.1500, 0.8800, -0.7500, 0.2000, 0.9800}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.6800, -0.6300, 0.1500, 0.8800, -0.7500, 0.2000, 0.9800}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 3, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.6800, -0.9000, 0.3300, 0.8800, -0.7500, 0.2000, 0.9800}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 7, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.6800, -0.9000, 0.3300, 0.7000, -0.7500, 0.2000, 1.0400}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
	}

	for _, test := range daxpyTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		*sa = test.sa
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		Daxpy(_C, n, sa, sx, incx, sy, incy)
		for j := 0; j < test.leny; j++ {
			if absf64(dfac*((*sy)[j]-test.strue[j])) > absf64(test.size[j])*epsilonf64()+1e-9 {
				t.Errorf("Test Failed: sy[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, test.n, (*sy)[j], test.strue[j])
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDaxpy(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sa := new(float64)
	sx := func() *[]float64 { y := make([]float64, 7); return &y }()
	sy := func() *[]float64 { y := make([]float64, 7); return &y }()
	*n = 4
	*sa = 0.3
	*sx = []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = -1
	*sy = []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Daxpy(_C, n, sa, sx, incx, sy, incy)
	}
}

func BenchmarkDaxpyFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sa := new(float64)
	sx := func() *[]float64 { y := make([]float64, 7); return &y }()
	sy := func() *[]float64 { y := make([]float64, 7); return &y }()
	*n = 4
	*sa = 0.3
	*sx = []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = -1
	*sy = []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		daxpyWrapper(n, sa, sx, incx, sy, incy)
	}
}

func TestDcopy(t *testing.T) {
	tname := "Dcopy"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float64 { y := make([]float64, 7); return &y }()
	sy := func() *[]float64 { y := make([]float64, 7); return &y }()
	var dcopyTests = []struct {
		n     int
		lenx  int
		leny  int
		sa    float64
		sx    []float64
		incx  int
		sy    []float64
		incy  int
		strue []float64
		size  []float64
	}{
		{0, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 2, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.6000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 4, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 3, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-0.5000, -0.9000, 0.6000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 7, 7, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-0.4000, -0.9000, 0.9000, 0.7000, -0.5000, 0.2000, 0.6000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 2, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-0.5000, 0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 7, 4, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-0.4000, 0.9000, -0.5000, 0.6000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 3, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.6000, -0.9000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 7, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.6000, -0.9000, 0.1000, 0.7000, -0.5000, 0.2000, 0.8000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
	}

	for _, test := range dcopyTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		Dcopy(_C, n, sx, incx, sy, incy)
		for j := 0; j < test.leny; j++ {
			if absf64(dfac*((*sy)[j]-test.strue[j])) > absf64(test.size[j])*epsilonf64()+1e-9 {
				t.Errorf("Test Failed: sy[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, test.n, (*sy)[j], test.strue[j])
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDcopy(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float64 { y := make([]float64, 7); return &y }()
	sy := func() *[]float64 { y := make([]float64, 7); return &y }()
	*n = 4
	*sx = []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Dcopy(_C, n, sx, incx, sy, incy)
	}
}

func BenchmarkDcopyFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float64 { y := make([]float64, 7); return &y }()
	sy := func() *[]float64 { y := make([]float64, 7); return &y }()
	*n = 4
	*sx = []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		dcopyWrapper(n, sx, incx, sy, incy)
	}
}

func TestDswap(t *testing.T) {
	tname := "Dswap"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float64 { y := make([]float64, 7); return &y }()
	sy := func() *[]float64 { y := make([]float64, 7); return &y }()
	var dswapTests = []struct {
		n      int
		lenx   int
		leny   int
		sa     float64
		sx     []float64
		incx   int
		sy     []float64
		incy   int
		sxtrue []float64
		sytrue []float64
		size   []float64
	}{
		{0, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 2, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.5000, -0.9000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 4, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 3, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.3000, 0.1000, 0.5000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-0.5000, -0.9000, 0.6000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 7, 7, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.8000, 0.1000, -0.6000, 0.8000, 0.3000, -0.3000, 0.5000}, []float64{-0.4000, -0.9000, 0.9000, 0.7000, -0.5000, 0.2000, 0.6000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 2, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-0.9000, 0.1000, 0.5000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-0.5000, 0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 7, 4, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.7000, 0.1000, 0.3000, 0.8000, -0.9000, -0.3000, 0.5000}, []float64{-0.4000, 0.9000, -0.5000, 0.6000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 3, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.5000, 0.3000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, -0.9000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 7, 0.3000, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.5000, 0.3000, -0.6000, 0.8000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, -0.9000, 0.1000, 0.7000, -0.5000, 0.2000, 0.8000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
	}

	for _, test := range dswapTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		Dswap(_C, n, sx, incx, sy, incy)
		for j := 0; j < test.lenx; j++ {
			if absf64(dfac*((*sx)[j]-test.sxtrue[j])) > absf64(test.size[j])*epsilonf64()+1e-9 {
				t.Errorf("Test Failed: sx[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, test.n, (*sx)[j], test.sxtrue[j])
			}
		}
		for j := 0; j < test.leny; j++ {
			if absf64(dfac*((*sy)[j]-test.sytrue[j])) > absf64(test.size[j])*epsilonf64()+1e-9 {
				t.Errorf("Test Failed: sx[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, test.n, (*sy)[j], test.sytrue[j])
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDswap(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float64 { y := make([]float64, 7); return &y }()
	sy := func() *[]float64 { y := make([]float64, 7); return &y }()
	*n = 4
	*sx = []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Dswap(_C, n, sx, incx, sy, incy)
	}
}

func BenchmarkDswapFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float64 { y := make([]float64, 7); return &y }()
	sy := func() *[]float64 { y := make([]float64, 7); return &y }()
	*n = 4
	*sx = []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		dswapWrapper(n, sx, incx, sy, incy)
	}
}

func TestDrotm(t *testing.T) {
	tname := "Drotm"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float64 { y := make([]float64, 7); return &y }()
	sy := func() *[]float64 { y := make([]float64, 7); return &y }()
	temp := func() *[]float64 { y := make([]float64, 5); return &y }()
	var drotmTests = []struct {
		n      int
		lenx   int
		leny   int
		sx     []float64
		incx   int
		sy     []float64
		incy   int
		dtemp  []float64
		sxtrue []float64
		sytrue []float64
		size   []float64
	}{
		{0, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float64{-0.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-0.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float64{-0.9000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{1.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-0.9000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float64{3.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-2.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{3.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 2, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, -0.9000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 2, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float64{-0.8000, 3.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.7000, -4.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-0.8000, 3.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 2, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float64{-0.9000, 2.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{1.7000, -0.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-0.9000, 2.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 2, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float64{3.5000, -0.4000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-2.6000, 3.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{3.5000, -0.4000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 4, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, -0.9000, 0.3000, 0.7000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 4, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float64{-0.8000, 3.8000, -2.2000, -1.2000, 0.0000, 0.0000, 0.0000}, []float64{0.7000, -4.8000, 3.0000, 1.1000, 0.0000, 0.0000, 0.0000}, []float64{-0.8000, 3.8000, -2.2000, -1.2000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 4, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float64{-0.9000, 2.8000, -1.4000, -1.3000, 0.0000, 0.0000, 0.0000}, []float64{1.7000, -0.7000, -0.7000, 2.3000, 0.0000, 0.0000, 0.0000}, []float64{-0.9000, 2.8000, -1.4000, -1.3000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 4, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float64{3.5000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}, []float64{-2.6000, 3.5000, -0.7000, -3.6000, 0.0000, 0.0000, 0.0000}, []float64{3.5000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float64{-0.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-0.8000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float64{-0.9000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{1.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-0.9000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float64{3.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-2.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{3.5000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 3, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -0.5000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, -0.9000, 0.3000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -0.5000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 3, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float64{0.0000, 0.1000, -3.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{4.0000, -0.9000, -0.3000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{2.4000, 0.1000, -3.0000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 3, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float64{-0.3000, 0.1000, -2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-0.5000, -0.9000, 1.5000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-0.3000, 0.1000, -2.0000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 3, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float64{3.3000, 0.1000, -2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-1.5000, -0.9000, -1.8000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{3.3000, 0.1000, -2.0000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{4, 7, 7, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}},
		{4, 7, 7, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float64{-2.0000, 0.1000, 1.4000, 0.8000, 0.6000, -0.3000, -2.8000}, []float64{3.7000, -0.9000, -1.2000, 0.7000, -1.5000, 0.2000, 2.2000}, []float64{-2.0000, 0.1000, 1.4000, 0.8000, 0.6000, -0.3000, -2.8000}},
		{4, 7, 7, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float64{-1.8000, 0.1000, 1.3000, 0.8000, 0.0000, -0.3000, -1.9000}, []float64{-0.3000, -0.9000, 2.1000, 0.7000, -1.6000, 0.2000, 2.0000}, []float64{-1.8000, 0.1000, 1.3000, 0.8000, 1.8000, -0.3000, -1.9000}},
		{4, 7, 7, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float64{3.8000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}, []float64{-1.6000, -0.9000, -2.1000, 0.7000, 2.9000, 0.2000, -3.8000}, []float64{3.8000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{0, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{0, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{0, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{0, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float64{-0.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-0.8000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float64{-0.9000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{1.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-0.9000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float64{3.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-2.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{3.5000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{2, 3, 2, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -0.5000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, -0.9000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -0.5000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{2, 3, 2, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float64{4.8000, 0.1000, -3.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{4.0000, -6.3000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{4.8000, 0.1000, -3.0000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{2, 3, 2, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float64{3.3000, 0.1000, -2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-0.5000, 0.3000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{3.3000, 0.1000, -2.0000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{2, 3, 2, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float64{2.1000, 0.1000, -2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-1.5000, 3.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{2.1000, 0.1000, -2.0000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{4, 7, 4, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, []float64{0.5000, -0.9000, 0.3000, 0.7000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}},
		{4, 7, 4, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float64{-1.6000, 0.1000, -2.2000, 0.8000, 5.4000, -0.3000, -2.8000}, []float64{3.7000, -7.2000, 3.0000, 1.7000, 0.0000, 0.0000, 0.0000}, []float64{-1.6000, 0.1000, -2.2000, 0.8000, 5.4000, -0.3000, -2.8000}},
		{4, 7, 4, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float64{-1.5000, 0.1000, -1.4000, 0.8000, 3.6000, -0.3000, -1.9000}, []float64{-0.3000, 0.9000, -0.7000, 1.9000, 0.0000, 0.0000, 0.0000}, []float64{-1.5000, 0.1000, -1.4000, 0.8000, 3.6000, -0.3000, -1.9000}},
		{4, 7, 4, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float64{3.7000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}, []float64{-1.6000, 2.7000, -0.7000, -3.4000, 0.0000, 0.0000, 0.0000}, []float64{3.7000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{0, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{0, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{0, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{0, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float64{-0.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-0.8000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float64{-0.9000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{1.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-0.9000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float64{3.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-2.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{3.5000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{2, 2, 3, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, -0.9000, 0.3000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{2, 2, 3, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float64{-0.8000, -1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.7000, -0.9000, 1.2000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-0.8000, -1.0000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{2, 2, 3, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float64{-0.9000, -0.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{1.7000, -0.9000, 0.5000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-0.9000, -0.8000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{2, 2, 3, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float64{3.5000, 0.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{-2.6000, -0.9000, -1.3000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{3.5000, 0.8000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{4, 4, 7, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, []float64{0.6000, 0.1000, -0.5000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{4, 4, 7, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float64{-0.8000, -1.0000, 1.4000, -1.6000, 0.0000, 0.0000, 0.0000}, []float64{0.7000, -0.9000, 1.2000, 0.7000, -1.5000, 0.2000, 1.6000}, []float64{-0.8000, -1.0000, 1.4000, -1.6000, 3.6000, -0.3000, -1.5000}},
		{4, 4, 7, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float64{-0.9000, -0.8000, 1.3000, -1.6000, 0.0000, 0.0000, 0.0000}, []float64{1.7000, -0.9000, 0.5000, 0.7000, -1.6000, 0.2000, 2.4000}, []float64{-0.9000, -0.8000, 1.3000, -1.6000, 3.6000, -0.3000, -1.5000}},
		{4, 4, 7, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float64{3.5000, 0.8000, -3.1000, 4.8000, 0.0000, 0.0000, 0.0000}, []float64{-2.6000, -0.9000, -1.3000, 0.7000, 2.9000, 0.2000, -4.0000}, []float64{3.5000, 0.8000, -3.1000, 4.8000, 3.6000, -0.3000, -1.5000}},
	}

	for _, test := range drotmTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		for j := 0; j < 5; j++ {
			(*temp)[j] = test.dtemp[j]
		}
		nc++
		Drotm(_C, n, sx, incx, sy, incy, temp)
		for j := 0; j < test.lenx; j++ {
			if absf64(dfac*((*sx)[j]-test.sxtrue[j])) > absf64(test.size[j])*epsilonf64()+1e-9 {
				t.Errorf("Test Failed: sx[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, test.n, (*sx)[j], test.sxtrue[j])
			}
		}
		for j := 0; j < test.leny; j++ {
			if absf64(dfac*((*sy)[j]-test.sytrue[j])) > absf64(test.sytrue[j])*epsilonf64()+1e-9 {
				t.Errorf("Test Failed: sy[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, test.n, (*sy)[j], test.sytrue[j])
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDrotm(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float64 { y := make([]float64, 7); return &y }()
	sy := func() *[]float64 { y := make([]float64, 7); return &y }()
	dtemp := func() *[]float64 { y := make([]float64, 5); return &y }()
	*n = 4
	*sx = []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2
	*dtemp = []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}

	for i := 0; i < b.N; i++ {
		Drotm(_C, n, sx, incx, sy, incy, dtemp)
	}
}

func BenchmarkDrotmFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float64 { y := make([]float64, 7); return &y }()
	sy := func() *[]float64 { y := make([]float64, 7); return &y }()
	dtemp := func() *[]float64 { y := make([]float64, 5); return &y }()
	*n = 4
	*sx = []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2
	*dtemp = []float64{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}

	for i := 0; i < b.N; i++ {
		drotmWrapper(n, sx, incx, sy, incy, dtemp)
	}
}

func TestDsdot(t *testing.T) {
	tname := "Dsdot"
	var nc int
	var res float64
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	var dsdotTests = []struct {
		n      int
		sx     []float32
		incx   int
		sy     []float32
		incy   int
		result float64
		size   float64
	}{
		{0, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.0000, 0.0000},
		{1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.3000, 0.3000},
		{2, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.2100, 1.6000},
		{4, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.6200, 3.2000},
		{0, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.0000, 0.0000},
		{1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.3000, 0.3000},
		{2, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, -0.0700, 1.6000},
		{4, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8500, 3.2000},
		{0, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.0000, 0.0000},
		{1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.3000, 0.3000},
		{2, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, -0.7900, 1.6000},
		{4, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, -0.7400, 3.2000},
		{0, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.0000, 0.0000},
		{1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.3000, 0.3000},
		{2, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.3300, 1.6000},
		{4, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 1.2700, 3.2000},
	}

	for _, test := range dsdotTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		res = Dsdot(_C, n, sx, incx, sy, incy)
		if absf64(dfac*(res-test.result)) > absf64(test.size)*epsilonf64()+1e-9 {
			t.Errorf("Test Failed: test %d: {%10.8f} output, {%10.8f} expected", test.n, res, test.result)
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDsdot(b *testing.B) {
	var res float64
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*n = 4
	*incx = 2
	*incy = -2

	for i := 0; i < b.N; i++ {
		res = Dsdot(_C, n, sx, incx, sy, incy)
	}
	resglobal = res
}

func BenchmarkDsdotFortran(b *testing.B) {
	var res float64
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*n = 4
	*incx = 2
	*incy = -2

	for i := 0; i < b.N; i++ {
		res = dsdotWrapper(n, sx, incx, sy, incy)
	}
	resglobal = res
}

func TestDrot(t *testing.T) {
	tname := "Drot"
	var i, nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	sc := new(float64)
	ss := new(float64)
	var drotTests = []struct {
		lenx   int
		leny   int
		n      int
		sx     []float64
		incx   int
		sy     []float64
		incy   int
		sc     float64
		ss     float64
		sxtrue []float64
		sytrue []float64
		sizex  []float64
		sizey  []float64
	}{
		{1, 1, 0, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.8000, 0.6000, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.8000, 0.6000, []float64{0.7800, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0400, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 2, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.8000, 0.6000, []float64{0.7800, -0.4600, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0400, -0.7800, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 4, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.8000, 0.6000, []float64{0.7800, -0.4600, -0.2200, 1.0600, 0.0000, 0.0000, 0.0000}, []float64{0.0400, -0.7800, 0.5400, 0.0800, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 0, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8000, 0.6000, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8000, 0.6000, []float64{0.7800, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0400, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{3, 3, 2, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8000, 0.6000, []float64{0.6600, 0.1000, -0.1000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.7000, -0.9000, -0.1200, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{7, 7, 4, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8000, 0.6000, []float64{0.9600, 0.1000, -0.7600, 0.8000, 0.9000, -0.3000, -0.0200}, []float64{0.6400, -0.9000, -0.3000, 0.7000, -0.1800, 0.2000, 0.2800}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 0, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.8000, 0.6000, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.8000, 0.6000, []float64{0.7800, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0400, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{3, 2, 2, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.8000, 0.6000, []float64{-0.0600, 0.1000, -0.1000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.7000, -1.0800, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{7, 4, 4, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.8000, 0.6000, []float64{0.9000, 0.1000, -0.2200, 0.8000, 0.1800, -0.3000, -0.0200}, []float64{0.6400, -1.2600, 0.5400, 0.2000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 0, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8000, 0.6000, []float64{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8000, 0.6000, []float64{0.7800, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0400, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 2, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8000, 0.6000, []float64{0.7800, 0.2600, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0400, -0.9000, 0.1800, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 7, 4, []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8000, 0.6000, []float64{0.7800, 0.2600, -0.7600, 1.1200, 0.0000, 0.0000, 0.0000}, []float64{0.0400, -0.9000, 0.1800, 0.7000, -0.1800, 0.2000, 0.1600}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float64{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{5, 5, 5, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, 1.0000, 0.0000, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}},
		{5, 5, 5, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, 0.0000, 1.0000, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float64{-1.0000, -2.0000, -3.0000, -4.0000, -5.0000}, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float64{-1.0000, -2.0000, -3.0000, -4.0000, -5.0000}},
		{5, 5, 5, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, -1, 0.0000, 1.0000, []float64{5.0000, 4.0000, 3.0000, 2.0000, 1.0000}, []float64{-5.0000, -4.0000, -3.0000, -2.0000, -1.0000}, []float64{5.0000, 4.0000, 3.0000, 2.0000, 1.0000}, []float64{-5.0000, -4.0000, -3.0000, -2.0000, -1.0000}},
		{5, 5, 5, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, -1, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, -1, 0.0000, 1.0000, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float64{-1.0000, -2.0000, -3.0000, -4.0000, -5.0000}, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float64{-1.0000, -2.0000, -3.0000, -4.0000, -5.0000}},
		{5, 5, 3, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 2, 0.0000, 1.0000, []float64{1.0000, 3.0000, 5.0000, 4.0000, 5.0000}, []float64{-1.0000, 2.0000, -2.0000, 4.0000, -3.0000}, []float64{1.0000, 3.0000, 5.0000, 4.0000, 5.0000}, []float64{-1.0000, 2.0000, -2.0000, 4.0000, -3.0000}},
		{5, 5, 5, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, -1, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, 0.0000, 1.0000, []float64{5.0000, 4.0000, 3.0000, 2.0000, 1.0000}, []float64{-5.0000, -4.0000, -3.0000, -2.0000, -1.0000}, []float64{5.0000, 4.0000, 3.0000, 2.0000, 1.0000}, []float64{-5.0000, -4.0000, -3.0000, -2.0000, -1.0000}},
		{5, 5, 5, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, 0.0000, -1.0000, []float64{-1.0000, -2.0000, -3.0000, -4.0000, -5.0000}, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float64{-1.0000, -2.0000, -3.0000, -4.0000, -5.0000}, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}},
		{5, 5, 5, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, -1, 0.0000, -1.0000, []float64{-5.0000, -4.0000, -3.0000, -2.0000, -1.0000}, []float64{5.0000, 4.0000, 3.0000, 2.0000, 1.0000}, []float64{-5.0000, -4.0000, -3.0000, -2.0000, -1.0000}, []float64{5.0000, 4.0000, 3.0000, 2.0000, 1.0000}},
		{5, 5, 5, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, -1, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, -1, 0.0000, -1.0000, []float64{-1.0000, -2.0000, -3.0000, -4.0000, -5.0000}, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float64{-1.0000, -2.0000, -3.0000, -4.0000, -5.0000}, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}},
		{5, 5, 3, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 2, 0.0000, -1.0000, []float64{-1.0000, -3.0000, -5.0000, 4.0000, 5.0000}, []float64{1.0000, 2.0000, 2.0000, 4.0000, 3.0000}, []float64{-1.0000, -3.0000, -5.0000, 4.0000, 5.0000}, []float64{1.0000, 2.0000, 2.0000, 4.0000, 3.0000}},
		{5, 5, 5, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, -1, []float64{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, 0.0000, -1.0000, []float64{-5.0000, -4.0000, -3.0000, -2.0000, -1.0000}, []float64{5.0000, 4.0000, 3.0000, 2.0000, 1.0000}, []float64{-5.0000, -4.0000, -3.0000, -2.0000, -1.0000}, []float64{5.0000, 4.0000, 3.0000, 2.0000, 1.0000}},
	}

	for _, test := range drotTests {
		i++
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		*sc = test.sc
		*ss = test.ss
		sx := func() *[]float64 { y := make([]float64, test.lenx); return &y }()
		sy := func() *[]float64 { y := make([]float64, test.leny); return &y }()
		for j := 0; j < test.lenx; j++ {
			(*sx)[j] = test.sx[j]
		}
		for j := 0; j < test.leny; j++ {
			(*sy)[j] = test.sy[j]
		}
		nc++
		Drot(_C, n, sx, incx, sy, incy, sc, ss)
		for j := 0; j < test.lenx; j++ {
			if absf64(dfac*((*sx)[j]-test.sxtrue[j])) > absf64(test.sizex[j])*epsilonf64()+1e-9 {
				t.Errorf("Test Failed: sx[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, i, (*sx)[j], test.sxtrue[j])
			}
		}
		for j := 0; j < test.leny; j++ {
			if absf64(dfac*((*sy)[j]-test.sytrue[j])) > absf64(test.sizey[j])*epsilonf64()+1e-9 {
				t.Errorf("Test Failed: sy[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, i, (*sy)[j], test.sytrue[j])
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDrot(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sc := new(float64)
	ss := new(float64)
	sx := func() *[]float64 { y := make([]float64, 7); return &y }()
	sy := func() *[]float64 { y := make([]float64, 7); return &y }()
	*n = 0
	*sx = []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 1
	*sy = []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = 1
	*sc = 0.8
	*ss = 0.6

	for i := 0; i < b.N; i++ {
		Drot(_C, n, sx, incx, sy, incy, sc, ss)
	}
}

func BenchmarkDrotFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sc := new(float64)
	ss := new(float64)
	sx := func() *[]float64 { y := make([]float64, 7); return &y }()
	sy := func() *[]float64 { y := make([]float64, 7); return &y }()
	*n = 0
	*sx = []float64{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 1
	*sy = []float64{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = 1
	*sc = 0.8
	*ss = 0.6

	for i := 0; i < b.N; i++ {
		drotWrapper(n, sx, incx, sy, incy, sc, ss)
	}
}

// BLAS Level 2
func TestDgemv(t *testing.T) {
	tname := "Dgemv"
	var i, ia, ib, ic, im, in, incxs, incys, ix, iy, j, laa, ldas, lx, ly, ml, ms, nl, ns, nd, nc int
	var als, bls, err, erri, epsf64 float64
	var transs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float64)
	beta := new(float64)
	transl := new(float64)
	kl := new(int)
	ku := new(int)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_ml := new(int)
	_nl := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	trans := new(byte)

	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]float64 { y := make([]float64, nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xs := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	y := func() *[]float64 { y := make([]float64, nmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	ys := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yt := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]
		ns = *n
		nd = (*n)/2 + 1
		for im = 1; im <= 2; im++ {
			if im == 1 {
				*m = max((*n)-nd, 0)
			} else if im == 2 {
				*m = min((*n)+nd, nmax)
			}

			*ku = (*n) - 1
			*kl = (*m) - 1
			ms = *m
			*lda = *m
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			ldas = *lda

			null = *n <= 0 || *m <= 0

			*transl = 0.0
			dmakeGEL2(m, n, aa, lda, kl, ku, reset, transl, miSbeg, icSbeg, iSbeg)
			for j = 1; j <= *n; j++ {
				for i = 1; i <= *m; i++ {
					(*a)[i-1][j-1] = (*aa)[i+(j-1)*absint(*lda)-1]
				}
			}

			for ic = 1; ic <= len(ichtL2); ic++ {
				*trans = ichtL2[ic-1]

				if *trans == 'T' || *trans == 'C' {
					ml = *n
					nl = *m
				} else {
					ml = *m
					nl = *n
				}

				for ix = 1; ix <= len(incL2); ix++ {
					*incx = incL2[ix-1]
					lx = absint(*incx) * nl

					*transl = 0.5
					*_nl = nl - 1
					dmakeGE2L2(onei, &nl, x, xx, incx, zeroi, _nl, reset, transl, miSbeg, icSbeg, iSbeg)
					if nl > 1 {
						(*x)[1+(nl/1)-1] = 0.0
						(*xx)[1+absint(*incx)*(nl/1)-1] = 0.0
					}

					for iy = 1; iy <= len(incL2); iy++ {
						*incy = incL2[iy-1]
						ly = absint(*incy) * ml

						for ia = 1; ia <= len(alff64L2); ia++ {
							*alpha = alff64L2[ia-1]

							for ib = 1; ib <= len(betf64L2); ib++ {
								*beta = betf64L2[ib-1]

								*transl = 0.0
								*_ml = ml - 1
								dmakeGE2L2(onei, &ml, y, yy, incy, zeroi, _ml, reset, transl, miSbeg, icSbeg, iSbeg)

								transs = *trans
								incxs = *incx
								incys = *incy
								als = *alpha
								bls = *beta
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lx; i++ {
									(*xs)[i-1] = (*xx)[i-1]
								}
								for i = 1; i <= ly; i++ {
									(*ys)[i-1] = (*yy)[i-1]
								}

								nc++

								_aa := dExpand(aa, n, lda)
								Dgemv(_C, trans, m, n, alpha, _aa, lda, xx, incx, beta, yy, incy)
								dReturn(_aa, aa)

								checkByte(t, nc, trans, &transs, "trans")
								checkInt(t, nc, m, &ms, "m")
								checkInt(t, nc, n, &ns, "n")
								checkFloat64(t, nc, &als, alpha, "alpha")
								checkFloat64(t, nc, &bls, beta, "beta")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, incx, &incxs, "incx")
								checkInt(t, nc, incy, &incys, "incy")
								checkFloat64Array1D(t, nc, &laa, aa, as, "aa")
								checkFloat64Array1D(t, nc, &lx, xx, xs, "xx")
								if null {
									checkFloat64Array1D(t, nc, &ly, yy, ys, "guardband yy")
									break
								} else {
									for j := 0; j < ml; j++ {
										for i = 1; i < absint(*incy); i++ {
											if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
												t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
											}
										}
									}
									dmvch2Test(trans, m, n, alpha, a, x, incx, beta, y, incy, yt, g)
									err = 0
									for i = 1; i <= ml; i++ {
										erri = absf64((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf64
										if (*g)[i-1] != 0.0 {
											erri /= (*g)[i-1]
										}
										err = maxf64(err, erri)
										if err*sqrtf64(epsf64) >= 1.0 {
											t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.8e} error\n\t\ttrans: %c\tm: %d\tn: %d\talpha: %4.2f\tbeta: %4.2f\tlda: %d\tincx: %d\tincy: %d", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf64(epsf64), *trans, *m, *n, *alpha, *beta, *lda, *incx, *incy)
										}
									}
								}
							}

							if null {
								break
							}
						}

						if null {
							break
						}
					}

					if null {
						break
					}
				}

				if null {
					break
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDgemv(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	major := new(byte)
	trans := new(byte)

	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*major = 'C'
	*trans = 'C'
	*m = 14
	*n = 9
	*alpha = 0.70
	*aa = []float64{-0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -10000000000.0000, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -0.4525, 0.3766, -10000000000.0000, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, -10000000000.0000, 0.0170, 0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, 0.3067, -0.4625, 0.4665, -10000000000.0000, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, -0.0929, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -0.2927, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, -10000000000.0000}
	*lda = 15
	*xx = []float64{0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.1274, -10000000000.0000, 0.1573, -10000000000.0000, 0.0000, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float64{-0.1728, -10000000000.0000, -0.1429, -10000000000.0000, -0.4126, -10000000000.0000, 0.0170, -10000000000.0000, 0.1469, -10000000000.0000, -0.4925, -10000000000.0000, -0.2627, -10000000000.0000, -0.3327, -10000000000.0000, 0.2967, -10000000000.0000, -0.5402, -10000000000.0000, -0.6307, -10000000000.0000, 0.4639, -10000000000.0000, 0.1913, -10000000000.0000, 0.0281, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	_aa := dExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Dgemv(major, trans, m, n, alpha, _aa, lda, xx, incx, beta, yy, incy)
	}
}

func BenchmarkDgemvFortran(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	trans := new(byte)

	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*trans = 'C'
	*m = 14
	*n = 9
	*alpha = 0.70
	*aa = []float64{-0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -10000000000.0000, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -0.4525, 0.3766, -10000000000.0000, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, -10000000000.0000, 0.0170, 0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, 0.3067, -0.4625, 0.4665, -10000000000.0000, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, -0.0929, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -0.2927, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, -10000000000.0000}
	*lda = 15
	*xx = []float64{0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.1274, -10000000000.0000, 0.1573, -10000000000.0000, 0.0000, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float64{-0.1728, -10000000000.0000, -0.1429, -10000000000.0000, -0.4126, -10000000000.0000, 0.0170, -10000000000.0000, 0.1469, -10000000000.0000, -0.4925, -10000000000.0000, -0.2627, -10000000000.0000, -0.3327, -10000000000.0000, 0.2967, -10000000000.0000, -0.5402, -10000000000.0000, -0.6307, -10000000000.0000, 0.4639, -10000000000.0000, 0.1913, -10000000000.0000, 0.0281, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		dgemvWrapper(trans, m, n, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func TestDgbmv(t *testing.T) {
	tname := "Dgbmv"
	var i, ia, ib, ic, iku, im, in, incxs, incys, ix, iy, kls, kus, laa, ldas, lx, ly, ml, ms, nl, ns, nd, nc int
	var als, bls, err, erri float64
	var transs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	major := new(byte)
	alpha := new(float64)
	beta := new(float64)
	transl := new(float64)
	m := new(int)
	n := new(int)
	kl := new(int)
	ku := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_ml := new(int)
	_nl := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	trans := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xs := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	ys := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yt := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]
		nd = (*n)/2 + 1

		for im = 1; im <= 2; im++ {
			if im == 1 {
				*m = max((*n)-nd, 0)
			} else if im == 2 {
				*m = min((*n)+nd, nmax)
			}

			for iku = 1; iku <= len(kbL2); iku++ {
				*ku = kbL2[iku-1]
				*kl = max((*ku)-1, 0)
				*lda = (*kl) + (*ku) + 1
				if *lda < nmax {
					*lda++
				} else if *lda > nmax {
					continue
				}
				laa = (*lda) * (*n)

				null = *n <= 0 || *m <= 0

				*transl = 0.0
				dmakeGBL2(m, n, a, aa, lda, kl, ku, reset, transl, miSbeg, icSbeg, iSbeg)

				for ic = 1; ic <= len(ichtL2); ic++ {
					*trans = ichtL2[ic-1]
					if *trans == 'T' || *trans == 'C' {
						ml = *n
						nl = *m
					} else {
						ml = *m
						nl = *n
					}

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * nl

						*transl = 0.5
						*_nl = nl - 1
						dmakeGEL2(onei, &nl, xx, incx, zeroi, _nl, reset, transl, miSbeg, icSbeg, iSbeg)
						if nl > 1 {
							(*xx)[1+absint(*incx)*(nl/2-1)-1] = 0.0
						}

						for iy = 1; iy <= len(incL2); iy++ {
							*incy = incL2[iy-1]
							ly = absint(*incy) * ml

							for ia = 1; ia <= len(alff64L2); ia++ {
								*alpha = alff64L2[ia-1]

								for ib = 1; ib <= len(betf64L2); ib++ {
									*beta = betf64L2[ib-1]

									*transl = 0.0
									*_ml = ml - 1
									dmakeGEL2(onei, &ml, yy, incy, zeroi, _ml, reset, transl, miSbeg, icSbeg, iSbeg)

									transs = *trans
									ns = *n
									ms = *m
									kls = *kl
									kus = *ku
									ldas = *lda
									incxs = *incx
									incys = *incy
									als = *alpha
									bls = *beta
									for i = 1; i <= laa; i++ {
										(*as)[i-1] = (*aa)[i-1]
									}
									for i = 1; i <= lx; i++ {
										(*xs)[i-1] = (*xx)[i-1]
									}
									for i = 1; i <= ly; i++ {
										(*ys)[i-1] = (*yy)[i-1]
									}

									nc++

									_aa := dExpand(aa, n, lda)
									Dgbmv(major, trans, m, n, kl, ku, alpha, _aa, lda, xx, incx, beta, yy, incy)
									dReturn(_aa, aa)

									checkByte(t, nc, trans, &transs, "trans")
									checkInt(t, nc, m, &ms, "m")
									checkInt(t, nc, n, &ns, "n")
									checkInt(t, nc, kl, &kls, "kl")
									checkInt(t, nc, ku, &kus, "ku")
									checkFloat64(t, nc, &als, alpha, "alpha")
									checkFloat64(t, nc, &bls, beta, "beta")
									checkInt(t, nc, lda, &ldas, "lda")
									checkInt(t, nc, incx, &incxs, "incx")
									checkInt(t, nc, incy, &incys, "incy")
									checkFloat64Array1D(t, nc, &laa, aa, as, "aa")
									checkFloat64Array1D(t, nc, &lx, xx, xs, "xx")
									if null {
										checkFloat64Array1D(t, nc, &ly, yy, ys, "guardband yy")
										break
									} else {
										for j := 0; j < ml; j++ {
											for i = 1; i < absint(*incy); i++ {
												if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
													t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
												}
											}
										}
										dmvchTest(trans, m, n, alpha, a, xx, incx, beta, ys, incy, yt, g)
										err = 0
										for i = 1; i <= ml; i++ {
											erri = absf64((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf64
											if (*g)[i-1] != 0.0 {
												erri /= (*g)[i-1]
											}
											err = maxf64(err, erri)
											if err*sqrtf64(epsf64) >= 1.0 {
												t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf64(epsf64))
											}
										}
									}
								}
								if null {
									break
								}
							}
							if null {
								break
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDgbmv(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	m := new(int)
	n := new(int)
	kl := new(int)
	ku := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	major := new(byte)
	trans := new(byte)

	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*major = 'C'
	*trans = 'C'
	*m = 14
	*n = 9
	*kl = 3
	*ku = 4
	*alpha = 0.70
	*aa = []float64{-10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -0.2627, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, -10000000000.0000, 0.2268, 0.2567, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0270, 0.0569, -0.2128, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, -10000000000.0000, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -0.0230, -0.4925, -0.3327, -10000000000.0000, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, 0.3067, -0.4625, -10000000000.0000, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, 0.3367, -10000000000.0000}
	*lda = 9
	*xx = []float64{0.7667, -10000000000.0000, 0.3971, -10000000000.0000, 0.7268, -10000000000.0000, 0.4870, -10000000000.0000, 0.9166, -10000000000.0000, 0.0475, -10000000000.0000, 0.0000, -10000000000.0000, 0.4071, -10000000000.0000, 0.5669, -10000000000.0000, 0.1973, -10000000000.0000, 0.5270, -10000000000.0000, 0.5569, -10000000000.0000, 0.2872, -10000000000.0000, 0.8467, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float64{0.1768, -10000000000.0000, -0.2927, -10000000000.0000, -0.0629, -10000000000.0000, -0.1329, -10000000000.0000, -0.1728, -10000000000.0000, -0.1429, -10000000000.0000, -0.4126, -10000000000.0000, 0.0170, -10000000000.0000, 0.1469, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	_aa := dExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Dgbmv(major, trans, m, n, kl, ku, alpha, _aa, lda, xx, incx, beta, yy, incy)
	}
}

func BenchmarkDgbmvFortran(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	m := new(int)
	n := new(int)
	kl := new(int)
	ku := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	trans := new(byte)

	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*trans = 'C'
	*m = 14
	*n = 9
	*kl = 3
	*ku = 4
	*alpha = 0.70
	*aa = []float64{-10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -0.2627, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, -10000000000.0000, 0.2268, 0.2567, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0270, 0.0569, -0.2128, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, -10000000000.0000, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -0.0230, -0.4925, -0.3327, -10000000000.0000, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, 0.3067, -0.4625, -10000000000.0000, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, 0.3367, -10000000000.0000}
	*lda = 9
	*xx = []float64{0.7667, -10000000000.0000, 0.3971, -10000000000.0000, 0.7268, -10000000000.0000, 0.4870, -10000000000.0000, 0.9166, -10000000000.0000, 0.0475, -10000000000.0000, 0.0000, -10000000000.0000, 0.4071, -10000000000.0000, 0.5669, -10000000000.0000, 0.1973, -10000000000.0000, 0.5270, -10000000000.0000, 0.5569, -10000000000.0000, 0.2872, -10000000000.0000, 0.8467, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float64{0.1768, -10000000000.0000, -0.2927, -10000000000.0000, -0.0629, -10000000000.0000, -0.1329, -10000000000.0000, -0.1728, -10000000000.0000, -0.1429, -10000000000.0000, -0.4126, -10000000000.0000, 0.0170, -10000000000.0000, 0.1469, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		dgbmvWrapper(trans, m, n, kl, ku, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func TestDsymv(t *testing.T) {
	tname := "Dsymv"
	var i, ia, ib, ic, in, incxs, incys, ix, iy, laa, ldas, lx, ly, ns, nc int
	var als, bls, err, erri float64
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float64)
	beta := new(float64)
	transl := new(float64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	major := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xs := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	ys := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yt := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = (*n)
		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			*transl = 0.0
			*_n = (*n) - 1
			dmakeSYL2(uplo, n, a, aa, lda, _n, _n, reset, transl, miSbeg, icSbeg, iSbeg)

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				dmakeGEL2(onei, n, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
				if (*n) > 1 {
					(*xx)[1+absint(*incx)*((*n)/1)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					for ia = 1; ia <= len(alff64L2); ia++ {
						*alpha = alff64L2[ia-1]

						for ib = 1; ib <= len(betf64L2); ib++ {
							*beta = betf64L2[ib-1]
							*transl = 0.0
							dmakeGEL2(onei, n, yy, incy, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)

							uplos = *uplo
							ns = *n
							ldas = *lda
							incxs = *incx
							incys = *incy
							als = *alpha
							bls = *beta
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lx; i++ {
								(*xs)[i-1] = (*xx)[i-1]
							}
							for i = 1; i <= ly; i++ {
								(*ys)[i-1] = (*yy)[i-1]
							}

							nc++

							_aa := dExpand(aa, n, lda)
							Dsymv(major, uplo, n, alpha, _aa, lda, xx, incx, beta, yy, incy)
							dReturn(_aa, aa)

							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkFloat64(t, nc, &als, alpha, "alpha")
							checkFloat64(t, nc, &bls, beta, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, incx, &incxs, "incx")
							checkInt(t, nc, incy, &incys, "incy")
							checkFloat64Array1D(t, nc, &laa, aa, as, "aa")
							checkFloat64Array1D(t, nc, &lx, xx, xs, "xx")
							if null {
								checkFloat64Array1D(t, nc, &ly, yy, ys, "guardband yy")
								break
							} else {
								for j := 0; j < *n; j++ {
									for i = 1; i < absint(*incy); i++ {
										if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
											t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
										}
									}
								}
								dmvchTest(uplo, n, n, alpha, a, xx, incx, beta, ys, incy, yt, g)
								err = 0
								for i = 1; i <= *n; i++ {
									erri = absf64((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf64
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf64(err, erri)
									if err*sqrtf64(epsf64) >= 1.0 {
										t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf64(epsf64))
									}
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDsymv(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	major := new(byte)
	uplo := new(byte)

	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*aa = []float64{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.3726, -10000000000.0000}
	*lda = 10
	*xx = []float64{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float64{0.1868, -10000000000.0000, -0.3826, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.2667, -10000000000.0000, -0.1029, -10000000000.0000, 0.2268, -10000000000.0000, 0.2567, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	_aa := dExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Dsymv(major, uplo, n, alpha, _aa, lda, xx, incx, beta, yy, incy)
	}
}

func BenchmarkDsymvFortran(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)

	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*aa = []float64{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.3726, -10000000000.0000}
	*lda = 10
	*xx = []float64{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float64{0.1868, -10000000000.0000, -0.3826, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.2667, -10000000000.0000, -0.1029, -10000000000.0000, 0.2268, -10000000000.0000, 0.2567, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		dsymvWrapper(uplo, n, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func TestDsbmv(t *testing.T) {
	tname := "Dsbmv"
	var i, ia, ib, ic, ik, in, incxs, incys, ix, iy, ks, laa, ldas, lx, ly, nc, ns int
	var als, bls, err, erri float64
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float64)
	beta := new(float64)
	transl := new(float64)
	n := new(int)
	k := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	major := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xs := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	ys := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yt := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		for ik = 1; ik <= len(kbL2); ik++ {
			*k = kbL2[ik-1]
			*lda = (*k) + 1

			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = (*lda) * (*n)
			null = *n <= 0

			for ic = 1; ic <= len(ichuL2); ic++ {
				*uplo = ichuL2[ic-1]

				*transl = 0.0
				dmakeSBL2(uplo, n, n, a, aa, lda, k, k, reset, transl, miSbeg, icSbeg, iSbeg)

				for ix = 1; ix <= len(incL2); ix++ {
					*incx = incL2[ix-1]
					lx = absint(*incx) * (*n)

					*transl = 0.5
					*_n = (*n) - 1
					dmakeGEL2(onei, n, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
					if (*n) > 1 {
						(*xx)[1+absint(*incx)*((*n)/1)-1] = 0.0
					}

					for iy = 1; iy <= len(incL2); iy++ {
						*incy = incL2[iy-1]
						ly = absint(*incy) * (*n)

						for ia = 1; ia <= len(alff64L2); ia++ {
							*alpha = alff64L2[ia-1]

							for ib = 1; ib <= len(betf64L2); ib++ {
								*beta = betf64L2[ib-1]

								*transl = 0.0
								dmakeGEL2(onei, n, yy, incy, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)

								uplos = *uplo
								ns = *n
								ks = *k
								ldas = *lda
								incxs = *incx
								incys = *incy
								als = *alpha
								bls = *beta
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lx; i++ {
									(*xs)[i-1] = (*xx)[i-1]
								}
								for i = 1; i <= ly; i++ {
									(*ys)[i-1] = (*yy)[i-1]
								}

								nc++

								_aa := dExpand(aa, n, lda)
								Dsbmv(major, uplo, n, k, alpha, _aa, lda, xx, incx, beta, yy, incy)
								dReturn(_aa, aa)

								checkByte(t, nc, uplo, &uplos, "uplo")
								checkInt(t, nc, n, &ns, "n")
								checkInt(t, nc, k, &ks, "k")
								checkFloat64(t, nc, &als, alpha, "alpha")
								checkFloat64(t, nc, &bls, beta, "beta")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, incx, &incxs, "incx")
								checkInt(t, nc, incy, &incys, "incy")
								checkFloat64Array1D(t, nc, &laa, aa, as, "aa")
								checkFloat64Array1D(t, nc, &lx, xx, xs, "xx")
								if null {
									checkFloat64Array1D(t, nc, &ly, yy, ys, "guardband yy")
									break
								} else {
									for j := 0; j < (*n); j++ {
										for i = 1; i < absint(*incy); i++ {
											if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
												t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
											}
										}
									}
									_n := func() *byte { y := byte('N'); return &y }()
									dmvchTest(_n, n, n, alpha, a, xx, incx, beta, ys, incy, yt, g)
									err = 0
									for i = 1; i <= (*n); i++ {
										erri = absf64((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf64
										if (*g)[i-1] != 0.0 {
											erri /= (*g)[i-1]
										}
										err = maxf64(err, erri)
										if err*sqrtf64(epsf64) >= 1.0 {
											t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf64(epsf64))
										}
									}
								}
							}
							if null {
								break
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDsbmv(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	n := new(int)
	k := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	major := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*n = 9
	*k = 4
	*alpha = 0.70
	*aa = []float64{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -10000000000.0000, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -10000000000.0000, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, -10000000000.0000, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, -10000000000.0000, 0.1369, 0.0669, -0.3027, 0.0270, -10000000000.0000, -10000000000.0000, -0.2128, 0.2168, 0.3467, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1768, -0.2927, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000}
	*lda = 6
	*xx = []float64{0.9965, -10000000000.0000, 0.3272, -10000000000.0000, 0.3571, -10000000000.0000, 0.0000, -10000000000.0000, 0.6469, -10000000000.0000, 0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float64{-0.3726, -10000000000.0000, -0.3427, -10000000000.0000, 0.3866, -10000000000.0000, -0.1828, -10000000000.0000, -0.0529, -10000000000.0000, 0.3067, -10000000000.0000, -0.4625, -10000000000.0000, 0.4665, -10000000000.0000, 0.0969, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	_aa := dExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Dsbmv(major, uplo, n, k, alpha, _aa, lda, xx, incx, beta, yy, incy)
	}
}

func BenchmarkDsbmvFortran(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	n := new(int)
	k := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*k = 4
	*alpha = 0.70
	*aa = []float64{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -10000000000.0000, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -10000000000.0000, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, -10000000000.0000, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, -10000000000.0000, 0.1369, 0.0669, -0.3027, 0.0270, -10000000000.0000, -10000000000.0000, -0.2128, 0.2168, 0.3467, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1768, -0.2927, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000}
	*lda = 6
	*xx = []float64{0.9965, -10000000000.0000, 0.3272, -10000000000.0000, 0.3571, -10000000000.0000, 0.0000, -10000000000.0000, 0.6469, -10000000000.0000, 0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float64{-0.3726, -10000000000.0000, -0.3427, -10000000000.0000, 0.3866, -10000000000.0000, -0.1828, -10000000000.0000, -0.0529, -10000000000.0000, 0.3067, -10000000000.0000, -0.4625, -10000000000.0000, 0.4665, -10000000000.0000, 0.0969, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		dsbmvWrapper(uplo, n, k, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func TestDspmv(t *testing.T) {
	tname := "Dspmv"
	var i, ia, ib, ic, in, incxs, incys, ix, iy, laa, lx, ly, nc, ns int
	var als, bls, err, erri float64
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float64)
	beta := new(float64)
	transl := new(float64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	major := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xs := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	ys := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yt := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			*transl = 0.0
			*_n = (*n) - 1
			dmakeSPL2(uplo, n, n, a, aa, _n, _n, reset, transl, miSbeg, icSbeg, iSbeg)

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				dmakeGEL2(onei, n, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
				if (*n) > 1 {
					(*xx)[1+absint(*incx)*((*n)/1)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					for ia = 1; ia <= len(alff64L2); ia++ {
						*alpha = alff64L2[ia-1]

						for ib = 1; ib <= len(betf64L2); ib++ {
							*beta = betf64L2[ib-1]

							*transl = 0.0
							dmakeGEL2(onei, n, yy, incy, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)

							uplos = *uplo
							ns = *n
							incxs = *incx
							incys = *incy
							als = *alpha
							bls = *beta
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lx; i++ {
								(*xs)[i-1] = (*xx)[i-1]
							}
							for i = 1; i <= ly; i++ {
								(*ys)[i-1] = (*yy)[i-1]
							}

							nc++

							Dspmv(major, uplo, n, alpha, aa, xx, incx, beta, yy, incy)

							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkFloat64(t, nc, &als, alpha, "alpha")
							checkFloat64(t, nc, &bls, beta, "beta")
							checkInt(t, nc, incx, &incxs, "incx")
							checkInt(t, nc, incy, &incys, "incy")
							checkFloat64Array1D(t, nc, &laa, aa, as, "aa")
							checkFloat64Array1D(t, nc, &lx, xx, xs, "xx")
							if null {
								checkFloat64Array1D(t, nc, &ly, yy, ys, "guardband yy")
								break
							} else {
								for j := 0; j < (*n); j++ {
									for i = 1; i < absint(*incy); i++ {
										if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
											t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
										}
									}
								}
								_n := func() *byte { y := byte('N'); return &y }()
								dmvchTest(_n, n, n, alpha, a, xx, incx, beta, ys, incy, yt, g)
								err = 0
								for i = 1; i <= (*n); i++ {
									erri = absf64((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf64
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf64(err, erri)
									if err*sqrtf64(epsf64) >= 1.0 {
										t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf64(epsf64))
									}
								}
							}
						}

						if null {
							break
						}
					}

					if null {
						break
					}
				}

				if null {
					break
				}
			}

			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDspmv(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	major := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*aa = []float64{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726}
	*xx = []float64{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float64{0.1868, -10000000000.0000, -0.3826, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.2667, -10000000000.0000, -0.1029, -10000000000.0000, 0.2268, -10000000000.0000, 0.2567, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Dspmv(major, uplo, n, alpha, aa, xx, incx, beta, yy, incy)
	}
}

func BenchmarkDspmvFortran(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*aa = []float64{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726}
	*xx = []float64{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float64{0.1868, -10000000000.0000, -0.3826, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.2667, -10000000000.0000, -0.1029, -10000000000.0000, 0.2268, -10000000000.0000, 0.2567, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		dspmvWrapper(uplo, n, alpha, aa, xx, incx, beta, yy, incy)
	}
}

func TestDtrmv(t *testing.T) {
	tname := "Dtrmv"
	var i, icd, ict, icu, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float64
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(float64)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	major := new(byte)
	trans := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xs := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xt := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*k = (*n) - 1
		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for icu = 1; icu <= len(ichuL2); icu++ {
			*uplo = ichuL2[icu-1]

			for ict = 1; ict <= len(ichtL2); ict++ {
				*trans = ichtL2[ict-1]

				for icd = 1; icd <= len(ichdL2); icd++ {
					*diag = ichdL2[icd-1]

					*transl = 0.0
					dmakeTRL2(uplo, diag, n, n, a, aa, lda, k, k, reset, transl, miSbeg, icSbeg, iSbeg)

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * (*n)

						*transl = 0.5
						*_n = (*n) - 1
						dmakeGEL2(onei, n, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
						if (*n) > 1 {
							(*xx)[1+absint(*incx)*((*n)/1)-1] = 0.0
						}

						uplos = *uplo
						transs = *trans
						diags = *diag
						ns = *n
						ldas = *lda
						incxs = *incx
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}

						nc++

						_aa := dExpand(aa, n, lda)
						Dtrmv(major, uplo, trans, diag, n, _aa, lda, xx, incx)
						dReturn(_aa, aa)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkByte(t, nc, trans, &transs, "trans")
						checkByte(t, nc, diag, &diags, "diag")
						checkInt(t, nc, n, &ns, "n")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkFloat64Array1D(t, nc, &laa, aa, as, "aa")
						if null {
							checkFloat64Array1D(t, nc, &lx, xx, xs, "guardband xx")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = 1; i < absint(*incx); i++ {
									if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
									}
								}
							}
							dmvchTest(trans, n, n, onef64, a, xs, incx, zerof64, xx, incx, xt, g)
							err = 0
							for i = 1; i <= (*n); i++ {
								erri = absf64((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf64
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf64(err, erri)
								if err*sqrtf64(epsf64) >= 1.0 {
									t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf64(epsf64))
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDtrmv(b *testing.B) {
	n := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	major := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float64{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.6274, -10000000000.0000}
	*lda = 10
	*xx = []float64{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	_aa := dExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Dtrmv(major, uplo, trans, diag, n, _aa, lda, xx, incx)
	}
}

func BenchmarkDtrmvFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float64{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.6274, -10000000000.0000}
	*lda = 10
	*xx = []float64{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		dtrmvWrapper(uplo, trans, diag, n, aa, lda, xx, incx)
	}
}

func TestDtbmv(t *testing.T) {
	tname := "Dtbmv"
	var i, icd, ict, icu, ik, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float64
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(float64)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	major := new(byte)
	trans := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xs := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xt := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		for ik = 1; ik <= len(kbL2); ik++ {
			*k = kbL2[ik-1]

			*lda = (*k) + 1
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = (*lda) * (*n)
			null = *n <= 0

			for icu = 1; icu <= len(ichuL2); icu++ {
				*uplo = ichuL2[icu-1]

				for ict = 1; ict <= len(ichtL2); ict++ {
					*trans = ichtL2[ict-1]

					for icd = 1; icd <= len(ichdL2); icd++ {
						*diag = ichdL2[icd-1]

						*transl = 0.0
						dmakeTBL2(uplo, diag, n, n, a, aa, lda, k, k, reset, transl, miSbeg, icSbeg, iSbeg)

						for ix = 1; ix <= len(incL2); ix++ {
							*incx = incL2[ix-1]
							lx = absint(*incx) * (*n)

							*transl = 0.5
							*_n = (*n) - 1
							dmakeGEL2(onei, n, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
							if (*n) > 1 {
								(*xx)[1+absint(*incx)*((*n)/1)-1] = 0.0
							}

							uplos = *uplo
							transs = *trans
							diags = *diag
							ns = *n
							ldas = *lda
							incxs = *incx
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lx; i++ {
								(*xs)[i-1] = (*xx)[i-1]
							}

							nc++

							_aa := dExpand(aa, n, lda)
							Dtbmv(major, uplo, trans, diag, n, k, _aa, lda, xx, incx)
							dReturn(_aa, aa)

							checkByte(t, nc, uplo, &uplos, "uplo")
							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, diag, &diags, "diag")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, incx, &incxs, "incx")
							checkFloat64Array1D(t, nc, &laa, aa, as, "aa")
							if null {
								checkFloat64Array1D(t, nc, &lx, xx, xs, "guardband xx")
								break
							} else {
								for j = 0; j < *n; j++ {
									for i = 1; i < absint(*incx); i++ {
										if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
											t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
										}
									}
								}
								dmvchTest(trans, n, n, onef64, a, xs, incx, zerof64, xx, incx, xt, g)
								err = 0
								for i = 1; i <= (*n); i++ {
									erri = absf64((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf64
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf64(err, erri)
									if err*sqrtf64(epsf64) >= 1.0 {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf64(epsf64))
									}
								}
							}
						}

						if null {
							break
						}
					}

					if null {
						break
					}
				}

				if null {
					break
				}
			}

			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDtbmv(b *testing.B) {
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	major := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*k = 4
	*aa = []float64{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -10000000000.0000, 0.8172, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 1.0969, 0.4266, 0.4565, 0.1868, -0.2527, -10000000000.0000, 0.5774, 0.1069, 0.3367, 0.2667, 0.2268, -10000000000.0000, 1.2567, -0.0130, 0.4166, -0.4525, -0.0929, -10000000000.0000, 1.1369, 0.0669, -0.3027, 0.0270, -10000000000.0000, -10000000000.0000, 0.7872, 0.2168, 0.3467, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1768, -0.2927, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.8671, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000}
	*lda = 6
	*xx = []float64{0.9965, -10000000000.0000, 0.3272, -10000000000.0000, 0.3571, -10000000000.0000, 0.0000, -10000000000.0000, 0.6469, -10000000000.0000, 0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	_aa := dExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Dtbmv(major, uplo, trans, diag, n, k, _aa, lda, xx, incx)
	}
}

func BenchmarkDtbmvFortran(b *testing.B) {
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*k = 4
	*aa = []float64{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -10000000000.0000, 0.8172, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 1.0969, 0.4266, 0.4565, 0.1868, -0.2527, -10000000000.0000, 0.5774, 0.1069, 0.3367, 0.2667, 0.2268, -10000000000.0000, 1.2567, -0.0130, 0.4166, -0.4525, -0.0929, -10000000000.0000, 1.1369, 0.0669, -0.3027, 0.0270, -10000000000.0000, -10000000000.0000, 0.7872, 0.2168, 0.3467, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1768, -0.2927, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.8671, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000}
	*lda = 6
	*xx = []float64{0.9965, -10000000000.0000, 0.3272, -10000000000.0000, 0.3571, -10000000000.0000, 0.0000, -10000000000.0000, 0.6469, -10000000000.0000, 0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		dtbmvWrapper(uplo, trans, diag, n, k, aa, lda, xx, incx)
	}
}

func TestDtpmv(t *testing.T) {
	tname := "Dtpmv"
	var i, icd, ict, icu, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float64
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(float64)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	major := new(byte)
	trans := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xs := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xt := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*k = (*n) - 1
		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for icu = 1; icu <= len(ichuL2); icu++ {
			*uplo = ichuL2[icu-1]

			for ict = 1; ict <= len(ichtL2); ict++ {
				*trans = ichtL2[ict-1]

				for icd = 1; icd <= len(ichdL2); icd++ {
					*diag = ichdL2[icd-1]

					*transl = 0.0
					dmakeTPL2(uplo, diag, n, n, a, aa, k, k, reset, transl, miSbeg, icSbeg, iSbeg)

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * (*n)

						*transl = 0.5
						*_n = (*n) - 1
						dmakeGEL2(onei, n, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
						if (*n) > 1 {
							(*xx)[1+absint(*incx)*((*n)/1)-1] = 0.0
						}

						uplos = *uplo
						transs = *trans
						diags = *diag
						ns = *n
						ldas = *lda
						incxs = *incx
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}

						nc++

						Dtpmv(major, uplo, trans, diag, n, aa, xx, incx)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkByte(t, nc, trans, &transs, "trans")
						checkByte(t, nc, diag, &diags, "diag")
						checkInt(t, nc, n, &ns, "n")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkFloat64Array1D(t, nc, &laa, aa, as, "aa")
						if null {
							checkFloat64Array1D(t, nc, &lx, xx, xs, "guardband xx")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = 1; i < absint(*incx); i++ {
									if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
									}
								}
							}
							dmvchTest(trans, n, n, onef64, a, xs, incx, zerof64, xx, incx, xt, g)
							err = 0
							for i = 1; i <= (*n); i++ {
								erri = absf64((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf64
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf64(err, erri)
								if err*sqrtf64(epsf64) >= 1.0 {
									t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf64(epsf64))
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDtpmv(b *testing.B) {
	n := new(int)
	incx := new(int)
	diag := new(byte)
	major := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float64{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, 1.4965, -0.1728, -0.1429, -0.4126, 1.1469, -0.0230, -0.4925, 0.7373, -0.3327, 0.6274}
	*xx = []float64{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		Dtpmv(major, uplo, trans, diag, n, aa, xx, incx)
	}
}

func BenchmarkDtpmvFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float64{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, 1.4965, -0.1728, -0.1429, -0.4126, 1.1469, -0.0230, -0.4925, 0.7373, -0.3327, 0.6274}
	*xx = []float64{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		dtpmvWrapper(uplo, trans, diag, n, aa, xx, incx)
	}
}

func TestDtrsv(t *testing.T) {
	tname := "Dtrsv"
	var i, icd, ict, icu, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float64
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(float64)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	major := new(byte)
	trans := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xs := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xt := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	z := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*k = (*n) - 1
		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for icu = 1; icu <= len(ichuL2); icu++ {
			*uplo = ichuL2[icu-1]

			for ict = 1; ict <= len(ichtL2); ict++ {
				*trans = ichtL2[ict-1]

				for icd = 1; icd <= len(ichdL2); icd++ {
					*diag = ichdL2[icd-1]

					*transl = 0.0
					dmakeTRL2(uplo, diag, n, n, a, aa, lda, k, k, reset, transl, miSbeg, icSbeg, iSbeg)

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * (*n)

						*transl = 0.5
						*_n = (*n) - 1
						dmakeGEL2(onei, n, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
						if (*n) > 1 {
							(*xx)[1+absint(*incx)*((*n)/1)-1] = 0.0
						}

						uplos = *uplo
						transs = *trans
						diags = *diag
						ns = *n
						ldas = *lda
						incxs = *incx
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}

						nc++

						_aa := dExpand(aa, n, lda)
						Dtrsv(major, uplo, trans, diag, n, _aa, lda, xx, incx)
						dReturn(_aa, aa)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkByte(t, nc, trans, &transs, "trans")
						checkByte(t, nc, diag, &diags, "diag")
						checkInt(t, nc, n, &ns, "n")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkFloat64Array1D(t, nc, &laa, aa, as, "aa")
						if null {
							checkFloat64Array1D(t, nc, &lx, xx, xs, "guardband xx")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = 1; i < absint(*incx); i++ {
									if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
									}
								}
							}
							for i = 1; i <= *n; i++ {
								(*z)[(i-1)*absint(*incx)] = (*xx)[(i-1)*absint(*incx)]
								(*xx)[(i-1)*absint(*incx)] = (*xs)[(i-1)*absint(*incx)]
							}
							dmvchTest(trans, n, n, onef64, a, z, incx, zerof64, xx, incx, xt, g)
							err = 0
							for i = 1; i <= (*n); i++ {
								erri = absf64((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf64
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf64(err, erri)
								if err*sqrtf64(epsf64) >= 1.0 {
									t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*z)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf64(epsf64))
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDtrsv(b *testing.B) {
	n := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	major := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float64{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.6274, -10000000000.0000}
	*lda = 10
	*xx = []float64{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	_aa := dExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Dtrsv(major, uplo, trans, diag, n, _aa, lda, xx, incx)
	}
}

func BenchmarkDtrsvFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float64{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.6274, -10000000000.0000}
	*lda = 10
	*xx = []float64{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		dtrsvWrapper(uplo, trans, diag, n, aa, lda, xx, incx)
	}
}

func TestDtbsv(t *testing.T) {
	tname := "Dtbsv"
	var i, icd, ict, icu, ik, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float64
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(float64)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	major := new(byte)
	trans := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xs := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xt := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	z := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		for ik = 1; ik <= len(kbL2); ik++ {
			*k = kbL2[ik-1]

			*lda = (*k) + 1
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = (*lda) * (*n)
			null = *n <= 0

			for icu = 1; icu <= len(ichuL2); icu++ {
				*uplo = ichuL2[icu-1]

				for ict = 1; ict <= len(ichtL2); ict++ {
					*trans = ichtL2[ict-1]

					for icd = 1; icd <= len(ichdL2); icd++ {
						*diag = ichdL2[icd-1]

						*transl = 0.0
						dmakeTBL2(uplo, diag, n, n, a, aa, lda, k, k, reset, transl, miSbeg, icSbeg, iSbeg)

						for ix = 1; ix <= len(incL2); ix++ {
							*incx = incL2[ix-1]
							lx = absint(*incx) * (*n)

							*transl = 0.5
							*_n = (*n) - 1
							dmakeGEL2(onei, n, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
							if (*n) > 1 {
								(*xx)[1+absint(*incx)*((*n)/1)-1] = 0.0
							}

							uplos = *uplo
							transs = *trans
							diags = *diag
							ns = *n
							ldas = *lda
							incxs = *incx
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lx; i++ {
								(*xs)[i-1] = (*xx)[i-1]
							}

							nc++

							_aa := dExpand(aa, n, lda)
							Dtbsv(major, uplo, trans, diag, n, k, _aa, lda, xx, incx)
							dReturn(_aa, aa)

							checkByte(t, nc, uplo, &uplos, "uplo")
							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, diag, &diags, "diag")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, incx, &incxs, "incx")
							checkFloat64Array1D(t, nc, &laa, aa, as, "aa")
							if null {
								checkFloat64Array1D(t, nc, &lx, xx, xs, "guardband xx")
								break
							} else {
								for j = 0; j < *n; j++ {
									for i = 1; i < absint(*incx); i++ {
										if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
											t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
										}
									}
								}
								for i = 1; i <= *n; i++ {
									(*z)[(i-1)*absint(*incx)] = (*xx)[(i-1)*absint(*incx)]
									(*xx)[(i-1)*absint(*incx)] = (*xs)[(i-1)*absint(*incx)]
								}
								dmvchTest(trans, n, n, onef64, a, z, incx, zerof64, xx, incx, xt, g)
								err = 0
								for i = 1; i <= (*n); i++ {
									erri = absf64((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf64
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf64(err, erri)
									if err*sqrtf64(epsf64) >= 1.0 {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf64(epsf64))
									}
								}
							}
							if null {
								break
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDtbsv(b *testing.B) {
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	major := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*k = 4
	*aa = []float64{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -10000000000.0000, 0.8172, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 1.0969, 0.4266, 0.4565, 0.1868, -0.2527, -10000000000.0000, 0.5774, 0.1069, 0.3367, 0.2667, 0.2268, -10000000000.0000, 1.2567, -0.0130, 0.4166, -0.4525, -0.0929, -10000000000.0000, 1.1369, 0.0669, -0.3027, 0.0270, -10000000000.0000, -10000000000.0000, 0.7872, 0.2168, 0.3467, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1768, -0.2927, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.8671, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000}
	*lda = 6
	*xx = []float64{0.9965, -10000000000.0000, 0.3272, -10000000000.0000, 0.3571, -10000000000.0000, 0.0000, -10000000000.0000, 0.6469, -10000000000.0000, 0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	_aa := dExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Dtbsv(major, uplo, trans, diag, n, k, _aa, lda, xx, incx)
	}
}

func BenchmarkDtbsvFortran(b *testing.B) {
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*k = 4
	*aa = []float64{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -10000000000.0000, 0.8172, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 1.0969, 0.4266, 0.4565, 0.1868, -0.2527, -10000000000.0000, 0.5774, 0.1069, 0.3367, 0.2667, 0.2268, -10000000000.0000, 1.2567, -0.0130, 0.4166, -0.4525, -0.0929, -10000000000.0000, 1.1369, 0.0669, -0.3027, 0.0270, -10000000000.0000, -10000000000.0000, 0.7872, 0.2168, 0.3467, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1768, -0.2927, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.8671, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000}
	*lda = 6
	*xx = []float64{0.9965, -10000000000.0000, 0.3272, -10000000000.0000, 0.3571, -10000000000.0000, 0.0000, -10000000000.0000, 0.6469, -10000000000.0000, 0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		dtbsvWrapper(uplo, trans, diag, n, k, aa, lda, xx, incx)
	}
}

func TestDtpsv(t *testing.T) {
	tname := "Dtpsv"
	var i, icd, ict, icu, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float64
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(float64)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	major := new(byte)
	trans := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xs := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xt := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	z := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*k = (*n) - 1
		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for icu = 1; icu <= len(ichuL2); icu++ {
			*uplo = ichuL2[icu-1]

			for ict = 1; ict <= len(ichtL2); ict++ {
				*trans = ichtL2[ict-1]

				for icd = 1; icd <= len(ichdL2); icd++ {
					*diag = ichdL2[icd-1]

					*transl = 0.0
					dmakeTPL2(uplo, diag, n, n, a, aa, k, k, reset, transl, miSbeg, icSbeg, iSbeg)

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * (*n)

						*transl = 0.5
						*_n = (*n) - 1
						dmakeGEL2(onei, n, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
						if (*n) > 1 {
							(*xx)[1+absint(*incx)*((*n)/1)-1] = 0.0
						}

						uplos = *uplo
						transs = *trans
						diags = *diag
						ns = *n
						ldas = *lda
						incxs = *incx
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}

						nc++

						Dtpsv(major, uplo, trans, diag, n, aa, xx, incx)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkByte(t, nc, trans, &transs, "trans")
						checkByte(t, nc, diag, &diags, "diag")
						checkInt(t, nc, n, &ns, "n")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkFloat64Array1D(t, nc, &laa, aa, as, "aa")
						if null {
							checkFloat64Array1D(t, nc, &lx, xx, xs, "guardband xx")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = 1; i < absint(*incx); i++ {
									if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
									}
								}
							}
							for i = 1; i <= *n; i++ {
								(*z)[(i-1)*absint(*incx)] = (*xx)[(i-1)*absint(*incx)]
								(*xx)[(i-1)*absint(*incx)] = (*xs)[(i-1)*absint(*incx)]
							}
							dmvchTest(trans, n, n, onef64, a, z, incx, zerof64, xx, incx, xt, g)
							err = 0
							for i = 1; i <= (*n); i++ {
								erri = absf64((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf64
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf64(err, erri)
								if err*sqrtf64(epsf64) >= 1.0 {
									t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf64(epsf64))
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDtpsv(b *testing.B) {
	n := new(int)
	incx := new(int)
	diag := new(byte)
	major := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float64{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, 1.4965, -0.1728, -0.1429, -0.4126, 1.1469, -0.0230, -0.4925, 0.7373, -0.3327, 0.6274}
	*xx = []float64{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		Dtpsv(major, uplo, trans, diag, n, aa, xx, incx)
	}
}

func BenchmarkDtpsvFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float64{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, 1.4965, -0.1728, -0.1429, -0.4126, 1.1469, -0.0230, -0.4925, 0.7373, -0.3327, 0.6274}
	*xx = []float64{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		dtpsvWrapper(uplo, trans, diag, n, aa, xx, incx)
	}
}

func TestDger(t *testing.T) {
	tname := "Dger"
	var i, ia, im, in, incxs, incys, ix, iy, j, laa, ldas, lx, ly, ms, ns, nd, nc int
	var als, err, erri float64
	var transs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float64)
	transl := new(float64)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_m := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	major := new(byte)
	trans := new(byte)

	*major = 'C'
	*reset = true

	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	at := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	ax := func() *[]float64 { y := make([]float64, nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xs := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	ys := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	w := func() *[]float64 { y := make([]float64, 1); return &y }()
	z := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		nd = (*n)/2 + 1

		for im = 1; im <= 2; im++ {
			if im == 1 {
				*m = max((*n)-nd, 0)
			} else if im == 2 {
				*m = min((*n)+nd, nmax)
			}

			*lda = *m
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = (*lda) * (*n)

			null = *n <= 0 || *m <= 0

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*m)

				*transl = 0.5
				*_m = (*m) - 1
				dmakeGEL2(onei, m, xx, incx, zeroi, _m, reset, transl, miSbeg, icSbeg, iSbeg)
				if *m > 1 {
					(*xx)[1+absint(*incx)*((*m)/1)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					*transl = 0.0
					*_n = (*n) - 1
					dmakeGEL2(onei, n, yy, incy, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
					if *n > 1 {
						(*yy)[1+absint(*incy)*((*n)/1)-1] = 0.0
					}

					for ia = 1; ia <= len(alff64L2); ia++ {
						*alpha = alff64L2[ia-1]

						*transl = 0.0
						dmakeGEL2(m, n, aa, lda, _m, _n, reset, transl, miSbeg, icSbeg, iSbeg)

						transs = *trans
						ms = *m
						ns = *n
						ldas = *lda
						incxs = *incx
						incys = *incy
						als = *alpha
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}
						for i = 1; i <= ly; i++ {
							(*ys)[i-1] = (*yy)[i-1]
						}

						nc++

						_aa := dExpand(aa, n, lda)
						Dger(major, m, n, alpha, xx, incx, yy, incy, _aa, lda)
						dReturn(_aa, aa)

						checkByte(t, nc, trans, &transs, "trans")
						checkInt(t, nc, m, &ms, "m")
						checkInt(t, nc, n, &ns, "n")
						checkFloat64(t, nc, alpha, &als, "alpha")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkInt(t, nc, incy, &incys, "incy")
						checkFloat64Array1D(t, nc, &lx, xx, xs, "xx")
						checkFloat64Array1D(t, nc, &ly, yy, ys, "yy")
						if null {
							checkFloat64Array1D(t, nc, &laa, aa, as, "guardband aa")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = (*m) + 1; i < *lda; i++ {
									if (*aa)[i+j*(*lda)] != (*as)[i+j*(*lda)] {
										t.Errorf("Test Failed: aa[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*lda), nc, (*aa)[i+j*(*lda)], (*as)[i+j*(*lda)])
									}
								}
							}
							if *incx > 0 {
								for i = 1; i <= *m; i++ {
									(*z)[i-1][0] = (*xx)[(i-1)*absint(*incx)]
								}
							} else {
								for i = 1; i <= *m; i++ {
									(*z)[i-1][0] = (*xx)[((*m)-i)*absint(*incx)]
								}
							}
							for j = 1; j <= *n; j++ {
								if *incy > 0 {
									(*w)[0] = (*yy)[(j-1)*absint(*incy)]
								} else {
									(*w)[0] = (*yy)[((*n)-j)*absint(*incy)]
								}
								for i = 0; i < nmax; i++ {
									(*ax)[i] = (*as)[i+(j-1)*(*lda)]
								}

								// dmvch(       trans,      m,      n,      alpha,         a, nmax,          x,     incx,     beta,         y,     incy,   yt,    g, yy, epsf64, err, fatal, nout, true)
								//                  ^       ^       ^         ^            ^                 ^        ^         ^           ^        ^      ^     ^
								//       transpose--^  r/c--^  r/c--^  alpha--^  a[m x n]--^      unchanged--^  incx--^   beta--^  changed--^  incy--^  yt--^  g--^
								//                                                                   vector                         vector
								//																																																	 start
								_N := func() *byte { y := byte('N'); return &y }()
								dmvchTest(_N, m, onei, alpha, z, w, onei, onef64, ax, onei, at, g)
								for i = 0; i < nmax; i++ {
									(*ax)[i] = (*aa)[i+(j-1)*(*lda)]
								}
								err = 0
								for i = 1; i <= *m; i++ {
									erri = absf64((*at)[i-1]-(*ax)[i-1]) / epsf64
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf64(err, erri)
									if err*sqrtf64(epsf64) >= 1.0 {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.8e} error", i-1, nc, j, (*aa)[i-1], (*at)[i-1], err*sqrtf64(epsf64))
									}
								}
							}
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
		}

	}

	printTestsRun(tname, nc)
}

func BenchmarkDger(b *testing.B) {
	alpha := new(float64)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	major := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*major = 'C'
	*m = 14
	*n = 9
	*alpha = 0.70
	*xx = []float64{0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.6868, -10000000000.0000, 0.0000, -10000000000.0000, 0.2473, -10000000000.0000, 0.0774, -10000000000.0000, 0.6069, -10000000000.0000, 0.7667, -10000000000.0000, 0.3971, -10000000000.0000, 0.7268, -10000000000.0000, 0.7567, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*yy = []float64{-0.0130, -10000000000.0000, -0.4525, -10000000000.0000, 0.3766, -10000000000.0000, 0.0000, -10000000000.0000, 0.1369, -10000000000.0000, 0.0669, -10000000000.0000, 0.0270, -10000000000.0000, 0.0569, -10000000000.0000, -0.2128, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	*aa = []float64{0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -10000000000.0000, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, -10000000000.0000, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -0.0929, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.3467, 0.1768, -0.2927, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -0.3327, 0.2967, -10000000000.0000, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, -10000000000.0000, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, -10000000000.0000, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, -10000000000.0000}
	*lda = 15
	_aa := dExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Dger(major, m, n, alpha, xx, incx, yy, incy, _aa, lda)
	}
}

func BenchmarkDgerFortran(b *testing.B) {
	alpha := new(float64)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*m = 14
	*n = 9
	*alpha = 0.70
	*xx = []float64{0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.6868, -10000000000.0000, 0.0000, -10000000000.0000, 0.2473, -10000000000.0000, 0.0774, -10000000000.0000, 0.6069, -10000000000.0000, 0.7667, -10000000000.0000, 0.3971, -10000000000.0000, 0.7268, -10000000000.0000, 0.7567, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*yy = []float64{-0.0130, -10000000000.0000, -0.4525, -10000000000.0000, 0.3766, -10000000000.0000, 0.0000, -10000000000.0000, 0.1369, -10000000000.0000, 0.0669, -10000000000.0000, 0.0270, -10000000000.0000, 0.0569, -10000000000.0000, -0.2128, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	*aa = []float64{0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -10000000000.0000, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, -10000000000.0000, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -0.0929, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.3467, 0.1768, -0.2927, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -0.3327, 0.2967, -10000000000.0000, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, -10000000000.0000, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, -10000000000.0000, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, -10000000000.0000}
	*lda = 15

	for i := 0; i < b.N; i++ {
		dgerWrapper(m, n, alpha, xx, incx, yy, incy, aa, lda)
	}
}

func TestDsyr(t *testing.T) {
	tname := "Dsyr"
	var i, ia, ibeg, ic, iend, in, incxs, ix, j, ja, jj, laa, ldas, lx, ns, nc int
	var als, err, erri float64
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float64)
	transl := new(float64)
	n := new(int)
	incx := new(int)
	lda := new(int)
	lj := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	major := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	_a := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	_aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	at := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xs := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	w := func() *[]float64 { y := make([]float64, 1); return &y }()
	z := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, 1)
		}
		return &arr
	}()
	_z := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, 1)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = (*n)
		if *lda < nmax {
			*lda++
		}
		if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				*_n = (*n) - 1
				dmakeGEL2(onei, n, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
				if (*n) > 1 {
					(*xx)[1+absint(*incx)*((*n)/1)-1] = 0.0
				}

				for ia = 1; ia <= len(alff64L2); ia++ {
					*alpha = alff64L2[ia-1]
					null = *n <= 0 || *alpha == 0.0

					*transl = 0.0
					dmakeSYL2(uplo, n, a, aa, lda, _n, _n, reset, transl, miSbeg, icSbeg, iSbeg)

					uplos = *uplo
					ns = *n
					ldas = *lda
					incxs = *incx
					als = *alpha
					for i = 1; i <= laa; i++ {
						(*as)[i-1] = (*aa)[i-1]
					}
					for i = 1; i <= lx; i++ {
						(*xs)[i-1] = (*xx)[i-1]
					}

					nc++

					_aaa := dExpand(aa, n, lda)
					Dsyr(major, uplo, n, alpha, xx, incx, _aaa, lda)
					dReturn(_aaa, aa)

					checkByte(t, nc, uplo, &uplos, "uplo")
					checkInt(t, nc, n, &ns, "n")
					checkFloat64(t, nc, alpha, &als, "alpha")
					checkInt(t, nc, lda, &ldas, "lda")
					checkInt(t, nc, incx, &incxs, "incx")
					checkFloat64Array1D(t, nc, &lx, xx, xs, "xx")
					if null {
						checkFloat64Array1D(t, nc, &laa, aa, as, "guardband aa")
						if *n <= 0 {
							break
						}
					} else {
						for j = 1; j <= *n; j++ {
							if *uplo == 'U' {
								ibeg = 1
								iend = j
							} else {
								ibeg = j
								iend = *n
							}
							for i = 1; i < ibeg; i++ {
								if (*aa)[i+(j-1)*(*lda)-1] != (*as)[i+(j-1)*(*lda)-1] {
									t.Errorf("Test Failed: aa[%d] guardband: iteration %d-%d: {%10.8f} output, {%10.8f} expected", i+(j-1)*(*lda)-1, nc, j, (*as)[i+(j-1)*(*lda)-1], (*aa)[i+(j-1)*(*lda)-1])
								}
							}
							for i = iend + 1; i <= *lda; i++ {
								if (*aa)[i+(j-1)*(*lda)-1] != (*as)[i+(j-1)*(*lda)-1] {
									t.Errorf("Test Failed: aa[%d] guardband: iteration %d-%d: {%10.8f} output, {%10.8f} expected", i+(j-1)*(*lda)-1, nc, j, (*as)[i+(j-1)*(*lda)-1], (*aa)[i+(j-1)*(*lda)-1])
								}
							}
						}

						if *incx > 0 {
							for i = 1; i <= *n; i++ {
								(*z)[i-1][0] = (*xx)[(i-1)*absint(*incx)]
							}
						} else {
							for i = 1; i <= *n; i++ {
								(*z)[i-1][0] = (*xx)[((*n)-i)*absint(*incx)]
							}
						}
						ja = 1
						for j = 1; j <= *n; j++ {
							(*w)[0] = (*z)[j-1][0]
							if *uplo == 'U' {
								jj = 1
								*lj = j
							} else {
								jj = j
								*lj = (*n) - j + 1
							}
							for i = 0; i < (*n); i++ {
								(*_z)[i][0] = (*z)[i+jj-1][0]
							}
							for i = 0; i < *lj; i++ {
								(*_a)[i] = (*a)[jj-1+i][j-1]
							}
							for i = 0; i < len((*aa)[ja-1:]); i++ {
								(*_aa)[i] = (*aa)[i+ja-1]
							}

							// dmvch(       trans,      m,      n,      alpha,         a, nmax,          x,     incx,     beta,         y,     incy,   yt,    g, yy, epsf64, err, fatal, nout, true)
							//                  ^       ^       ^         ^            ^                 ^        ^         ^           ^        ^      ^     ^
							//       transpose--^  r/c--^  r/c--^  alpha--^  a[m x n]--^      unchanged--^  incx--^   beta--^  changed--^  incy--^  yt--^  g--^
							//                                                                   vector                         vector
							//																																																	 start
							_N := func() *byte { y := byte('N'); return &y }()
							dmvchTest(_N, lj, onei, alpha, _z, w, onei, onef64, _a, onei, at, g)
							err = 0
							for i = 1; i <= *lj; i++ {
								erri = absf64((*at)[i-1]-(*_aa)[i-1]) / epsf64
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf64(err, erri)
								if err*sqrtf64(epsf64) >= 1.0 {
									t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", i-1, nc, j, (*_aa)[i-1], (*at)[i-1], err*sqrtf64(epsf64))
								}
							}
							if *uplo == 'U' {
								ja += *lda
							} else {
								ja += (*lda) + 1
							}
						}
					}

					if *n <= 0 {
						break
					}
				}
				if *n <= 0 {
					break
				}
			}

			if *n <= 0 {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDsyr(b *testing.B) {
	alpha := new(float64)
	n := new(int)
	incx := new(int)
	lda := new(int)
	major := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float64{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*aa = []float64{0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.3726, -0.3427, 0.3866, -0.1828, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0529, 0.3067, -0.4625, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4665, 0.0969, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4266, -10000000000.0000}
	*lda = 10
	_aa := dExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Dsyr(major, uplo, n, alpha, xx, incx, _aa, lda)
	}
}

func BenchmarkDsyrFortran(b *testing.B) {
	alpha := new(float64)
	n := new(int)
	incx := new(int)
	lda := new(int)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float64{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*aa = []float64{0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.3726, -0.3427, 0.3866, -0.1828, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0529, 0.3067, -0.4625, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4665, 0.0969, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4266, -10000000000.0000}
	*lda = 10

	for i := 0; i < b.N; i++ {
		dsyrWrapper(uplo, n, alpha, xx, incx, aa, lda)
	}
}

func TestDspr(t *testing.T) {
	tname := "Dspr"
	var i, ia, ic, in, incxs, ix, j, ja, jj, laa, lx, ns, nc int
	var als, err, erri float64
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float64)
	transl := new(float64)
	n := new(int)
	incx := new(int)
	lj := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	major := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	_a := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	_aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	at := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xs := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	w := func() *[]float64 { y := make([]float64, 2); return &y }()
	z := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, 1)
		}
		return &arr
	}()
	_z := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, 1)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		laa = ((*n) + ((*n) + 1)) / 2

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				*_n = (*n) - 1
				dmakeGEL2(onei, n, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
				if (*n) > 1 {
					(*xx)[1+absint(*incx)*((*n)/1)-1] = 0.0
				}

				for ia = 1; ia <= len(alff64L2); ia++ {
					*alpha = alff64L2[ia-1]
					null = *n <= 0 || *alpha == 0.0

					*transl = 0.0
					dmakeSPL2(uplo, n, n, a, aa, _n, _n, reset, transl, miSbeg, icSbeg, iSbeg)

					uplos = *uplo
					ns = *n
					incxs = *incx
					als = *alpha
					for i = 1; i <= laa; i++ {
						(*as)[i-1] = (*aa)[i-1]
					}
					for i = 1; i <= lx; i++ {
						(*xs)[i-1] = (*xx)[i-1]
					}

					nc++

					Dspr(major, uplo, n, alpha, xx, incx, aa)

					checkByte(t, nc, uplo, &uplos, "uplo")
					checkInt(t, nc, n, &ns, "n")
					checkFloat64(t, nc, alpha, &als, "alpha")
					checkInt(t, nc, incx, &incxs, "incx")
					checkFloat64Array1D(t, nc, &lx, xx, xs, "xx")
					if null {
						checkFloat64Array1D(t, nc, &laa, aa, as, "guardband aa")
						if *n <= 0 {
							break
						}
					} else {
						if *incx > 0 {
							for i = 1; i <= *n; i++ {
								(*z)[i-1][0] = (*xx)[(i-1)*absint(*incx)]
							}
						} else {
							for i = 1; i <= *n; i++ {
								(*z)[i-1][0] = (*xx)[((*n)-i)*absint(*incx)]
							}
						}
						ja = 1
						for j = 1; j <= *n; j++ {
							(*w)[0] = (*z)[j-1][0]
							if *uplo == 'U' {
								jj = 1
								*lj = j
							} else {
								jj = j
								*lj = (*n) - j + 1
							}
							for i = 0; i < *n; i++ {
								(*_z)[i][0] = (*z)[i+jj-1][0]
							}
							for i = 0; i < *lj; i++ {
								(*_a)[i] = (*a)[jj-1+i][j-1]
							}
							for i = 0; i < len((*aa)[ja-1:]); i++ {
								(*_aa)[i] = (*aa)[i+ja-1]
							}

							// dmvch(       trans,      m,      n,      alpha,         a, nmax,          x,     incx,     beta,         y,     incy,   yt,    g, yy, epsf64, err, fatal, nout, true)
							//                  ^       ^       ^         ^            ^                 ^        ^         ^           ^        ^      ^     ^
							//       transpose--^  r/c--^  r/c--^  alpha--^  a[m x n]--^      unchanged--^  incx--^   beta--^  changed--^  incy--^  yt--^  g--^
							//                                                                   vector                         vector
							//																																																	 start
							_N := func() *byte { y := byte('N'); return &y }()
							dmvchTest(_N, lj, onei, alpha, _z, w, onei, onef64, _a, onei, at, g)
							err = 0
							for i = 1; i <= *lj; i++ {
								erri = absf64((*at)[i-1]-(*_aa)[i-1]) / epsf64
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf64(err, erri)
								if err*sqrtf64(epsf64) >= 1.0 {
									t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", i-1, nc, j, (*aa)[i-1], (*at)[i-1], err*sqrtf64(epsf64))
								}
							}
							ja += *lj
						}
					}
				}

				if *n <= 0 {
					break
				}

			}

			if *n <= 0 {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDspr(b *testing.B) {
	alpha := new(float64)
	n := new(int)
	incx := new(int)
	major := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float64{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*aa = []float64{0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266}

	for i := 0; i < b.N; i++ {
		Dspr(major, uplo, n, alpha, xx, incx, aa)
	}
}

func BenchmarkDsprFortran(b *testing.B) {
	alpha := new(float64)
	n := new(int)
	incx := new(int)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float64{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*aa = []float64{0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266}

	for i := 0; i < b.N; i++ {
		dsprWrapper(uplo, n, alpha, xx, incx, aa)
	}
}

func TestDsyr2(t *testing.T) {
	tname := "Dsyr2"
	var i, ia, ibeg, ic, iend, in, incxs, incys, ix, iy, j, ja, jj, laa, ldas, lx, ly, ns, nc int
	var als, err, erri float64
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float64)
	transl := new(float64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	lj := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	major := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	_a := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	_aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	at := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xs := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	ys := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	w := func() *[]float64 { y := make([]float64, 2); return &y }()
	z := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, 2)
		}
		return &arr
	}()
	_z := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, 2)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = (*n)
		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				*_n = (*n) - 1
				dmakeGEL2(onei, n, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
				if (*n) > 1 {
					(*xx)[1+absint(*incx)*((*n)/1)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incx) * (*n)

					*transl = 0.0
					dmakeGEL2(onei, n, yy, incy, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
					if (*n) > 1 {
						(*yy)[1+absint(*incy)*((*n)/1)-1] = 0.0
					}

					for ia = 1; ia <= len(alff64L2); ia++ {
						*alpha = alff64L2[ia-1]
						null = *n <= 0 || *alpha == 0.0

						*transl = 0.0
						dmakeSYL2(uplo, n, a, aa, lda, _n, _n, reset, transl, miSbeg, icSbeg, iSbeg)

						uplos = *uplo
						ns = *n
						ldas = *lda
						incxs = *incx
						incys = *incy
						als = *alpha
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}
						for i = 1; i <= ly; i++ {
							(*ys)[i-1] = (*yy)[i-1]
						}

						nc++

						_aaa := dExpand(aa, n, lda)
						Dsyr2(major, uplo, n, alpha, xx, incx, yy, incy, _aaa, lda)
						dReturn(_aaa, aa)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkInt(t, nc, n, &ns, "n")
						checkFloat64(t, nc, alpha, &als, "alpha")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkInt(t, nc, incy, &incys, "incy")
						checkFloat64Array1D(t, nc, &lx, xx, xs, "xx")
						checkFloat64Array1D(t, nc, &ly, yy, ys, "yy")
						if null {
							checkFloat64Array1D(t, nc, &laa, aa, as, "guardband aa")
							if *n <= 0 {
								break
							}
						} else {
							for j = 1; j <= *n; j++ {
								if *uplo == 'U' {
									ibeg = 1
									iend = j
								} else {
									ibeg = j
									iend = *n
								}
								for i = 1; i < ibeg; i++ {
									if (*aa)[i+(j-1)*(*lda)-1] != (*as)[i+(j-1)*(*lda)-1] {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected", i+(j-1)*(*lda)-1, nc, j, (*as)[i+(j-1)*(*lda)-1], (*aa)[i+(j-1)*(*lda)-1])
									}
								}
								for i = iend + 1; i <= *lda; i++ {
									if (*aa)[i+(j-1)*(*lda)-1] != (*as)[i+(j-1)*(*lda)-1] {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected", i+(j-1)*(*lda)-1, nc, j, (*as)[i+(j-1)*(*lda)-1], (*aa)[i+(j-1)*(*lda)-1])
									}
								}
							}

							if *incx > 0 {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][0] = (*xx)[(i-1)*absint(*incx)]
								}
							} else {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][0] = (*xx)[((*n)-i)*absint(*incx)]
								}
							}
							if *incy > 0 {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][1] = (*yy)[(i-1)*absint(*incy)]
								}
							} else {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][1] = (*yy)[((*n)-i)*absint(*incy)]
								}
							}
							ja = 1
							for j = 1; j <= *n; j++ {
								(*w)[0] = (*z)[j-1][1]
								(*w)[1] = (*z)[j-1][0]
								if *uplo == 'U' {
									jj = 1
									*lj = j
								} else {
									jj = j
									*lj = (*n) - j + 1
								}
								for i = 0; i < len((*z)[jj-1:]); i++ {
									(*_z)[i][0] = (*z)[i+jj-1][0]
									(*_z)[i][1] = (*z)[i+jj-1][1]
								}
								for i = 0; i < *lj; i++ {
									(*_a)[i] = (*a)[jj-1+i][j-1]
								}
								for i = 0; i < len((*aa)[ja-1:]); i++ {
									(*_aa)[i] = (*aa)[i+ja-1]
								}

								// dmvch(       trans,      m,      n,      alpha,         a, nmax,          x,     incx,     beta,         y,     incy,   yt,    g, yy, epsf64, err, fatal, nout, true)
								//                  ^       ^       ^         ^            ^                 ^        ^         ^           ^        ^      ^     ^
								//       transpose--^  r/c--^  r/c--^  alpha--^  a[m x n]--^      unchanged--^  incx--^   beta--^  changed--^  incy--^  yt--^  g--^
								//                                                                   vector                         vector
								//																																																	 start
								_N := func() *byte { y := byte('N'); return &y }()
								dmvchTest(_N, lj, twoi, alpha, _z, w, onei, onef64, _a, onei, at, g)
								err = 0
								for i = 1; i <= *lj; i++ {
									erri = absf64((*at)[i-1]-(*_aa)[i-1]) / epsf64
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf64(err, erri)
									if err*sqrtf64(epsf64) >= 1.0 {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", i-1, nc, j, (*_aa)[i-1], (*at)[i-1], err*sqrtf64(epsf64))
									}
								}
								if *uplo == 'U' {
									ja += *lda
								} else {
									ja += (*lda) + 1
								}
							}
						}

						if *n <= 0 {
							break
						}
					}

					if *n <= 0 {
						break
					}
				}

				if *n <= 0 {
					break
				}
			}

			if *n <= 0 {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDsyr2(b *testing.B) {
	alpha := new(float64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	major := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float64{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*yy = []float64{0.4665, -10000000000.0000, 0.0969, -10000000000.0000, 0.4266, -10000000000.0000, 0.0000, -10000000000.0000, 0.1868, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.3367, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	*aa = []float64{0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, -10000000000.0000, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4266, 0.1868, -0.3826, -0.2527, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.4226, 0.1069, 0.2667, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1029, 0.2268, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2567, -10000000000.0000}
	*lda = 10
	_aa := dExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Dsyr2(major, uplo, n, alpha, xx, incx, yy, incy, _aa, lda)
	}
}

func BenchmarkDsyr2Fortran(b *testing.B) {
	alpha := new(float64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float64{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*yy = []float64{0.4665, -10000000000.0000, 0.0969, -10000000000.0000, 0.4266, -10000000000.0000, 0.0000, -10000000000.0000, 0.1868, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.3367, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	*aa = []float64{0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, -10000000000.0000, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4266, 0.1868, -0.3826, -0.2527, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.4226, 0.1069, 0.2667, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1029, 0.2268, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2567, -10000000000.0000}
	*lda = 10

	for i := 0; i < b.N; i++ {
		dsyr2Wrapper(uplo, n, alpha, xx, incx, yy, incy, aa, lda)
	}
}

func TestDspr2(t *testing.T) {
	tname := "Dspr2"
	var i, ia, ic, in, incxs, incys, ix, iy, j, ja, jj, laa, lx, ly, ns, nc int
	var als, err, erri float64
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float64)
	transl := new(float64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lj := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	major := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	_a := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	_aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	at := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	xs := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	ys := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	w := func() *[]float64 { y := make([]float64, 2); return &y }()
	z := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, 2)
		}
		return &arr
	}()
	_z := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, 2)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		laa = ((*n) + ((*n) + 1)) / 2

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				*_n = (*n) - 1
				dmakeGEL2(onei, n, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
				if (*n) > 1 {
					(*xx)[1+absint(*incx)*((*n)/1)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					*transl = 0.0
					dmakeGEL2(onei, n, yy, incy, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
					if (*n) > 1 {
						(*yy)[1+absint(*incy)*((*n)/1)-1] = 0.0
					}

					for ia = 1; ia <= len(alff64L2); ia++ {
						*alpha = alff64L2[ia-1]
						null = *n <= 0 || *alpha == 0.0

						*transl = 0.0
						dmakeSPL2(uplo, n, n, a, aa, _n, _n, reset, transl, miSbeg, icSbeg, iSbeg)

						uplos = *uplo
						ns = *n
						incxs = *incx
						incys = *incy
						als = *alpha
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}
						for i = 1; i <= ly; i++ {
							(*ys)[i-1] = (*yy)[i-1]
						}

						nc++

						Dspr2(major, uplo, n, alpha, xx, incx, yy, incy, aa)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkInt(t, nc, n, &ns, "n")
						checkFloat64(t, nc, alpha, &als, "alpha")
						checkInt(t, nc, incx, &incxs, "incx")
						checkInt(t, nc, incy, &incys, "incy")
						checkFloat64Array1D(t, nc, &lx, xx, xs, "xx")
						checkFloat64Array1D(t, nc, &ly, yy, ys, "yy")
						if null {
							checkFloat64Array1D(t, nc, &laa, aa, as, "guardband aa")
							if *n <= 0 {
								break
							}
						} else {
							if *incx > 0 {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][0] = (*xx)[(i-1)*absint(*incx)]
								}
							} else {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][0] = (*xx)[((*n)-i)*absint(*incx)]
								}
							}
							if *incy > 0 {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][1] = (*yy)[(i-1)*absint(*incy)]
								}
							} else {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][1] = (*yy)[((*n)-i)*absint(*incy)]
								}
							}
							ja = 1
							for j = 1; j <= *n; j++ {
								(*w)[0] = (*z)[j-1][1]
								(*w)[1] = (*z)[j-1][0]
								if *uplo == 'U' {
									jj = 1
									*lj = j
								} else {
									jj = j
									*lj = (*n) - j + 1
								}
								for i = 0; i < *n; i++ {
									(*_z)[i][0] = (*z)[i+jj-1][0]
									(*_z)[i][1] = (*z)[i+jj-1][1]
								}
								for i = 0; i < *lj; i++ {
									(*_a)[i] = (*a)[jj-1+i][j-1]
								}
								for i = 0; i < len((*aa)[ja-1:]); i++ {
									(*_aa)[i] = (*aa)[i+ja-1]
								}

								// dmvch(       trans,      m,      n,      alpha,         a, nmax,          x,     incx,     beta,         y,     incy,   yt,    g, yy, epsf64, err, fatal, nout, true)
								//                  ^       ^       ^         ^            ^                 ^        ^         ^           ^        ^      ^     ^
								//       transpose--^  r/c--^  r/c--^  alpha--^  a[m x n]--^      unchanged--^  incx--^   beta--^  changed--^  incy--^  yt--^  g--^
								//                                                                   vector                         vector
								//																																																	 start
								_N := func() *byte { y := byte('N'); return &y }()
								dmvchTest(_N, lj, twoi, alpha, _z, w, onei, onef64, _a, onei, at, g)
								err = 0
								for i = 1; i <= *lj; i++ {
									erri = absf64((*at)[i-1]-(*_aa)[i-1]) / epsf64
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf64(err, erri)
									if err*sqrtf64(epsf64) >= 1.0 {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", i-1, nc, j, (*_aa)[i-1], (*at)[i-1], err*sqrtf64(epsf64))
									}
								}
								ja += *lj
							}
						}
					}

					if *n <= 0 {
						break
					}
				}

				if *n <= 0 {
					break
				}
			}

			if *n <= 0 {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDspr2(b *testing.B) {
	alpha := new(float64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	major := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float64{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*yy = []float64{0.4665, -10000000000.0000, 0.0969, -10000000000.0000, 0.4266, -10000000000.0000, 0.0000, -10000000000.0000, 0.1868, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.3367, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	*aa = []float64{0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266}

	for i := 0; i < b.N; i++ {
		Dspr2(major, uplo, n, alpha, xx, incx, yy, incy, aa)
	}
}

func BenchmarkDspr2Fortran(b *testing.B) {
	alpha := new(float64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float64{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*yy = []float64{0.4665, -10000000000.0000, 0.0969, -10000000000.0000, 0.4266, -10000000000.0000, 0.0000, -10000000000.0000, 0.1868, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.3367, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	*aa = []float64{0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266}

	for i := 0; i < b.N; i++ {
		dspr2Wrapper(uplo, n, alpha, xx, incx, yy, incy, aa)
	}
}

// BLAS Level 3
func TestDgemm(t *testing.T) {
	tname := "Dgemm"
	var i, ia, ib, ica, icb, ik, im, in, j, ks, laa, lbb, lcc, ldas, ldbs, ldcs, ms, nc, ns int
	var als, bls float64
	var tranas, tranbs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float64)
	beta := new(float64)
	transl := new(float64)
	k := new(int)
	m := new(int)
	ma := new(int)
	mb := new(int)
	n := new(int)
	na := new(int)
	nb := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	transa := new(byte)
	transb := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	b := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	bb := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	bs := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	c := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	cc := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	cs := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	ct := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldc = *m
			if *ldc < nmax {
				*ldc++
			}
			if *ldc > nmax {
				continue
			}
			lcc = (*ldc) * (*n)

			null = *n <= 0 || *m <= 0

			for ik = 1; ik <= len(idimL3); ik++ {
				*k = idimL3[ik-1]

				for ica = 1; ica <= len(ichtL3); ica++ {
					*transa = ichtL3[ica-1]

					if *transa == 'T' || *transa == 'C' {
						*ma = *k
						*na = *m
					} else {
						*ma = *m
						*na = *k
					}

					*lda = *ma
					if *lda < nmax {
						*lda++
					}
					if *lda > nmax {
						continue
					}
					laa = (*lda) * (*na)

					dmakeGEL3(ma, na, a, aa, lda, reset, zerof64, miSbeg, icSbeg, iSbeg)

					for icb = 1; icb <= len(ichtL3); icb++ {
						*transb = ichtL3[icb-1]

						if *transb == 'T' || *transb == 'C' {
							*mb = *n
							*nb = *k
						} else {
							*mb = *k
							*nb = *n
						}

						*ldb = *mb
						if *ldb < nmax {
							*ldb++
						}
						if *ldb > nmax {
							continue
						}
						lbb = (*ldb) * (*nb)

						dmakeGEL3(mb, nb, b, bb, ldb, reset, zerof64, miSbeg, icSbeg, iSbeg)

						for ia = 1; ia <= len(alff64L3); ia++ {
							*alpha = alff64L3[ia-1]

							for ib = 1; ib <= len(betf64L3); ib++ {
								*beta = betf64L3[ib-1]

								dmakeGEL3(m, n, c, cc, ldc, reset, transl, miSbeg, icSbeg, iSbeg)

								tranas = *transa
								tranbs = *transb
								ms = *m
								ns = *n
								ks = *k
								als = *alpha
								bls = *beta
								ldas = *lda
								ldbs = *ldb
								ldcs = *ldc
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lbb; i++ {
									(*bs)[i-1] = (*bb)[i-1]
								}
								for i = 1; i <= lcc; i++ {
									(*cs)[i-1] = (*cc)[i-1]
								}

								nc++

								_aa := dExpand(aa, na, lda)
								_bb := dExpand(bb, nb, ldb)
								_cc := dExpand(cc, n, ldc)
								Dgemm(major, transa, transb, m, n, k, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
								dReturn(_aa, aa)
								dReturn(_bb, bb)
								dReturn(_cc, cc)

								checkByte(t, nc, transa, &tranas, "transa")
								checkByte(t, nc, transb, &tranbs, "transb")
								checkInt(t, nc, m, &ms, "m")
								checkInt(t, nc, n, &ns, "n")
								checkInt(t, nc, k, &ks, "k")
								checkFloat64(t, nc, alpha, &als, "alpha")
								checkFloat64(t, nc, beta, &bls, "beta")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, ldb, &ldbs, "ldb")
								checkInt(t, nc, ldc, &ldcs, "ldc")
								checkFloat64Array1D(t, nc, &laa, aa, as, "aa")
								checkFloat64Array1D(t, nc, &lbb, bb, bs, "bb")
								if null {
									checkFloat64Array1D(t, nc, &lcc, cc, cs, "guardband cc")
								} else {
									for j = 0; j < *n; j++ {
										for i = (*m) + 1; i <= *ldc; i++ {
											if (*cc)[i+j*(*ldc)-1] != (*cs)[i+j*(*ldc)-1] {
												t.Errorf("Test Failed: cc[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldc), nc, (*cc)[i+j*(*ldc)], (*cs)[i+j*(*ldc)])
											}
										}
									}
									dmmchTest(transa, transb, m, n, k, alpha, a, b, beta, c, ct, g, cc, ldc, nc, "cc", t)
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDgemm(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	k := new(int)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	major := new(byte)
	transa := new(byte)
	transb := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	bb := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	cc := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	*major = 'C'
	*transa = 'C'
	*transb = 'C'
	*m = 9
	*n = 9
	*k = 9
	*alpha = 0.70
	*aa = []float64{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*lda = 10
	*bb = []float64{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, -10000000000.0000, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0270, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -10000000000.0000, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -10000000000.0000}
	*ldb = 10
	*beta = 1.30
	*cc = []float64{-0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -10000000000.0000, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.1369, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -10000000000.0000, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, -10000000000.0000, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, -10000000000.0000, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -0.0929, -10000000000.0000, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -0.2927, -0.0629, -10000000000.0000}
	*ldc = 10
	_aa := dExpand(aa, m, lda)
	_bb := dExpand(bb, k, ldb)
	_cc := dExpand(cc, n, ldc)

	for i := 0; i < b.N; i++ {
		Dgemm(major, transa, transb, m, n, k, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
	}
}

func BenchmarkDgemmFortran(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	k := new(int)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	transa := new(byte)
	transb := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	bb := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	cc := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	*transa = 'C'
	*transb = 'C'
	*m = 9
	*n = 9
	*k = 9
	*alpha = 0.70
	*aa = []float64{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*lda = 10
	*bb = []float64{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, -10000000000.0000, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0270, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -10000000000.0000, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -10000000000.0000}
	*ldb = 10
	*beta = 1.30
	*cc = []float64{-0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -10000000000.0000, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.1369, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -10000000000.0000, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, -10000000000.0000, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, -10000000000.0000, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -0.0929, -10000000000.0000, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -0.2927, -0.0629, -10000000000.0000}
	*ldc = 10

	for i := 0; i < b.N; i++ {
		dgemmWrapper(transa, transb, m, n, k, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func TestDsymm(t *testing.T) {
	tname := "Dsymm"
	var i, ia, ib, ics, icu, im, in, j, laa, lbb, lcc, ldas, ldbs, ldcs, ms, nc, ns int
	var als, bls float64
	var sides, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float64)
	beta := new(float64)
	transl := new(float64)
	m := new(int)
	n := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	major := new(byte)
	side := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	b := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	bb := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	bs := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	c := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	cc := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	cs := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	ct := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldc = *m
			if *ldc < nmax {
				*ldc++
			}
			if *ldc > nmax {
				continue
			}
			lcc = (*ldc) * (*n)

			null = *n <= 0 || *m <= 0

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			dmakeGEL3(m, n, b, bb, ldb, reset, zerof64, miSbeg, icSbeg, iSbeg)

			for ics = 1; ics <= len(ichsL3); ics++ {
				*side = ichsL3[ics-1]

				if *side == 'L' {
					*na = *m
				} else {
					*na = *n
				}

				*lda = *na
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					dmakeSYL3(uplo, na, na, a, aa, lda, reset, zerof64, miSbeg, icSbeg, iSbeg)

					for ia = 1; ia <= len(alff64L3); ia++ {
						*alpha = alff64L3[ia-1]

						for ib = 1; ib <= len(betf64L3); ib++ {
							*beta = betf64L3[ib-1]

							dmakeGEL3(m, n, c, cc, ldc, reset, transl, miSbeg, icSbeg, iSbeg)

							sides = *side
							uplos = *uplo
							ms = *m
							ns = *n
							als = *alpha
							bls = *beta
							ldas = *lda
							ldbs = *ldb
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lbb; i++ {
								(*bs)[i-1] = (*bb)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := dExpand(aa, na, lda)
							_bb := dExpand(bb, n, ldb)
							_cc := dExpand(cc, n, ldc)
							Dsymm(major, side, uplo, m, n, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
							dReturn(_aa, aa)
							dReturn(_bb, bb)
							dReturn(_cc, cc)

							checkByte(t, nc, side, &sides, "side")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, m, &ms, "m")
							checkInt(t, nc, n, &ns, "n")
							checkFloat64(t, nc, alpha, &als, "alpha")
							checkFloat64(t, nc, beta, &bls, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldb, &ldbs, "ldb")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkFloat64Array1D(t, nc, &laa, aa, as, "aa")
							checkFloat64Array1D(t, nc, &lbb, bb, bs, "bb")
							if null {
								checkFloat64Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 0; j < *n; j++ {
									for i = (*m) + 1; i <= *ldc; i++ {
										if (*cc)[i+j*(*ldc)-1] != (*cs)[i+j*(*ldc)-1] {
											t.Errorf("Test Failed: guardband cc[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldc), nc, (*cc)[i+j*(*ldc)], (*cs)[i+j*(*ldc)])
										}
									}
								}
								_N := func() *byte { y := byte('N'); return &y }()
								if *side == 'L' {
									dmmchTest(_N, _N, m, n, m, alpha, a, b, beta, c, ct, g, cc, ldc, nc, "cc", t)
								} else {
									dmmchTest(_N, _N, m, n, n, alpha, b, a, beta, c, ct, g, cc, ldc, nc, "cc", t)
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDsymm(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	major := new(byte)
	side := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	bb := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	cc := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	*major = 'C'
	*side = 'R'
	*uplo = 'L'
	*m = 9
	*n = 9
	*alpha = 0.70
	*aa = []float64{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2527, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4166, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2927, -0.0629, -0.1329, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1429, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -10000000000.0000}
	*lda = 10
	*bb = []float64{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*ldb = 10
	*beta = 1.30
	*cc = []float64{-0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.3467, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -10000000000.0000, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -10000000000.0000, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, -10000000000.0000, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -10000000000.0000}
	*ldc = 10
	_aa := dExpand(aa, n, lda)
	_bb := dExpand(bb, n, ldb)
	_cc := dExpand(cc, n, ldc)

	for i := 0; i < b.N; i++ {
		Dsymm(major, side, uplo, m, n, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
	}
}

func BenchmarkDsymmFortran(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	side := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	bb := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	cc := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	*side = 'R'
	*uplo = 'L'
	*m = 9
	*n = 9
	*alpha = 0.70
	*aa = []float64{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2527, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4166, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2927, -0.0629, -0.1329, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1429, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -10000000000.0000}
	*lda = 10
	*bb = []float64{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*ldb = 10
	*beta = 1.30
	*cc = []float64{-0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.3467, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -10000000000.0000, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -10000000000.0000, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, -10000000000.0000, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -10000000000.0000}
	*ldc = 10

	for i := 0; i < b.N; i++ {
		dsymmWrapper(side, uplo, m, n, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func TestDtrmm(t *testing.T) {
	tname := "Dtrmm"
	var i, ia, icd, ics, ict, icu, im, in, j, laa, lbb, ldas, ldbs, ms, nc, ns int
	var als float64
	var diags, sides, tranas, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float64)
	beta := new(float64)
	m := new(int)
	n := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	major := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	b := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	bb := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	bs := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	c := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	// cc := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	ct := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			null = *n <= 0 || *m <= 0

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			dmakeGEL3(m, n, b, bb, ldb, reset, zerof64, miSbeg, icSbeg, iSbeg)

			for ics = 1; ics <= len(ichsL3); ics++ {
				*side = ichsL3[ics-1]

				if *side == 'L' {
					*na = *m
				} else {
					*na = *n
				}

				*lda = *na
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ict = 1; ict <= len(ichtL3); ict++ {
						*transa = ichtL3[ict-1]

						for icd = 1; icd <= len(ichdL3); icd++ {
							*diag = ichdL3[icd-1]

							for ia = 1; ia <= len(alff64L3); ia++ {
								*alpha = alff64L3[ia-1]

								dmakeTRL3(uplo, diag, na, na, a, aa, lda, reset, zerof64, miSbeg, icSbeg, iSbeg)

								dmakeGEL3(m, n, b, bb, ldb, reset, zerof64, miSbeg, icSbeg, iSbeg)

								diags = *diag
								sides = *side
								tranas = *transa
								uplos = *uplo
								ms = *m
								ns = *n
								als = *alpha
								ldas = *lda
								ldbs = *ldb
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lbb; i++ {
									(*bs)[i-1] = (*bb)[i-1]
								}

								nc++

								_aa := dExpand(aa, na, lda)
								_bb := dExpand(bb, n, ldb)
								Dtrmm(major, side, uplo, transa, diag, m, n, alpha, _aa, lda, _bb, ldb)
								dReturn(_aa, aa)
								dReturn(_bb, bb)

								checkByte(t, nc, diag, &diags, "diag")
								checkByte(t, nc, side, &sides, "side")
								checkByte(t, nc, transa, &tranas, "transa")
								checkByte(t, nc, uplo, &uplos, "uplo")
								checkInt(t, nc, m, &ms, "m")
								checkInt(t, nc, n, &ns, "n")
								checkFloat64(t, nc, alpha, &als, "alpha")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, ldb, &ldbs, "ldb")
								checkFloat64Array1D(t, nc, &laa, aa, as, "aa")
								if null {
									checkFloat64Array1D(t, nc, &lbb, bb, bs, "guardband bb")
								} else {
									for j = 0; j < *n; j++ {
										for i = (*m) + 1; i <= *ldb; i++ {
											if (*bb)[i+j*(*ldb)-1] != (*bs)[i+j*(*ldb)-1] {
												t.Errorf("Test Failed: guardband bb[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldb), nc, (*bb)[i+j*(*ldb)], (*bs)[i+j*(*ldb)])
											}
										}
									}
									_N := func() *byte { y := byte('N'); return &y }()
									if *side == 'L' {
										dmmchTest(transa, _N, m, n, m, alpha, a, b, beta, c, ct, g, bb, ldb, nc, "bb", t)
									} else {
										dmmchTest(_N, transa, m, n, n, alpha, b, a, beta, c, ct, g, bb, ldb, nc, "bb", t)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDtrmm(b *testing.B) {
	alpha := new(float64)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	major := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	bb := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	*major = 'C'
	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'N'
	*m = 9
	*n = 9
	*alpha = 0.70
	*aa = []float64{1.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -10000000000.0000, 0.7772, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7473, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4166, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.0270, 0.0569, -0.2128, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7073, -0.0629, -0.1329, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.8571, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -10000000000.0000}
	*lda = 10
	*bb = []float64{-0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.3467, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -10000000000.0000, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -10000000000.0000, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, -10000000000.0000, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -10000000000.0000}
	*ldb = 10
	_aa := dExpand(aa, n, lda)
	_bb := dExpand(bb, n, ldb)

	for i := 0; i < b.N; i++ {
		Dtrmm(major, side, uplo, transa, diag, m, n, alpha, _aa, lda, _bb, ldb)
	}
}

func BenchmarkDtrmmFortran(b *testing.B) {
	alpha := new(float64)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	bb := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'N'
	*m = 9
	*n = 9
	*alpha = 0.70
	*aa = []float64{1.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -10000000000.0000, 0.7772, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7473, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4166, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.0270, 0.0569, -0.2128, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7073, -0.0629, -0.1329, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.8571, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -10000000000.0000}
	*lda = 10
	*bb = []float64{-0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.3467, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -10000000000.0000, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -10000000000.0000, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, -10000000000.0000, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -10000000000.0000}
	*ldb = 10

	for i := 0; i < b.N; i++ {
		dtrmmWrapper(side, uplo, transa, diag, m, n, alpha, aa, lda, bb, ldb)
	}
}

func TestDtrsm(t *testing.T) {
	tname := "Dtrsm"
	var i, ia, icd, ics, ict, icu, im, in, j, laa, lbb, ldas, ldbs, ms, nc, ns int
	var als float64
	var diags, sides, tranas, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float64)
	m := new(int)
	n := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	major := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	b := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	bb := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	bs := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	c := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	ct := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			null = *n <= 0 || *m <= 0

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			for ics = 1; ics <= len(ichsL3); ics++ {
				*side = ichsL3[ics-1]

				if *side == 'L' {
					*na = *m
				} else {
					*na = *n
				}

				*lda = *na
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ict = 1; ict <= len(ichtL3); ict++ {
						*transa = ichtL3[ict-1]

						for icd = 1; icd <= len(ichdL3); icd++ {
							*diag = ichdL3[icd-1]

							for ia = 1; ia <= len(alff64L3); ia++ {
								*alpha = alff64L3[ia-1]

								dmakeTRL3(uplo, diag, na, na, a, aa, lda, reset, zerof64, miSbeg, icSbeg, iSbeg)

								dmakeGEL3(m, n, b, bb, ldb, reset, zerof64, miSbeg, icSbeg, iSbeg)

								diags = *diag
								sides = *side
								tranas = *transa
								uplos = *uplo
								ms = *m
								ns = *n
								als = *alpha
								ldas = *lda
								ldbs = *ldb
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lbb; i++ {
									(*bs)[i-1] = (*bb)[i-1]
								}

								nc++

								_aa := dExpand(aa, na, lda)
								_bb := dExpand(bb, n, ldb)
								Dtrsm(major, side, uplo, transa, diag, m, n, alpha, _aa, lda, _bb, ldb)
								dReturn(_aa, aa)
								dReturn(_bb, bb)

								checkByte(t, nc, diag, &diags, "diag")
								checkByte(t, nc, side, &sides, "side")
								checkByte(t, nc, transa, &tranas, "transa")
								checkByte(t, nc, uplo, &uplos, "uplo")
								checkInt(t, nc, m, &ms, "m")
								checkInt(t, nc, n, &ns, "n")
								checkFloat64(t, nc, alpha, &als, "alpha")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, ldb, &ldbs, "ldb")
								checkFloat64Array1D(t, nc, &laa, aa, as, "aa")
								if null {
									checkFloat64Array1D(t, nc, &lbb, bb, bs, "guardband bb")
								} else {
									for j = 0; j < *n; j++ {
										for i = (*m) + 1; i <= *ldb; i++ {
											if (*bb)[i+j*(*ldb)-1] != (*bs)[i+j*(*ldb)-1] {
												t.Errorf("Test Failed: guardband bb[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldb), nc, (*bb)[i+j*(*ldb)], (*bs)[i+j*(*ldb)])
											}
										}
									}
									for j = 1; j <= *n; j++ {
										for i = 1; i <= *m; i++ {
											(*c)[i-1][j-1] = (*bb)[i+(j-1)*(*ldb)-1]
											(*bb)[i+(j-1)*(*ldb)-1] = (*alpha) * (*b)[i-1][j-1]
										}
									}
									_N := func() *byte { y := byte('N'); return &y }()
									if *side == 'L' {
										dmmchTest(transa, _N, m, n, m, onef64, a, c, zerof64, b, ct, g, bb, ldb, nc, "bb", t)
									} else {
										dmmchTest(_N, transa, m, n, n, onef64, c, a, zerof64, b, ct, g, bb, ldb, nc, "bb", t)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDtrsm(b *testing.B) {
	alpha := new(float64)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	major := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	bb := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	*major = 'C'
	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'N'
	*m = 9
	*n = 9
	*alpha = 0.70
	*aa = []float64{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.9071, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.6274, -10000000000.0000}
	*lda = 10
	*bb = []float64{-0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.0000, 0.0000, 0.0000, -0.0629, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, -10000000000.0000, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, -0.0929, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -0.2927, -10000000000.0000, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -10000000000.0000}
	*ldb = 10
	_aa := dExpand(aa, n, lda)
	_bb := dExpand(bb, n, ldb)

	for i := 0; i < b.N; i++ {
		Dtrsm(major, side, uplo, transa, diag, m, n, alpha, _aa, lda, _bb, ldb)
	}
}

func BenchmarkDtrsmFortran(b *testing.B) {
	alpha := new(float64)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	bb := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'N'
	*m = 9
	*n = 9
	*alpha = 0.70
	*aa = []float64{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.9071, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.6274, -10000000000.0000}
	*lda = 10
	*bb = []float64{-0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.0000, 0.0000, 0.0000, -0.0629, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, -10000000000.0000, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, -0.0929, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -0.2927, -10000000000.0000, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -10000000000.0000}
	*ldb = 10

	for i := 0; i < b.N; i++ {
		dtrsmWrapper(side, uplo, transa, diag, m, n, alpha, aa, lda, bb, ldb)
	}
}

func TestDsyrk(t *testing.T) {
	tname := "Dsyrk"
	var i, ia, ib, ibeg, ict, icu, ik, in, iend, j, jc, jj, ks, laa, lcc, ldas, ldcs, nc, ns, x, y int
	var als, bls float64
	var transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float64)
	beta := new(float64)
	k := new(int)
	n := new(int)
	lj := new(int)
	ma := new(int)
	na := new(int)
	lda := new(int)
	ldc := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	major := new(byte)
	trans := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	c := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	cc := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	cs := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	ct := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	for in = 1; in <= len(idimL3); in++ {
		*n = idimL3[in-1]

		*ldc = *n
		if *ldc < nmax {
			*ldc++
		}
		if *ldc > nmax {
			continue
		}
		lcc = (*ldc) * (*n)
		null = *n <= 0

		for ik = 1; ik <= len(idimL3); ik++ {
			*k = idimL3[ik-1]

			for ict = 1; ict <= len(ichtL3); ict++ {
				*trans = ichtL3[ict-1]

				if *trans == 'T' || *trans == 'C' {
					*ma = *k
					*na = *n
				} else {
					*ma = *n
					*na = *k
				}

				*lda = *ma
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				dmakeGEL3(ma, na, a, aa, lda, reset, zerof64, miSbeg, icSbeg, iSbeg)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ia = 1; ia <= len(alff64L3); ia++ {
						*alpha = alff64L3[ia-1]

						for ib = 1; ib <= len(betf64L3); ib++ {
							*beta = betf64L3[ib-1]

							dmakeSYL3(uplo, n, n, c, cc, ldc, reset, zerof64, miSbeg, icSbeg, iSbeg)

							transs = *trans
							uplos = *uplo
							ns = *n
							ks = *k
							als = *alpha
							bls = *beta
							ldas = *lda
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := dExpand(aa, na, lda)
							_cc := dExpand(cc, n, ldc)
							Dsyrk(major, uplo, trans, n, k, alpha, _aa, lda, beta, _cc, ldc)
							dReturn(_aa, aa)
							dReturn(_cc, cc)

							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, k, &ks, "k")
							checkFloat64(t, nc, alpha, &als, "alpha")
							checkFloat64(t, nc, beta, &bls, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkFloat64Array1D(t, nc, &laa, aa, as, "aa")
							if null {
								checkFloat64Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										ibeg = 1
										iend = j
									} else {
										ibeg = j
										iend = *n
									}
									for i = 1; i <= *ldc; i++ {
										if i < ibeg || i > iend {
											checkFloat64(t, nc, &(*cc)[i+(j-1)*(*ldc)-1], &(*cs)[i+(j-1)*(*ldc)-1], "guardband cc")
										}
									}
								}

								jc = 1
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										jj = 1
										*lj = j
									} else {
										jj = j
										*lj = (*n) - j + 1
									}
									_c := func() *[][]float64 {
										arr := make([][]float64, nmax-jj-1)
										for y := 0; y < nmax-jj-1; y++ {
											arr[y] = make([]float64, 1)
											for x := 0; x < 1; x++ {
												arr[y][x] = (*c)[y+jj-1][x+j-1]
											}
										}
										return &arr
									}()
									_cc := func() *[]float64 {
										arr := make([]float64, *ldc)
										for y := 0; y < *ldc; y++ {
											for x := 0; x < 1; x++ {
												arr[y+x*(*ldc)] = (*cc)[y+jc-1+x*(*ldc)]
											}
										}
										return &arr
									}()
									_N := func() *byte { y := byte('N'); return &y }()
									_T := func() *byte { y := byte('T'); return &y }()
									if *trans == 'T' || *trans == 'C' {
										_a := func() *[][]float64 {
											arr := make([][]float64, nmax)
											for y = 0; y < nmax; y++ {
												arr[y] = make([]float64, *n)
												for x = 0; x < *n; x++ {
													arr[y][x] = (*a)[y][x+jj-1]
												}
											}
											return &arr
										}()
										_b := func() *[][]float64 {
											arr := make([][]float64, nmax)
											for y = 0; y < nmax; y++ {
												arr[y] = make([]float64, 1)
												for x = 0; x < 1; x++ {
													arr[y][x] = (*a)[y][x+j-1]
												}
											}
											return &arr
										}()
										dmmchTest(_T, _N, lj, onei, k, alpha, _a, _b, beta, _c, ct, g, _cc, ldc, nc, "cc", t)
									} else {
										_a := func() *[][]float64 {
											arr := make([][]float64, nmax-jj-1)
											for y = 0; y < nmax-jj-1; y++ {
												arr[y] = make([]float64, *k)
												for x = 0; x < *k; x++ {
													arr[y][x] = (*a)[y+jj-1][x]
												}
											}
											return &arr
										}()
										_b := func() *[][]float64 {
											arr := make([][]float64, nmax-j-1)
											for y = 0; y < nmax-j-1; y++ {
												arr[y] = make([]float64, *k)
												for x = 0; x < *k; x++ {
													arr[y][x] = (*a)[y+j-1][x]
												}
											}
											return &arr
										}()
										dmmchTest(_N, _T, lj, onei, k, alpha, _a, _b, beta, _c, ct, g, _cc, ldc, nc, "cc", t)
									}
									if *uplo == 'U' {
										jc += *ldc
									} else {
										jc += (*ldc) + 1
									}
								}
							}
						}
					}
				}
			}

		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDsyrk(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldc := new(int)
	major := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	cc := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*alpha = 0.70
	*aa = []float64{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*lda = 10
	*beta = 1.30
	*cc = []float64{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2527, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4166, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2927, -0.0629, -0.1329, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1429, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -10000000000.0000}
	*ldc = 10
	_aa := dExpand(aa, n, lda)
	_cc := dExpand(cc, n, ldc)

	for i := 0; i < b.N; i++ {
		Dsyrk(major, uplo, trans, n, k, alpha, _aa, lda, beta, _cc, ldc)
	}
}

func BenchmarkDsyrkFortran(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	cc := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*alpha = 0.70
	*aa = []float64{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*lda = 10
	*beta = 1.30
	*cc = []float64{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2527, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4166, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2927, -0.0629, -0.1329, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1429, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -10000000000.0000}
	*ldc = 10

	for i := 0; i < b.N; i++ {
		dsyrkWrapper(uplo, trans, n, k, alpha, aa, lda, beta, cc, ldc)
	}
}

func TestDsyr2k(t *testing.T) {
	tname := "Dsyr2k"
	var i, ia, ib, ibeg, ict, icu, ik, in, iend, j, jc, jj, jjab, ks, laa, lbb, lcc, ldas, ldbs, ldcs, nc, ns, x, y int
	var als, bls float64
	var transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float64)
	beta := new(float64)
	k := new(int)
	n := new(int)
	k2 := new(int)
	lj := new(int)
	ma := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	major := new(byte)
	trans := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	as := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	ab := func() *[]float64 { y := make([]float64, nmax*nmax*2); return &y }()
	bb := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	bs := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	c := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	cc := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	cs := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	ct := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	w := func() *[]float64 { y := make([]float64, 2*nmax); return &y }()

	for j = 1; j <= min(32, nmax); j++ {
		for i = 1; i <= min(32, nmax); i++ {
			(*ab)[i+(j-1)*min(32, nmax)-1] = float64(max(i-j+1, 0))
		}
		(*ab)[j+nmax*min(32, nmax)-1] = float64(j)
		(*ab)[(nmax+j-1)*min(32, nmax)] = float64(j)
	}
	for j = 1; j <= min(32, nmax); j++ {
		(*ab)[j+nmax*min(32, nmax)-1] = float64(min(32, nmax) - j + 1)
	}

	for in = 1; in <= len(idimL3); in++ {
		*n = idimL3[in-1]

		*ldc = *n
		if *ldc < nmax {
			*ldc++
		}
		if *ldc > nmax {
			continue
		}
		lcc = (*ldc) * (*n)
		null = *n <= 0

		for ik = 1; ik <= len(idimL3); ik++ {
			*k = idimL3[ik-1]
			*k2 = 2 * (*k)

			for ict = 1; ict <= len(ichtL3); ict++ {
				*trans = ichtL3[ict-1]

				if *trans == 'T' || *trans == 'C' {
					*ma = *k
					*na = *n
				} else {
					*ma = *n
					*na = *k
				}

				*lda = *ma
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				if *trans == 'T' || *trans == 'C' {
					_ab := func() *[][]float64 {
						arr := make([][]float64, nmax)
						for i = 0; i < nmax; i++ {
							arr[i] = make([]float64, *na)
							for j = 0; j < *na; j++ {
								arr[i][j] = (*ab)[i+j*nmax]
							}
						}
						return &arr
					}()
					dmakeGEL3(ma, na, _ab, aa, lda, reset, zerof64, miSbeg, icSbeg, iSbeg)
					for j = 0; j < *na; j++ {
						for i = 0; i < *ma; i++ {
							(*ab)[i+j*nmax] = (*_ab)[i][j]
						}
					}
				} else {
					_ab := func() *[][]float64 {
						arr := make([][]float64, *ma)
						for i = 0; i < *ma; i++ {
							arr[i] = make([]float64, *na)
							for j = 0; j < *na; j++ {
								arr[i][j] = (*ab)[i+j*nmax]
							}
						}
						return &arr
					}()
					dmakeGEL3(ma, na, _ab, aa, lda, reset, zerof64, miSbeg, icSbeg, iSbeg)
					for j = 0; j < *na; j++ {
						for i = 0; i < *ma; i++ {
							(*ab)[i+j*nmax] = (*_ab)[i][j]
						}
					}
				}

				*ldb = *lda
				lbb = laa
				if *trans == 'T' || *trans == 'C' {
					_ab := func() *[][]float64 {
						arr := make([][]float64, *ma)
						for i = 0; i < *ma; i++ {
							arr[i] = make([]float64, *na)
							for j = 0; j < *na; j++ {
								arr[i][j] = (*ab)[i+(*k)+j*nmax]
							}
						}
						return &arr
					}()
					dmakeGEL3(ma, na, _ab, bb, ldb, reset, zerof64, miSbeg, icSbeg, iSbeg)
					for j = 0; j < *na; j++ {
						for i = 0; i < *ma; i++ {
							(*ab)[i+j*nmax+(*k)] = (*_ab)[i][j]
						}
					}
				} else {
					_ab := func() *[][]float64 {
						arr := make([][]float64, *ma)
						for i = 0; i < *ma; i++ {
							arr[i] = make([]float64, *na)
							for j = 0; j < *na; j++ {
								arr[i][j] = (*ab)[i+(*k)*nmax+j*nmax]
							}
						}
						return &arr
					}()
					dmakeGEL3(ma, na, _ab, bb, ldb, reset, zerof64, miSbeg, icSbeg, iSbeg)
					for j = 0; j < *na; j++ {
						for i = 0; i < *ma; i++ {
							(*ab)[i+j*nmax+(*k)*nmax] = (*_ab)[i][j]
						}
					}
				}

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ia = 1; ia <= len(alff64L3); ia++ {
						*alpha = alff64L3[ia-1]

						for ib = 1; ib <= len(betf64L3); ib++ {
							*beta = betf64L3[ib-1]

							dmakeSYL3(uplo, n, n, c, cc, ldc, reset, zerof64, miSbeg, icSbeg, iSbeg)

							transs = *trans
							uplos = *uplo
							ns = *n
							ks = *k
							als = *alpha
							bls = *beta
							ldas = *lda
							ldbs = *ldb
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lbb; i++ {
								(*bs)[i-1] = (*bb)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := dExpand(aa, na, lda)
							_bb := dExpand(bb, na, ldb)
							_cc := dExpand(cc, n, ldc)
							Dsyr2k(major, uplo, trans, n, k, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
							dReturn(_aa, aa)
							dReturn(_bb, bb)
							dReturn(_cc, cc)

							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, k, &ks, "k")
							checkFloat64(t, nc, alpha, &als, "alpha")
							checkFloat64(t, nc, beta, &bls, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldb, &ldbs, "ldb")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkFloat64Array1D(t, nc, &laa, aa, as, "aa")
							checkFloat64Array1D(t, nc, &lbb, bb, bs, "bb")
							if null {
								checkFloat64Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										ibeg = 1
										iend = j
									} else {
										ibeg = j
										iend = *n
									}
									for i = 1; i <= *ldc; i++ {
										if i < ibeg || i > iend {
											checkFloat64(t, nc, &(*cc)[i+(j-1)*(*ldc)-1], &(*cs)[i+(j-1)*(*ldc)-1], "guardband cc")
										}
									}
								}

								jjab = 1
								jc = 1
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										jj = 1
										*lj = j
									} else {
										jj = j
										*lj = (*n) - j + 1
									}
									_c := func() *[][]float64 {
										arr := make([][]float64, nmax-jj-1)
										for y = 0; y < nmax-jj-1; y++ {
											arr[y] = make([]float64, 1)
											for x = 0; x < 1; x++ {
												arr[y][x] = (*c)[y+jj-1][x+j-1]
											}
										}
										return &arr
									}()
									_cc := func() *[]float64 {
										arr := make([]float64, *ldc)
										for y := 0; y < *ldc; y++ {
											for x := 0; x < 1; x++ {
												arr[y+x*(*ldc)] = (*cc)[y+jc-1+x*(*ldc)]
											}
										}
										return &arr
									}()
									_N := func() *byte { y := byte('N'); return &y }()
									_T := func() *byte { y := byte('T'); return &y }()
									if *trans == 'T' || *trans == 'C' {
										for i = 1; i <= *k; i++ {
											(*w)[i-1] = (*ab)[(j-1)*nmax+(*k)+i-1]
											(*w)[(*k)+i-1] = (*ab)[(j-1)*nmax+i-1]
										}
										_jjab := (jjab - 1) * nmax
										_ab := func() *[][]float64 {
											_x := (*ab)[_jjab:]
											arr := make([][]float64, nmax)
											for y := 0; y < nmax; y++ {
												arr[y] = make([]float64, *lj)
												for x := 0; x < *lj; x++ {
													arr[y][x] = _x[y+x*nmax]
												}
											}
											return &arr
										}()
										_w := func() *[][]float64 {
											arr := make([][]float64, 2*nmax)
											for y := 0; y < 2*nmax; y++ {
												arr[y] = make([]float64, 1)
												for x := 0; x < 1; x++ {
													arr[y][x] = (*w)[y+x*2*nmax]
												}
											}
											return &arr
										}()
										dmmchTest(_T, _N, lj, onei, k2, alpha, _ab, _w, beta, _c, ct, g, _cc, ldc, nc, "cc", t)
									} else {
										for i = 1; i <= *k; i++ {
											(*w)[i-1] = (*ab)[((*k)+i-1)*nmax+j-1]
											(*w)[(*k)+i-1] = (*ab)[(i-1)*nmax+j-1]
										}
										_ab := func() *[][]float64 {
											_x := (*ab)[jj-1:]
											arr := make([][]float64, nmax)
											for y := 0; y < nmax; y++ {
												arr[y] = make([]float64, *k2)
												for x := 0; x < *k2; x++ {
													arr[y][x] = _x[y+x*nmax]
												}
											}
											return &arr
										}()
										_w := func() *[][]float64 {
											arr := make([][]float64, 2*nmax)
											for y := 0; y < 2*nmax; y++ {
												arr[y] = make([]float64, 1)
												for x := 0; x < 1; x++ {
													arr[y][x] = (*w)[y+x*2*nmax]
												}
											}
											return &arr
										}()
										dmmchTest(_N, _N, lj, onei, k2, alpha, _ab, _w, beta, _c, ct, g, _cc, ldc, nc, "cc", t)
									}
									if *uplo == 'U' {
										jc += *ldc
									} else {
										jc += (*ldc) + 1
										if *trans == 'T' || *trans == 'C' {
											jjab++
										}
									}
								}
							}
						}
					}
				}
			}

		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkDsyr2k(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	major := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	bb := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	cc := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*alpha = 0.70
	*aa = []float64{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*lda = 10
	*bb = []float64{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, -10000000000.0000, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0270, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -10000000000.0000, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -10000000000.0000}
	*ldb = 10
	*beta = 1.30
	*cc = []float64{-0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2268, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1329, 0.4965, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -10000000000.0000}
	*ldc = 10
	_aa := dExpand(aa, n, lda)
	_bb := dExpand(bb, n, ldb)
	_cc := dExpand(cc, n, ldc)

	for i := 0; i < b.N; i++ {
		Dsyr2k(major, uplo, trans, n, k, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
	}
}

func BenchmarkDsyr2kFortran(b *testing.B) {
	alpha := new(float64)
	beta := new(float64)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	bb := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	cc := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*alpha = 0.70
	*aa = []float64{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*lda = 10
	*bb = []float64{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, -10000000000.0000, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0270, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -10000000000.0000, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -10000000000.0000}
	*ldb = 10
	*beta = 1.30
	*cc = []float64{-0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2268, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1329, 0.4965, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -10000000000.0000}
	*ldc = 10

	for i := 0; i < b.N; i++ {
		dsyr2kWrapper(uplo, trans, n, k, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func TestDerrors(t *testing.T) {
	var infot *int
	var srnamt *string
	var test *bool

	alpha := new(float64)
	beta := new(float64)

	infot = &common.infoc.infot
	srnamt = &common.srnamc.srnamt
	test = &common.infoc.test
	*test = true

	aa := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	xx := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	yy := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	a := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	b := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()
	c := func() *[][]float64 {
		arr := make([][]float64, nmax)
		for u := range arr {
			arr[u] = make([]float64, nmax)
		}
		return &arr
	}()

	*srnamt = "Dgemv"
	*infot = 1
	Dgemv(_X, _N, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Dgemv(_C, _X, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Dgemv(_C, _N, negonei, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 4
	Dgemv(_C, _N, zeroi, negonei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 7
	Dgemv(_C, _N, twoi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 9
	Dgemv(_C, _N, zeroi, zeroi, alpha, a, onei, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 12
	Dgemv(_C, _N, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Dgbmv"
	*infot = 1
	Dgbmv(_X, _N, zeroi, zeroi, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Dgbmv(_C, _X, zeroi, zeroi, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Dgbmv(_C, _N, negonei, zeroi, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 4
	Dgbmv(_C, _N, zeroi, negonei, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 5
	Dgbmv(_C, _N, zeroi, zeroi, negonei, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 6
	Dgbmv(_C, _N, twoi, zeroi, zeroi, negonei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 9
	Dgbmv(_C, _N, zeroi, zeroi, onei, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 11
	Dgbmv(_C, _N, zeroi, zeroi, zeroi, zeroi, alpha, a, onei, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 14
	Dgbmv(_C, _N, zeroi, zeroi, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Dsymv"
	*infot = 1
	Dsymv(_X, _U, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Dsymv(_C, _X, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Dsymv(_C, _U, negonei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 6
	Dsymv(_C, _U, twoi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 8
	Dsymv(_C, _U, zeroi, alpha, a, onei, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 11
	Dsymv(_C, _U, zeroi, alpha, a, onei, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Dsbmv"
	*infot = 1
	Dsbmv(_X, _U, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Dsbmv(_C, _X, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Dsbmv(_C, _U, negonei, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 4
	Dsbmv(_C, _U, zeroi, negonei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 7
	Dsbmv(_C, _U, zeroi, onei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 9
	Dsbmv(_C, _U, zeroi, zeroi, alpha, a, onei, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 12
	Dsbmv(_C, _U, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Dspmv"
	*infot = 1
	Dspmv(_X, _U, zeroi, alpha, aa, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Dspmv(_C, _X, zeroi, alpha, aa, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Dspmv(_C, _U, negonei, alpha, aa, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 7
	Dspmv(_C, _U, zeroi, alpha, aa, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 10
	Dspmv(_C, _U, zeroi, alpha, aa, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Dtrmv"
	*infot = 1
	Dtrmv(_X, _U, _N, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 2
	Dtrmv(_C, _X, _N, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 3
	Dtrmv(_C, _U, _X, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 4
	Dtrmv(_C, _U, _N, _X, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 5
	Dtrmv(_C, _U, _N, _N, negonei, a, onei, xx, onei)
	chkxer(t)
	*infot = 7
	Dtrmv(_C, _U, _N, _N, twoi, a, onei, xx, onei)
	chkxer(t)
	*infot = 9
	Dtrmv(_C, _U, _N, _N, zeroi, a, onei, xx, zeroi)
	chkxer(t)

	*srnamt = "Dtbmv"
	*infot = 1
	Dtbmv(_X, _U, _N, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 2
	Dtbmv(_C, _X, _N, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 3
	Dtbmv(_C, _U, _X, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 4
	Dtbmv(_C, _U, _N, _X, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 5
	Dtbmv(_C, _U, _N, _N, negonei, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 6
	Dtbmv(_C, _U, _N, _N, zeroi, negonei, a, onei, xx, onei)
	chkxer(t)
	*infot = 8
	Dtbmv(_C, _U, _N, _N, zeroi, onei, a, onei, xx, onei)
	chkxer(t)
	*infot = 10
	Dtbmv(_C, _U, _N, _N, zeroi, zeroi, a, onei, xx, zeroi)
	chkxer(t)

	*srnamt = "Dtpmv"
	*infot = 1
	Dtpmv(_X, _U, _N, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 2
	Dtpmv(_C, _X, _N, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 3
	Dtpmv(_C, _U, _X, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 4
	Dtpmv(_C, _U, _N, _X, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 5
	Dtpmv(_C, _U, _N, _N, negonei, aa, xx, onei)
	chkxer(t)
	*infot = 8
	Dtpmv(_C, _U, _N, _N, zeroi, aa, xx, zeroi)
	chkxer(t)

	*srnamt = "Dtrsv"
	*infot = 1
	Dtrsv(_X, _U, _N, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 2
	Dtrsv(_C, _X, _N, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 3
	Dtrsv(_C, _U, _X, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 4
	Dtrsv(_C, _U, _N, _X, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 5
	Dtrsv(_C, _U, _N, _N, negonei, a, onei, xx, onei)
	chkxer(t)
	*infot = 7
	Dtrsv(_C, _U, _N, _N, twoi, a, onei, xx, onei)
	chkxer(t)
	*infot = 9
	Dtrsv(_C, _U, _N, _N, zeroi, a, onei, xx, zeroi)
	chkxer(t)

	*srnamt = "Dtbsv"
	*infot = 1
	Dtbsv(_X, _U, _N, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 2
	Dtbsv(_C, _X, _N, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 3
	Dtbsv(_C, _U, _X, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 4
	Dtbsv(_C, _U, _N, _X, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 5
	Dtbsv(_C, _U, _N, _N, negonei, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 6
	Dtbsv(_C, _U, _N, _N, zeroi, negonei, a, onei, xx, onei)
	chkxer(t)
	*infot = 8
	Dtbsv(_C, _U, _N, _N, zeroi, onei, a, onei, xx, onei)
	chkxer(t)
	*infot = 10
	Dtbsv(_C, _U, _N, _N, zeroi, zeroi, a, onei, xx, zeroi)
	chkxer(t)

	*srnamt = "Dtpsv"
	*infot = 1
	Dtpsv(_X, _U, _N, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 2
	Dtpsv(_C, _X, _N, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 3
	Dtpsv(_C, _U, _X, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 4
	Dtpsv(_C, _U, _N, _X, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 5
	Dtpsv(_C, _U, _N, _N, negonei, aa, xx, onei)
	chkxer(t)
	*infot = 8
	Dtpsv(_C, _U, _N, _N, zeroi, aa, xx, zeroi)
	chkxer(t)

	*srnamt = "Dger"
	*infot = 1
	Dger(_X, zeroi, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 2
	Dger(_C, negonei, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 3
	Dger(_C, zeroi, negonei, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 6
	Dger(_C, zeroi, zeroi, alpha, xx, zeroi, yy, onei, a, onei)
	chkxer(t)
	*infot = 8
	Dger(_C, zeroi, zeroi, alpha, xx, onei, yy, zeroi, a, onei)
	chkxer(t)
	*infot = 10
	Dger(_C, twoi, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)

	*srnamt = "Dsyr"
	*infot = 1
	Dsyr(_X, _U, zeroi, alpha, xx, onei, a, onei)
	chkxer(t)
	*infot = 2
	Dsyr(_C, _X, zeroi, alpha, xx, onei, a, onei)
	chkxer(t)
	*infot = 3
	Dsyr(_C, _U, negonei, alpha, xx, onei, a, onei)
	chkxer(t)
	*infot = 6
	Dsyr(_C, _U, zeroi, alpha, xx, zeroi, a, onei)
	chkxer(t)
	*infot = 8
	Dsyr(_C, _U, twoi, alpha, xx, onei, a, onei)
	chkxer(t)

	*srnamt = "Dspr"
	*infot = 1
	Dspr(_X, _U, zeroi, alpha, xx, onei, aa)
	chkxer(t)
	*infot = 2
	Dspr(_C, _X, zeroi, alpha, xx, onei, aa)
	chkxer(t)
	*infot = 3
	Dspr(_C, _U, negonei, alpha, xx, onei, aa)
	chkxer(t)
	*infot = 6
	Dspr(_C, _U, zeroi, alpha, xx, zeroi, aa)
	chkxer(t)

	*srnamt = "Dsyr2"
	*infot = 1
	Dsyr2(_X, _U, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 2
	Dsyr2(_C, _X, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 3
	Dsyr2(_C, _U, negonei, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 6
	Dsyr2(_C, _U, zeroi, alpha, xx, zeroi, yy, onei, a, onei)
	chkxer(t)
	*infot = 8
	Dsyr2(_C, _U, zeroi, alpha, xx, onei, yy, zeroi, a, onei)
	chkxer(t)
	*infot = 10
	Dsyr2(_C, _U, twoi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)

	*srnamt = "Dspr2"
	*infot = 1
	Dspr2(_X, _U, zeroi, alpha, xx, onei, yy, onei, aa)
	chkxer(t)
	*infot = 2
	Dspr2(_C, _X, zeroi, alpha, xx, onei, yy, onei, aa)
	chkxer(t)
	*infot = 3
	Dspr2(_C, _U, negonei, alpha, xx, onei, yy, onei, aa)
	chkxer(t)
	*infot = 6
	Dspr2(_C, _U, zeroi, alpha, xx, zeroi, yy, onei, aa)
	chkxer(t)
	*infot = 8
	Dspr2(_C, _U, zeroi, alpha, xx, onei, yy, zeroi, aa)
	chkxer(t)

	*srnamt = "Dgemm"
	*infot = 1
	Dgemm(_X, _N, _T, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Dgemm(_C, _X, _N, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Dgemm(_C, _X, _T, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Dgemm(_C, _N, _X, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Dgemm(_C, _T, _X, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Dgemm(_C, _N, _N, negonei, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Dgemm(_C, _N, _T, negonei, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Dgemm(_C, _T, _T, negonei, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Dgemm(_C, _T, _T, negonei, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Dgemm(_C, _N, _N, zeroi, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Dgemm(_C, _N, _T, zeroi, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Dgemm(_C, _T, _N, zeroi, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Dgemm(_C, _T, _T, zeroi, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 6
	Dgemm(_C, _N, _N, zeroi, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 6
	Dgemm(_C, _N, _T, zeroi, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 6
	Dgemm(_C, _T, _N, zeroi, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 6
	Dgemm(_C, _T, _T, zeroi, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 9
	Dgemm(_C, _N, _N, twoi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 9
	Dgemm(_C, _N, _T, twoi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 9
	Dgemm(_C, _T, _N, zeroi, zeroi, twoi, alpha, a, onei, b, twoi, beta, c, onei)
	chkxer(t)
	*infot = 9
	Dgemm(_C, _T, _T, zeroi, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Dgemm(_C, _N, _N, zeroi, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Dgemm(_C, _T, _N, zeroi, zeroi, twoi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Dgemm(_C, _N, _T, zeroi, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Dgemm(_C, _T, _T, zeroi, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 14
	Dgemm(_C, _N, _N, twoi, zeroi, zeroi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 14
	Dgemm(_C, _N, _T, twoi, zeroi, zeroi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 14
	Dgemm(_C, _T, _N, twoi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 14
	Dgemm(_C, _T, _T, twoi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)

	*srnamt = "Dsymm"
	*infot = 1
	Dsymm(_X, _L, _U, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Dsymm(_C, _X, _U, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Dsymm(_C, _L, _X, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Dsymm(_C, _L, _U, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Dsymm(_C, _R, _U, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Dsymm(_C, _L, _L, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Dsymm(_C, _R, _L, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Dsymm(_C, _L, _U, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Dsymm(_C, _R, _U, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Dsymm(_C, _L, _L, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Dsymm(_C, _R, _L, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Dsymm(_C, _L, _U, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, twoi)
	chkxer(t)
	*infot = 8
	Dsymm(_C, _R, _U, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Dsymm(_C, _L, _L, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, twoi)
	chkxer(t)
	*infot = 8
	Dsymm(_C, _R, _L, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 10
	Dsymm(_C, _L, _U, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 10
	Dsymm(_C, _R, _U, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 10
	Dsymm(_C, _L, _L, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 10
	Dsymm(_C, _R, _L, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 13
	Dsymm(_C, _L, _U, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	*infot = 13
	Dsymm(_C, _R, _U, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, onei)
	chkxer(t)
	*infot = 13
	Dsymm(_C, _L, _L, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	*infot = 13
	Dsymm(_C, _R, _L, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, onei)
	chkxer(t)

	*srnamt = "Dtrmm"
	*infot = 1
	Dtrmm(_X, _L, _U, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 2
	Dtrmm(_C, _X, _U, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 3
	Dtrmm(_C, _L, _X, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 4
	Dtrmm(_C, _L, _U, _X, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 5
	Dtrmm(_C, _L, _U, _N, _X, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 6
	Dtrmm(_C, _L, _U, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _L, _U, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _R, _U, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _R, _U, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _L, _L, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _L, _L, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _R, _L, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _R, _L, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 7
	Dtrmm(_C, _L, _U, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _L, _U, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _R, _U, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _R, _U, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _L, _L, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _L, _L, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _R, _L, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _R, _L, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 10
	Dtrmm(_C, _L, _U, _N, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Dtrmm(_C, _L, _U, _T, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Dtrmm(_C, _R, _U, _N, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _R, _U, _T, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _L, _L, _N, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Dtrmm(_C, _L, _L, _T, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Dtrmm(_C, _R, _L, _N, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _R, _L, _T, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 12
	Dtrmm(_C, _L, _U, _N, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Dtrmm(_C, _L, _U, _T, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Dtrmm(_C, _R, _U, _N, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _R, _U, _T, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _L, _L, _N, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Dtrmm(_C, _L, _L, _T, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Dtrmm(_C, _R, _L, _N, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrmm(_C, _R, _L, _T, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)

	*srnamt = "Dtrsm"
	*infot = 1
	Dtrsm(_X, _L, _U, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 2
	Dtrsm(_C, _X, _U, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 3
	Dtrsm(_C, _L, _X, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 4
	Dtrsm(_C, _L, _U, _X, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 5
	Dtrsm(_C, _L, _U, _N, _X, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 6
	Dtrsm(_C, _L, _U, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _L, _U, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _R, _U, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _R, _U, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _L, _L, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _L, _L, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _R, _L, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _R, _L, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 7
	Dtrsm(_C, _L, _U, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _L, _U, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _R, _U, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _R, _U, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _L, _L, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _L, _L, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _R, _L, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _R, _L, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 10
	Dtrsm(_C, _L, _U, _N, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Dtrsm(_C, _L, _U, _T, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Dtrsm(_C, _R, _U, _N, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _R, _U, _T, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _L, _L, _N, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Dtrsm(_C, _L, _L, _T, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Dtrsm(_C, _R, _L, _N, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _R, _L, _T, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 12
	Dtrsm(_C, _L, _U, _N, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Dtrsm(_C, _L, _U, _T, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Dtrsm(_C, _R, _U, _N, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _R, _U, _T, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _L, _L, _N, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Dtrsm(_C, _L, _L, _T, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Dtrsm(_C, _R, _L, _N, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Dtrsm(_C, _R, _L, _T, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)

	*srnamt = "Dsyrk"
	*infot = 1
	Dsyrk(_X, _U, _N, zeroi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Dsyrk(_C, _X, _N, zeroi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Dsyrk(_C, _U, _X, zeroi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Dsyrk(_C, _U, _N, negonei, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Dsyrk(_C, _U, _T, negonei, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Dsyrk(_C, _L, _N, negonei, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Dsyrk(_C, _L, _T, negonei, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Dsyrk(_C, _U, _N, zeroi, negonei, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Dsyrk(_C, _U, _T, zeroi, negonei, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Dsyrk(_C, _L, _N, zeroi, negonei, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Dsyrk(_C, _L, _T, zeroi, negonei, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Dsyrk(_C, _U, _N, twoi, zeroi, alpha, a, onei, beta, c, twoi)
	chkxer(t)
	Dsyrk(_C, _U, _T, zeroi, twoi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Dsyrk(_C, _L, _N, twoi, zeroi, alpha, a, onei, beta, c, twoi)
	chkxer(t)
	Dsyrk(_C, _L, _T, zeroi, twoi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Dsyrk(_C, _U, _N, twoi, zeroi, alpha, a, twoi, beta, c, onei)
	chkxer(t)
	Dsyrk(_C, _U, _T, twoi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Dsyrk(_C, _L, _N, twoi, zeroi, alpha, a, twoi, beta, c, onei)
	chkxer(t)
	Dsyrk(_C, _L, _T, twoi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)

	*srnamt = "Dsyr2k"
	*infot = 1
	Dsyr2k(_X, _U, _N, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Dsyr2k(_C, _X, _N, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Dsyr2k(_C, _U, _X, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Dsyr2k(_C, _U, _N, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Dsyr2k(_C, _U, _T, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Dsyr2k(_C, _L, _N, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Dsyr2k(_C, _L, _T, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Dsyr2k(_C, _U, _N, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Dsyr2k(_C, _U, _T, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Dsyr2k(_C, _L, _N, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Dsyr2k(_C, _L, _T, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Dsyr2k(_C, _U, _N, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	Dsyr2k(_C, _U, _T, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Dsyr2k(_C, _L, _N, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	Dsyr2k(_C, _L, _T, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 10
	Dsyr2k(_C, _U, _N, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	Dsyr2k(_C, _U, _T, zeroi, twoi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	Dsyr2k(_C, _L, _N, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	Dsyr2k(_C, _L, _T, zeroi, twoi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 13
	Dsyr2k(_C, _U, _N, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	Dsyr2k(_C, _U, _T, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Dsyr2k(_C, _L, _N, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	Dsyr2k(_C, _L, _T, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)

	*test = false
	fmt.Println("\t\t\tDblas error tests completed")
}
