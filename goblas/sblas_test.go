package goblas

import (
	"fmt"
	"testing"
)

var iglobal int
var sglobal float32

// BLAS Level 1
func TestSrot(t *testing.T) {
	tname := "Srot"
	var i, nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	sc := new(float32)
	ss := new(float32)
	major := new(byte)
	var srotTests = []struct {
		lenx   int
		leny   int
		n      int
		sx     []float32
		incx   int
		sy     []float32
		incy   int
		sc     float32
		ss     float32
		sxtrue []float32
		sytrue []float32
		sizex  []float32
		sizey  []float32
	}{
		{1, 1, 0, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.8000, 0.6000, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.8000, 0.6000, []float32{0.7800, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0400, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 2, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.8000, 0.6000, []float32{0.7800, -0.4600, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0400, -0.7800, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 4, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.8000, 0.6000, []float32{0.7800, -0.4600, -0.2200, 1.0600, 0.0000, 0.0000, 0.0000}, []float32{0.0400, -0.7800, 0.5400, 0.0800, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 0, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8000, 0.6000, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8000, 0.6000, []float32{0.7800, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0400, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{3, 3, 2, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8000, 0.6000, []float32{0.6600, 0.1000, -0.1000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.7000, -0.9000, -0.1200, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{7, 7, 4, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8000, 0.6000, []float32{0.9600, 0.1000, -0.7600, 0.8000, 0.9000, -0.3000, -0.0200}, []float32{0.6400, -0.9000, -0.3000, 0.7000, -0.1800, 0.2000, 0.2800}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 0, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.8000, 0.6000, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.8000, 0.6000, []float32{0.7800, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0400, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{3, 2, 2, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.8000, 0.6000, []float32{-0.0600, 0.1000, -0.1000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.7000, -1.0800, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{7, 4, 4, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.8000, 0.6000, []float32{0.9000, 0.1000, -0.2200, 0.8000, 0.1800, -0.3000, -0.0200}, []float32{0.6400, -1.2600, 0.5400, 0.2000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 0, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8000, 0.6000, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8000, 0.6000, []float32{0.7800, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0400, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 2, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8000, 0.6000, []float32{0.7800, 0.2600, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0400, -0.9000, 0.1800, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 7, 4, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8000, 0.6000, []float32{0.7800, 0.2600, -0.7600, 1.1200, 0.0000, 0.0000, 0.0000}, []float32{0.0400, -0.9000, 0.1800, 0.7000, -0.1800, 0.2000, 0.1600}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{5, 5, 5, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, 1.0000, 0.0000, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}},
		{5, 5, 5, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, 0.0000, 1.0000, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float32{-1.0000, -2.0000, -3.0000, -4.0000, -5.0000}, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float32{-1.0000, -2.0000, -3.0000, -4.0000, -5.0000}},
		{5, 5, 5, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, -1, 0.0000, 1.0000, []float32{5.0000, 4.0000, 3.0000, 2.0000, 1.0000}, []float32{-5.0000, -4.0000, -3.0000, -2.0000, -1.0000}, []float32{5.0000, 4.0000, 3.0000, 2.0000, 1.0000}, []float32{-5.0000, -4.0000, -3.0000, -2.0000, -1.0000}},
		{5, 5, 5, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, -1, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, -1, 0.0000, 1.0000, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float32{-1.0000, -2.0000, -3.0000, -4.0000, -5.0000}, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float32{-1.0000, -2.0000, -3.0000, -4.0000, -5.0000}},
		{5, 5, 3, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 2, 0.0000, 1.0000, []float32{1.0000, 3.0000, 5.0000, 4.0000, 5.0000}, []float32{-1.0000, 2.0000, -2.0000, 4.0000, -3.0000}, []float32{1.0000, 3.0000, 5.0000, 4.0000, 5.0000}, []float32{-1.0000, 2.0000, -2.0000, 4.0000, -3.0000}},
		{5, 5, 5, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, -1, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, 0.0000, 1.0000, []float32{5.0000, 4.0000, 3.0000, 2.0000, 1.0000}, []float32{-5.0000, -4.0000, -3.0000, -2.0000, -1.0000}, []float32{5.0000, 4.0000, 3.0000, 2.0000, 1.0000}, []float32{-5.0000, -4.0000, -3.0000, -2.0000, -1.0000}},
		{5, 5, 5, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, 0.0000, -1.0000, []float32{-1.0000, -2.0000, -3.0000, -4.0000, -5.0000}, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float32{-1.0000, -2.0000, -3.0000, -4.0000, -5.0000}, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}},
		{5, 5, 5, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, -1, 0.0000, -1.0000, []float32{-5.0000, -4.0000, -3.0000, -2.0000, -1.0000}, []float32{5.0000, 4.0000, 3.0000, 2.0000, 1.0000}, []float32{-5.0000, -4.0000, -3.0000, -2.0000, -1.0000}, []float32{5.0000, 4.0000, 3.0000, 2.0000, 1.0000}},
		{5, 5, 5, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, -1, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, -1, 0.0000, -1.0000, []float32{-1.0000, -2.0000, -3.0000, -4.0000, -5.0000}, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, []float32{-1.0000, -2.0000, -3.0000, -4.0000, -5.0000}, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}},
		{5, 5, 3, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 2, 0.0000, -1.0000, []float32{-1.0000, -3.0000, -5.0000, 4.0000, 5.0000}, []float32{1.0000, 2.0000, 2.0000, 4.0000, 3.0000}, []float32{-1.0000, -3.0000, -5.0000, 4.0000, 5.0000}, []float32{1.0000, 2.0000, 2.0000, 4.0000, 3.0000}},
		{5, 5, 5, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, -1, []float32{1.0000, 2.0000, 3.0000, 4.0000, 5.0000}, 1, 0.0000, -1.0000, []float32{-5.0000, -4.0000, -3.0000, -2.0000, -1.0000}, []float32{5.0000, 4.0000, 3.0000, 2.0000, 1.0000}, []float32{-5.0000, -4.0000, -3.0000, -2.0000, -1.0000}, []float32{5.0000, 4.0000, 3.0000, 2.0000, 1.0000}},
	}
	*major = 'C'

	for _, test := range srotTests {
		i++
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		*sc = test.sc
		*ss = test.ss
		sx := func() *[]float32 { y := make([]float32, test.lenx); return &y }()
		sy := func() *[]float32 { y := make([]float32, test.leny); return &y }()
		for j := 0; j < test.lenx; j++ {
			(*sx)[j] = test.sx[j]
		}
		for j := 0; j < test.leny; j++ {
			(*sy)[j] = test.sy[j]
		}
		nc++
		Srot(major, n, sx, incx, sy, incy, sc, ss)
		for j := 0; j < test.lenx; j++ {
			if absf32(sfac*((*sx)[j]-test.sxtrue[j])) > absf32(test.sizex[j])*epsilonf32()+1e-9 {
				t.Errorf("Test Failed: sx[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, i, (*sx)[j], test.sxtrue[j])
			}
		}
		for j := 0; j < test.leny; j++ {
			if absf32(sfac*((*sy)[j]-test.sytrue[j])) > absf32(test.sizey[j])*epsilonf32()+1e-9 {
				t.Errorf("Test Failed: sy[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, i, (*sy)[j], test.sytrue[j])
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSrotFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sc := new(float32)
	ss := new(float32)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*n = 0
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 1
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = 1
	*sc = 0.8
	*ss = 0.6

	for i := 0; i < b.N; i++ {
		srotWrapper(n, sx, incx, sy, incy, sc, ss)
	}
}

func BenchmarkSrot(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sc := new(float32)
	ss := new(float32)
	major := new(byte)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*n = 0
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 1
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = 1
	*sc = 0.8
	*ss = 0.6
	*major = 'C'

	for i := 0; i < b.N; i++ {
		Srot(major, n, sx, incx, sy, incy, sc, ss)
	}
}

func TestSdsdot(t *testing.T) {
	tname := "Sdsdot"
	var nc int
	var res float32
	n := new(int)
	incx := new(int)
	incy := new(int)
	sa := new(float32)
	major := new(byte)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	var sdsdotTests = []struct {
		n      int
		sa     float32
		sx     []float32
		incx   int
		sy     []float32
		incy   int
		result float32
		size   float32
	}{
		{0, 0.1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.1000, 0.1000},
		{1, 0.1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.4000, 0.4000},
		{2, 0.1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.3100, 1.7000},
		{4, 0.1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.7200, 3.3000},
		{0, 0.1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.1000, 0.1000},
		{1, 0.1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.4000, 0.4000},
		{2, 0.1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.0300, 1.7000},
		{4, 0.1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.9500, 3.3000},
		{0, 0.1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.1000, 0.1000},
		{1, 0.1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.4000, 0.4000},
		{2, 0.1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, -0.6900, 1.7000},
		{4, 0.1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, -0.6400, 3.3000},
		{0, 0.1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.1000, 0.1000},
		{1, 0.1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.4000, 0.4000},
		{2, 0.1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.4300, 1.7000},
		{4, 0.1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 1.3700, 3.3000},
	}
	*major = 'C'

	for _, test := range sdsdotTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		*sa = test.sa
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		res = Sdsdot(major, n, sa, sx, incx, sy, incy)
		if absf32(sfac*(res-test.result)) > absf32(test.size)*epsilonf32()+1e-9 {
			t.Errorf("Test Failed: test %d: {%10.8f} output, {%10.8f} expected", test.n, res, test.result)
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSdsdotFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sa := new(float32)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*n = 4
	*sa = 0.1
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		_ = sdsdotWrapper(n, sa, sx, incx, sy, incy)
	}
}

func BenchmarkSdsdot(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sa := new(float32)
	major := new(byte)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*n = 4
	*sa = 0.1
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2
	*major = 'C'

	for i := 0; i < b.N; i++ {
		_ = Sdsdot(major, n, sa, sx, incx, sy, incy)
	}
}

func TestSrotm(t *testing.T) {
	tname := "Srotm"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	major := new(byte)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	temp := func() *[]float32 { y := make([]float32, 5); return &y }()
	var srotmTests = []struct {
		n      int
		lenx   int
		leny   int
		sx     []float32
		incx   int
		sy     []float32
		incy   int
		dtemp  []float32
		sxtrue []float32
		sytrue []float32
		size   []float32
	}{
		{0, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float32{-0.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-0.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float32{-0.9000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{1.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-0.9000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float32{3.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-2.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{3.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 2, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, -0.9000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 2, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float32{-0.8000, 3.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.7000, -4.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-0.8000, 3.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 2, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float32{-0.9000, 2.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{1.7000, -0.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-0.9000, 2.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 2, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float32{3.5000, -0.4000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-2.6000, 3.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{3.5000, -0.4000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 4, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, -0.9000, 0.3000, 0.7000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 4, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float32{-0.8000, 3.8000, -2.2000, -1.2000, 0.0000, 0.0000, 0.0000}, []float32{0.7000, -4.8000, 3.0000, 1.1000, 0.0000, 0.0000, 0.0000}, []float32{-0.8000, 3.8000, -2.2000, -1.2000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 4, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float32{-0.9000, 2.8000, -1.4000, -1.3000, 0.0000, 0.0000, 0.0000}, []float32{1.7000, -0.7000, -0.7000, 2.3000, 0.0000, 0.0000, 0.0000}, []float32{-0.9000, 2.8000, -1.4000, -1.3000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 4, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float32{3.5000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}, []float32{-2.6000, 3.5000, -0.7000, -3.6000, 0.0000, 0.0000, 0.0000}, []float32{3.5000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float32{-0.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-0.8000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float32{-0.9000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{1.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-0.9000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float32{3.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-2.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{3.5000, -0.4000, -2.2000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 3, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -0.5000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, -0.9000, 0.3000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -0.5000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 3, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float32{0.0000, 0.1000, -3.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{4.0000, -0.9000, -0.3000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{2.4000, 0.1000, -3.0000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 3, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float32{-0.3000, 0.1000, -2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-0.5000, -0.9000, 1.5000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-0.3000, 0.1000, -2.0000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 3, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float32{3.3000, 0.1000, -2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-1.5000, -0.9000, -1.8000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{3.3000, 0.1000, -2.0000, 4.7000, 0.0000, 0.0000, 0.0000}},
		{4, 7, 7, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}},
		{4, 7, 7, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float32{-2.0000, 0.1000, 1.4000, 0.8000, 0.6000, -0.3000, -2.8000}, []float32{3.7000, -0.9000, -1.2000, 0.7000, -1.5000, 0.2000, 2.2000}, []float32{-2.0000, 0.1000, 1.4000, 0.8000, 0.6000, -0.3000, -2.8000}},
		{4, 7, 7, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float32{-1.8000, 0.1000, 1.3000, 0.8000, 0.0000, -0.3000, -1.9000}, []float32{-0.3000, -0.9000, 2.1000, 0.7000, -1.6000, 0.2000, 2.0000}, []float32{-1.8000, 0.1000, 1.3000, 0.8000, 1.8000, -0.3000, -1.9000}},
		{4, 7, 7, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float32{3.8000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}, []float32{-1.6000, -0.9000, -2.1000, 0.7000, 2.9000, 0.2000, -3.8000}, []float32{3.8000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{0, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{0, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{0, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{0, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float32{-0.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-0.8000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float32{-0.9000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{1.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-0.9000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float32{3.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-2.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{3.5000, 0.1000, -3.1000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{2, 3, 2, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -0.5000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, -0.9000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -0.5000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{2, 3, 2, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float32{4.8000, 0.1000, -3.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{4.0000, -6.3000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{4.8000, 0.1000, -3.0000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{2, 3, 2, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float32{3.3000, 0.1000, -2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-0.5000, 0.3000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{3.3000, 0.1000, -2.0000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{2, 3, 2, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float32{2.1000, 0.1000, -2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-1.5000, 3.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{2.1000, 0.1000, -2.0000, 0.8000, 4.8000, -0.3000, -1.5000}},
		{4, 7, 4, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, []float32{0.5000, -0.9000, 0.3000, 0.7000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}},
		{4, 7, 4, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float32{-1.6000, 0.1000, -2.2000, 0.8000, 5.4000, -0.3000, -2.8000}, []float32{3.7000, -7.2000, 3.0000, 1.7000, 0.0000, 0.0000, 0.0000}, []float32{-1.6000, 0.1000, -2.2000, 0.8000, 5.4000, -0.3000, -2.8000}},
		{4, 7, 4, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float32{-1.5000, 0.1000, -1.4000, 0.8000, 3.6000, -0.3000, -1.9000}, []float32{-0.3000, 0.9000, -0.7000, 1.9000, 0.0000, 0.0000, 0.0000}, []float32{-1.5000, 0.1000, -1.4000, 0.8000, 3.6000, -0.3000, -1.9000}},
		{4, 7, 4, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float32{3.7000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}, []float32{-1.6000, 2.7000, -0.7000, -3.4000, 0.0000, 0.0000, 0.0000}, []float32{3.7000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{0, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{0, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{0, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{0, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float32{-0.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-0.8000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float32{-0.9000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{1.7000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-0.9000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{1, 1, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float32{3.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-2.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{3.5000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{2, 2, 3, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, -0.9000, 0.3000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{2, 2, 3, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float32{-0.8000, -1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.7000, -0.9000, 1.2000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-0.8000, -1.0000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{2, 2, 3, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float32{-0.9000, -0.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{1.7000, -0.9000, 0.5000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-0.9000, -0.8000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{2, 2, 3, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float32{3.5000, 0.8000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-2.6000, -0.9000, -1.3000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{3.5000, 0.8000, -2.2000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{4, 4, 7, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-2.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, []float32{0.6000, 0.1000, -0.5000, 0.8000, 3.6000, -0.3000, -1.5000}},
		{4, 4, 7, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-1.0000, 2.0000, -3.0000, -4.0000, 5.0000}, []float32{-0.8000, -1.0000, 1.4000, -1.6000, 0.0000, 0.0000, 0.0000}, []float32{0.7000, -0.9000, 1.2000, 0.7000, -1.5000, 0.2000, 1.6000}, []float32{-0.8000, -1.0000, 1.4000, -1.6000, 3.6000, -0.3000, -1.5000}},
		{4, 4, 7, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.0000, 0.0000, 2.0000, -3.0000, 0.0000}, []float32{-0.9000, -0.8000, 1.3000, -1.6000, 0.0000, 0.0000, 0.0000}, []float32{1.7000, -0.9000, 0.5000, 0.7000, -1.6000, 0.2000, 2.4000}, []float32{-0.9000, -0.8000, 1.3000, -1.6000, 3.6000, -0.3000, -1.5000}},
		{4, 4, 7, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}, []float32{3.5000, 0.8000, -3.1000, 4.8000, 0.0000, 0.0000, 0.0000}, []float32{-2.6000, -0.9000, -1.3000, 0.7000, 2.9000, 0.2000, -4.0000}, []float32{3.5000, 0.8000, -3.1000, 4.8000, 3.6000, -0.3000, -1.5000}},
	}
	*major = 'C'

	for _, test := range srotmTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		for j := 0; j < 5; j++ {
			(*temp)[j] = test.dtemp[j]
		}
		nc++
		Srotm(major, n, sx, incx, sy, incy, temp)
		for j := 0; j < test.lenx; j++ {
			if absf32(sfac*((*sx)[j]-test.sxtrue[j])) > absf32(test.size[j])*epsilonf32()+1e-9 {
				t.Errorf("Test Failed: sx[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, test.n, (*sx)[j], test.sxtrue[j])
			}
		}
		for j := 0; j < test.leny; j++ {
			if absf32(sfac*((*sy)[j]-test.sytrue[j])) > absf32(test.sytrue[j])*epsilonf32()+1e-9 {
				t.Errorf("Test Failed: sy[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, test.n, (*sy)[j], test.sytrue[j])
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSrotmFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	dtemp := func() *[]float32 { y := make([]float32, 5); return &y }()
	*n = 4
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2
	*dtemp = []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}

	for i := 0; i < b.N; i++ {
		srotmWrapper(n, sx, incx, sy, incy, dtemp)
	}
}

func BenchmarkSrotm(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	major := new(byte)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	dtemp := func() *[]float32 { y := make([]float32, 5); return &y }()
	*major = 'C'
	*n = 4
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2
	*dtemp = []float32{1.0000, 5.0000, 2.0000, 0.0000, -4.0000}

	for i := 0; i < b.N; i++ {
		Srotm(major, n, sx, incx, sy, incy, dtemp)
	}
}

func TestSswap(t *testing.T) {
	tname := "Sswap"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	major := new(byte)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*major = 'C'
	var sswapTests = []struct {
		n      int
		lenx   int
		leny   int
		sa     float32
		sx     []float32
		incx   int
		sy     []float32
		incy   int
		sxtrue []float32
		sytrue []float32
		size   []float32
	}{
		{0, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 2, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.5000, -0.9000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 4, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 3, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.3000, 0.1000, 0.5000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-0.5000, -0.9000, 0.6000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 7, 7, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.8000, 0.1000, -0.6000, 0.8000, 0.3000, -0.3000, 0.5000}, []float32{-0.4000, -0.9000, 0.9000, 0.7000, -0.5000, 0.2000, 0.6000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 2, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-0.9000, 0.1000, 0.5000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{-0.5000, 0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 7, 4, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.7000, 0.1000, 0.3000, 0.8000, -0.9000, -0.3000, 0.5000}, []float32{-0.4000, 0.9000, -0.5000, 0.6000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 3, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.5000, 0.3000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, -0.9000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 7, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.5000, 0.3000, -0.6000, 0.8000, 0.0000, 0.0000, 0.0000}, []float32{0.6000, -0.9000, 0.1000, 0.7000, -0.5000, 0.2000, 0.8000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
	}

	for _, test := range sswapTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		Sswap(major, n, sx, incx, sy, incy)
		for j := 0; j < test.lenx; j++ {
			if absf32(sfac*((*sx)[j]-test.sxtrue[j])) > absf32(test.size[j])*epsilonf32()+1e-9 {
				t.Errorf("Test Failed: sx[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, test.n, (*sx)[j], test.sxtrue[j])
			}
		}
		for j := 0; j < test.leny; j++ {
			if absf32(sfac*((*sy)[j]-test.sytrue[j])) > absf32(test.size[j])*epsilonf32()+1e-9 {
				t.Errorf("Test Failed: sx[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, test.n, (*sy)[j], test.sytrue[j])
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSswapFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*n = 4
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		sswapWrapper(n, sx, incx, sy, incy)
	}
}

func BenchmarkSswap(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	major := new(byte)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*major = 'C'
	*n = 4
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Sswap(major, n, sx, incx, sy, incy)
	}
}

func TestScopy(t *testing.T) {
	tname := "Scopy"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	major := new(byte)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*major = 'C'
	var scopyTests = []struct {
		n     int
		lenx  int
		leny  int
		sa    float32
		sx    []float32
		incx  int
		sy    []float32
		incy  int
		strue []float32
		size  []float32
	}{
		{0, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 2, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.6000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 4, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 3, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-0.5000, -0.9000, 0.6000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 7, 7, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{-0.4000, -0.9000, 0.9000, 0.7000, -0.5000, 0.2000, 0.6000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 2, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-0.5000, 0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 7, 4, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{-0.4000, 0.9000, -0.5000, 0.6000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.6000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 3, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.6000, -0.9000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 7, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.6000, -0.9000, 0.1000, 0.7000, -0.5000, 0.2000, 0.8000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
	}

	for _, test := range scopyTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		Scopy(major, n, sx, incx, sy, incy)
		for j := 0; j < test.leny; j++ {
			if absf32(sfac*((*sy)[j]-test.strue[j])) > absf32(test.size[j])*epsilonf32()+1e-9 {
				t.Errorf("Test Failed: sy[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, test.n, (*sy)[j], test.strue[j])
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkScopyFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*n = 4
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		scopyWrapper(n, sx, incx, sy, incy)
	}
}

func BenchmarkScopy(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	major := new(byte)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*major = 'C'
	*n = 4
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Scopy(major, n, sx, incx, sy, incy)
	}
}

func TestSaxpy(t *testing.T) {
	tname := "Saxpy"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	major := new(byte)
	sa := new(float32)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*major = 'C'
	var saxpyTests = []struct {
		n     int
		lenx  int
		leny  int
		sa    float32
		sx    []float32
		incx  int
		sy    []float32
		incy  int
		strue []float32
		size  []float32
	}{
		{0, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.5000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.6800, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 2, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.6800, -0.8700, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 4, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.6800, -0.8700, 0.1500, 0.9400, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.5000, -0.8700, 0.1500, 0.9400, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.6800, -0.8700, 0.1500, 0.9400, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 3, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.3500, -0.9000, 0.4800, 0.9400, 0.0000, 0.0000, 0.0000}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 7, 7, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.3800, -0.9000, 0.5700, 0.7000, -0.7500, 0.2000, 0.9800}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.5000, -0.9000, 0.5700, 0.7000, -0.7500, 0.2000, 0.9800}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.6800, -0.9000, 0.5700, 0.7000, -0.7500, 0.2000, 0.9800}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 3, 2, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.3500, -0.7200, 0.5700, 0.7000, -0.7500, 0.2000, 0.9800}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 7, 4, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, []float32{0.3800, -0.6300, 0.1500, 0.8800, -0.7500, 0.2000, 0.9800}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{0, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.5000, -0.6300, 0.1500, 0.8800, -0.7500, 0.2000, 0.9800}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{1, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.6800, -0.6300, 0.1500, 0.8800, -0.7500, 0.2000, 0.9800}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{2, 2, 3, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.6800, -0.9000, 0.3300, 0.8800, -0.7500, 0.2000, 0.9800}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
		{4, 4, 7, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, []float32{0.6800, -0.9000, 0.3300, 0.7000, -0.7500, 0.2000, 1.0400}, []float32{0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}},
	}

	for _, test := range saxpyTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		*sa = test.sa
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		Saxpy(major, n, sa, sx, incx, sy, incy)
		for j := 0; j < test.leny; j++ {
			if absf32(sfac*((*sy)[j]-test.strue[j])) > absf32(test.size[j])*epsilonf32()+1e-9 {
				t.Errorf("Test Failed: sy[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, test.n, (*sy)[j], test.strue[j])
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSaxpyFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sa := new(float32)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*n = 4
	*sa = 0.3
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = -1
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		saxpyWrapper(n, sa, sx, incx, sy, incy)
	}
}

func BenchmarkSaxpy(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	major := new(byte)
	sa := new(float32)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*major = 'C'
	*n = 4
	*sa = 0.3
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = -1
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Saxpy(major, n, sa, sx, incx, sy, incy)
	}
}

func TestSdot(t *testing.T) {
	tname := "Sdot"
	var nc int
	var res float32
	major := new(byte)
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*major = 'C'
	var sdotTests = []struct {
		n      int
		lenx   int
		leny   int
		sa     float32
		sx     []float32
		incx   int
		sy     []float32
		incy   int
		result float32
		size   float32
	}{
		{0, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.0000, 0.0000},
		{1, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.3000, 0.3000},
		{2, 2, 2, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.2100, 1.6000},
		{4, 4, 4, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.6200, 3.2000},
		{0, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.0000, 0.0000},
		{1, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.3000, 0.3000},
		{2, 3, 3, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, -0.0700, 1.6000},
		{4, 7, 7, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, 2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.8500, 3.2000},
		{0, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.0000, 0.0000},
		{1, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, 0.3000, 0.3000},
		{2, 3, 2, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, -0.7900, 1.6000},
		{4, 7, 4, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -2, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, 1, -0.7400, 3.2000},
		{0, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.0000, 0.0000},
		{1, 1, 1, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.3000, 0.3000},
		{2, 2, 3, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 0.3300, 1.6000},
		{4, 4, 7, 0.3000, []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}, -1, []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}, -2, 1.2700, 3.2000},
	}

	for _, test := range sdotTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		res = Sdot(major, n, sx, incx, sy, incy)
		if absf32(sfac*(res-test.result)) > absf32(test.size)*epsilonf32()+1e-9 {
			t.Errorf("Test Failed: result: test %d: {%10.8f} output, {%10.8f} expected", test.n, res, test.result)
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSdotFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*n = 4
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		_ = sdotWrapper(n, sx, incx, sy, incy)
	}
}

func BenchmarkSdot(b *testing.B) {
	major := new(byte)
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]float32 { y := make([]float32, 7); return &y }()
	sy := func() *[]float32 { y := make([]float32, 7); return &y }()
	*major = 'C'
	*n = 4
	*sx = []float32{0.6000, 0.1000, -0.5000, 0.8000, 0.9000, -0.3000, -0.4000}
	*incx = 2
	*sy = []float32{0.5000, -0.9000, 0.3000, 0.7000, -0.6000, 0.2000, 0.8000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		_ = Sdot(major, n, sx, incx, sy, incy)
	}
}

func TestSrotg(t *testing.T) {
	tname := "Srotg"
	major := new(byte)
	sa := new(float32)
	sb := new(float32)
	sc := new(float32)
	ss := new(float32)
	*major = 'C'
	var n, nc int
	var srotgTests = []struct {
		sa     float32
		sb     float32
		satrue float32
		sbtrue float32
		sc     float32
		ss     float32
	}{
		{0.3000, 0.4000, 0.5000, 1.0 / 0.6, 0.6000, 0.8000},
		{0.4000, 0.3000, 0.5000, 0.6000, 0.8000, 0.6000},
		{-0.3000, 0.4000, 0.5000, -1.0 / 0.6, -0.6000, 0.8000},
		{-0.4000, 0.3000, -0.5000, -0.6000, 0.8000, -0.6000},
		{-0.3000, -0.4000, -0.5000, 1.0 / 0.6, 0.6000, 0.8000},
		{0.0000, 0.0000, 0.0000, 0.0000, 1.0000, 0.0000},
		{0.0000, 1.0000, 1.0000, 1.0000, 0.0000, 1.0000},
		{1.0000, 0.0000, 1.0000, 0.0000, 1.0000, 0.0000},
	}

	for _, test := range srotgTests {
		n++
		*sa = test.sa
		*sb = test.sb
		*sc = test.sc
		*ss = test.ss
		nc++
		Srotg(major, sa, sb, sc, ss)
		if absf32(sfac*((*sa)-test.satrue)) > absf32(test.satrue)*epsilonf32()+1e-9 {
			t.Errorf("Test Failed: sa: test %d: {%10.8f} input, {%10.8f} output, {%10.8f} expected", n, test.sa, *sa, test.satrue)
		}
		if absf32(sfac*((*sb)-test.sbtrue)) > absf32(test.sbtrue)*epsilonf32()+1e-9 {
			t.Errorf("Test Failed: sb: test %d: {%10.8f} input, {%10.8f} output, {%10.8f} expected", n, test.sb, *sb, test.sbtrue)
		}
		if absf32(sfac*((*sc)-test.sc)) > absf32(test.sc)*epsilonf32()+1e-9 {
			t.Errorf("Test Failed: sc: test %d: {%10.8f} output, {%10.8f} expected", n, *sc, test.sc)
		}
		if absf32(sfac*((*ss)-test.ss)) > absf32(test.ss)*epsilonf32()+1e-9 {
			t.Errorf("Test Failed: ss: test %d: {%10.8f} output, {%10.8f} expected", n, *ss, test.ss)
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSrotgFortran(b *testing.B) {
	sa := new(float32)
	sb := new(float32)
	sc := new(float32)
	ss := new(float32)
	*sa = -0.3
	*sb = 0.4
	*sc = -0.6
	*ss = 0.8

	for i := 0; i < b.N; i++ {
		srotgWrapper(sa, sb, sc, ss)
	}
}

func BenchmarkSrotg(b *testing.B) {
	major := new(byte)
	sa := new(float32)
	sb := new(float32)
	sc := new(float32)
	ss := new(float32)
	*major = 'C'
	*sa = -0.3
	*sb = 0.4
	*sc = -0.6
	*ss = 0.8

	for i := 0; i < b.N; i++ {
		Srotg(major, sa, sb, sc, ss)
	}
}

func TestSrotmg(t *testing.T) {
	tname := "Srotmg"
	var nc int
	major := new(byte)
	d1 := new(float32)
	d2 := new(float32)
	x := new(float32)
	y := new(float32)
	sparam := func() *[]float32 {
		y := make([]float32, 5)
		return &y
	}()
	*major = 'C'
	var n int
	var srotmgTests = []struct {
		d1         float32
		d2         float32
		x          float32
		y          float32
		d1true     float32
		d2true     float32
		xtrue      float32
		ytrue      float32
		sparamtrue []float32
	}{
		{0.1, 0.3, 1.2, 0.2, 12.0 / 130.0, 36.0 / 130.0, 1.3, 0.2, []float32{0.0, 0.0, -1.0 / 6.0, 0.5, 0.0}},
		{0.7, 0.2, 0.6, 4.2, 14.0 / 75.0, 49.0 / 75.0, 4.5, 4.2, []float32{1.0, 0.5, 0.0, 0.0, 1.0 / 7.0}},
		{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, []float32{-2.0, 0.0, 0.0, 0.0, 0.0}},
		{4.0, -1.0, 2.0, 4.0, 0.0, 0.0, 0.0, 4.0, []float32{-1.0, 0.0, 0.0, 0.0, 0.0}},
		{6e-10, 2e-2, 1e5, 10.0, 45e-11 * (4096.0 * 4096.0), 15e-3, 4e5 / (3.0 * 4096.0), 10.0, []float32{-1.0, 1.0 / 4096.0, -1e-4, 1e4 / (3.0 * 4096.0), 1.0}},
		{4e10, 2e-2, 1e-5, 10.0, 4e10 / (1.5 * 4096.0 * 4096.0), 2e-2 / 1.5, 6144e-5, 10.0, []float32{-1.0, 4096.0, -1e6, 5e-7 * 4096.0, 1.0}},
		{2e-10, 4e-2, 1e5, 10.0, 4.0 / 150.0, (2e-10 / 1.5) * (4096.0 * 4096.0), 15.0, 10.0, []float32{-1.0, 5e-5, -1.0 / 4096.0, 1.0, 1e4 / 4096.0}},
		{2e10, 4e-2, 1e-5, 10.0, 4.0 / 150.0, 2e10 / (1.5 * 4096.0 * 4096.0), 15.0, 10.0, []float32{-1.0, 5e5, -4096.0, 1.0, 4096e-6}},
		{4.0, -2.0, 8.0, 4.0, 32.0 / 7.0, -16.0 / 7.0, 7.0, 4.0, []float32{0.0, 0.0, -.5, -.25, 0.0}},
	}

	for _, test := range srotmgTests {
		n++
		*d1 = test.d1
		*d2 = test.d2
		*x = test.x
		*y = test.y
		*sparam = []float32{0.0, 0.0, 0.0, 0.0, 0.0}
		nc++
		Srotmg(major, d1, d2, x, y, sparam)
		if absf32(sfac*((*d1)-test.d1true)) > absf32(test.d1true)*epsilonf32()+1e-9 {
			t.Errorf("Test Failed: d1: test %d: {%10.8f} input, {%10.8f} output, {%10.8f} expected", n, test.d1, *d1, test.d1true)
		}
		if absf32(sfac*((*d2)-test.d2true)) > absf32(test.d2true)*epsilonf32()+1e-9 {
			t.Errorf("Test Failed: d2: test %d: {%10.8f} input, {%10.8f} output, {%10.8f} expected", n, test.d2, *d2, test.d2true)
		}
		if absf32(sfac*((*x)-test.xtrue)) > absf32(test.xtrue)*epsilonf32()+1e-9 {
			t.Errorf("Test Failed: x: test %d: {%10.8f} input, {%10.8f} output, {%10.8f} expected", n, test.x, *x, test.xtrue)
		}
		if absf32(sfac*((*y)-test.ytrue)) > absf32(test.ytrue)*epsilonf32()+1e-9 {
			t.Errorf("Test Failed: y: test %d: {%10.8f} input, {%10.8f} output, {%10.8f} expected", n, test.y, *y, test.ytrue)
		}
		for j, val := range test.sparamtrue {
			if absf32(sfac*((*sparam)[j]-val)) > absf32(val)*epsilonf32()+1e-9 {
				t.Errorf("Test Failed: sparam[%d]: test %d: {%10.8f} output, {%10.8f} expected", j, n, (*sparam)[j], val)
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSrotmgFortran(b *testing.B) {
	d1 := new(float32)
	d2 := new(float32)
	x := new(float32)
	y := new(float32)
	sparam := func() *[]float32 {
		y := make([]float32, 5)
		return &y
	}()
	*d1 = 0.1
	*d2 = 0.3
	*x = 1.2
	*y = 0.2

	for i := 0; i < b.N; i++ {
		srotmgWrapper(d1, d2, x, y, sparam)
	}
}

func BenchmarkSrotmg(b *testing.B) {
	major := new(byte)
	d1 := new(float32)
	d2 := new(float32)
	x := new(float32)
	y := new(float32)
	sparam := func() *[]float32 {
		y := make([]float32, 5)
		return &y
	}()
	*major = 'C'
	*d1 = 0.1
	*d2 = 0.3
	*x = 1.2
	*y = 0.2

	for i := 0; i < b.N; i++ {
		Srotmg(major, d1, d2, x, y, sparam)
	}
}

func TestSnrm2(t *testing.T) {
	tname := "Snrm2"
	var nc int
	var res float32
	major := new(byte)
	n := new(int)
	incx := new(int)
	sx := func() *[]float32 { y := make([]float32, 8); return &y }()
	*major = 'C'
	var snrm2Tests = []struct {
		n      int
		incx   int
		len    int
		sa     float32
		sx     []float32
		result float32
	}{
		{0, 1, 2, 0.3, []float32{0.1, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0}, 0.0},
		{0, 2, 2, 0.3, []float32{0.1, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0}, 0.0},
		{1, 1, 2, -1.0, []float32{0.3, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0}, 0.3},
		{1, 2, 2, 0.3, []float32{0.3, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0}, 0.3},
		{2, 1, 4, 0.0, []float32{0.3, -0.4, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0}, 0.5},
		{2, 2, 4, 0.3, []float32{0.3, 2.0, -0.4, 2.0, 2.0, 2.0, 2.0, 2.0}, 0.5},
		{3, 1, 6, 1.0, []float32{0.2, -0.6, 0.3, 5.0, 5.0, 5.0, 5.0, 5.0}, 0.7},
		{3, 2, 6, 0.3, []float32{0.2, 3.0, -0.6, 5.0, 0.3, 2.0, 2.0, 2.0}, 0.7},
		{4, 1, 8, 0.3, []float32{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}, 0.6},
		{4, 2, 8, 0.3, []float32{0.1, 4.0, -0.3, 6.0, -0.5, 7.0, -0.1, 3.0}, 0.6},
	}

	for _, test := range snrm2Tests {
		*n = test.n
		*incx = test.incx
		for j := 0; j < 8; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		res = Snrm2(major, n, sx, incx)
		if absf32(sfac*(res-test.result)) > absf32(test.result)*epsilonf32()+1e-9 {
			t.Errorf("Test Failed: result: test %d: {%10.8f} output, {%10.8f} expected", test.n, res, test.result)
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSnrm2Fortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	sx := func() *[]float32 { y := make([]float32, 8); return &y }()
	*n = 0
	*incx = 1
	*sx = []float32{0.1, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0}

	for i := 0; i < b.N; i++ {
		_ = snrm2Wrapper(n, sx, incx)
	}
}

func BenchmarkSnrm2(b *testing.B) {
	major := new(byte)
	n := new(int)
	incx := new(int)
	sx := func() *[]float32 { y := make([]float32, 8); return &y }()
	*major = 'C'
	*n = 0
	*incx = 1
	*sx = []float32{0.1, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0}

	for i := 0; i < b.N; i++ {
		_ = Snrm2(major, n, sx, incx)
	}
}

func TestSasum(t *testing.T) {
	tname := "Sasum"
	var nc int
	var res float32
	major := new(byte)
	n := new(int)
	incx := new(int)
	sx := func() *[]float32 { y := make([]float32, 8); return &y }()
	*major = 'C'
	var sasumTests = []struct {
		n      int
		incx   int
		len    int
		sa     float32
		sx     []float32
		result float32
	}{
		{0, 1, 2, 0.3, []float32{0.1, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0}, 0.0},
		{0, 2, 2, 0.3, []float32{0.1, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0}, 0.0},
		{1, 1, 2, -1.0, []float32{0.3, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0}, 0.3},
		{1, 2, 2, 0.3, []float32{0.3, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0}, 0.3},
		{2, 1, 4, 0.0, []float32{0.3, -0.4, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0}, 0.7},
		{2, 2, 4, 0.3, []float32{0.3, 2.0, -0.4, 2.0, 2.0, 2.0, 2.0, 2.0}, 0.7},
		{3, 1, 6, 1.0, []float32{0.2, -0.6, 0.3, 5.0, 5.0, 5.0, 5.0, 5.0}, 1.1},
		{3, 2, 6, 0.3, []float32{0.2, 3.0, -0.6, 5.0, 0.3, 2.0, 2.0, 2.0}, 1.1},
		{4, 1, 8, 0.3, []float32{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}, 1.0},
		{4, 2, 8, 0.3, []float32{0.1, 4.0, -0.3, 6.0, -0.5, 7.0, -0.1, 3.0}, 1.0},
	}

	for _, test := range sasumTests {
		*n = test.n
		*incx = test.incx
		for j := 0; j < 8; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		res = Sasum(major, n, sx, incx)
		if absf32(sfac*(res-test.result)) > absf32(test.result)*epsilonf32()+1e-9 {
			t.Errorf("Test Failed: result: test %d: {%10.8f} output, {%10.8f} expected", test.n, res, test.result)
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSasumFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	sx := func() *[]float32 { y := make([]float32, 8); return &y }()
	*n = 4
	*incx = 2
	*sx = []float32{0.1, 4.0, -0.3, 6.0, -0.5, 7.0, -0.1, 3.0}

	for i := 0; i < b.N; i++ {
		_ = sasumWrapper(n, sx, incx)
	}
}

func BenchmarkSasum(b *testing.B) {
	major := new(byte)
	n := new(int)
	incx := new(int)
	sx := func() *[]float32 { y := make([]float32, 8); return &y }()
	*major = 'C'
	*n = 4
	*incx = 2
	*sx = []float32{0.1, 4.0, -0.3, 6.0, -0.5, 7.0, -0.1, 3.0}

	for i := 0; i < b.N; i++ {
		_ = Sasum(major, n, sx, incx)
	}
}

func TestSscal(t *testing.T) {
	tname := "Sscal"
	var nc int
	major := new(byte)
	n := new(int)
	incx := new(int)
	sa := new(float32)
	sx := func() *[]float32 { y := make([]float32, 8); return &y }()
	*major = 'C'
	var sscalTests = []struct {
		n      int
		incx   int
		len    int
		sa     float32
		sx     []float32
		sxtrue []float32
	}{
		{0, 1, 2, 0.3, []float32{0.1, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0}, []float32{0.10, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0}},
		{0, 2, 2, 0.3, []float32{0.1, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0}, []float32{0.10, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0}},
		{1, 1, 2, -1.0, []float32{0.3, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0}, []float32{-0.3, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0}},
		{1, 2, 2, 0.3, []float32{0.3, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0}, []float32{0.09, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0}},
		{2, 1, 4, 0.0, []float32{0.3, -0.4, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0}, []float32{0.0, 0.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0}},
		{2, 2, 4, 0.3, []float32{0.3, 2.0, -0.4, 2.0, 2.0, 2.0, 2.0, 2.0}, []float32{0.09, 2.0, -0.12, 2.0, 2.0, 2.0, 2.0, 2.0}},
		{3, 1, 6, 1.0, []float32{0.2, -0.6, 0.3, 5.0, 5.0, 5.0, 5.0, 5.0}, []float32{0.20, -0.60, 0.30, 5.0, 5.0, 5.0, 5.0, 5.0}},
		{3, 2, 6, 0.3, []float32{0.2, 3.0, -0.6, 5.0, 0.3, 2.0, 2.0, 2.0}, []float32{0.06, 3.0, -0.18, 5.0, 0.09, 2.0, 2.0, 2.0}},
		{4, 1, 8, 0.3, []float32{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}, []float32{0.03, -0.09, 0.15, -0.03, 6.0, 6.0, 6.0, 6.0}},
		{4, 2, 8, 0.3, []float32{0.1, 4.0, -0.3, 6.0, -0.5, 7.0, -0.1, 3.0}, []float32{0.03, 4.0, -0.09, 6.0, -0.15, 7.0, -0.03, 3.0}},
	}

	for _, test := range sscalTests {
		*n = test.n
		*incx = test.incx
		*sa = test.sa
		for j := 0; j < 8; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		Sscal(major, n, sa, sx, incx)
		for j, val := range test.sxtrue {
			if absf32(sfac*((*sx)[j]-val)) > absf32(val)*epsilonf32()+1e-9 {
				t.Errorf("Test Failed: sx[%d]: test %d: {%10.8f} input, {%10.8f} output, {%10.8f} expected", j, n, test.sx, *sx, val)
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSscalFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	sa := new(float32)
	sx := func() *[]float32 { y := make([]float32, 8); return &y }()
	*n = 4
	*incx = 1
	*sa = 0.3
	*sx = []float32{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}

	for i := 0; i < b.N; i++ {
		sscalWrapper(n, sa, sx, incx)
	}
}

func BenchmarkSscal(b *testing.B) {
	major := new(byte)
	n := new(int)
	incx := new(int)
	sa := new(float32)
	sx := func() *[]float32 { y := make([]float32, 8); return &y }()
	*major = 'C'
	*n = 4
	*incx = 1
	*sa = 0.3
	*sx = []float32{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}

	for i := 0; i < b.N; i++ {
		Sscal(major, n, sa, sx, incx)
	}
}

func TestIsamax(t *testing.T) {
	tname := "Isamax"
	var nc, res int
	major := new(byte)
	n := new(int)
	incx := new(int)
	sx := func() *[]float32 { y := make([]float32, 8); return &y }()
	*major = 'C'
	var isamaxTests = []struct {
		n     int
		incx  int
		len   int
		sa    float32
		sx    []float32
		ntrue int
	}{
		{0, 1, 2, 0.3, []float32{0.1, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0}, 0},
		{0, 2, 2, 0.3, []float32{0.1, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0}, 0},
		{1, 1, 2, -1.0, []float32{0.3, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0}, 1},
		{1, 2, 2, 0.3, []float32{0.3, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0}, 1},
		{2, 1, 4, 0.0, []float32{0.3, -0.4, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0}, 2},
		{2, 2, 4, 0.3, []float32{0.3, 2.0, -0.4, 2.0, 2.0, 2.0, 2.0, 2.0}, 2},
		{3, 1, 6, 1.0, []float32{0.2, -0.6, 0.3, 5.0, 5.0, 5.0, 5.0, 5.0}, 2},
		{3, 2, 6, 0.3, []float32{0.2, 3.0, -0.6, 5.0, 0.3, 2.0, 2.0, 2.0}, 2},
		{4, 1, 8, 0.3, []float32{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}, 3},
		{4, 2, 8, 0.3, []float32{0.1, 4.0, -0.3, 6.0, -0.5, 7.0, -0.1, 3.0}, 3},
	}

	for _, test := range isamaxTests {
		*n = test.n
		*incx = test.incx
		for j := 0; j < 8; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		res = Isamax(major, n, sx, incx)
		if res != test.ntrue {
			t.Errorf("Test Failed: result: test %d: {%d} output, {%d} expected", test.n, res, test.ntrue)
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkIsamaxFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	sx := func() *[]float32 { y := make([]float32, 8); return &y }()
	*n = 4
	*incx = 1
	*sx = []float32{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}

	for i := 0; i < b.N; i++ {
		_ = isamaxWrapper(n, sx, incx)
	}
}

func BenchmarkIsamax(b *testing.B) {
	major := new(byte)
	n := new(int)
	incx := new(int)
	sx := func() *[]float32 { y := make([]float32, 8); return &y }()
	*major = 'C'
	*n = 4
	*incx = 1
	*sx = []float32{0.1, -0.3, 0.5, -0.1, 6.0, 6.0, 6.0, 6.0}

	for i := 0; i < b.N; i++ {
		_ = Isamax(major, n, sx, incx)
	}
}

// BLAS Level 2
func TestSgemv(t *testing.T) {
	tname := "Sgemv"
	var i, ia, ib, ic, im, in, incxs, incys, ix, iy, laa, ldas, lx, ly, ml, ms, nl, ns, nd, nc int
	var als, bls, err, erri, epsf32 float32
	var transs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float32)
	beta := new(float32)
	transl := new(float32)
	kl := new(int)
	ku := new(int)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_ml := new(int)
	_nl := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	major := new(byte)

	*reset = true
	*major = 'C'

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]float32 { y := make([]float32, nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xs := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	y := func() *[]float32 { y := make([]float32, nmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	ys := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yt := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]
		ns = *n
		nd = (*n)/2 + 1
		for im = 1; im <= 2; im++ {
			if im == 1 {
				*m = max((*n)-nd, 0)
			} else if im == 2 {
				*m = min((*n)+nd, nmax)
			}

			*ku = (*n) - 1
			*kl = (*m) - 1
			ms = *m
			*lda = *m
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			ldas = *lda

			null = *n <= 0 || *m <= 0

			*transl = 0.0
			smakeGEL2(m, n, aa, lda, kl, ku, reset, transl, miSbeg, icSbeg, iSbeg)
			sReturn(a, aa)

			for ic = 1; ic <= len(ichtL2); ic++ {
				*trans = ichtL2[ic-1]

				if *trans == 'T' || *trans == 'C' {
					ml = *n
					nl = *m
				} else {
					ml = *m
					nl = *n
				}

				for ix = 1; ix <= len(incL2); ix++ {
					*incx = incL2[ix-1]
					lx = absint(*incx) * nl

					*transl = 0.5
					*_nl = nl - 1
					smakeGE2L2(onei, &nl, x, xx, incx, zeroi, _nl, reset, transl, miSbeg, icSbeg, iSbeg)
					if nl > 1 {
						(*x)[nl/2-1] = 0.0
						(*xx)[1+absint(*incx)*(nl/2-1)-1] = 0.0
					}

					for iy = 1; iy <= len(incL2); iy++ {
						*incy = incL2[iy-1]
						ly = absint(*incy) * ml

						for ia = 1; ia <= len(alff32L2); ia++ {
							*alpha = alff32L2[ia-1]

							for ib = 1; ib <= len(betf32L2); ib++ {
								*beta = betf32L2[ib-1]

								*transl = 0.0
								*_ml = ml - 1
								smakeGE2L2(onei, &ml, y, yy, incy, zeroi, _ml, reset, transl, miSbeg, icSbeg, iSbeg)

								transs = *trans
								incxs = *incx
								incys = *incy
								als = *alpha
								bls = *beta
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lx; i++ {
									(*xs)[i-1] = (*xx)[i-1]
								}
								for i = 1; i <= ly; i++ {
									(*ys)[i-1] = (*yy)[i-1]
								}

								nc++

								_aa := sExpand(aa, n, lda)
								Sgemv(major, trans, m, n, alpha, _aa, lda, xx, incx, beta, yy, incy)
								sReturn(_aa, aa)

								checkByte(t, nc, trans, &transs, "trans")
								checkInt(t, nc, m, &ms, "m")
								checkInt(t, nc, n, &ns, "n")
								checkFloat32(t, nc, &als, alpha, "alpha")
								checkFloat32(t, nc, &bls, beta, "beta")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, incx, &incxs, "incx")
								checkInt(t, nc, incy, &incys, "incy")
								checkFloat32Array1D(t, nc, &laa, aa, as, "aa")
								checkFloat32Array1D(t, nc, &lx, xx, xs, "xx")
								if null {
									checkFloat32Array1D(t, nc, &ly, yy, ys, "guardband yy")
									break
								} else {
									for j := 0; j < ml; j++ {
										for i = 1; i < absint(*incy); i++ {
											if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
												t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
											}
										}
									}
									smvch2Test(trans, m, n, alpha, a, x, incx, beta, y, incy, yt, g)
									err = 0
									for i = 1; i <= ml; i++ {
										erri = absf32((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf32
										if (*g)[i-1] != 0.0 {
											erri /= (*g)[i-1]
										}
										err = maxf32(err, erri)
										if err*sqrtf32(epsf32) >= 1.0 {
											t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.8e} error\n\t\ttrans: %c\tm: %d\tn: %d\talpha: %4.2f\tbeta: %4.2f\tlda: %d\tincx: %d\tincy: %d", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf32(epsf32), *trans, *m, *n, *alpha, *beta, *lda, *incx, *incy)
										}
									}
								}
							}

							if null {
								break
							}
						}

						if null {
							break
						}
					}

					if null {
						break
					}
				}

				if null {
					break
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSgemv(b *testing.B) {
	major := new(byte)
	alpha := new(float32)
	beta := new(float32)
	m := new(int)
	n := new(int)
	lda := new(int)
	incx := new(int)
	incy := new(int)
	trans := new(byte)

	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*major = 'C'
	*trans = 'C'
	*m = 14
	*n = 9
	*alpha = 0.70
	*aa = []float32{-0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -10000000000.0000, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -0.4525, 0.3766, -10000000000.0000, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, -10000000000.0000, 0.0170, 0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, 0.3067, -0.4625, 0.4665, -10000000000.0000, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, -0.0929, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -0.2927, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, -10000000000.0000}
	*lda = 15
	*xx = []float32{0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.1274, -10000000000.0000, 0.1573, -10000000000.0000, 0.0000, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float32{-0.1728, -10000000000.0000, -0.1429, -10000000000.0000, -0.4126, -10000000000.0000, 0.0170, -10000000000.0000, 0.1469, -10000000000.0000, -0.4925, -10000000000.0000, -0.2627, -10000000000.0000, -0.3327, -10000000000.0000, 0.2967, -10000000000.0000, -0.5402, -10000000000.0000, -0.6307, -10000000000.0000, 0.4639, -10000000000.0000, 0.1913, -10000000000.0000, 0.0281, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	_aa := sExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Sgemv(major, trans, m, n, alpha, _aa, lda, xx, incx, beta, yy, incy)
	}
}

func BenchmarkSgemvFortran(b *testing.B) {
	alpha := new(float32)
	beta := new(float32)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	trans := new(byte)

	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*trans = 'C'
	*m = 14
	*n = 9
	*alpha = 0.70
	*aa = []float32{-0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -10000000000.0000, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -0.4525, 0.3766, -10000000000.0000, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, -10000000000.0000, 0.0170, 0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, 0.3067, -0.4625, 0.4665, -10000000000.0000, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, -0.0929, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -0.2927, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, -10000000000.0000}
	*lda = 15
	*xx = []float32{0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.1274, -10000000000.0000, 0.1573, -10000000000.0000, 0.0000, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float32{-0.1728, -10000000000.0000, -0.1429, -10000000000.0000, -0.4126, -10000000000.0000, 0.0170, -10000000000.0000, 0.1469, -10000000000.0000, -0.4925, -10000000000.0000, -0.2627, -10000000000.0000, -0.3327, -10000000000.0000, 0.2967, -10000000000.0000, -0.5402, -10000000000.0000, -0.6307, -10000000000.0000, 0.4639, -10000000000.0000, 0.1913, -10000000000.0000, 0.0281, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		sgemvWrapper(trans, m, n, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func TestSgbmv(t *testing.T) {
	tname := "Sgbmv"
	var i, ia, ib, ic, iku, im, in, incxs, incys, ix, iy, kls, kus, laa, ldas, lx, ly, ml, ms, nl, ns, nd, nc int
	var als, bls, err, erri float32
	var transs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	major := new(byte)
	alpha := new(float32)
	beta := new(float32)
	transl := new(float32)
	m := new(int)
	n := new(int)
	kl := new(int)
	ku := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_ml := new(int)
	_nl := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	trans := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]float32 { y := make([]float32, nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xs := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	y := func() *[]float32 { y := make([]float32, nmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	ys := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yt := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]
		nd = (*n)/2 + 1

		for im = 1; im <= 2; im++ {
			if im == 1 {
				*m = max((*n)-nd, 0)
			} else if im == 2 {
				*m = min((*n)+nd, nmax)
			}

			for iku = 1; iku <= len(kbL2); iku++ {
				*ku = kbL2[iku-1]
				*kl = max((*ku)-1, 0)
				*lda = (*kl) + (*ku) + 1
				if *lda < nmax {
					*lda++
				} else if *lda > nmax {
					continue
				}
				laa = (*lda) * (*n)

				null = *n <= 0 || *m <= 0

				*transl = 0.0
				smakeGBL2(m, n, a, aa, lda, kl, ku, reset, transl, miSbeg, icSbeg, iSbeg)

				for ic = 1; ic <= len(ichtL2); ic++ {
					*trans = ichtL2[ic-1]
					if *trans == 'T' || *trans == 'C' {
						ml = *n
						nl = *m
					} else {
						ml = *m
						nl = *n
					}

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * nl

						*transl = 0.5
						*_nl = nl - 1
						smakeGE2L2(onei, &nl, x, xx, incx, zeroi, _nl, reset, transl, miSbeg, icSbeg, iSbeg)
						if nl > 1 {
							(*x)[nl/2-1] = 0.0
							(*xx)[1+absint(*incx)*(nl/2-1)-1] = 0.0
						}

						for iy = 1; iy <= len(incL2); iy++ {
							*incy = incL2[iy-1]
							ly = absint(*incy) * ml

							for ia = 1; ia <= len(alff32L2); ia++ {
								*alpha = alff32L2[ia-1]

								for ib = 1; ib <= len(betf32L2); ib++ {
									*beta = betf32L2[ib-1]

									*transl = 0.0
									*_ml = ml - 1
									smakeGE2L2(onei, &ml, y, yy, incy, zeroi, _ml, reset, transl, miSbeg, icSbeg, iSbeg)

									transs = *trans
									ns = *n
									ms = *m
									kls = *kl
									kus = *ku
									ldas = *lda
									incxs = *incx
									incys = *incy
									als = *alpha
									bls = *beta
									for i = 1; i <= laa; i++ {
										(*as)[i-1] = (*aa)[i-1]
									}
									for i = 1; i <= lx; i++ {
										(*xs)[i-1] = (*xx)[i-1]
									}
									for i = 1; i <= ly; i++ {
										(*ys)[i-1] = (*yy)[i-1]
									}

									nc++

									_aa := sExpand(aa, n, lda)
									Sgbmv(major, trans, m, n, kl, ku, alpha, _aa, lda, xx, incx, beta, yy, incy)
									sReturn(_aa, aa)

									checkByte(t, nc, trans, &transs, "trans")
									checkInt(t, nc, m, &ms, "m")
									checkInt(t, nc, n, &ns, "n")
									checkInt(t, nc, kl, &kls, "kl")
									checkInt(t, nc, ku, &kus, "ku")
									checkFloat32(t, nc, &als, alpha, "alpha")
									checkFloat32(t, nc, &bls, beta, "beta")
									checkInt(t, nc, lda, &ldas, "lda")
									checkInt(t, nc, incx, &incxs, "incx")
									checkInt(t, nc, incy, &incys, "incy")
									checkFloat32Array1D(t, nc, &laa, aa, as, "aa")
									checkFloat32Array1D(t, nc, &lx, xx, xs, "xx")
									if null {
										checkFloat32Array1D(t, nc, &ly, yy, ys, "guardband yy")
										break
									} else {
										for j := 0; j < ml; j++ {
											for i = 1; i < absint(*incy); i++ {
												if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
													t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
												}
											}
										}
										smvch2Test(trans, m, n, alpha, a, x, incx, beta, y, incy, yt, g)
										err = 0
										for i = 1; i <= ml; i++ {
											erri = absf32((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf32
											if (*g)[i-1] != 0.0 {
												erri /= (*g)[i-1]
											}
											err = maxf32(err, erri)
											if err*sqrtf32(epsf32) >= 1.0 {
												t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf32(epsf32))
											}
										}
									}
								}
								if null {
									break
								}
							}
							if null {
								break
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSgbmv(b *testing.B) {
	major := new(byte)
	alpha := new(float32)
	beta := new(float32)
	m := new(int)
	n := new(int)
	kl := new(int)
	ku := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	trans := new(byte)

	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*major = 'C'
	*trans = 'C'
	*m = 14
	*n = 9
	*kl = 3
	*ku = 4
	*alpha = 0.70
	*aa = []float32{-10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -0.2627, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, -10000000000.0000, 0.2268, 0.2567, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0270, 0.0569, -0.2128, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, -10000000000.0000, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -0.0230, -0.4925, -0.3327, -10000000000.0000, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, 0.3067, -0.4625, -10000000000.0000, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, 0.3367, -10000000000.0000}
	*lda = 9
	*xx = []float32{0.7667, -10000000000.0000, 0.3971, -10000000000.0000, 0.7268, -10000000000.0000, 0.4870, -10000000000.0000, 0.9166, -10000000000.0000, 0.0475, -10000000000.0000, 0.0000, -10000000000.0000, 0.4071, -10000000000.0000, 0.5669, -10000000000.0000, 0.1973, -10000000000.0000, 0.5270, -10000000000.0000, 0.5569, -10000000000.0000, 0.2872, -10000000000.0000, 0.8467, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float32{0.1768, -10000000000.0000, -0.2927, -10000000000.0000, -0.0629, -10000000000.0000, -0.1329, -10000000000.0000, -0.1728, -10000000000.0000, -0.1429, -10000000000.0000, -0.4126, -10000000000.0000, 0.0170, -10000000000.0000, 0.1469, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	_aa := sExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Sgbmv(major, trans, m, n, kl, ku, alpha, _aa, lda, xx, incx, beta, yy, incy)
	}
}

func BenchmarkSgbmvFortran(b *testing.B) {
	alpha := new(float32)
	beta := new(float32)
	m := new(int)
	n := new(int)
	kl := new(int)
	ku := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	trans := new(byte)

	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*trans = 'C'
	*m = 14
	*n = 9
	*kl = 3
	*ku = 4
	*alpha = 0.70
	*aa = []float32{-10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -0.2627, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, -10000000000.0000, 0.2268, 0.2567, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0270, 0.0569, -0.2128, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, -10000000000.0000, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -0.0230, -0.4925, -0.3327, -10000000000.0000, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, 0.3067, -0.4625, -10000000000.0000, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, 0.3367, -10000000000.0000}
	*lda = 9
	*xx = []float32{0.7667, -10000000000.0000, 0.3971, -10000000000.0000, 0.7268, -10000000000.0000, 0.4870, -10000000000.0000, 0.9166, -10000000000.0000, 0.0475, -10000000000.0000, 0.0000, -10000000000.0000, 0.4071, -10000000000.0000, 0.5669, -10000000000.0000, 0.1973, -10000000000.0000, 0.5270, -10000000000.0000, 0.5569, -10000000000.0000, 0.2872, -10000000000.0000, 0.8467, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float32{0.1768, -10000000000.0000, -0.2927, -10000000000.0000, -0.0629, -10000000000.0000, -0.1329, -10000000000.0000, -0.1728, -10000000000.0000, -0.1429, -10000000000.0000, -0.4126, -10000000000.0000, 0.0170, -10000000000.0000, 0.1469, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		sgbmvWrapper(trans, m, n, kl, ku, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func TestSsymv(t *testing.T) {
	tname := "Ssymv"
	var i, ia, ib, ic, in, incxs, incys, ix, iy, laa, ldas, lx, ly, ns, nc int
	var als, bls, err, erri float32
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float32)
	beta := new(float32)
	transl := new(float32)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]float32 { y := make([]float32, nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xs := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	y := func() *[]float32 { y := make([]float32, nmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	ys := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yt := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = (*n)
		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			*transl = 0.0
			*_n = (*n) - 1
			smakeSYL2(uplo, n, a, aa, lda, _n, _n, reset, transl, miSbeg, icSbeg, iSbeg)

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				smakeGE2L2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
				if (*n) > 1 {
					(*x)[(*n)/2-1] = 0.0
					(*xx)[1+absint(*incx)*((*n)/2-1)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					for ia = 1; ia <= len(alff32L2); ia++ {
						*alpha = alff32L2[ia-1]

						for ib = 1; ib <= len(betf32L2); ib++ {
							*beta = betf32L2[ib-1]

							*transl = 0.0
							smakeGE2L2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)

							uplos = *uplo
							ns = *n
							ldas = *lda
							incxs = *incx
							incys = *incy
							als = *alpha
							bls = *beta
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lx; i++ {
								(*xs)[i-1] = (*xx)[i-1]
							}
							for i = 1; i <= ly; i++ {
								(*ys)[i-1] = (*yy)[i-1]
							}

							nc++

							_aa := sExpand(aa, n, lda)
							Ssymv(major, uplo, n, alpha, _aa, lda, xx, incx, beta, yy, incy)
							sReturn(_aa, aa)

							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkFloat32(t, nc, &als, alpha, "alpha")
							checkFloat32(t, nc, &bls, beta, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, incx, &incxs, "incx")
							checkInt(t, nc, incy, &incys, "incy")
							checkFloat32Array1D(t, nc, &laa, aa, as, "aa")
							checkFloat32Array1D(t, nc, &lx, xx, xs, "xx")
							if null {
								checkFloat32Array1D(t, nc, &ly, yy, ys, "guardband yy")
								break
							} else {
								for j := 0; j < *n; j++ {
									for i = 1; i < absint(*incy); i++ {
										if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
											t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
										}
									}
								}
								smvch2Test(uplo, n, n, alpha, a, x, incx, beta, y, incy, yt, g)
								err = 0
								for i = 1; i <= *n; i++ {
									erri = absf32((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf32
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf32(err, erri)
									if err*sqrtf32(epsf32) >= 1.0 {
										t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf32(epsf32))
									}
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSsymv(b *testing.B) {
	major := new(byte)
	alpha := new(float32)
	beta := new(float32)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)

	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.3726, -10000000000.0000}
	*lda = 10
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float32{0.1868, -10000000000.0000, -0.3826, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.2667, -10000000000.0000, -0.1029, -10000000000.0000, 0.2268, -10000000000.0000, 0.2567, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	_aa := sExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Ssymv(major, uplo, n, alpha, _aa, lda, xx, incx, beta, yy, incy)
	}
}

func BenchmarkSsymvFortran(b *testing.B) {
	alpha := new(float32)
	beta := new(float32)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)

	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.3726, -10000000000.0000}
	*lda = 10
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float32{0.1868, -10000000000.0000, -0.3826, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.2667, -10000000000.0000, -0.1029, -10000000000.0000, 0.2268, -10000000000.0000, 0.2567, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		ssymvWrapper(uplo, n, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func TestSsbmv(t *testing.T) {
	tname := "Ssbmv"
	var i, ia, ib, ic, ik, in, incxs, incys, ix, iy, ks, laa, ldas, lx, ly, nc, ns int
	var als, bls, err, erri float32
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float32)
	beta := new(float32)
	transl := new(float32)
	n := new(int)
	k := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]float32 { y := make([]float32, nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xs := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	y := func() *[]float32 { y := make([]float32, nmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	ys := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yt := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		for ik = 1; ik <= len(kbL2); ik++ {
			*k = kbL2[ik-1]
			*lda = (*k) + 1

			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = (*lda) * (*n)
			null = *n <= 0

			for ic = 1; ic <= len(ichuL2); ic++ {
				*uplo = ichuL2[ic-1]

				*transl = 0.0
				smakeSBL2(uplo, n, n, a, aa, lda, k, k, reset, transl, miSbeg, icSbeg, iSbeg)

				for ix = 1; ix <= len(incL2); ix++ {
					*incx = incL2[ix-1]
					lx = absint(*incx) * (*n)

					*transl = 0.5
					*_n = (*n) - 1
					smakeGE2L2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
					if (*n) > 1 {
						(*x)[(*n)/2-1] = 0.0
						(*xx)[1+absint(*incx)*((*n)/2-1)-1] = 0.0
					}

					for iy = 1; iy <= len(incL2); iy++ {
						*incy = incL2[iy-1]
						ly = absint(*incy) * (*n)

						for ia = 1; ia <= len(alff32L2); ia++ {
							*alpha = alff32L2[ia-1]

							for ib = 1; ib <= len(betf32L2); ib++ {
								*beta = betf32L2[ib-1]

								*transl = 0.0
								smakeGE2L2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)

								uplos = *uplo
								ns = *n
								ks = *k
								ldas = *lda
								incxs = *incx
								incys = *incy
								als = *alpha
								bls = *beta
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lx; i++ {
									(*xs)[i-1] = (*xx)[i-1]
								}
								for i = 1; i <= ly; i++ {
									(*ys)[i-1] = (*yy)[i-1]
								}

								nc++

								_aa := sExpand(aa, n, lda)
								Ssbmv(major, uplo, n, k, alpha, _aa, lda, xx, incx, beta, yy, incy)
								sReturn(_aa, aa)

								checkByte(t, nc, uplo, &uplos, "uplo")
								checkInt(t, nc, n, &ns, "n")
								checkInt(t, nc, k, &ks, "k")
								checkFloat32(t, nc, &als, alpha, "alpha")
								checkFloat32(t, nc, &bls, beta, "beta")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, incx, &incxs, "incx")
								checkInt(t, nc, incy, &incys, "incy")
								checkFloat32Array1D(t, nc, &laa, aa, as, "aa")
								checkFloat32Array1D(t, nc, &lx, xx, xs, "xx")
								if null {
									checkFloat32Array1D(t, nc, &ly, yy, ys, "guardband yy")
									break
								} else {
									for j := 0; j < (*n); j++ {
										for i = 1; i < absint(*incy); i++ {
											if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
												t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
											}
										}
									}
									_n := func() *byte { y := byte('N'); return &y }()
									smvch2Test(_n, n, n, alpha, a, x, incx, beta, y, incy, yt, g)
									err = 0
									for i = 1; i <= (*n); i++ {
										erri = absf32((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf32
										if (*g)[i-1] != 0.0 {
											erri /= (*g)[i-1]
										}
										err = maxf32(err, erri)
										if err*sqrtf32(epsf32) >= 1.0 {
											t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf32(epsf32))
										}
									}
								}
							}
							if null {
								break
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSsbmv(b *testing.B) {
	alpha := new(float32)
	beta := new(float32)
	n := new(int)
	k := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	major := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*n = 9
	*k = 4
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -10000000000.0000, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -10000000000.0000, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, -10000000000.0000, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, -10000000000.0000, 0.1369, 0.0669, -0.3027, 0.0270, -10000000000.0000, -10000000000.0000, -0.2128, 0.2168, 0.3467, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1768, -0.2927, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000}
	*lda = 6
	*xx = []float32{0.9965, -10000000000.0000, 0.3272, -10000000000.0000, 0.3571, -10000000000.0000, 0.0000, -10000000000.0000, 0.6469, -10000000000.0000, 0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float32{-0.3726, -10000000000.0000, -0.3427, -10000000000.0000, 0.3866, -10000000000.0000, -0.1828, -10000000000.0000, -0.0529, -10000000000.0000, 0.3067, -10000000000.0000, -0.4625, -10000000000.0000, 0.4665, -10000000000.0000, 0.0969, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	_aa := sExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Ssbmv(major, uplo, n, k, alpha, _aa, lda, xx, incx, beta, yy, incy)
	}
}

func BenchmarkSsbmvFortran(b *testing.B) {
	alpha := new(float32)
	beta := new(float32)
	n := new(int)
	k := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*k = 4
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -10000000000.0000, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -10000000000.0000, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, -10000000000.0000, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, -10000000000.0000, 0.1369, 0.0669, -0.3027, 0.0270, -10000000000.0000, -10000000000.0000, -0.2128, 0.2168, 0.3467, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1768, -0.2927, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000}
	*lda = 6
	*xx = []float32{0.9965, -10000000000.0000, 0.3272, -10000000000.0000, 0.3571, -10000000000.0000, 0.0000, -10000000000.0000, 0.6469, -10000000000.0000, 0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float32{-0.3726, -10000000000.0000, -0.3427, -10000000000.0000, 0.3866, -10000000000.0000, -0.1828, -10000000000.0000, -0.0529, -10000000000.0000, 0.3067, -10000000000.0000, -0.4625, -10000000000.0000, 0.4665, -10000000000.0000, 0.0969, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		ssbmvWrapper(uplo, n, k, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func TestSspmv(t *testing.T) {
	tname := "Sspmv"
	var i, ia, ib, ic, in, incxs, incys, ix, iy, laa, lx, ly, nc, ns int
	var als, bls, err, erri float32
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float32)
	beta := new(float32)
	transl := new(float32)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	major := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]float32 { y := make([]float32, nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xs := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	y := func() *[]float32 { y := make([]float32, nmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	ys := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yt := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			*transl = 0.0
			*_n = (*n) - 1
			smakeSPL2(uplo, n, n, a, aa, _n, _n, reset, transl, miSbeg, icSbeg, iSbeg)

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				smakeGE2L2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
				if (*n) > 1 {
					(*x)[(*n)/2-1] = 0.0
					(*xx)[1+absint(*incx)*((*n)/2-1)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					for ia = 1; ia <= len(alff32L2); ia++ {
						*alpha = alff32L2[ia-1]

						for ib = 1; ib <= len(betf32L2); ib++ {
							*beta = betf32L2[ib-1]

							*transl = 0.0
							smakeGE2L2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)

							uplos = *uplo
							ns = *n
							incxs = *incx
							incys = *incy
							als = *alpha
							bls = *beta
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lx; i++ {
								(*xs)[i-1] = (*xx)[i-1]
							}
							for i = 1; i <= ly; i++ {
								(*ys)[i-1] = (*yy)[i-1]
							}

							nc++

							Sspmv(major, uplo, n, alpha, aa, xx, incx, beta, yy, incy)

							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkFloat32(t, nc, &als, alpha, "alpha")
							checkFloat32(t, nc, &bls, beta, "beta")
							checkInt(t, nc, incx, &incxs, "incx")
							checkInt(t, nc, incy, &incys, "incy")
							checkFloat32Array1D(t, nc, &laa, aa, as, "aa")
							checkFloat32Array1D(t, nc, &lx, xx, xs, "xx")
							if null {
								checkFloat32Array1D(t, nc, &ly, yy, ys, "guardband yy")
								break
							} else {
								for j := 0; j < (*n); j++ {
									for i = 1; i < absint(*incy); i++ {
										if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
											t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
										}
									}
								}
								_n := func() *byte { y := byte('N'); return &y }()
								smvch2Test(_n, n, n, alpha, a, x, incx, beta, y, incy, yt, g)
								err = 0
								for i = 1; i <= (*n); i++ {
									erri = absf32((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf32
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf32(err, erri)
									if err*sqrtf32(epsf32) >= 1.0 {
										t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf32(epsf32))
									}
								}
							}
						}

						if null {
							break
						}
					}

					if null {
						break
					}
				}

				if null {
					break
				}
			}

			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSspmv(b *testing.B) {
	alpha := new(float32)
	beta := new(float32)
	n := new(int)
	incx := new(int)
	incy := new(int)
	major := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726}
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float32{0.1868, -10000000000.0000, -0.3826, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.2667, -10000000000.0000, -0.1029, -10000000000.0000, 0.2268, -10000000000.0000, 0.2567, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Sspmv(major, uplo, n, alpha, aa, xx, incx, beta, yy, incy)
	}
}

func BenchmarkSspmvFortran(b *testing.B) {
	alpha := new(float32)
	beta := new(float32)
	n := new(int)
	incx := new(int)
	incy := new(int)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726}
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*beta = 0.90
	*yy = []float32{0.1868, -10000000000.0000, -0.3826, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.2667, -10000000000.0000, -0.1029, -10000000000.0000, 0.2268, -10000000000.0000, 0.2567, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2

	for i := 0; i < b.N; i++ {
		sspmvWrapper(uplo, n, alpha, aa, xx, incx, beta, yy, incy)
	}
}

func TestStrmv(t *testing.T) {
	tname := "Strmv"
	var i, icd, ict, icu, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float32
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(float32)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	major := new(byte)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xs := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xt := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*k = (*n) - 1
		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for icu = 1; icu <= len(ichuL2); icu++ {
			*uplo = ichuL2[icu-1]

			for ict = 1; ict <= len(ichtL2); ict++ {
				*trans = ichtL2[ict-1]

				for icd = 1; icd <= len(ichdL2); icd++ {
					*diag = ichdL2[icd-1]

					*transl = 0.0
					smakeTRL2(uplo, diag, n, n, a, aa, lda, k, k, reset, transl, miSbeg, icSbeg, iSbeg)

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * (*n)

						*transl = 0.5
						*_n = (*n) - 1
						smakeGE2L2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
						if (*n) > 1 {
							(*x)[(*n)/2-1] = 0.0
							(*xx)[1+absint(*incx)*((*n)/2-1)-1] = 0.0
						}

						uplos = *uplo
						transs = *trans
						diags = *diag
						ns = *n
						ldas = *lda
						incxs = *incx
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}

						nc++

						_aa := sExpand(aa, n, lda)
						Strmv(major, uplo, trans, diag, n, _aa, lda, xx, incx)
						sReturn(_aa, aa)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkByte(t, nc, trans, &transs, "trans")
						checkByte(t, nc, diag, &diags, "diag")
						checkInt(t, nc, n, &ns, "n")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkFloat32Array1D(t, nc, &laa, aa, as, "aa")
						if null {
							checkFloat32Array1D(t, nc, &lx, xx, xs, "guardband xx")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = 1; i < absint(*incx); i++ {
									if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
									}
								}
							}
							smvch2Test(trans, n, n, onef32, a, x, incx, zerof32, x, incx, xt, g)
							err = 0
							for i = 1; i <= (*n); i++ {
								erri = absf32((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf32
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf32(err, erri)
								if err*sqrtf32(epsf32) >= 1.0 {
									t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf32(epsf32))
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkStrmv(b *testing.B) {
	n := new(int)
	incx := new(int)
	lda := new(int)
	major := new(byte)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.6274, -10000000000.0000}
	*lda = 10
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	_aa := sExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Strmv(major, uplo, trans, diag, n, _aa, lda, xx, incx)
	}
}

func BenchmarkStrmvFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.6274, -10000000000.0000}
	*lda = 10
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		strmvWrapper(uplo, trans, diag, n, aa, lda, xx, incx)
	}
}

func TestStbmv(t *testing.T) {
	tname := "Stbmv"
	var i, icd, ict, icu, ik, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float32
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(float32)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]float32 { y := make([]float32, nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xs := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xt := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		for ik = 1; ik <= len(kbL2); ik++ {
			*k = kbL2[ik-1]

			*lda = (*k) + 1
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = (*lda) * (*n)
			null = *n <= 0

			for icu = 1; icu <= len(ichuL2); icu++ {
				*uplo = ichuL2[icu-1]

				for ict = 1; ict <= len(ichtL2); ict++ {
					*trans = ichtL2[ict-1]

					for icd = 1; icd <= len(ichdL2); icd++ {
						*diag = ichdL2[icd-1]

						*transl = 0.0
						smakeTBL2(uplo, diag, n, n, a, aa, lda, k, k, reset, transl, miSbeg, icSbeg, iSbeg)

						for ix = 1; ix <= len(incL2); ix++ {
							*incx = incL2[ix-1]
							lx = absint(*incx) * (*n)

							*transl = 0.5
							*_n = (*n) - 1
							smakeGE2L2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
							if (*n) > 1 {
								(*x)[(*n)/2-1] = 0.0
								(*xx)[1+absint(*incx)*((*n)/2-1)-1] = 0.0
							}

							uplos = *uplo
							transs = *trans
							diags = *diag
							ns = *n
							ldas = *lda
							incxs = *incx
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lx; i++ {
								(*xs)[i-1] = (*xx)[i-1]
							}

							nc++
							_aa := sExpand(aa, n, lda)
							Stbmv(major, uplo, trans, diag, n, k, _aa, lda, xx, incx)
							sReturn(_aa, aa)

							checkByte(t, nc, uplo, &uplos, "uplo")
							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, diag, &diags, "diag")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, incx, &incxs, "incx")
							checkFloat32Array1D(t, nc, &laa, aa, as, "aa")
							if null {
								checkFloat32Array1D(t, nc, &lx, xx, xs, "guardband xx")
								break
							} else {
								for j = 0; j < *n; j++ {
									for i = 1; i < absint(*incx); i++ {
										if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
											t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
										}
									}
								}
								smvch2Test(trans, n, n, onef32, a, x, incx, zerof32, x, incx, xt, g)
								err = 0
								for i = 1; i <= (*n); i++ {
									erri = absf32((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf32
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf32(err, erri)
									if err*sqrtf32(epsf32) >= 1.0 {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf32(epsf32))
									}
								}
							}
						}

						if null {
							break
						}
					}

					if null {
						break
					}
				}

				if null {
					break
				}
			}

			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkStbmv(b *testing.B) {
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	major := new(byte)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*k = 4
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -10000000000.0000, 0.8172, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 1.0969, 0.4266, 0.4565, 0.1868, -0.2527, -10000000000.0000, 0.5774, 0.1069, 0.3367, 0.2667, 0.2268, -10000000000.0000, 1.2567, -0.0130, 0.4166, -0.4525, -0.0929, -10000000000.0000, 1.1369, 0.0669, -0.3027, 0.0270, -10000000000.0000, -10000000000.0000, 0.7872, 0.2168, 0.3467, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1768, -0.2927, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.8671, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000}
	*lda = 6
	*xx = []float32{0.9965, -10000000000.0000, 0.3272, -10000000000.0000, 0.3571, -10000000000.0000, 0.0000, -10000000000.0000, 0.6469, -10000000000.0000, 0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	_aa := sExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Stbmv(major, uplo, trans, diag, n, k, _aa, lda, xx, incx)
	}
}

func BenchmarkStbmvFortran(b *testing.B) {
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*k = 4
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -10000000000.0000, 0.8172, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 1.0969, 0.4266, 0.4565, 0.1868, -0.2527, -10000000000.0000, 0.5774, 0.1069, 0.3367, 0.2667, 0.2268, -10000000000.0000, 1.2567, -0.0130, 0.4166, -0.4525, -0.0929, -10000000000.0000, 1.1369, 0.0669, -0.3027, 0.0270, -10000000000.0000, -10000000000.0000, 0.7872, 0.2168, 0.3467, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1768, -0.2927, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.8671, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000}
	*lda = 6
	*xx = []float32{0.9965, -10000000000.0000, 0.3272, -10000000000.0000, 0.3571, -10000000000.0000, 0.0000, -10000000000.0000, 0.6469, -10000000000.0000, 0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		stbmvWrapper(uplo, trans, diag, n, k, aa, lda, xx, incx)
	}
}

func TestStpmv(t *testing.T) {
	tname := "Stpmv"
	var i, icd, ict, icu, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float32
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(float32)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]float32 { y := make([]float32, nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xs := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xt := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*k = (*n) - 1
		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for icu = 1; icu <= len(ichuL2); icu++ {
			*uplo = ichuL2[icu-1]

			for ict = 1; ict <= len(ichtL2); ict++ {
				*trans = ichtL2[ict-1]

				for icd = 1; icd <= len(ichdL2); icd++ {
					*diag = ichdL2[icd-1]

					*transl = 0.0
					smakeTPL2(uplo, diag, n, n, a, aa, k, k, reset, transl, miSbeg, icSbeg, iSbeg)

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * (*n)

						*transl = 0.5
						*_n = (*n) - 1
						smakeGE2L2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
						if (*n) > 1 {
							(*x)[(*n)/2-1] = 0.0
							(*xx)[1+absint(*incx)*((*n)/2-1)-1] = 0.0
						}

						uplos = *uplo
						transs = *trans
						diags = *diag
						ns = *n
						ldas = *lda
						incxs = *incx
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}

						nc++

						Stpmv(major, uplo, trans, diag, n, aa, xx, incx)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkByte(t, nc, trans, &transs, "trans")
						checkByte(t, nc, diag, &diags, "diag")
						checkInt(t, nc, n, &ns, "n")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkFloat32Array1D(t, nc, &laa, aa, as, "aa")
						if null {
							checkFloat32Array1D(t, nc, &lx, xx, xs, "guardband xx")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = 1; i < absint(*incx); i++ {
									if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
									}
								}
							}
							smvch2Test(trans, n, n, onef32, a, x, incx, zerof32, x, incx, xt, g)
							err = 0
							for i = 1; i <= (*n); i++ {
								erri = absf32((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf32
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf32(err, erri)
								if err*sqrtf32(epsf32) >= 1.0 {
									t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf32(epsf32))
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkStpmv(b *testing.B) {
	n := new(int)
	incx := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, 1.4965, -0.1728, -0.1429, -0.4126, 1.1469, -0.0230, -0.4925, 0.7373, -0.3327, 0.6274}
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		Stpmv(major, uplo, trans, diag, n, aa, xx, incx)
	}
}

func BenchmarkStpmvFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, 1.4965, -0.1728, -0.1429, -0.4126, 1.1469, -0.0230, -0.4925, 0.7373, -0.3327, 0.6274}
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		stpmvWrapper(uplo, trans, diag, n, aa, xx, incx)
	}
}

func TestStrsv(t *testing.T) {
	tname := "Strsv"
	var i, icd, ict, icu, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float32
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(float32)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]float32 { y := make([]float32, nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xs := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xt := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	z := func() *[]float32 { y := make([]float32, nmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*k = (*n) - 1
		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for icu = 1; icu <= len(ichuL2); icu++ {
			*uplo = ichuL2[icu-1]

			for ict = 1; ict <= len(ichtL2); ict++ {
				*trans = ichtL2[ict-1]

				for icd = 1; icd <= len(ichdL2); icd++ {
					*diag = ichdL2[icd-1]

					*transl = 0.0
					smakeTRL2(uplo, diag, n, n, a, aa, lda, k, k, reset, transl, miSbeg, icSbeg, iSbeg)

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * (*n)

						*transl = 0.5
						*_n = (*n) - 1
						smakeGE2L2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
						if (*n) > 1 {
							(*x)[(*n)/2-1] = 0.0
							(*xx)[1+absint(*incx)*((*n)/2-1)-1] = 0.0
						}

						uplos = *uplo
						transs = *trans
						diags = *diag
						ns = *n
						ldas = *lda
						incxs = *incx
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}

						nc++

						_aa := sExpand(aa, n, lda)
						Strsv(major, uplo, trans, diag, n, _aa, lda, xx, incx)
						sReturn(_aa, aa)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkByte(t, nc, trans, &transs, "trans")
						checkByte(t, nc, diag, &diags, "diag")
						checkInt(t, nc, n, &ns, "n")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkFloat32Array1D(t, nc, &laa, aa, as, "aa")
						if null {
							checkFloat32Array1D(t, nc, &lx, xx, xs, "guardband xx")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = 1; i < absint(*incx); i++ {
									if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
									}
								}
							}
							for i = 1; i <= *n; i++ {
								(*z)[i-1] = (*xx)[(i-1)*absint(*incx)]
								(*xx)[(i-1)*absint(*incx)] = (*xs)[(i-1)*absint(*incx)]
							}
							smvch2Test(trans, n, n, onef32, a, z, incx, zerof32, x, incx, xt, g)
							err = 0
							for i = 1; i <= (*n); i++ {
								erri = absf32((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf32
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf32(err, erri)
								if err*sqrtf32(epsf32) >= 1.0 {
									t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*z)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf32(epsf32))
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkStrsv(b *testing.B) {
	n := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.6274, -10000000000.0000}
	*lda = 10
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	_aa := sExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Strsv(major, uplo, trans, diag, n, _aa, lda, xx, incx)
	}
}

func BenchmarkStrsvFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.6274, -10000000000.0000}
	*lda = 10
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		strsvWrapper(uplo, trans, diag, n, aa, lda, xx, incx)
	}
}

func TestStbsv(t *testing.T) {
	tname := "Stbsv"
	var i, icd, ict, icu, ik, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float32
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(float32)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]float32 { y := make([]float32, nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xs := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xt := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	z := func() *[]float32 { y := make([]float32, nmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		for ik = 1; ik <= len(kbL2); ik++ {
			*k = kbL2[ik-1]

			*lda = (*k) + 1
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = (*lda) * (*n)
			null = *n <= 0

			for icu = 1; icu <= len(ichuL2); icu++ {
				*uplo = ichuL2[icu-1]

				for ict = 1; ict <= len(ichtL2); ict++ {
					*trans = ichtL2[ict-1]

					for icd = 1; icd <= len(ichdL2); icd++ {
						*diag = ichdL2[icd-1]

						*transl = 0.0
						smakeTBL2(uplo, diag, n, n, a, aa, lda, k, k, reset, transl, miSbeg, icSbeg, iSbeg)

						for ix = 1; ix <= len(incL2); ix++ {
							*incx = incL2[ix-1]
							lx = absint(*incx) * (*n)

							*transl = 0.5
							*_n = (*n) - 1
							smakeGE2L2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
							if (*n) > 1 {
								(*x)[(*n)/2-1] = 0.0
								(*xx)[1+absint(*incx)*((*n)/2-1)-1] = 0.0
							}

							uplos = *uplo
							transs = *trans
							diags = *diag
							ns = *n
							ldas = *lda
							incxs = *incx
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lx; i++ {
								(*xs)[i-1] = (*xx)[i-1]
							}

							nc++

							_aa := sExpand(aa, n, lda)
							Stbsv(major, uplo, trans, diag, n, k, _aa, lda, xx, incx)
							sReturn(_aa, aa)

							checkByte(t, nc, uplo, &uplos, "uplo")
							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, diag, &diags, "diag")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, incx, &incxs, "incx")
							checkFloat32Array1D(t, nc, &laa, aa, as, "aa")
							if null {
								checkFloat32Array1D(t, nc, &lx, xx, xs, "guardband xx")
								break
							} else {
								for j = 0; j < *n; j++ {
									for i = 1; i < absint(*incx); i++ {
										if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
											t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
										}
									}
								}
								for i = 1; i <= *n; i++ {
									(*z)[i-1] = (*xx)[(i-1)*absint(*incx)]
									(*xx)[(i-1)*absint(*incx)] = (*xs)[(i-1)*absint(*incx)]
								}
								smvch2Test(trans, n, n, onef32, a, z, incx, zerof32, x, incx, xt, g)
								err = 0
								for i = 1; i <= (*n); i++ {
									erri = absf32((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf32
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf32(err, erri)
									if err*sqrtf32(epsf32) >= 1.0 {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf32(epsf32))
									}
								}
							}
							if null {
								break
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkStbsv(b *testing.B) {
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*k = 4
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -10000000000.0000, 0.8172, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 1.0969, 0.4266, 0.4565, 0.1868, -0.2527, -10000000000.0000, 0.5774, 0.1069, 0.3367, 0.2667, 0.2268, -10000000000.0000, 1.2567, -0.0130, 0.4166, -0.4525, -0.0929, -10000000000.0000, 1.1369, 0.0669, -0.3027, 0.0270, -10000000000.0000, -10000000000.0000, 0.7872, 0.2168, 0.3467, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1768, -0.2927, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.8671, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000}
	*lda = 6
	*xx = []float32{0.9965, -10000000000.0000, 0.3272, -10000000000.0000, 0.3571, -10000000000.0000, 0.0000, -10000000000.0000, 0.6469, -10000000000.0000, 0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	_aa := sExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Stbsv(major, uplo, trans, diag, n, k, _aa, lda, xx, incx)
	}
}

func BenchmarkStbsvFortran(b *testing.B) {
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*k = 4
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -10000000000.0000, 0.8172, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 1.0969, 0.4266, 0.4565, 0.1868, -0.2527, -10000000000.0000, 0.5774, 0.1069, 0.3367, 0.2667, 0.2268, -10000000000.0000, 1.2567, -0.0130, 0.4166, -0.4525, -0.0929, -10000000000.0000, 1.1369, 0.0669, -0.3027, 0.0270, -10000000000.0000, -10000000000.0000, 0.7872, 0.2168, 0.3467, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1768, -0.2927, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.8671, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000}
	*lda = 6
	*xx = []float32{0.9965, -10000000000.0000, 0.3272, -10000000000.0000, 0.3571, -10000000000.0000, 0.0000, -10000000000.0000, 0.6469, -10000000000.0000, 0.4770, -10000000000.0000, 0.0075, -10000000000.0000, 0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		stbsvWrapper(uplo, trans, diag, n, k, aa, lda, xx, incx)
	}
}

func TestStpsv(t *testing.T) {
	tname := "Stpsv"
	var i, icd, ict, icu, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float32
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(float32)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]float32 { y := make([]float32, nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xs := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xt := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	z := func() *[]float32 { y := make([]float32, nmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*k = (*n) - 1
		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for icu = 1; icu <= len(ichuL2); icu++ {
			*uplo = ichuL2[icu-1]

			for ict = 1; ict <= len(ichtL2); ict++ {
				*trans = ichtL2[ict-1]

				for icd = 1; icd <= len(ichdL2); icd++ {
					*diag = ichdL2[icd-1]

					*transl = 0.0
					smakeTPL2(uplo, diag, n, n, a, aa, k, k, reset, transl, miSbeg, icSbeg, iSbeg)

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * (*n)

						*transl = 0.5
						*_n = (*n) - 1
						smakeGE2L2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
						if (*n) > 1 {
							(*x)[(*n)/2-1] = 0.0
							(*xx)[1+absint(*incx)*((*n)/2-1)-1] = 0.0
						}

						uplos = *uplo
						transs = *trans
						diags = *diag
						ns = *n
						ldas = *lda
						incxs = *incx
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}

						nc++

						Stpsv(major, uplo, trans, diag, n, aa, xx, incx)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkByte(t, nc, trans, &transs, "trans")
						checkByte(t, nc, diag, &diags, "diag")
						checkInt(t, nc, n, &ns, "n")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkFloat32Array1D(t, nc, &laa, aa, as, "aa")
						if null {
							checkFloat32Array1D(t, nc, &lx, xx, xs, "guardband xx")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = 1; i < absint(*incx); i++ {
									if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
									}
								}
							}
							for i = 1; i <= *n; i++ {
								(*z)[i-1] = (*xx)[(i-1)*absint(*incx)]
								(*xx)[(i-1)*absint(*incx)] = (*xs)[(i-1)*absint(*incx)]
							}
							smvch2Test(trans, n, n, onef32, a, z, incx, zerof32, x, incx, xt, g)
							err = 0
							for i = 1; i <= (*n); i++ {
								erri = absf32((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf32
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf32(err, erri)
								if err*sqrtf32(epsf32) >= 1.0 {
									t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf32(epsf32))
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkStpsv(b *testing.B) {
	n := new(int)
	incx := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, 1.4965, -0.1728, -0.1429, -0.4126, 1.1469, -0.0230, -0.4925, 0.7373, -0.3327, 0.6274}
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		Stpsv(major, uplo, trans, diag, n, aa, xx, incx)
	}
}

func BenchmarkStpsvFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*diag = 'N'
	*n = 9
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, 0.9071, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, 1.4965, -0.1728, -0.1429, -0.4126, 1.1469, -0.0230, -0.4925, 0.7373, -0.3327, 0.6274}
	*xx = []float32{0.1573, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.0000, -10000000000.0000, 0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2

	for i := 0; i < b.N; i++ {
		stpsvWrapper(uplo, trans, diag, n, aa, xx, incx)
	}
}

func TestSger(t *testing.T) {
	tname := "Sger"
	var i, ia, im, in, incxs, incys, ix, iy, j, laa, ldas, lx, ly, ms, ns, nd, nc int
	var als, err, erri float32
	var transs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float32)
	transl := new(float32)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_m := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	at := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	ax := func() *[]float32 { y := make([]float32, nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]float32 { y := make([]float32, nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xs := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	y := func() *[]float32 { y := make([]float32, nmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	ys := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	w := func() *[]float32 { y := make([]float32, 1); return &y }()
	z := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		nd = (*n)/2 + 1

		for im = 1; im <= 2; im++ {
			if im == 1 {
				*m = max((*n)-nd, 0)
			} else if im == 2 {
				*m = min((*n)+nd, nmax)
			}

			*lda = *m
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = (*lda) * (*n)

			null = *n <= 0 || *m <= 0

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*m)

				*transl = 0.5
				*_m = (*m) - 1
				smakeGE2L2(onei, m, x, xx, incx, zeroi, _m, reset, transl, miSbeg, icSbeg, iSbeg)
				if *m > 1 {
					(*x)[(*m)/2-1] = 0.0
					(*xx)[1+absint(*incx)*((*m)/2-1)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					*transl = 0.0
					*_n = (*n) - 1
					smakeGE2L2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
					if *n > 1 {
						(*y)[(*n)/2-1] = 0.0
						(*yy)[1+absint(*incy)*((*n)/2-1)-1] = 0.0
					}

					for ia = 1; ia <= len(alff32L2); ia++ {
						*alpha = alff32L2[ia-1]

						*transl = 0.0
						smakeGEL2(m, n, aa, lda, _m, _n, reset, transl, miSbeg, icSbeg, iSbeg)

						transs = *trans
						ms = *m
						ns = *n
						ldas = *lda
						incxs = *incx
						incys = *incy
						als = *alpha
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}
						for i = 1; i <= ly; i++ {
							(*ys)[i-1] = (*yy)[i-1]
						}

						nc++

						_aa := sExpand(aa, n, lda)
						Sger(major, m, n, alpha, xx, incx, yy, incy, _aa, lda)
						sReturn(_aa, aa)

						checkByte(t, nc, trans, &transs, "trans")
						checkInt(t, nc, m, &ms, "m")
						checkInt(t, nc, n, &ns, "n")
						checkFloat32(t, nc, alpha, &als, "alpha")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkInt(t, nc, incy, &incys, "incy")
						checkFloat32Array1D(t, nc, &lx, xx, xs, "xx")
						checkFloat32Array1D(t, nc, &ly, yy, ys, "yy")
						if null {
							checkFloat32Array1D(t, nc, &laa, aa, as, "guardband aa")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = (*m) + 1; i < *lda; i++ {
									if (*aa)[i+j*(*lda)] != (*as)[i+j*(*lda)] {
										t.Errorf("Test Failed: aa[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*lda), nc, (*aa)[i+j*(*lda)], (*as)[i+j*(*lda)])
									}
								}
							}
							if *incx > 0 {
								for i = 1; i <= *m; i++ {
									(*z)[i-1][0] = (*x)[i-1]
								}
							} else {
								for i = 1; i <= *m; i++ {
									(*z)[i-1][0] = (*x)[(*m)-i]
								}
							}
							for j = 1; j <= *n; j++ {
								if *incy > 0 {
									(*w)[0] = (*y)[j-1]
								} else {
									(*w)[0] = (*y)[(*n)-j]
								}
								for i = 0; i < nmax; i++ {
									(*ax)[i] = (*as)[i+(j-1)*(*lda)]
								}

								smvch2Test(_N, m, onei, alpha, z, w, onei, onef32, ax, onei, at, g)
								for i = 0; i < nmax; i++ {
									(*ax)[i] = (*aa)[i+(j-1)*(*lda)]
								}
								err = 0
								for i = 1; i <= *m; i++ {
									erri = absf32((*at)[i-1]-(*ax)[i-1]) / epsf32
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf32(err, erri)
									if err*sqrtf32(epsf32) >= 1.0 {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.8e} error", i-1, nc, j, (*aa)[i-1], (*at)[i-1], err*sqrtf32(epsf32))
									}
								}
							}
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
		}

	}

	printTestsRun(tname, nc)
}

func BenchmarkSger(b *testing.B) {
	alpha := new(float32)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	major := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*major = 'C'
	*m = 14
	*n = 9
	*alpha = 0.70
	*xx = []float32{0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.6868, -10000000000.0000, 0.0000, -10000000000.0000, 0.2473, -10000000000.0000, 0.0774, -10000000000.0000, 0.6069, -10000000000.0000, 0.7667, -10000000000.0000, 0.3971, -10000000000.0000, 0.7268, -10000000000.0000, 0.7567, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*yy = []float32{-0.0130, -10000000000.0000, -0.4525, -10000000000.0000, 0.3766, -10000000000.0000, 0.0000, -10000000000.0000, 0.1369, -10000000000.0000, 0.0669, -10000000000.0000, 0.0270, -10000000000.0000, 0.0569, -10000000000.0000, -0.2128, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	*aa = []float32{0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -10000000000.0000, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, -10000000000.0000, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -0.0929, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.3467, 0.1768, -0.2927, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -0.3327, 0.2967, -10000000000.0000, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, -10000000000.0000, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, -10000000000.0000, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, -10000000000.0000}
	*lda = 15
	_aa := sExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Sger(major, m, n, alpha, xx, incx, yy, incy, _aa, lda)
	}
}

func BenchmarkSgerFortran(b *testing.B) {
	alpha := new(float32)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*m = 14
	*n = 9
	*alpha = 0.70
	*xx = []float32{0.8067, -10000000000.0000, 0.0375, -10000000000.0000, 0.9665, -10000000000.0000, 0.5969, -10000000000.0000, 0.9266, -10000000000.0000, 0.6868, -10000000000.0000, 0.0000, -10000000000.0000, 0.2473, -10000000000.0000, 0.0774, -10000000000.0000, 0.6069, -10000000000.0000, 0.7667, -10000000000.0000, 0.3971, -10000000000.0000, 0.7268, -10000000000.0000, 0.7567, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*yy = []float32{-0.0130, -10000000000.0000, -0.4525, -10000000000.0000, 0.3766, -10000000000.0000, 0.0000, -10000000000.0000, 0.1369, -10000000000.0000, 0.0669, -10000000000.0000, 0.0270, -10000000000.0000, 0.0569, -10000000000.0000, -0.2128, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	*aa = []float32{0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -10000000000.0000, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, -10000000000.0000, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -0.0929, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.3467, 0.1768, -0.2927, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -0.3327, 0.2967, -10000000000.0000, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, -10000000000.0000, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, -10000000000.0000, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, -10000000000.0000}
	*lda = 15

	for i := 0; i < b.N; i++ {
		sgerWrapper(m, n, alpha, xx, incx, yy, incy, aa, lda)
	}
}

func TestSsyr(t *testing.T) {
	tname := "Ssyr"
	var i, ia, ibeg, ic, iend, in, incxs, ix, j, ja, jj, laa, ldas, lx, ns, nc int
	var als, err, erri float32
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float32)
	transl := new(float32)
	n := new(int)
	incx := new(int)
	lda := new(int)
	lj := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	_a := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	_aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	at := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xs := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	w := func() *[]float32 { y := make([]float32, 1); return &y }()
	z := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, 1)
		}
		return &arr
	}()
	_z := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, 1)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = (*n)
		if *lda < nmax {
			*lda++
		}
		if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				*_n = (*n) - 1
				smakeGEL2(onei, n, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
				if (*n) > 1 {
					(*xx)[1+absint(*incx)*((*n)/2-1)-1] = 0.0
				}

				for ia = 1; ia <= len(alff32L2); ia++ {
					*alpha = alff32L2[ia-1]
					null = *n <= 0 || *alpha == 0.0

					*transl = 0.0
					smakeSYL2(uplo, n, a, aa, lda, _n, _n, reset, transl, miSbeg, icSbeg, iSbeg)

					uplos = *uplo
					ns = *n
					ldas = *lda
					incxs = *incx
					als = *alpha
					for i = 1; i <= laa; i++ {
						(*as)[i-1] = (*aa)[i-1]
					}
					for i = 1; i <= lx; i++ {
						(*xs)[i-1] = (*xx)[i-1]
					}

					nc++

					_aaa := sExpand(aa, n, lda)
					Ssyr(major, uplo, n, alpha, xx, incx, _aaa, lda)
					sReturn(_aaa, aa)

					checkByte(t, nc, uplo, &uplos, "uplo")
					checkInt(t, nc, n, &ns, "n")
					checkFloat32(t, nc, alpha, &als, "alpha")
					checkInt(t, nc, lda, &ldas, "lda")
					checkInt(t, nc, incx, &incxs, "incx")
					checkFloat32Array1D(t, nc, &lx, xx, xs, "xx")
					if null {
						checkFloat32Array1D(t, nc, &laa, aa, as, "guardband aa")
						if *n <= 0 {
							break
						}
					} else {
						for j = 1; j <= *n; j++ {
							if *uplo == 'U' {
								ibeg = 1
								iend = j
							} else {
								ibeg = j
								iend = *n
							}
							for i = 1; i < ibeg; i++ {
								if (*aa)[i+(j-1)*(*lda)-1] != (*as)[i+(j-1)*(*lda)-1] {
									t.Errorf("Test Failed: aa[%d] guardband: iteration %d-%d: {%10.8f} output, {%10.8f} expected", i+(j-1)*(*lda)-1, nc, j, (*as)[i+(j-1)*(*lda)-1], (*aa)[i+(j-1)*(*lda)-1])
								}
							}
							for i = iend + 1; i <= *lda; i++ {
								if (*aa)[i+(j-1)*(*lda)-1] != (*as)[i+(j-1)*(*lda)-1] {
									t.Errorf("Test Failed: aa[%d] guardband: iteration %d-%d: {%10.8f} output, {%10.8f} expected", i+(j-1)*(*lda)-1, nc, j, (*as)[i+(j-1)*(*lda)-1], (*aa)[i+(j-1)*(*lda)-1])
								}
							}
						}

						if *incx > 0 {
							for i = 1; i <= *n; i++ {
								(*z)[i-1][0] = (*xx)[(i-1)*absint(*incx)]
							}
						} else {
							for i = 1; i <= *n; i++ {
								(*z)[i-1][0] = (*xx)[((*n)-i)*absint(*incx)]
							}
						}
						ja = 1
						for j = 1; j <= *n; j++ {
							(*w)[0] = (*z)[j-1][0]
							if *uplo == 'U' {
								jj = 1
								*lj = j
							} else {
								jj = j
								*lj = (*n) - j + 1
							}
							for i = 0; i < (*n); i++ {
								(*_z)[i][0] = (*z)[i+jj-1][0]
							}
							for i = 0; i < *lj; i++ {
								(*_a)[i] = (*a)[jj-1+i][j-1]
							}
							for i = 0; i < len((*aa)[ja-1:]); i++ {
								(*_aa)[i] = (*aa)[i+ja-1]
							}

							// smvch(       trans,      m,      n,      alpha,         a, nmax,          x,     incx,     beta,         y,     incy,   yt,    g, yy, epsf32, err, fatal, nout, true)
							//                  ^       ^       ^         ^            ^                 ^        ^         ^           ^        ^      ^     ^
							//       transpose--^  r/c--^  r/c--^  alpha--^  a[m x n]--^      unchanged--^  incx--^   beta--^  changed--^  incy--^  yt--^  g--^
							//                                                                   vector                         vector
							//																																																	 start
							_N := func() *byte { y := byte('N'); return &y }()
							smvchTest(_N, lj, onei, alpha, _z, w, onei, onef32, _a, onei, at, g)
							err = 0
							for i = 1; i <= *lj; i++ {
								erri = absf32((*at)[i-1]-(*_aa)[i-1]) / epsf32
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf32(err, erri)
								if err*sqrtf32(epsf32) >= 1.0 {
									t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", i-1, nc, j, (*_aa)[i-1], (*at)[i-1], err*sqrtf32(epsf32))
								}
							}
							if *uplo == 'U' {
								ja += *lda
							} else {
								ja += (*lda) + 1
							}
						}
					}

					if *n <= 0 {
						break
					}
				}
				if *n <= 0 {
					break
				}
			}

			if *n <= 0 {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSsyr(b *testing.B) {
	alpha := new(float32)
	n := new(int)
	incx := new(int)
	lda := new(int)
	uplo := new(byte)
	major := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float32{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*aa = []float32{0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.3726, -0.3427, 0.3866, -0.1828, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0529, 0.3067, -0.4625, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4665, 0.0969, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4266, -10000000000.0000}
	*lda = 10
	_aa := sExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Ssyr(major, uplo, n, alpha, xx, incx, _aa, lda)
	}
}

func BenchmarkSsyrFortran(b *testing.B) {
	alpha := new(float32)
	n := new(int)
	incx := new(int)
	lda := new(int)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float32{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*aa = []float32{0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.3726, -0.3427, 0.3866, -0.1828, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0529, 0.3067, -0.4625, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4665, 0.0969, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4266, -10000000000.0000}
	*lda = 10

	for i := 0; i < b.N; i++ {
		ssyrWrapper(uplo, n, alpha, xx, incx, aa, lda)
	}
}

func TestSspr(t *testing.T) {
	tname := "Sspr"
	var i, ia, ic, in, incxs, ix, j, ja, jj, laa, lx, ns, nc int
	var als, err, erri float32
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float32)
	transl := new(float32)
	n := new(int)
	incx := new(int)
	lj := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	_a := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	_aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	at := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xs := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	w := func() *[]float32 { y := make([]float32, 2); return &y }()
	z := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, 1)
		}
		return &arr
	}()
	_z := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, 1)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		laa = ((*n) + ((*n) + 1)) / 2

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				*_n = (*n) - 1
				smakeGEL2(onei, n, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
				if (*n) > 1 {
					(*xx)[1+absint(*incx)*((*n)/2-1)-1] = 0.0
				}

				for ia = 1; ia <= len(alff32L2); ia++ {
					*alpha = alff32L2[ia-1]
					null = *n <= 0 || *alpha == 0.0

					*transl = 0.0
					smakeSPL2(uplo, n, n, a, aa, _n, _n, reset, transl, miSbeg, icSbeg, iSbeg)

					uplos = *uplo
					ns = *n
					incxs = *incx
					als = *alpha
					for i = 1; i <= laa; i++ {
						(*as)[i-1] = (*aa)[i-1]
					}
					for i = 1; i <= lx; i++ {
						(*xs)[i-1] = (*xx)[i-1]
					}

					nc++

					Sspr(major, uplo, n, alpha, xx, incx, aa)

					checkByte(t, nc, uplo, &uplos, "uplo")
					checkInt(t, nc, n, &ns, "n")
					checkFloat32(t, nc, alpha, &als, "alpha")
					checkInt(t, nc, incx, &incxs, "incx")
					checkFloat32Array1D(t, nc, &lx, xx, xs, "xx")
					if null {
						checkFloat32Array1D(t, nc, &laa, aa, as, "guardband aa")
						if *n <= 0 {
							break
						}
					} else {
						if *incx > 0 {
							for i = 1; i <= *n; i++ {
								(*z)[i-1][0] = (*xx)[(i-1)*absint(*incx)]
							}
						} else {
							for i = 1; i <= *n; i++ {
								(*z)[i-1][0] = (*xx)[((*n)-i)*absint(*incx)]
							}
						}
						ja = 1
						for j = 1; j <= *n; j++ {
							(*w)[0] = (*z)[j-1][0]
							if *uplo == 'U' {
								jj = 1
								*lj = j
							} else {
								jj = j
								*lj = (*n) - j + 1
							}
							for i = 0; i < *n; i++ {
								(*_z)[i][0] = (*z)[i+jj-1][0]
							}
							for i = 0; i < *lj; i++ {
								(*_a)[i] = (*a)[jj-1+i][j-1]
							}
							for i = 0; i < len((*aa)[ja-1:]); i++ {
								(*_aa)[i] = (*aa)[i+ja-1]
							}

							smvchTest(_N, lj, onei, alpha, _z, w, onei, onef32, _a, onei, at, g)
							err = 0
							for i = 1; i <= *lj; i++ {
								erri = absf32((*at)[i-1]-(*_aa)[i-1]) / epsf32
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf32(err, erri)
								if err*sqrtf32(epsf32) >= 1.0 {
									t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", i-1, nc, j, (*aa)[i-1], (*at)[i-1], err*sqrtf32(epsf32))
								}
							}
							ja += *lj
						}
					}
				}

				if *n <= 0 {
					break
				}

			}

			if *n <= 0 {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSspr(b *testing.B) {
	alpha := new(float32)
	n := new(int)
	incx := new(int)
	uplo := new(byte)
	major := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float32{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*aa = []float32{0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266}

	for i := 0; i < b.N; i++ {
		Sspr(major, uplo, n, alpha, xx, incx, aa)
	}
}

func BenchmarkSsprFortran(b *testing.B) {
	alpha := new(float32)
	n := new(int)
	incx := new(int)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float32{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*aa = []float32{0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266}

	for i := 0; i < b.N; i++ {
		ssprWrapper(uplo, n, alpha, xx, incx, aa)
	}
}

func TestSsyr2(t *testing.T) {
	tname := "Ssyr2"
	var i, ia, ibeg, ic, iend, in, incxs, incys, ix, iy, j, ja, jj, laa, ldas, lx, ly, ns, nc int
	var als, err, erri float32
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float32)
	transl := new(float32)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	lj := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	_a := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	_aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	at := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xs := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	ys := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	w := func() *[]float32 { y := make([]float32, 2); return &y }()
	z := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, 2)
		}
		return &arr
	}()
	_z := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, 2)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = (*n)
		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				*_n = (*n) - 1
				smakeGEL2(onei, n, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
				if (*n) > 1 {
					(*xx)[1+absint(*incx)*((*n)/2-1)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incx) * (*n)

					*transl = 0.0
					smakeGEL2(onei, n, yy, incy, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
					if (*n) > 1 {
						(*yy)[1+absint(*incy)*((*n)/2-1)-1] = 0.0
					}

					for ia = 1; ia <= len(alff32L2); ia++ {
						*alpha = alff32L2[ia-1]
						null = *n <= 0 || *alpha == 0.0

						*transl = 0.0
						smakeSYL2(uplo, n, a, aa, lda, _n, _n, reset, transl, miSbeg, icSbeg, iSbeg)

						uplos = *uplo
						ns = *n
						ldas = *lda
						incxs = *incx
						incys = *incy
						als = *alpha
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}
						for i = 1; i <= ly; i++ {
							(*ys)[i-1] = (*yy)[i-1]
						}

						nc++

						_aaa := func() *[][]float32 {
							arr := make([][]float32, *lda)
							for y := 0; y < *lda; y++ {
								arr[y] = make([]float32, *n)
								for x := 0; x < *n; x++ {
									arr[y][x] = (*aa)[y+x*(*lda)]
								}
							}
							return &arr
						}()
						Ssyr2(major, uplo, n, alpha, xx, incx, yy, incy, _aaa, lda)
						for y := range *_aaa {
							for x := range (*_aaa)[0] {
								(*aa)[y+x*(*lda)] = (*_aaa)[y][x]
							}
						}

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkInt(t, nc, n, &ns, "n")
						checkFloat32(t, nc, alpha, &als, "alpha")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkInt(t, nc, incy, &incys, "incy")
						checkFloat32Array1D(t, nc, &lx, xx, xs, "xx")
						checkFloat32Array1D(t, nc, &ly, yy, ys, "yy")
						if null {
							checkFloat32Array1D(t, nc, &laa, aa, as, "guardband aa")
							if *n <= 0 {
								break
							}
						} else {
							for j = 1; j <= *n; j++ {
								if *uplo == 'U' {
									ibeg = 1
									iend = j
								} else {
									ibeg = j
									iend = *n
								}
								for i = 1; i < ibeg; i++ {
									if (*aa)[i+(j-1)*(*lda)-1] != (*as)[i+(j-1)*(*lda)-1] {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected", i+(j-1)*(*lda)-1, nc, j, (*as)[i+(j-1)*(*lda)-1], (*aa)[i+(j-1)*(*lda)-1])
									}
								}
								for i = iend + 1; i <= *lda; i++ {
									if (*aa)[i+(j-1)*(*lda)-1] != (*as)[i+(j-1)*(*lda)-1] {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected", i+(j-1)*(*lda)-1, nc, j, (*as)[i+(j-1)*(*lda)-1], (*aa)[i+(j-1)*(*lda)-1])
									}
								}
							}

							if *incx > 0 {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][0] = (*xx)[(i-1)*absint(*incx)]
								}
							} else {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][0] = (*xx)[((*n)-i)*absint(*incx)]
								}
							}
							if *incy > 0 {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][1] = (*yy)[(i-1)*absint(*incy)]
								}
							} else {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][1] = (*yy)[((*n)-i)*absint(*incy)]
								}
							}
							ja = 1
							for j = 1; j <= *n; j++ {
								(*w)[0] = (*z)[j-1][1]
								(*w)[1] = (*z)[j-1][0]
								if *uplo == 'U' {
									jj = 1
									*lj = j
								} else {
									jj = j
									*lj = (*n) - j + 1
								}
								for i = 0; i < len((*z)[jj-1:]); i++ {
									(*_z)[i][0] = (*z)[i+jj-1][0]
									(*_z)[i][1] = (*z)[i+jj-1][1]
								}
								for i = 0; i < *lj; i++ {
									(*_a)[i] = (*a)[jj-1+i][j-1]
								}
								for i = 0; i < len((*aa)[ja-1:]); i++ {
									(*_aa)[i] = (*aa)[i+ja-1]
								}

								// smvch(       trans,      m,      n,      alpha,         a, nmax,          x,     incx,     beta,         y,     incy,   yt,    g, yy, epsf32, err, fatal, nout, true)
								//                  ^       ^       ^         ^            ^                 ^        ^         ^           ^        ^      ^     ^
								//       transpose--^  r/c--^  r/c--^  alpha--^  a[m x n]--^      unchanged--^  incx--^   beta--^  changed--^  incy--^  yt--^  g--^
								//                                                                   vector                         vector
								//																																																	 start
								_N := func() *byte { y := byte('N'); return &y }()
								smvchTest(_N, lj, twoi, alpha, _z, w, onei, onef32, _a, onei, at, g)
								err = 0
								for i = 1; i <= *lj; i++ {
									erri = absf32((*at)[i-1]-(*_aa)[i-1]) / epsf32
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf32(err, erri)
									if err*sqrtf32(epsf32) >= 1.0 {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", i-1, nc, j, (*_aa)[i-1], (*at)[i-1], err*sqrtf32(epsf32))
									}
								}
								if *uplo == 'U' {
									ja += *lda
								} else {
									ja += (*lda) + 1
								}
							}
						}

						if *n <= 0 {
							break
						}
					}

					if *n <= 0 {
						break
					}
				}

				if *n <= 0 {
					break
				}
			}

			if *n <= 0 {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSsyr2(b *testing.B) {
	alpha := new(float32)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)
	major := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float32{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*yy = []float32{0.4665, -10000000000.0000, 0.0969, -10000000000.0000, 0.4266, -10000000000.0000, 0.0000, -10000000000.0000, 0.1868, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.3367, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	*aa = []float32{0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, -10000000000.0000, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4266, 0.1868, -0.3826, -0.2527, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.4226, 0.1069, 0.2667, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1029, 0.2268, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2567, -10000000000.0000}
	*lda = 10
	_aa := func() *[][]float32 {
		arr := make([][]float32, *lda)
		for y := 0; y < *lda; y++ {
			arr[y] = make([]float32, *n)
			for x := 0; x < *n; x++ {
				arr[y][x] = (*aa)[y+x*(*lda)]
			}
		}
		return &arr
	}()

	for i := 0; i < b.N; i++ {
		Ssyr2(major, uplo, n, alpha, xx, incx, yy, incy, _aa, lda)
	}
}

func BenchmarkSsyr2Fortran(b *testing.B) {
	alpha := new(float32)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float32{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*yy = []float32{0.4665, -10000000000.0000, 0.0969, -10000000000.0000, 0.4266, -10000000000.0000, 0.0000, -10000000000.0000, 0.1868, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.3367, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	*aa = []float32{0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, -10000000000.0000, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4266, 0.1868, -0.3826, -0.2527, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.4226, 0.1069, 0.2667, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1029, 0.2268, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2567, -10000000000.0000}
	*lda = 10

	for i := 0; i < b.N; i++ {
		ssyr2Wrapper(uplo, n, alpha, xx, incx, yy, incy, aa, lda)
	}
}

func TestSspr2(t *testing.T) {
	tname := "Sspr2"
	var i, ia, ic, in, incxs, incys, ix, iy, j, ja, jj, laa, lx, ly, ns, nc int
	var als, err, erri float32
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float32)
	transl := new(float32)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lj := new(int)
	_n := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	_a := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	_aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	at := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	xs := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	ys := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	w := func() *[]float32 { y := make([]float32, 2); return &y }()
	z := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, 2)
		}
		return &arr
	}()
	_z := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, 2)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		laa = ((*n) + ((*n) + 1)) / 2

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				*_n = (*n) - 1
				smakeGEL2(onei, n, xx, incx, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
				if (*n) > 1 {
					(*xx)[1+absint(*incx)*((*n)/2-1)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					*transl = 0.0
					smakeGEL2(onei, n, yy, incy, zeroi, _n, reset, transl, miSbeg, icSbeg, iSbeg)
					if (*n) > 1 {
						(*yy)[1+absint(*incy)*((*n)/2-1)-1] = 0.0
					}

					for ia = 1; ia <= len(alff32L2); ia++ {
						*alpha = alff32L2[ia-1]
						null = *n <= 0 || *alpha == 0.0

						*transl = 0.0
						smakeSPL2(uplo, n, n, a, aa, _n, _n, reset, transl, miSbeg, icSbeg, iSbeg)

						uplos = *uplo
						ns = *n
						incxs = *incx
						incys = *incy
						als = *alpha
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}
						for i = 1; i <= ly; i++ {
							(*ys)[i-1] = (*yy)[i-1]
						}

						nc++

						Sspr2(major, uplo, n, alpha, xx, incx, yy, incy, aa)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkInt(t, nc, n, &ns, "n")
						checkFloat32(t, nc, alpha, &als, "alpha")
						checkInt(t, nc, incx, &incxs, "incx")
						checkInt(t, nc, incy, &incys, "incy")
						checkFloat32Array1D(t, nc, &lx, xx, xs, "xx")
						checkFloat32Array1D(t, nc, &ly, yy, ys, "yy")
						if null {
							checkFloat32Array1D(t, nc, &laa, aa, as, "guardband aa")
							if *n <= 0 {
								break
							}
						} else {
							if *incx > 0 {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][0] = (*xx)[(i-1)*absint(*incx)]
								}
							} else {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][0] = (*xx)[((*n)-i)*absint(*incx)]
								}
							}
							if *incy > 0 {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][1] = (*yy)[(i-1)*absint(*incy)]
								}
							} else {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][1] = (*yy)[((*n)-i)*absint(*incy)]
								}
							}
							ja = 1
							for j = 1; j <= *n; j++ {
								(*w)[0] = (*z)[j-1][1]
								(*w)[1] = (*z)[j-1][0]
								if *uplo == 'U' {
									jj = 1
									*lj = j
								} else {
									jj = j
									*lj = (*n) - j + 1
								}
								for i = 0; i < *n; i++ {
									(*_z)[i][0] = (*z)[i+jj-1][0]
									(*_z)[i][1] = (*z)[i+jj-1][1]
								}
								for i = 0; i < *lj; i++ {
									(*_a)[i] = (*a)[jj-1+i][j-1]
								}
								for i = 0; i < len((*aa)[ja-1:]); i++ {
									(*_aa)[i] = (*aa)[i+ja-1]
								}

								// smvch(       trans,      m,      n,      alpha,         a, nmax,          x,     incx,     beta,         y,     incy,   yt,    g, yy, epsf32, err, fatal, nout, true)
								//                  ^       ^       ^         ^            ^                 ^        ^         ^           ^        ^      ^     ^
								//       transpose--^  r/c--^  r/c--^  alpha--^  a[m x n]--^      unchanged--^  incx--^   beta--^  changed--^  incy--^  yt--^  g--^
								//                                                                   vector                         vector
								//																																																	 start
								_N := func() *byte { y := byte('N'); return &y }()
								smvchTest(_N, lj, twoi, alpha, _z, w, onei, onef32, _a, onei, at, g)
								err = 0
								for i = 1; i <= *lj; i++ {
									erri = absf32((*at)[i-1]-(*_aa)[i-1]) / epsf32
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf32(err, erri)
									if err*sqrtf32(epsf32) >= 1.0 {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", i-1, nc, j, (*_aa)[i-1], (*at)[i-1], err*sqrtf32(epsf32))
									}
								}
								ja += *lj
							}
						}
					}

					if *n <= 0 {
						break
					}
				}

				if *n <= 0 {
					break
				}
			}

			if *n <= 0 {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSspr2(b *testing.B) {
	alpha := new(float32)
	n := new(int)
	incx := new(int)
	incy := new(int)
	uplo := new(byte)
	major := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float32{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*yy = []float32{0.4665, -10000000000.0000, 0.0969, -10000000000.0000, 0.4266, -10000000000.0000, 0.0000, -10000000000.0000, 0.1868, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.3367, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	*aa = []float32{0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266}

	for i := 0; i < b.N; i++ {
		Sspr2(major, uplo, n, alpha, xx, incx, yy, incy, aa)
	}
}

func BenchmarkSspr2Fortran(b *testing.B) {
	alpha := new(float32)
	n := new(int)
	incx := new(int)
	incy := new(int)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()

	*uplo = 'L'
	*n = 9
	*alpha = 0.70
	*xx = []float32{0.2373, -10000000000.0000, 0.1673, -10000000000.0000, 0.7967, -10000000000.0000, 0.0000, -10000000000.0000, 0.8866, -10000000000.0000, 0.3172, -10000000000.0000, 0.4471, -10000000000.0000, 0.2772, -10000000000.0000, 0.8067, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incx = -2
	*yy = []float32{0.4665, -10000000000.0000, 0.0969, -10000000000.0000, 0.4266, -10000000000.0000, 0.0000, -10000000000.0000, 0.1868, -10000000000.0000, -0.2527, -10000000000.0000, -0.4226, -10000000000.0000, 0.1069, -10000000000.0000, 0.3367, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000}
	*incy = -2
	*aa = []float32{0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266}

	for i := 0; i < b.N; i++ {
		sspr2Wrapper(uplo, n, alpha, xx, incx, yy, incy, aa)
	}
}

// BLAS Level 3
func TestSgemm(t *testing.T) {
	tname := "Sgemm"
	var i, ia, ib, ica, icb, ik, im, in, j, ks, laa, lbb, lcc, ldas, ldbs, ldcs, ms, nc, ns int
	var als, bls float32
	var tranas, tranbs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float32)
	beta := new(float32)
	transl := new(float32)
	k := new(int)
	m := new(int)
	ma := new(int)
	mb := new(int)
	n := new(int)
	na := new(int)
	nb := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	transa := new(byte)
	transb := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	b := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bs := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	c := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	cc := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	cs := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	ct := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldc = *m
			if *ldc < nmax {
				*ldc++
			}
			if *ldc > nmax {
				continue
			}
			lcc = (*ldc) * (*n)

			null = *n <= 0 || *m <= 0

			for ik = 1; ik <= len(idimL3); ik++ {
				*k = idimL3[ik-1]

				for ica = 1; ica <= len(ichtL3); ica++ {
					*transa = ichtL3[ica-1]

					if *transa == 'T' || *transa == 'C' {
						*ma = *k
						*na = *m
					} else {
						*ma = *m
						*na = *k
					}

					*lda = *ma
					if *lda < nmax {
						*lda++
					}
					if *lda > nmax {
						continue
					}
					laa = (*lda) * (*na)

					smakeGEL3(ma, na, a, aa, lda, reset, zerof32, miSbeg, icSbeg, iSbeg)

					for icb = 1; icb <= len(ichtL3); icb++ {
						*transb = ichtL3[icb-1]

						if *transb == 'T' || *transb == 'C' {
							*mb = *n
							*nb = *k
						} else {
							*mb = *k
							*nb = *n
						}

						*ldb = *mb
						if *ldb < nmax {
							*ldb++
						}
						if *ldb > nmax {
							continue
						}
						lbb = (*ldb) * (*nb)

						smakeGEL3(mb, nb, b, bb, ldb, reset, zerof32, miSbeg, icSbeg, iSbeg)

						for ia = 1; ia <= len(alff32L3); ia++ {
							*alpha = alff32L3[ia-1]

							for ib = 1; ib <= len(betf32L3); ib++ {
								*beta = betf32L3[ib-1]

								smakeGEL3(m, n, c, cc, ldc, reset, transl, miSbeg, icSbeg, iSbeg)

								tranas = *transa
								tranbs = *transb
								ms = *m
								ns = *n
								ks = *k
								als = *alpha
								bls = *beta
								ldas = *lda
								ldbs = *ldb
								ldcs = *ldc
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lbb; i++ {
									(*bs)[i-1] = (*bb)[i-1]
								}
								for i = 1; i <= lcc; i++ {
									(*cs)[i-1] = (*cc)[i-1]
								}

								nc++

								_aa := sExpand(aa, na, lda)
								_bb := sExpand(bb, nb, ldb)
								_cc := sExpand(cc, n, ldc)
								Sgemm(major, transa, transb, m, n, k, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
								sReturn(_aa, aa)
								sReturn(_bb, bb)
								sReturn(_cc, cc)

								checkByte(t, nc, transa, &tranas, "transa")
								checkByte(t, nc, transb, &tranbs, "transb")
								checkInt(t, nc, m, &ms, "m")
								checkInt(t, nc, n, &ns, "n")
								checkInt(t, nc, k, &ks, "k")
								checkFloat32(t, nc, alpha, &als, "alpha")
								checkFloat32(t, nc, beta, &bls, "beta")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, ldb, &ldbs, "ldb")
								checkInt(t, nc, ldc, &ldcs, "ldc")
								checkFloat32Array1D(t, nc, &laa, aa, as, "aa")
								checkFloat32Array1D(t, nc, &lbb, bb, bs, "bb")
								if null {
									checkFloat32Array1D(t, nc, &lcc, cc, cs, "guardband cc")
								} else {
									for j = 0; j < *n; j++ {
										for i = (*m) + 1; i <= *ldc; i++ {
											if (*cc)[i+j*(*ldc)-1] != (*cs)[i+j*(*ldc)-1] {
												t.Errorf("Test Failed: cc[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldc), nc, (*cc)[i+j*(*ldc)], (*cs)[i+j*(*ldc)])
											}
										}
									}
									smmchTest(transa, transb, m, n, k, alpha, a, b, beta, c, ct, g, cc, ldc, nc, "cc", t)
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSgemm(b *testing.B) {
	alpha := new(float32)
	beta := new(float32)
	k := new(int)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	transa := new(byte)
	transb := new(byte)
	major := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	cc := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*major = 'C'
	*transa = 'C'
	*transb = 'C'
	*m = 9
	*n = 9
	*k = 9
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*lda = 10
	*bb = []float32{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, -10000000000.0000, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0270, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -10000000000.0000, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -10000000000.0000}
	*ldb = 10
	*beta = 1.30
	*cc = []float32{-0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -10000000000.0000, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.1369, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -10000000000.0000, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, -10000000000.0000, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, -10000000000.0000, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -0.0929, -10000000000.0000, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -0.2927, -0.0629, -10000000000.0000}
	*ldc = 10
	_aa := func() *[][]float32 {
		arr := make([][]float32, *lda)
		for y := 0; y < *lda; y++ {
			arr[y] = make([]float32, *m)
			for x := 0; x < *m; x++ {
				arr[y][x] = (*aa)[y+x*(*lda)]
			}
		}
		return &arr
	}()
	_bb := func() *[][]float32 {
		arr := make([][]float32, *ldb)
		for y := 0; y < *ldb; y++ {
			arr[y] = make([]float32, *k)
			for x := 0; x < *k; x++ {
				arr[y][x] = (*bb)[y+x*(*ldb)]
			}
		}
		return &arr
	}()
	_cc := func() *[][]float32 {
		arr := make([][]float32, *ldc)
		for y := 0; y < *ldc; y++ {
			arr[y] = make([]float32, *n)
			for x := 0; x < *n; x++ {
				arr[y][x] = (*cc)[y+x*(*ldc)]
			}
		}
		return &arr
	}()

	for i := 0; i < b.N; i++ {
		Sgemm(major, transa, transb, m, n, k, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
	}
}

func BenchmarkSgemmFortran(b *testing.B) {
	alpha := new(float32)
	beta := new(float32)
	k := new(int)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	transa := new(byte)
	transb := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	cc := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*transa = 'C'
	*transb = 'C'
	*m = 9
	*n = 9
	*k = 9
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*lda = 10
	*bb = []float32{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, -10000000000.0000, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0270, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -10000000000.0000, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -10000000000.0000}
	*ldb = 10
	*beta = 1.30
	*cc = []float32{-0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -10000000000.0000, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.1369, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -10000000000.0000, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -0.2228, -10000000000.0000, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, 0.1069, -10000000000.0000, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -0.0929, -10000000000.0000, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -0.2927, -0.0629, -10000000000.0000}
	*ldc = 10

	for i := 0; i < b.N; i++ {
		sgemmWrapper(transa, transb, m, n, k, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func TestSsymm(t *testing.T) {
	tname := "Ssymm"
	var i, ia, ib, ics, icu, im, in, j, laa, lbb, lcc, ldas, ldbs, ldcs, ms, nc, ns int
	var als, bls float32
	var sides, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float32)
	beta := new(float32)
	transl := new(float32)
	m := new(int)
	n := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	side := new(byte)
	uplo := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	b := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bs := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	c := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	cc := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	cs := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	ct := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldc = *m
			if *ldc < nmax {
				*ldc++
			}
			if *ldc > nmax {
				continue
			}
			lcc = (*ldc) * (*n)

			null = *n <= 0 || *m <= 0

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			smakeGEL3(m, n, b, bb, ldb, reset, zerof32, miSbeg, icSbeg, iSbeg)

			for ics = 1; ics <= len(ichsL3); ics++ {
				*side = ichsL3[ics-1]

				if *side == 'L' {
					*na = *m
				} else {
					*na = *n
				}

				*lda = *na
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					smakeSYL3(uplo, na, na, a, aa, lda, reset, zerof32, miSbeg, icSbeg, iSbeg)

					for ia = 1; ia <= len(alff32L3); ia++ {
						*alpha = alff32L3[ia-1]

						for ib = 1; ib <= len(betf32L3); ib++ {
							*beta = betf32L3[ib-1]

							smakeGEL3(m, n, c, cc, ldc, reset, transl, miSbeg, icSbeg, iSbeg)

							sides = *side
							uplos = *uplo
							ms = *m
							ns = *n
							als = *alpha
							bls = *beta
							ldas = *lda
							ldbs = *ldb
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lbb; i++ {
								(*bs)[i-1] = (*bb)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := func() *[][]float32 {
								arr := make([][]float32, *lda)
								for y := 0; y < *lda; y++ {
									arr[y] = make([]float32, *na)
									for x := 0; x < *na; x++ {
										arr[y][x] = (*aa)[y+x*(*lda)]
									}
								}
								return &arr
							}()
							_bb := func() *[][]float32 {
								arr := make([][]float32, *ldb)
								for y := 0; y < *ldb; y++ {
									arr[y] = make([]float32, *n)
									for x := 0; x < *n; x++ {
										arr[y][x] = (*bb)[y+x*(*ldb)]
									}
								}
								return &arr
							}()
							_cc := func() *[][]float32 {
								arr := make([][]float32, *ldc)
								for y := 0; y < *ldc; y++ {
									arr[y] = make([]float32, *n)
									for x := 0; x < *n; x++ {
										arr[y][x] = (*cc)[y+x*(*ldc)]
									}
								}
								return &arr
							}()
							Ssymm(major, side, uplo, m, n, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
							for y := range *_aa {
								for x := range (*_aa)[0] {
									(*aa)[y+x*(*lda)] = (*_aa)[y][x]
								}
							}
							for y := range *_bb {
								for x := range (*_bb)[0] {
									(*bb)[y+x*(*ldb)] = (*_bb)[y][x]
								}
							}
							for y := range *_cc {
								for x := range (*_cc)[0] {
									(*cc)[y+x*(*ldc)] = (*_cc)[y][x]
								}
							}

							checkByte(t, nc, side, &sides, "side")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, m, &ms, "m")
							checkInt(t, nc, n, &ns, "n")
							checkFloat32(t, nc, alpha, &als, "alpha")
							checkFloat32(t, nc, beta, &bls, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldb, &ldbs, "ldb")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkFloat32Array1D(t, nc, &laa, aa, as, "aa")
							checkFloat32Array1D(t, nc, &lbb, bb, bs, "bb")
							if null {
								checkFloat32Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 0; j < *n; j++ {
									for i = (*m) + 1; i <= *ldc; i++ {
										if (*cc)[i+j*(*ldc)-1] != (*cs)[i+j*(*ldc)-1] {
											t.Errorf("Test Failed: guardband cc[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldc), nc, (*cc)[i+j*(*ldc)], (*cs)[i+j*(*ldc)])
										}
									}
								}
								_N := func() *byte { y := byte('N'); return &y }()
								if *side == 'L' {
									smmchTest(_N, _N, m, n, m, alpha, a, b, beta, c, ct, g, cc, ldc, nc, "cc", t)
								} else {
									smmchTest(_N, _N, m, n, n, alpha, b, a, beta, c, ct, g, cc, ldc, nc, "cc", t)
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSsymm(b *testing.B) {
	alpha := new(float32)
	beta := new(float32)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	side := new(byte)
	uplo := new(byte)
	major := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	cc := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*major = 'C'
	*side = 'R'
	*uplo = 'L'
	*m = 9
	*n = 9
	*alpha = 0.70
	*aa = []float32{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2527, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4166, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2927, -0.0629, -0.1329, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1429, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -10000000000.0000}
	*lda = 10
	*bb = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*ldb = 10
	*beta = 1.30
	*cc = []float32{-0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.3467, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -10000000000.0000, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -10000000000.0000, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, -10000000000.0000, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -10000000000.0000}
	*ldc = 10

	_aa := func() *[][]float32 {
		arr := make([][]float32, *lda)
		for y := 0; y < *lda; y++ {
			arr[y] = make([]float32, *n)
			for x := 0; x < *n; x++ {
				arr[y][x] = (*aa)[y+x*(*lda)]
			}
		}
		return &arr
	}()
	_bb := func() *[][]float32 {
		arr := make([][]float32, *ldb)
		for y := 0; y < *ldb; y++ {
			arr[y] = make([]float32, *n)
			for x := 0; x < *n; x++ {
				arr[y][x] = (*bb)[y+x*(*ldb)]
			}
		}
		return &arr
	}()
	_cc := func() *[][]float32 {
		arr := make([][]float32, *ldc)
		for y := 0; y < *ldc; y++ {
			arr[y] = make([]float32, *n)
			for x := 0; x < *n; x++ {
				arr[y][x] = (*cc)[y+x*(*ldc)]
			}
		}
		return &arr
	}()
	for i := 0; i < b.N; i++ {
		Ssymm(major, side, uplo, m, n, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
	}
}

func BenchmarkSsymmFortran(b *testing.B) {
	alpha := new(float32)
	beta := new(float32)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	side := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	cc := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*side = 'R'
	*uplo = 'L'
	*m = 9
	*n = 9
	*alpha = 0.70
	*aa = []float32{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2527, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4166, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2927, -0.0629, -0.1329, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1429, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -10000000000.0000}
	*lda = 10
	*bb = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*ldb = 10
	*beta = 1.30
	*cc = []float32{-0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.3467, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -10000000000.0000, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -10000000000.0000, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, -10000000000.0000, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -10000000000.0000}
	*ldc = 10

	for i := 0; i < b.N; i++ {
		ssymmWrapper(side, uplo, m, n, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func TestStrmm(t *testing.T) {
	tname := "Strmm"
	var i, ia, icd, ics, ict, icu, im, in, j, laa, lbb, ldas, ldbs, ms, nc, ns int
	var als float32
	var diags, sides, tranas, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float32)
	beta := new(float32)
	m := new(int)
	n := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	b := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bs := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	c := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	ct := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			null = *n <= 0 || *m <= 0

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			smakeGEL3(m, n, b, bb, ldb, reset, zerof32, miSbeg, icSbeg, iSbeg)

			for ics = 1; ics <= len(ichsL3); ics++ {
				*side = ichsL3[ics-1]

				if *side == 'L' {
					*na = *m
				} else {
					*na = *n
				}

				*lda = *na
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ict = 1; ict <= len(ichtL3); ict++ {
						*transa = ichtL3[ict-1]

						for icd = 1; icd <= len(ichdL3); icd++ {
							*diag = ichdL3[icd-1]

							for ia = 1; ia <= len(alff32L3); ia++ {
								*alpha = alff32L3[ia-1]

								smakeTRL3(uplo, diag, na, na, a, aa, lda, reset, zerof32, miSbeg, icSbeg, iSbeg)

								smakeGEL3(m, n, b, bb, ldb, reset, zerof32, miSbeg, icSbeg, iSbeg)

								diags = *diag
								sides = *side
								tranas = *transa
								uplos = *uplo
								ms = *m
								ns = *n
								als = *alpha
								ldas = *lda
								ldbs = *ldb
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lbb; i++ {
									(*bs)[i-1] = (*bb)[i-1]
								}

								nc++

								_aa := func() *[][]float32 {
									arr := make([][]float32, *lda)
									for y := 0; y < *lda; y++ {
										arr[y] = make([]float32, *na)
										for x := 0; x < *na; x++ {
											arr[y][x] = (*aa)[y+x*(*lda)]
										}
									}
									return &arr
								}()
								_bb := func() *[][]float32 {
									arr := make([][]float32, *ldb)
									for y := 0; y < *ldb; y++ {
										arr[y] = make([]float32, *n)
										for x := 0; x < *n; x++ {
											arr[y][x] = (*bb)[y+x*(*ldb)]
										}
									}
									return &arr
								}()
								Strmm(major, side, uplo, transa, diag, m, n, alpha, _aa, lda, _bb, ldb)
								for y := range *_aa {
									for x := range (*_aa)[0] {
										(*aa)[y+x*(*lda)] = (*_aa)[y][x]
									}
								}
								for y := range *_bb {
									for x := range (*_bb)[0] {
										(*bb)[y+x*(*ldb)] = (*_bb)[y][x]
									}
								}

								checkByte(t, nc, diag, &diags, "diag")
								checkByte(t, nc, side, &sides, "side")
								checkByte(t, nc, transa, &tranas, "transa")
								checkByte(t, nc, uplo, &uplos, "uplo")
								checkInt(t, nc, m, &ms, "m")
								checkInt(t, nc, n, &ns, "n")
								checkFloat32(t, nc, alpha, &als, "alpha")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, ldb, &ldbs, "ldb")
								checkFloat32Array1D(t, nc, &laa, aa, as, "aa")
								if null {
									checkFloat32Array1D(t, nc, &lbb, bb, bs, "guardband bb")
								} else {
									for j = 0; j < *n; j++ {
										for i = (*m) + 1; i <= *ldb; i++ {
											if (*bb)[i+j*(*ldb)-1] != (*bs)[i+j*(*ldb)-1] {
												t.Errorf("Test Failed: guardband bb[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldb), nc, (*bb)[i+j*(*ldb)], (*bs)[i+j*(*ldb)])
											}
										}
									}
									_N := func() *byte { y := byte('N'); return &y }()
									if *side == 'L' {
										smmchTest(transa, _N, m, n, m, alpha, a, b, beta, c, ct, g, bb, ldb, nc, "bb", t)
									} else {
										smmchTest(_N, transa, m, n, n, alpha, b, a, beta, c, ct, g, bb, ldb, nc, "bb", t)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkStrmm(b *testing.B) {
	alpha := new(float32)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	major := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*major = 'C'
	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'N'
	*m = 9
	*n = 9
	*alpha = 0.70
	*aa = []float32{1.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -10000000000.0000, 0.7772, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7473, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4166, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.0270, 0.0569, -0.2128, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7073, -0.0629, -0.1329, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.8571, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -10000000000.0000}
	*lda = 10
	*bb = []float32{-0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.3467, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -10000000000.0000, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -10000000000.0000, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, -10000000000.0000, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -10000000000.0000}
	*ldb = 10
	_aa := func() *[][]float32 {
		arr := make([][]float32, *lda)
		for y := 0; y < *lda; y++ {
			arr[y] = make([]float32, *n)
			for x := 0; x < *n; x++ {
				arr[y][x] = (*aa)[y+x*(*lda)]
			}
		}
		return &arr
	}()
	_bb := func() *[][]float32 {
		arr := make([][]float32, *ldb)
		for y := 0; y < *ldb; y++ {
			arr[y] = make([]float32, *n)
			for x := 0; x < *n; x++ {
				arr[y][x] = (*bb)[y+x*(*ldb)]
			}
		}
		return &arr
	}()

	for i := 0; i < b.N; i++ {
		Strmm(major, side, uplo, transa, diag, m, n, alpha, _aa, lda, _bb, ldb)
	}
}

func BenchmarkStrmmFortran(b *testing.B) {
	alpha := new(float32)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'N'
	*m = 9
	*n = 9
	*alpha = 0.70
	*aa = []float32{1.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -10000000000.0000, 0.7772, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7473, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4166, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.0270, 0.0569, -0.2128, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7073, -0.0629, -0.1329, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.8571, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -10000000000.0000}
	*lda = 10
	*bb = []float32{-0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.3467, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, 0.1868, -10000000000.0000, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -0.0130, -10000000000.0000, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, 0.2168, -10000000000.0000, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, 0.1469, -10000000000.0000}
	*ldb = 10

	for i := 0; i < b.N; i++ {
		strmmWrapper(side, uplo, transa, diag, m, n, alpha, aa, lda, bb, ldb)
	}
}

func TestStrsm(t *testing.T) {
	tname := "Strsm"
	var i, ia, icd, ics, ict, icu, im, in, j, laa, lbb, ldas, ldbs, ms, nc, ns int
	var als float32
	var diags, sides, tranas, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float32)
	m := new(int)
	n := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	b := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bs := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	c := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	ct := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			null = *n <= 0 || *m <= 0

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			for ics = 1; ics <= len(ichsL3); ics++ {
				*side = ichsL3[ics-1]

				if *side == 'L' {
					*na = *m
				} else {
					*na = *n
				}

				*lda = *na
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ict = 1; ict <= len(ichtL3); ict++ {
						*transa = ichtL3[ict-1]

						for icd = 1; icd <= len(ichdL3); icd++ {
							*diag = ichdL3[icd-1]

							for ia = 1; ia <= len(alff32L3); ia++ {
								*alpha = alff32L3[ia-1]

								smakeTRL3(uplo, diag, na, na, a, aa, lda, reset, zerof32, miSbeg, icSbeg, iSbeg)

								smakeGEL3(m, n, b, bb, ldb, reset, zerof32, miSbeg, icSbeg, iSbeg)

								diags = *diag
								sides = *side
								tranas = *transa
								uplos = *uplo
								ms = *m
								ns = *n
								als = *alpha
								ldas = *lda
								ldbs = *ldb
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lbb; i++ {
									(*bs)[i-1] = (*bb)[i-1]
								}

								nc++

								_aa := func() *[][]float32 {
									arr := make([][]float32, *lda)
									for y := 0; y < *lda; y++ {
										arr[y] = make([]float32, *na)
										for x := 0; x < *na; x++ {
											arr[y][x] = (*aa)[y+x*(*lda)]
										}
									}
									return &arr
								}()
								_bb := func() *[][]float32 {
									arr := make([][]float32, *ldb)
									for y := 0; y < *ldb; y++ {
										arr[y] = make([]float32, *n)
										for x := 0; x < *n; x++ {
											arr[y][x] = (*bb)[y+x*(*ldb)]
										}
									}
									return &arr
								}()
								Strsm(major, side, uplo, transa, diag, m, n, alpha, _aa, lda, _bb, ldb)
								for y := range *_aa {
									for x := range (*_aa)[0] {
										(*aa)[y+x*(*lda)] = (*_aa)[y][x]
									}
								}
								for y := range *_bb {
									for x := range (*_bb)[0] {
										(*bb)[y+x*(*ldb)] = (*_bb)[y][x]
									}
								}

								checkByte(t, nc, diag, &diags, "diag")
								checkByte(t, nc, side, &sides, "side")
								checkByte(t, nc, transa, &tranas, "transa")
								checkByte(t, nc, uplo, &uplos, "uplo")
								checkInt(t, nc, m, &ms, "m")
								checkInt(t, nc, n, &ns, "n")
								checkFloat32(t, nc, alpha, &als, "alpha")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, ldb, &ldbs, "ldb")
								checkFloat32Array1D(t, nc, &laa, aa, as, "aa")
								if null {
									checkFloat32Array1D(t, nc, &lbb, bb, bs, "guardband bb")
								} else {
									for j = 0; j < *n; j++ {
										for i = (*m) + 1; i <= *ldb; i++ {
											if (*bb)[i+j*(*ldb)-1] != (*bs)[i+j*(*ldb)-1] {
												t.Errorf("Test Failed: guardband bb[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldb), nc, (*bb)[i+j*(*ldb)], (*bs)[i+j*(*ldb)])
											}
										}
									}
									for j = 1; j <= *n; j++ {
										for i = 1; i <= *m; i++ {
											(*c)[i-1][j-1] = (*bb)[i+(j-1)*(*ldb)-1]
											(*bb)[i+(j-1)*(*ldb)-1] = (*alpha) * (*b)[i-1][j-1]
										}
									}
									_N := func() *byte { y := byte('N'); return &y }()
									if *side == 'L' {
										smmchTest(transa, _N, m, n, m, onef32, a, c, zerof32, b, ct, g, bb, ldb, nc, "bb", t)
									} else {
										smmchTest(_N, transa, m, n, n, onef32, c, a, zerof32, b, ct, g, bb, ldb, nc, "bb", t)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkStrsm(b *testing.B) {
	alpha := new(float32)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	major := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*major = 'C'
	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'N'
	*m = 9
	*n = 9
	*alpha = 0.70
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.9071, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.6274, -10000000000.0000}
	*lda = 10
	*bb = []float32{-0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.0000, 0.0000, 0.0000, -0.0629, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, -10000000000.0000, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, -0.0929, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -0.2927, -10000000000.0000, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -10000000000.0000}
	*ldb = 10
	_aa := func() *[][]float32 {
		arr := make([][]float32, *lda)
		for y := 0; y < *lda; y++ {
			arr[y] = make([]float32, *n)
			for x := 0; x < *n; x++ {
				arr[y][x] = (*aa)[y+x*(*lda)]
			}
		}
		return &arr
	}()
	_bb := func() *[][]float32 {
		arr := make([][]float32, *ldb)
		for y := 0; y < *ldb; y++ {
			arr[y] = make([]float32, *n)
			for x := 0; x < *n; x++ {
				arr[y][x] = (*bb)[y+x*(*ldb)]
			}
		}
		return &arr
	}()

	for i := 0; i < b.N; i++ {
		Strsm(major, side, uplo, transa, diag, m, n, alpha, _aa, lda, _bb, ldb)
	}
}

func BenchmarkStrsmFortran(b *testing.B) {
	alpha := new(float32)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'N'
	*m = 9
	*n = 9
	*alpha = 0.70
	*aa = []float32{0.7373, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, -10000000000.0000, 1.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.3367, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.9071, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.2168, 0.3467, 0.1768, -0.2927, -0.1329, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.4965, -0.1728, -0.1429, -0.4126, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 1.1469, -0.0230, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.7373, -0.3327, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.6274, -10000000000.0000}
	*lda = 10
	*bb = []float32{-0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.0000, 0.0000, 0.0000, -0.0629, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, 0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, -10000000000.0000, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, -0.0929, 0.0669, -0.3027, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -0.2927, -10000000000.0000, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -10000000000.0000}
	*ldb = 10

	for i := 0; i < b.N; i++ {
		strsmWrapper(side, uplo, transa, diag, m, n, alpha, aa, lda, bb, ldb)
	}
}

func TestSsyrk(t *testing.T) {
	tname := "Ssyrk"
	var i, ia, ib, ibeg, ict, icu, ik, in, iend, j, jc, jj, ks, laa, lcc, ldas, ldcs, nc, ns, x, y int
	var als, bls float32
	var transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float32)
	beta := new(float32)
	k := new(int)
	n := new(int)
	lj := new(int)
	ma := new(int)
	na := new(int)
	lda := new(int)
	ldc := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	c := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	cc := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	cs := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	ct := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	for in = 1; in <= len(idimL3); in++ {
		*n = idimL3[in-1]

		*ldc = *n
		if *ldc < nmax {
			*ldc++
		}
		if *ldc > nmax {
			continue
		}
		lcc = (*ldc) * (*n)
		null = *n <= 0

		for ik = 1; ik <= len(idimL3); ik++ {
			*k = idimL3[ik-1]

			for ict = 1; ict <= len(ichtL3); ict++ {
				*trans = ichtL3[ict-1]

				if *trans == 'T' || *trans == 'C' {
					*ma = *k
					*na = *n
				} else {
					*ma = *n
					*na = *k
				}

				*lda = *ma
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				smakeGEL3(ma, na, a, aa, lda, reset, zerof32, miSbeg, icSbeg, iSbeg)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ia = 1; ia <= len(alff32L3); ia++ {
						*alpha = alff32L3[ia-1]

						for ib = 1; ib <= len(betf32L3); ib++ {
							*beta = betf32L3[ib-1]

							smakeSYL3(uplo, n, n, c, cc, ldc, reset, zerof32, miSbeg, icSbeg, iSbeg)

							transs = *trans
							uplos = *uplo
							ns = *n
							ks = *k
							als = *alpha
							bls = *beta
							ldas = *lda
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := func() *[][]float32 {
								arr := make([][]float32, *lda)
								for y := 0; y < *lda; y++ {
									arr[y] = make([]float32, *na)
									for x := 0; x < *na; x++ {
										arr[y][x] = (*aa)[y+x*(*lda)]
									}
								}
								return &arr
							}()
							_cc := func() *[][]float32 {
								arr := make([][]float32, *ldc)
								for y := 0; y < *ldc; y++ {
									arr[y] = make([]float32, *n)
									for x := 0; x < *n; x++ {
										arr[y][x] = (*cc)[y+x*(*ldc)]
									}
								}
								return &arr
							}()
							Ssyrk(major, uplo, trans, n, k, alpha, _aa, lda, beta, _cc, ldc)
							for y := range *_aa {
								for x := range (*_aa)[0] {
									(*aa)[y+x*(*lda)] = (*_aa)[y][x]
								}
							}
							for y := range *_cc {
								for x := range (*_cc)[0] {
									(*cc)[y+x*(*ldc)] = (*_cc)[y][x]
								}
							}

							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, k, &ks, "k")
							checkFloat32(t, nc, alpha, &als, "alpha")
							checkFloat32(t, nc, beta, &bls, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkFloat32Array1D(t, nc, &laa, aa, as, "aa")
							if null {
								checkFloat32Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										ibeg = 1
										iend = j
									} else {
										ibeg = j
										iend = *n
									}
									for i = 1; i <= *ldc; i++ {
										if i < ibeg || i > iend {
											checkFloat32(t, nc, &(*cc)[i+(j-1)*(*ldc)-1], &(*cs)[i+(j-1)*(*ldc)-1], "guardband cc")
										}
									}
								}

								jc = 1
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										jj = 1
										*lj = j
									} else {
										jj = j
										*lj = (*n) - j + 1
									}
									_c := func() *[][]float32 {
										arr := make([][]float32, nmax-jj-1)
										for y := 0; y < nmax-jj-1; y++ {
											arr[y] = make([]float32, 1)
											for x := 0; x < 1; x++ {
												arr[y][x] = (*c)[y+jj-1][x+j-1]
											}
										}
										return &arr
									}()
									_cc := func() *[]float32 {
										arr := make([]float32, *ldc)
										for y := 0; y < *ldc; y++ {
											for x := 0; x < 1; x++ {
												arr[y+x*(*ldc)] = (*cc)[y+jc-1+x*(*ldc)]
											}
										}
										return &arr
									}()
									_N := func() *byte { y := byte('N'); return &y }()
									_T := func() *byte { y := byte('T'); return &y }()
									if *trans == 'T' || *trans == 'C' {
										_a := func() *[][]float32 {
											arr := make([][]float32, nmax)
											for y = 0; y < nmax; y++ {
												arr[y] = make([]float32, *n)
												for x = 0; x < *n; x++ {
													arr[y][x] = (*a)[y][x+jj-1]
												}
											}
											return &arr
										}()
										_b := func() *[][]float32 {
											arr := make([][]float32, nmax)
											for y = 0; y < nmax; y++ {
												arr[y] = make([]float32, 1)
												for x = 0; x < 1; x++ {
													arr[y][x] = (*a)[y][x+j-1]
												}
											}
											return &arr
										}()
										smmchTest(_T, _N, lj, onei, k, alpha, _a, _b, beta, _c, ct, g, _cc, ldc, nc, "cc", t)
									} else {
										_a := func() *[][]float32 {
											arr := make([][]float32, nmax-jj-1)
											for y = 0; y < nmax-jj-1; y++ {
												arr[y] = make([]float32, *k)
												for x = 0; x < *k; x++ {
													arr[y][x] = (*a)[y+jj-1][x]
												}
											}
											return &arr
										}()
										_b := func() *[][]float32 {
											arr := make([][]float32, nmax-j-1)
											for y = 0; y < nmax-j-1; y++ {
												arr[y] = make([]float32, *k)
												for x = 0; x < *k; x++ {
													arr[y][x] = (*a)[y+j-1][x]
												}
											}
											return &arr
										}()
										smmchTest(_N, _T, lj, onei, k, alpha, _a, _b, beta, _c, ct, g, _cc, ldc, nc, "cc", t)
									}
									if *uplo == 'U' {
										jc += *ldc
									} else {
										jc += (*ldc) + 1
									}
								}
							}
						}
					}
				}
			}

		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSsyrk(b *testing.B) {
	alpha := new(float32)
	beta := new(float32)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	cc := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*lda = 10
	*beta = 1.30
	*cc = []float32{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2527, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4166, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2927, -0.0629, -0.1329, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1429, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -10000000000.0000}
	*ldc = 10
	_aa := func() *[][]float32 {
		arr := make([][]float32, *lda)
		for y := 0; y < *lda; y++ {
			arr[y] = make([]float32, *n)
			for x := 0; x < *n; x++ {
				arr[y][x] = (*aa)[y+x*(*lda)]
			}
		}
		return &arr
	}()
	_cc := func() *[][]float32 {
		arr := make([][]float32, *ldc)
		for y := 0; y < *ldc; y++ {
			arr[y] = make([]float32, *n)
			for x := 0; x < *n; x++ {
				arr[y][x] = (*cc)[y+x*(*ldc)]
			}
		}
		return &arr
	}()

	for i := 0; i < b.N; i++ {
		Ssyrk(major, uplo, trans, n, k, alpha, _aa, lda, beta, _cc, ldc)
	}
}

func BenchmarkSsyrkFortran(b *testing.B) {
	alpha := new(float32)
	beta := new(float32)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	cc := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*lda = 10
	*beta = 1.30
	*cc = []float32{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2527, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.4166, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.0270, 0.0569, -0.2128, 0.3467, 0.1768, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2927, -0.0629, -0.1329, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1429, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -0.4925, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.2627, -10000000000.0000}
	*ldc = 10

	for i := 0; i < b.N; i++ {
		ssyrkWrapper(uplo, trans, n, k, alpha, aa, lda, beta, cc, ldc)
	}
}

func TestSsyr2k(t *testing.T) {
	tname := "Ssyr2k"
	var i, ia, ib, ibeg, ict, icu, ik, in, iend, j, jc, jj, jjab, ks, laa, lbb, lcc, ldas, ldbs, ldcs, nc, ns, x, y int
	var als, bls float32
	var transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(float32)
	beta := new(float32)
	k := new(int)
	n := new(int)
	k2 := new(int)
	lj := new(int)
	ma := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	miSbeg := new(int)
	icSbeg := new(int)
	iSbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)

	*major = 'C'
	*reset = true

	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	as := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	ab := func() *[]float32 { y := make([]float32, nmax*nmax*2); return &y }()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bs := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	c := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	cc := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	cs := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	ct := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	w := func() *[]float32 { y := make([]float32, 2*nmax); return &y }()

	for j = 1; j <= min(32, nmax); j++ {
		for i = 1; i <= min(32, nmax); i++ {
			(*ab)[i+(j-1)*min(32, nmax)-1] = float32(max(i-j+1, 0))
		}
		(*ab)[j+nmax*min(32, nmax)-1] = float32(j)
		(*ab)[(nmax+j-1)*min(32, nmax)] = float32(j)
	}
	for j = 1; j <= min(32, nmax); j++ {
		(*ab)[j+nmax*min(32, nmax)-1] = float32(min(32, nmax) - j + 1)
	}

	for in = 1; in <= len(idimL3); in++ {
		*n = idimL3[in-1]

		*ldc = *n
		if *ldc < nmax {
			*ldc++
		}
		if *ldc > nmax {
			continue
		}
		lcc = (*ldc) * (*n)
		null = *n <= 0

		for ik = 1; ik <= len(idimL3); ik++ {
			*k = idimL3[ik-1]
			*k2 = 2 * (*k)

			for ict = 1; ict <= len(ichtL3); ict++ {
				*trans = ichtL3[ict-1]

				if *trans == 'T' || *trans == 'C' {
					*ma = *k
					*na = *n
				} else {
					*ma = *n
					*na = *k
				}

				*lda = *ma
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				if *trans == 'T' || *trans == 'C' {
					_ab := func() *[][]float32 {
						arr := make([][]float32, nmax)
						for i = 0; i < nmax; i++ {
							arr[i] = make([]float32, *na)
							for j = 0; j < *na; j++ {
								arr[i][j] = (*ab)[i+j*nmax]
							}
						}
						return &arr
					}()
					smakeGEL3(ma, na, _ab, aa, lda, reset, zerof32, miSbeg, icSbeg, iSbeg)
					for j = 0; j < *na; j++ {
						for i = 0; i < *ma; i++ {
							(*ab)[i+j*nmax] = (*_ab)[i][j]
						}
					}
				} else {
					_ab := func() *[][]float32 {
						arr := make([][]float32, *ma)
						for i = 0; i < *ma; i++ {
							arr[i] = make([]float32, *na)
							for j = 0; j < *na; j++ {
								arr[i][j] = (*ab)[i+j*nmax]
							}
						}
						return &arr
					}()
					smakeGEL3(ma, na, _ab, aa, lda, reset, zerof32, miSbeg, icSbeg, iSbeg)
					for j = 0; j < *na; j++ {
						for i = 0; i < *ma; i++ {
							(*ab)[i+j*nmax] = (*_ab)[i][j]
						}
					}
				}

				*ldb = *lda
				lbb = laa
				if *trans == 'T' || *trans == 'C' {
					_ab := func() *[][]float32 {
						arr := make([][]float32, *ma)
						for i = 0; i < *ma; i++ {
							arr[i] = make([]float32, *na)
							for j = 0; j < *na; j++ {
								arr[i][j] = (*ab)[i+(*k)+j*nmax]
							}
						}
						return &arr
					}()
					smakeGEL3(ma, na, _ab, bb, ldb, reset, zerof32, miSbeg, icSbeg, iSbeg)
					for j = 0; j < *na; j++ {
						for i = 0; i < *ma; i++ {
							(*ab)[i+j*nmax+(*k)] = (*_ab)[i][j]
						}
					}
				} else {
					_ab := func() *[][]float32 {
						arr := make([][]float32, *ma)
						for i = 0; i < *ma; i++ {
							arr[i] = make([]float32, *na)
							for j = 0; j < *na; j++ {
								arr[i][j] = (*ab)[i+(*k)*nmax+j*nmax]
							}
						}
						return &arr
					}()
					smakeGEL3(ma, na, _ab, bb, ldb, reset, zerof32, miSbeg, icSbeg, iSbeg)
					for j = 0; j < *na; j++ {
						for i = 0; i < *ma; i++ {
							(*ab)[i+j*nmax+(*k)*nmax] = (*_ab)[i][j]
						}
					}
				}

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ia = 1; ia <= len(alff32L3); ia++ {
						*alpha = alff32L3[ia-1]

						for ib = 1; ib <= len(betf32L3); ib++ {
							*beta = betf32L3[ib-1]

							smakeSYL3(uplo, n, n, c, cc, ldc, reset, zerof32, miSbeg, icSbeg, iSbeg)

							transs = *trans
							uplos = *uplo
							ns = *n
							ks = *k
							als = *alpha
							bls = *beta
							ldas = *lda
							ldbs = *ldb
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lbb; i++ {
								(*bs)[i-1] = (*bb)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := func() *[][]float32 {
								arr := make([][]float32, *lda)
								for y := 0; y < *lda; y++ {
									arr[y] = make([]float32, *na)
									for x := 0; x < *na; x++ {
										arr[y][x] = (*aa)[y+x*(*lda)]
									}
								}
								return &arr
							}()
							_bb := func() *[][]float32 {
								arr := make([][]float32, *ldb)
								for y := 0; y < *ldb; y++ {
									arr[y] = make([]float32, *na)
									for x := 0; x < *na; x++ {
										arr[y][x] = (*bb)[y+x*(*ldb)]
									}
								}
								return &arr
							}()
							_cc := func() *[][]float32 {
								arr := make([][]float32, *ldc)
								for y := 0; y < *ldc; y++ {
									arr[y] = make([]float32, *n)
									for x := 0; x < *n; x++ {
										arr[y][x] = (*cc)[y+x*(*ldc)]
									}
								}
								return &arr
							}()
							Ssyr2k(major, uplo, trans, n, k, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
							for y := range *_aa {
								for x := range (*_aa)[0] {
									(*aa)[y+x*(*lda)] = (*_aa)[y][x]
								}
							}
							for y := range *_bb {
								for x := range (*_bb)[0] {
									(*bb)[y+x*(*ldb)] = (*_bb)[y][x]
								}
							}
							for y := range *_cc {
								for x := range (*_cc)[0] {
									(*cc)[y+x*(*ldc)] = (*_cc)[y][x]
								}
							}

							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, k, &ks, "k")
							checkFloat32(t, nc, alpha, &als, "alpha")
							checkFloat32(t, nc, beta, &bls, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldb, &ldbs, "ldb")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkFloat32Array1D(t, nc, &laa, aa, as, "aa")
							checkFloat32Array1D(t, nc, &lbb, bb, bs, "bb")
							if null {
								checkFloat32Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										ibeg = 1
										iend = j
									} else {
										ibeg = j
										iend = *n
									}
									for i = 1; i <= *ldc; i++ {
										if i < ibeg || i > iend {
											checkFloat32(t, nc, &(*cc)[i+(j-1)*(*ldc)-1], &(*cs)[i+(j-1)*(*ldc)-1], "guardband cc")
										}
									}
								}

								jjab = 1
								jc = 1
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										jj = 1
										*lj = j
									} else {
										jj = j
										*lj = (*n) - j + 1
									}
									_c := func() *[][]float32 {
										arr := make([][]float32, nmax-jj-1)
										for y = 0; y < nmax-jj-1; y++ {
											arr[y] = make([]float32, 1)
											for x = 0; x < 1; x++ {
												arr[y][x] = (*c)[y+jj-1][x+j-1]
											}
										}
										return &arr
									}()
									_cc := func() *[]float32 {
										arr := make([]float32, *ldc)
										for y := 0; y < *ldc; y++ {
											for x := 0; x < 1; x++ {
												arr[y+x*(*ldc)] = (*cc)[y+jc-1+x*(*ldc)]
											}
										}
										return &arr
									}()
									_N := func() *byte { y := byte('N'); return &y }()
									_T := func() *byte { y := byte('T'); return &y }()
									if *trans == 'T' || *trans == 'C' {
										for i = 1; i <= *k; i++ {
											(*w)[i-1] = (*ab)[(j-1)*nmax+(*k)+i-1]
											(*w)[(*k)+i-1] = (*ab)[(j-1)*nmax+i-1]
										}
										_jjab := (jjab - 1) * nmax
										_ab := func() *[][]float32 {
											_x := (*ab)[_jjab:]
											arr := make([][]float32, nmax)
											for y := 0; y < nmax; y++ {
												arr[y] = make([]float32, *lj)
												for x := 0; x < *lj; x++ {
													arr[y][x] = _x[y+x*nmax]
												}
											}
											return &arr
										}()
										_w := func() *[][]float32 {
											arr := make([][]float32, 2*nmax)
											for y := 0; y < 2*nmax; y++ {
												arr[y] = make([]float32, 1)
												for x := 0; x < 1; x++ {
													arr[y][x] = (*w)[y+x*2*nmax]
												}
											}
											return &arr
										}()
										smmchTest(_T, _N, lj, onei, k2, alpha, _ab, _w, beta, _c, ct, g, _cc, ldc, nc, "cc", t)
									} else {
										for i = 1; i <= *k; i++ {
											(*w)[i-1] = (*ab)[((*k)+i-1)*nmax+j-1]
											(*w)[(*k)+i-1] = (*ab)[(i-1)*nmax+j-1]
										}
										_ab := func() *[][]float32 {
											_x := (*ab)[jj-1:]
											arr := make([][]float32, nmax)
											for y := 0; y < nmax; y++ {
												arr[y] = make([]float32, *k2)
												for x := 0; x < *k2; x++ {
													arr[y][x] = _x[y+x*nmax]
												}
											}
											return &arr
										}()
										_w := func() *[][]float32 {
											arr := make([][]float32, 2*nmax)
											for y := 0; y < 2*nmax; y++ {
												arr[y] = make([]float32, 1)
												for x := 0; x < 1; x++ {
													arr[y][x] = (*w)[y+x*2*nmax]
												}
											}
											return &arr
										}()
										smmchTest(_N, _N, lj, onei, k2, alpha, _ab, _w, beta, _c, ct, g, _cc, ldc, nc, "cc", t)
									}
									if *uplo == 'U' {
										jc += *ldc
									} else {
										jc += (*ldc) + 1
										if *trans == 'T' || *trans == 'C' {
											jjab++
										}
									}
								}
							}
						}
					}
				}
			}

		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkSsyr2k(b *testing.B) {
	alpha := new(float32)
	beta := new(float32)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	cc := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*major = 'C'
	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*lda = 10
	*bb = []float32{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, -10000000000.0000, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0270, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -10000000000.0000, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -10000000000.0000}
	*ldb = 10
	*beta = 1.30
	*cc = []float32{-0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2268, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1329, 0.4965, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -10000000000.0000}
	*ldc = 10
	_aa := func() *[][]float32 {
		arr := make([][]float32, *lda)
		for y := 0; y < *lda; y++ {
			arr[y] = make([]float32, *n)
			for x := 0; x < *n; x++ {
				arr[y][x] = (*aa)[y+x*(*lda)]
			}
		}
		return &arr
	}()
	_bb := func() *[][]float32 {
		arr := make([][]float32, *ldb)
		for y := 0; y < *ldb; y++ {
			arr[y] = make([]float32, *n)
			for x := 0; x < *n; x++ {
				arr[y][x] = (*bb)[y+x*(*ldb)]
			}
		}
		return &arr
	}()
	_cc := func() *[][]float32 {
		arr := make([][]float32, *ldc)
		for y := 0; y < *ldc; y++ {
			arr[y] = make([]float32, *n)
			for x := 0; x < *n; x++ {
				arr[y][x] = (*cc)[y+x*(*ldc)]
			}
		}
		return &arr
	}()

	for i := 0; i < b.N; i++ {
		Ssyr2k(major, uplo, trans, n, k, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
	}
}

func BenchmarkSsyr2kFortran(b *testing.B) {
	alpha := new(float32)
	beta := new(float32)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	bb := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	cc := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*alpha = 0.70
	*aa = []float32{-0.2627, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, -10000000000.0000, 0.4665, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, -10000000000.0000, 0.2667, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.2168, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.1728, -0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -10000000000.0000, -0.3427, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, 0.2268, 0.2567, -10000000000.0000, -0.0130, -0.4525, 0.3766, -0.0929, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -0.1329, 0.4965, -0.1728, -0.4126, 0.0170, -10000000000.0000}
	*lda = 10
	*bb = []float32{0.1469, -0.0230, -0.4925, -0.3327, 0.2967, -0.3726, -0.3427, 0.3866, -0.0529, -10000000000.0000, -0.2228, 0.3067, -0.4625, 0.4665, 0.4266, 0.4565, 0.1868, -0.3826, -0.2527, -10000000000.0000, 0.1069, 0.3367, 0.2667, -0.1029, 0.2268, -0.0130, 0.4166, -0.4525, 0.3766, -10000000000.0000, 0.0000, 0.0000, 0.0000, 0.0270, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -0.0629, -0.1329, -0.1728, -0.1429, -0.4126, 0.0170, 0.1469, -0.4925, -0.2627, -10000000000.0000, -0.3327, 0.2967, -0.3726, 0.3866, -0.1828, -0.0529, -0.2228, 0.3067, 0.4665, -10000000000.0000, 0.0969, 0.4266, 0.4565, 0.1868, -0.2527, -0.4226, 0.1069, 0.3367, 0.2667, -10000000000.0000, 0.2268, 0.2567, -0.0130, 0.4166, -0.4525, -0.0929, 0.1369, 0.0669, -0.3027, -10000000000.0000, 0.0270, -0.2128, 0.2168, 0.3467, 0.1768, -0.2927, -0.1329, 0.4965, -0.1728, -10000000000.0000}
	*ldb = 10
	*beta = 1.30
	*cc = []float32{-0.1429, -0.4126, 0.1469, -0.0230, -0.4925, -0.2627, -0.3327, -0.3726, -0.3427, -10000000000.0000, -10000000000.0000, 0.3866, -0.1828, -0.0529, 0.3067, -0.4625, 0.4665, 0.0969, 0.4266, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1868, -0.3826, -0.2527, -0.4226, 0.1069, 0.2667, -0.1029, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2268, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1369, 0.0669, 0.0270, 0.0569, -0.2128, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.2168, 0.3467, -0.2927, -0.0629, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.1329, 0.4965, -0.1728, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -0.4126, 0.0170, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, -10000000000.0000, 0.1469, -10000000000.0000}
	*ldc = 10

	for i := 0; i < b.N; i++ {
		ssyr2kWrapper(uplo, trans, n, k, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func TestSerrors(t *testing.T) {
	var infot *int
	var srnamt *string
	var test *bool

	alpha := new(float32)
	beta := new(float32)

	infot = &common.infoc.infot
	srnamt = &common.srnamc.srnamt
	test = &common.infoc.test
	*test = true

	aa := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	xx := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	yy := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	a := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	b := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()
	c := func() *[][]float32 {
		arr := make([][]float32, nmax)
		for u := range arr {
			arr[u] = make([]float32, nmax)
		}
		return &arr
	}()

	*srnamt = "Sgemv"
	*infot = 1
	Sgemv(_X, _N, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Sgemv(_C, _X, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Sgemv(_C, _N, negonei, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 4
	Sgemv(_C, _N, zeroi, negonei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 7
	Sgemv(_C, _N, twoi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 9
	Sgemv(_C, _N, zeroi, zeroi, alpha, a, onei, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 12
	Sgemv(_C, _N, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Sgbmv"
	*infot = 1
	Sgbmv(_X, _N, zeroi, zeroi, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Sgbmv(_C, _X, zeroi, zeroi, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Sgbmv(_C, _N, negonei, zeroi, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 4
	Sgbmv(_C, _N, zeroi, negonei, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 5
	Sgbmv(_C, _N, zeroi, zeroi, negonei, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 6
	Sgbmv(_C, _N, twoi, zeroi, zeroi, negonei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 9
	Sgbmv(_C, _N, zeroi, zeroi, onei, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 11
	Sgbmv(_C, _N, zeroi, zeroi, zeroi, zeroi, alpha, a, onei, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 14
	Sgbmv(_C, _N, zeroi, zeroi, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Stpsv"
	*infot = 1
	Stpsv(_X, _U, _N, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 2
	Stpsv(_C, _X, _N, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 3
	Stpsv(_C, _U, _X, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 4
	Stpsv(_C, _U, _N, _X, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 5
	Stpsv(_C, _U, _N, _N, negonei, aa, xx, onei)
	chkxer(t)
	*infot = 8
	Stpsv(_C, _U, _N, _N, zeroi, aa, xx, zeroi)
	chkxer(t)

	*test = true
	*srnamt = "Ssbmv"
	*infot = 1
	Ssbmv(_X, _U, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Ssbmv(_C, _X, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Ssbmv(_C, _U, negonei, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 4
	Ssbmv(_C, _U, zeroi, negonei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 7
	Ssbmv(_C, _U, zeroi, onei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 9
	Ssbmv(_C, _U, zeroi, zeroi, alpha, a, onei, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 12
	Ssbmv(_C, _U, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Sspmv"
	*infot = 1
	Sspmv(_X, _U, zeroi, alpha, aa, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Sspmv(_C, _X, zeroi, alpha, aa, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Sspmv(_C, _U, negonei, alpha, aa, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 7
	Sspmv(_C, _U, zeroi, alpha, aa, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 10
	Sspmv(_C, _U, zeroi, alpha, aa, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Strmv"
	*infot = 1
	Strmv(_X, _U, _N, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 2
	Strmv(_C, _X, _N, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 3
	Strmv(_C, _U, _X, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 4
	Strmv(_C, _U, _N, _X, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 5
	Strmv(_C, _U, _N, _N, negonei, a, onei, xx, onei)
	chkxer(t)
	*infot = 7
	Strmv(_C, _U, _N, _N, twoi, a, onei, xx, onei)
	chkxer(t)
	*infot = 9
	Strmv(_C, _U, _N, _N, zeroi, a, onei, xx, zeroi)
	chkxer(t)

	*srnamt = "Stbmv"
	*infot = 1
	Stbmv(_X, _U, _N, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 2
	Stbmv(_C, _X, _N, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 3
	Stbmv(_C, _U, _X, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 4
	Stbmv(_C, _U, _N, _X, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 5
	Stbmv(_C, _U, _N, _N, negonei, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 6
	Stbmv(_C, _U, _N, _N, zeroi, negonei, a, onei, xx, onei)
	chkxer(t)
	*infot = 8
	Stbmv(_C, _U, _N, _N, zeroi, onei, a, onei, xx, onei)
	chkxer(t)
	*infot = 10
	Stbmv(_C, _U, _N, _N, zeroi, zeroi, a, onei, xx, zeroi)
	chkxer(t)

	*srnamt = "Stpmv"
	*infot = 1
	Stpmv(_X, _U, _N, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 2
	Stpmv(_C, _X, _N, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 3
	Stpmv(_C, _U, _X, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 4
	Stpmv(_C, _U, _N, _X, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 5
	Stpmv(_C, _U, _N, _N, negonei, aa, xx, onei)
	chkxer(t)
	*infot = 8
	Stpmv(_C, _U, _N, _N, zeroi, aa, xx, zeroi)
	chkxer(t)

	*srnamt = "Strsv"
	*infot = 1
	Strsv(_X, _U, _N, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 2
	Strsv(_C, _X, _N, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 3
	Strsv(_C, _U, _X, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 4
	Strsv(_C, _U, _N, _X, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 5
	Strsv(_C, _U, _N, _N, negonei, a, onei, xx, onei)
	chkxer(t)
	*infot = 7
	Strsv(_C, _U, _N, _N, twoi, a, onei, xx, onei)
	chkxer(t)
	*infot = 9
	Strsv(_C, _U, _N, _N, zeroi, a, onei, xx, zeroi)
	chkxer(t)

	*srnamt = "Stbsv"
	*infot = 1
	Stbsv(_X, _U, _N, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 2
	Stbsv(_C, _X, _N, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 3
	Stbsv(_C, _U, _X, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 4
	Stbsv(_C, _U, _N, _X, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 5
	Stbsv(_C, _U, _N, _N, negonei, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 6
	Stbsv(_C, _U, _N, _N, zeroi, negonei, a, onei, xx, onei)
	chkxer(t)
	*infot = 8
	Stbsv(_C, _U, _N, _N, zeroi, onei, a, onei, xx, onei)
	chkxer(t)
	*infot = 10
	Stbsv(_C, _U, _N, _N, zeroi, zeroi, a, onei, xx, zeroi)
	chkxer(t)

	*srnamt = "Sger"
	*infot = 1
	Sger(_X, zeroi, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 2
	Sger(_C, negonei, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 3
	Sger(_C, zeroi, negonei, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 6
	Sger(_C, zeroi, zeroi, alpha, xx, zeroi, yy, onei, a, onei)
	chkxer(t)
	*infot = 8
	Sger(_C, zeroi, zeroi, alpha, xx, onei, yy, zeroi, a, onei)
	chkxer(t)
	*infot = 10
	Sger(_C, twoi, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)

	*srnamt = "Ssyr"
	*infot = 1
	Ssyr(_X, _U, zeroi, alpha, xx, onei, a, onei)
	chkxer(t)
	*infot = 2
	Ssyr(_C, _X, zeroi, alpha, xx, onei, a, onei)
	chkxer(t)
	*infot = 3
	Ssyr(_C, _U, negonei, alpha, xx, onei, a, onei)
	chkxer(t)
	*infot = 6
	Ssyr(_C, _U, zeroi, alpha, xx, zeroi, a, onei)
	chkxer(t)
	*infot = 8
	Ssyr(_C, _U, twoi, alpha, xx, onei, a, onei)
	chkxer(t)

	*srnamt = "Sspr"
	*infot = 1
	Sspr(_X, _U, zeroi, alpha, xx, onei, aa)
	chkxer(t)
	*infot = 2
	Sspr(_C, _X, zeroi, alpha, xx, onei, aa)
	chkxer(t)
	*infot = 3
	Sspr(_C, _U, negonei, alpha, xx, onei, aa)
	chkxer(t)
	*infot = 6
	Sspr(_C, _U, zeroi, alpha, xx, zeroi, aa)
	chkxer(t)

	*srnamt = "Ssyr2"
	*infot = 1
	Ssyr2(_X, _U, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 2
	Ssyr2(_C, _X, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 3
	Ssyr2(_C, _U, negonei, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 6
	Ssyr2(_C, _U, zeroi, alpha, xx, zeroi, yy, onei, a, onei)
	chkxer(t)
	*infot = 8
	Ssyr2(_C, _U, zeroi, alpha, xx, onei, yy, zeroi, a, onei)
	chkxer(t)
	*infot = 10
	Ssyr2(_C, _U, twoi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)

	*srnamt = "Sspr2"
	*infot = 1
	Sspr2(_X, _U, zeroi, alpha, xx, onei, yy, onei, aa)
	chkxer(t)
	*infot = 2
	Sspr2(_C, _X, zeroi, alpha, xx, onei, yy, onei, aa)
	chkxer(t)
	*infot = 3
	Sspr2(_C, _U, negonei, alpha, xx, onei, yy, onei, aa)
	chkxer(t)
	*infot = 6
	Sspr2(_C, _U, zeroi, alpha, xx, zeroi, yy, onei, aa)
	chkxer(t)
	*infot = 8
	Sspr2(_C, _U, zeroi, alpha, xx, onei, yy, zeroi, aa)
	chkxer(t)

	*srnamt = "Sgemm"
	*infot = 1
	Sgemm(_X, _N, _T, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Sgemm(_C, _X, _N, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Sgemm(_C, _X, _T, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Sgemm(_C, _N, _X, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Sgemm(_C, _T, _X, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Sgemm(_C, _N, _N, negonei, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Sgemm(_C, _N, _T, negonei, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Sgemm(_C, _T, _T, negonei, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Sgemm(_C, _T, _T, negonei, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Sgemm(_C, _N, _N, zeroi, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Sgemm(_C, _N, _T, zeroi, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Sgemm(_C, _T, _N, zeroi, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Sgemm(_C, _T, _T, zeroi, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 6
	Sgemm(_C, _N, _N, zeroi, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 6
	Sgemm(_C, _N, _T, zeroi, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 6
	Sgemm(_C, _T, _N, zeroi, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 6
	Sgemm(_C, _T, _T, zeroi, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 9
	Sgemm(_C, _N, _N, twoi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 9
	Sgemm(_C, _N, _T, twoi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 9
	Sgemm(_C, _T, _N, zeroi, zeroi, twoi, alpha, a, onei, b, twoi, beta, c, onei)
	chkxer(t)
	*infot = 9
	Sgemm(_C, _T, _T, zeroi, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Sgemm(_C, _N, _N, zeroi, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Sgemm(_C, _T, _N, zeroi, zeroi, twoi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Sgemm(_C, _N, _T, zeroi, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Sgemm(_C, _T, _T, zeroi, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 14
	Sgemm(_C, _N, _N, twoi, zeroi, zeroi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 14
	Sgemm(_C, _N, _T, twoi, zeroi, zeroi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 14
	Sgemm(_C, _T, _N, twoi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 14
	Sgemm(_C, _T, _T, twoi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)

	*srnamt = "Ssymm"
	*infot = 1
	Ssymm(_X, _L, _U, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Ssymm(_C, _X, _U, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Ssymm(_C, _L, _X, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Ssymm(_C, _L, _U, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Ssymm(_C, _R, _U, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Ssymm(_C, _L, _L, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Ssymm(_C, _R, _L, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Ssymm(_C, _L, _U, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Ssymm(_C, _R, _U, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Ssymm(_C, _L, _L, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Ssymm(_C, _R, _L, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Ssymm(_C, _L, _U, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, twoi)
	chkxer(t)
	*infot = 8
	Ssymm(_C, _R, _U, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Ssymm(_C, _L, _L, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, twoi)
	chkxer(t)
	*infot = 8
	Ssymm(_C, _R, _L, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 10
	Ssymm(_C, _L, _U, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 10
	Ssymm(_C, _R, _U, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 10
	Ssymm(_C, _L, _L, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 10
	Ssymm(_C, _R, _L, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 13
	Ssymm(_C, _L, _U, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	*infot = 13
	Ssymm(_C, _R, _U, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, onei)
	chkxer(t)
	*infot = 13
	Ssymm(_C, _L, _L, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	*infot = 13
	Ssymm(_C, _R, _L, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, onei)
	chkxer(t)

	*srnamt = "Ssymv"
	*infot = 1
	Ssymv(_X, _U, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Ssymv(_C, _X, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Ssymv(_C, _U, negonei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 6
	Ssymv(_C, _U, twoi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 8
	Ssymv(_C, _U, zeroi, alpha, a, onei, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 11
	Ssymv(_C, _U, zeroi, alpha, a, onei, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Strmm"
	*infot = 1
	Strmm(_X, _L, _U, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 2
	Strmm(_C, _X, _U, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 3
	Strmm(_C, _L, _X, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 4
	Strmm(_C, _L, _U, _X, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 5
	Strmm(_C, _L, _U, _N, _X, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 6
	Strmm(_C, _L, _U, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _L, _U, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _R, _U, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _R, _U, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _L, _L, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _L, _L, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _R, _L, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _R, _L, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 7
	Strmm(_C, _L, _U, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _L, _U, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _R, _U, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _R, _U, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _L, _L, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _L, _L, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _R, _L, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _R, _L, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 10
	Strmm(_C, _L, _U, _N, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Strmm(_C, _L, _U, _T, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Strmm(_C, _R, _U, _N, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _R, _U, _T, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _L, _L, _N, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Strmm(_C, _L, _L, _T, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Strmm(_C, _R, _L, _N, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _R, _L, _T, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 12
	Strmm(_C, _L, _U, _N, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Strmm(_C, _L, _U, _T, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Strmm(_C, _R, _U, _N, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _R, _U, _T, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _L, _L, _N, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Strmm(_C, _L, _L, _T, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Strmm(_C, _R, _L, _N, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strmm(_C, _R, _L, _T, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)

	*srnamt = "Strsm"
	*infot = 1
	Strsm(_X, _L, _U, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 2
	Strsm(_C, _X, _U, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 3
	Strsm(_C, _L, _X, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 4
	Strsm(_C, _L, _U, _X, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 5
	Strsm(_C, _L, _U, _N, _X, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 6
	Strsm(_C, _L, _U, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _L, _U, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _R, _U, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _R, _U, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _L, _L, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _L, _L, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _R, _L, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _R, _L, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 7
	Strsm(_C, _L, _U, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _L, _U, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _R, _U, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _R, _U, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _L, _L, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _L, _L, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _R, _L, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _R, _L, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 10
	Strsm(_C, _L, _U, _N, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Strsm(_C, _L, _U, _T, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Strsm(_C, _R, _U, _N, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _R, _U, _T, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _L, _L, _N, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Strsm(_C, _L, _L, _T, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Strsm(_C, _R, _L, _N, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _R, _L, _T, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 12
	Strsm(_C, _L, _U, _N, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Strsm(_C, _L, _U, _T, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Strsm(_C, _R, _U, _N, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _R, _U, _T, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _L, _L, _N, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Strsm(_C, _L, _L, _T, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Strsm(_C, _R, _L, _N, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Strsm(_C, _R, _L, _T, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)

	*srnamt = "Ssyrk"
	*infot = 1
	Ssyrk(_X, _U, _N, zeroi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Ssyrk(_C, _X, _N, zeroi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Ssyrk(_C, _U, _X, zeroi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Ssyrk(_C, _U, _N, negonei, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Ssyrk(_C, _U, _T, negonei, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Ssyrk(_C, _L, _N, negonei, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Ssyrk(_C, _L, _T, negonei, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Ssyrk(_C, _U, _N, zeroi, negonei, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Ssyrk(_C, _U, _T, zeroi, negonei, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Ssyrk(_C, _L, _N, zeroi, negonei, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Ssyrk(_C, _L, _T, zeroi, negonei, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Ssyrk(_C, _U, _N, twoi, zeroi, alpha, a, onei, beta, c, twoi)
	chkxer(t)
	Ssyrk(_C, _U, _T, zeroi, twoi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Ssyrk(_C, _L, _N, twoi, zeroi, alpha, a, onei, beta, c, twoi)
	chkxer(t)
	Ssyrk(_C, _L, _T, zeroi, twoi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Ssyrk(_C, _U, _N, twoi, zeroi, alpha, a, twoi, beta, c, onei)
	chkxer(t)
	Ssyrk(_C, _U, _T, twoi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Ssyrk(_C, _L, _N, twoi, zeroi, alpha, a, twoi, beta, c, onei)
	chkxer(t)
	Ssyrk(_C, _L, _T, twoi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)

	*srnamt = "Ssyr2k"
	*infot = 1
	Ssyr2k(_X, _U, _N, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Ssyr2k(_C, _X, _N, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Ssyr2k(_C, _U, _X, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Ssyr2k(_C, _U, _N, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Ssyr2k(_C, _U, _T, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Ssyr2k(_C, _L, _N, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Ssyr2k(_C, _L, _T, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Ssyr2k(_C, _U, _N, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Ssyr2k(_C, _U, _T, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Ssyr2k(_C, _L, _N, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Ssyr2k(_C, _L, _T, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Ssyr2k(_C, _U, _N, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	Ssyr2k(_C, _U, _T, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Ssyr2k(_C, _L, _N, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	Ssyr2k(_C, _L, _T, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 10
	Ssyr2k(_C, _U, _N, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	Ssyr2k(_C, _U, _T, zeroi, twoi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	Ssyr2k(_C, _L, _N, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	Ssyr2k(_C, _L, _T, zeroi, twoi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 13
	Ssyr2k(_C, _U, _N, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	Ssyr2k(_C, _U, _T, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Ssyr2k(_C, _L, _N, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	Ssyr2k(_C, _L, _T, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)

	*test = false
	fmt.Println("\t\t\tSblas error tests completed")
}
