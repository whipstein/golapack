package goblas

import 

// \brief \b Zblat1
//
//  =========== DOCUMENTATION ===========
//
// Online html documentation available at
//            http://www.netlib.org/lapack/explore-html/
//
//  Definition:
//  ===========
//
//       PROGRAM Zblat1
//
//
// \par Purpose:
//  =============
//
// \verbatim
//
//    Test program for the COMPLEX//16 Level 1 BLAS.
//
//    Based upon the original BLAS test routine together with:
//    F06GAF Example Program Text
// \endverbatim
//
//  Authors:
//  ========
//
// \author Univ. of Tennessee
// \author Univ. of California Berkeley
// \author Univ. of Colorado Denver
// \author NAG Ltd.
//
// \date April 2012
//
// \ingroup complex16_blas_testing
//
//  =====================================================================
func main() {
	nout := new(int)
	icase := new(int)
	incx := new(int)
	incy := new(int)
	mode := new(int)
	n := new(int)
	pass := new(bool)
	sfac := new(float64)
	ic := new(int)
	common.combla.pass = new(bool)
	common.combla.mode = new(int)
	common.combla.incy = new(int)
	common.combla.incx = new(int)
	common.combla.n = new(int)
	common.combla.icase = new(int)
	//*
	//*  -- Reference BLAS test routine (version 3.7.0) --
	//*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
	//*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
	//*     April 2012
	//*
	//*  =====================================================================
	//*
	//*     .. Parameters ..
	(*nout) = 6
	//*     .. Scalars in Common ..
	//*     .. Local Scalars ..
	//*     .. External Subroutines ..
	//*     .. Common blocks ..
	icase = common.combla.icase
	n = common.combla.n
	incx = common.combla.incx
	incy = common.combla.incy
	mode = common.combla.mode
	pass = common.combla.pass
	//*     .. Data statements ..
	(*sfac) = 9.765625e-4
	//*     .. Executable Statements ..
	WRITE((*nout), *func() *[]byte{y := []byte(" complex blas test program results\n \n"); return &y }())
	for (*ic) = 1; (*ic) <= 10; (*ic)++ {
		(*icase) = (*ic)
		Header()
		//*
		//*        Initialize pass, incx, incy, and mode for a new case.
		//*        The value 9999 for incx, incy or mode will appear in the
		//*        detailed  output, if any, for cases that do not involve
		//*        these parameters.
		//*
		(*pass) = true
		(*incx) = 9999
		(*incy) = 9999
		(*mode) = 9999
		if (*icase) <= 5 {
			Check2(sfac)
		} else if (*icase) >= 6 {
			Check1(sfac)
		}
		//*        -- Print
		if *pass {
			WRITE((*nout), *func() *[]byte{y := []byte("                                    ----- pass -----\n"); return &y }())
		}
	//Label20:
	}
	panic("")
	//*
}

func Header() {
	nout := new(int)
	icase := new(int)
	incx := new(int)
	incy := new(int)
	mode := new(int)
	n := new(int)
	pass := new(bool)
	l := func() *[][]byte {
		arr := make([][]byte, 6)
		for u := 0; u < 6; u++ {
			arr[u] = make([]byte, 10)
		}
		return &arr
	}()
	common.combla.pass = new(bool)
	common.combla.mode = new(int)
	common.combla.incy = new(int)
	common.combla.incx = new(int)
	common.combla.n = new(int)
	common.combla.icase = new(int)
	//*     .. Parameters ..
	(*nout) = 6
	//*     .. Scalars in Common ..
	//*     .. Local Arrays ..
	//*     .. Common blocks ..
	icase = common.combla.icase
	n = common.combla.n
	incx = common.combla.incx
	incy = common.combla.incy
	mode = common.combla.mode
	pass = common.combla.pass
	//*     .. Data statements ..
	(*l)[0][0], (*l)[1][0], (*l)[2][0], (*l)[3][0], (*l)[4][0], (*l)[5][0] = 'z', 'd', 'o', 't', 'c', ' '
	(*l)[0][1], (*l)[1][1], (*l)[2][1], (*l)[3][1], (*l)[4][1], (*l)[5][1] = 'z', 'd', 'o', 't', 'u', ' '
	(*l)[0][2], (*l)[1][2], (*l)[2][2], (*l)[3][2], (*l)[4][2], (*l)[5][2] = 'z', 'a', 'x', 'p', 'y', ' '
	(*l)[0][3], (*l)[1][3], (*l)[2][3], (*l)[3][3], (*l)[4][3], (*l)[5][3] = 'z', 'c', 'o', 'p', 'y', ' '
	(*l)[0][4], (*l)[1][4], (*l)[2][4], (*l)[3][4], (*l)[4][4], (*l)[5][4] = 'z', 's', 'w', 'a', 'p', ' '
	(*l)[0][5], (*l)[1][5], (*l)[2][5], (*l)[3][5], (*l)[4][5], (*l)[5][5] = 'd', 'z', 'n', 'r', 'm', '2'
	(*l)[0][6], (*l)[1][6], (*l)[2][6], (*l)[3][6], (*l)[4][6], (*l)[5][6] = 'd', 'z', 'a', 's', 'u', 'm'
	(*l)[0][7], (*l)[1][7], (*l)[2][7], (*l)[3][7], (*l)[4][7], (*l)[5][7] = 'z', 's', 'c', 'a', 'l', ' '
	(*l)[0][8], (*l)[1][8], (*l)[2][8], (*l)[3][8], (*l)[4][8], (*l)[5][8] = 'z', 'd', 's', 'c', 'a', 'l'
	(*l)[0][9], (*l)[1][9], (*l)[2][9], (*l)[3][9], (*l)[4][9], (*l)[5][9] = 'i', 'z', 'a', 'm', 'a', 'x'
	//*     .. Executable Statements ..
	WRITE((*nout), *func() *[]byte{y := []byte("\n test of subprogram number%3d            %6s\n"); return &y }(), (*icase), (*l)[(*icase)-(1)])
	return
	//*
}

func Check1(sfac *float64) {
	nout := new(int)
	icase := new(int)
	incx := new(int)
	incy := new(int)
	mode := new(int)
	n := new(int)
	pass := new(bool)
	ca := new(complex128)
	sa := new(float64)
	i := new(int)
	j := new(int)
	len := new(int)
	np1 := new(int)
	ctrue5 := func() *[][][]complex128 {
		arr := make([][][]complex128, 8)
		for u := 0; u < 8; u++ {
			arr[u] = make([][]complex128, 5)
			for w := 0; w < 5; w++ {
				arr[u][w] = make([]complex128, 2)
			}
		}
		return &arr
	}()
	ctrue6 := func() *[][][]complex128 {
		arr := make([][][]complex128, 8)
		for u := 0; u < 8; u++ {
			arr[u] = make([][]complex128, 5)
			for w := 0; w < 5; w++ {
				arr[u][w] = make([]complex128, 2)
			}
		}
		return &arr
	}()
	cv := func() *[][][]complex128 {
		arr := make([][][]complex128, 8)
		for u := 0; u < 8; u++ {
			arr[u] = make([][]complex128, 5)
			for w := 0; w < 5; w++ {
				arr[u][w] = make([]complex128, 2)
			}
		}
		return &arr
	}()
	cx := func() *[]complex128 {
		arr := make([]complex128, 8)
		return &arr
	}()
	mwpcs := func() *[]complex128 {
		arr := make([]complex128, 5)
		return &arr
	}()
	mwpct := func() *[]complex128 {
		arr := make([]complex128, 5)
		return &arr
	}()
	strue2 := func() *[]float64 {
		arr := make([]float64, 5)
		return &arr
	}()
	strue4 := func() *[]float64 {
		arr := make([]float64, 5)
		return &arr
	}()
	itrue3 := func() *[]int {
		arr := make([]int, 5)
		return &arr
	}()
	common.combla.pass = new(bool)
	common.combla.mode = new(int)
	common.combla.incy = new(int)
	common.combla.incx = new(int)
	common.combla.n = new(int)
	common.combla.icase = new(int)
	//*     .. Parameters ..
	(*nout) = 6
	//*     .. Scalar Arguments ..
	//*     .. Scalars in Common ..
	//*     .. Local Scalars ..
	//*     .. Local Arrays ..
	//*     .. External Functions ..
	//*     .. External Subroutines ..
	//*     .. Intrinsic Functions ..
	//*     .. Common blocks ..
	icase = common.combla.icase
	n = common.combla.n
	incx = common.combla.incx
	incy = common.combla.incy
	mode = common.combla.mode
	pass = common.combla.pass
	//*     .. Data statements ..
	(*sa), (*ca) = 0.3, (0.4 + (-0.7)*1i)
	(*cv)[0][0][0], (*cv)[1][0][0], (*cv)[2][0][0], (*cv)[3][0][0], (*cv)[4][0][0], (*cv)[5][0][0], (*cv)[6][0][0], (*cv)[7][0][0], (*cv)[0][1][0], (*cv)[1][1][0], (*cv)[2][1][0], (*cv)[3][1][0], (*cv)[4][1][0], (*cv)[5][1][0], (*cv)[6][1][0], (*cv)[7][1][0], (*cv)[0][2][0], (*cv)[1][2][0], (*cv)[2][2][0], (*cv)[3][2][0], (*cv)[4][2][0], (*cv)[5][2][0], (*cv)[6][2][0], (*cv)[7][2][0], (*cv)[0][3][0], (*cv)[1][3][0], (*cv)[2][3][0], (*cv)[3][3][0], (*cv)[4][3][0], (*cv)[5][3][0], (*cv)[6][3][0], (*cv)[7][3][0], (*cv)[0][4][0], (*cv)[1][4][0], (*cv)[2][4][0], (*cv)[3][4][0], (*cv)[4][4][0], (*cv)[5][4][0], (*cv)[6][4][0], (*cv)[7][4][0] = (0.1 + (0.1)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (0.3 + (-0.4)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (0.1 + (-0.3)*1i), (0.5 + (-0.1)*1i), (5.0 + (6.0)*1i), (5.0 + (6.0)*1i), (5.0 + (6.0)*1i), (5.0 + (6.0)*1i), (5.0 + (6.0)*1i), (5.0 + (6.0)*1i), (0.1 + (0.1)*1i), (-0.6 + (0.1)*1i), (0.1 + (-0.3)*1i), (7.0 + (8.0)*1i), (7.0 + (8.0)*1i), (7.0 + (8.0)*1i), (7.0 + (8.0)*1i), (7.0 + (8.0)*1i), (0.3 + (0.1)*1i), (0.5 + (0.0)*1i), (0.0 + (0.5)*1i), (0.0 + (0.2)*1i), (2.0 + (3.0)*1i), (2.0 + (3.0)*1i), (2.0 + (3.0)*1i), (2.0 + (3.0)*1i)
	(*cv)[0][0][1], (*cv)[1][0][1], (*cv)[2][0][1], (*cv)[3][0][1], (*cv)[4][0][1], (*cv)[5][0][1], (*cv)[6][0][1], (*cv)[7][0][1], (*cv)[0][1][1], (*cv)[1][1][1], (*cv)[2][1][1], (*cv)[3][1][1], (*cv)[4][1][1], (*cv)[5][1][1], (*cv)[6][1][1], (*cv)[7][1][1], (*cv)[0][2][1], (*cv)[1][2][1], (*cv)[2][2][1], (*cv)[3][2][1], (*cv)[4][2][1], (*cv)[5][2][1], (*cv)[6][2][1], (*cv)[7][2][1], (*cv)[0][3][1], (*cv)[1][3][1], (*cv)[2][3][1], (*cv)[3][3][1], (*cv)[4][3][1], (*cv)[5][3][1], (*cv)[6][3][1], (*cv)[7][3][1], (*cv)[0][4][1], (*cv)[1][4][1], (*cv)[2][4][1], (*cv)[3][4][1], (*cv)[4][4][1], (*cv)[5][4][1], (*cv)[6][4][1], (*cv)[7][4][1] = (0.1 + (0.1)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (0.3 + (-0.4)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (0.1 + (-0.3)*1i), (8.0 + (9.0)*1i), (0.5 + (-0.1)*1i), (2.0 + (5.0)*1i), (2.0 + (5.0)*1i), (2.0 + (5.0)*1i), (2.0 + (5.0)*1i), (2.0 + (5.0)*1i), (0.1 + (0.1)*1i), (3.0 + (6.0)*1i), (-0.6 + (0.1)*1i), (4.0 + (7.0)*1i), (0.1 + (-0.3)*1i), (7.0 + (2.0)*1i), (7.0 + (2.0)*1i), (7.0 + (2.0)*1i), (0.3 + (0.1)*1i), (5.0 + (8.0)*1i), (0.5 + (0.0)*1i), (6.0 + (9.0)*1i), (0.0 + (0.5)*1i), (8.0 + (3.0)*1i), (0.0 + (0.2)*1i), (9.0 + (4.0)*1i)
	(*strue2)[0], (*strue2)[1], (*strue2)[2], (*strue2)[3], (*strue2)[4] = 0.0, 0.5, 0.6, 0.7, 0.8
	(*strue4)[0], (*strue4)[1], (*strue4)[2], (*strue4)[3], (*strue4)[4] = 0.0, 0.7, 1.0, 1.3, 1.6
	(*ctrue5)[0][0][0], (*ctrue5)[1][0][0], (*ctrue5)[2][0][0], (*ctrue5)[3][0][0], (*ctrue5)[4][0][0], (*ctrue5)[5][0][0], (*ctrue5)[6][0][0], (*ctrue5)[7][0][0], (*ctrue5)[0][1][0], (*ctrue5)[1][1][0], (*ctrue5)[2][1][0], (*ctrue5)[3][1][0], (*ctrue5)[4][1][0], (*ctrue5)[5][1][0], (*ctrue5)[6][1][0], (*ctrue5)[7][1][0], (*ctrue5)[0][2][0], (*ctrue5)[1][2][0], (*ctrue5)[2][2][0], (*ctrue5)[3][2][0], (*ctrue5)[4][2][0], (*ctrue5)[5][2][0], (*ctrue5)[6][2][0], (*ctrue5)[7][2][0], (*ctrue5)[0][3][0], (*ctrue5)[1][3][0], (*ctrue5)[2][3][0], (*ctrue5)[3][3][0], (*ctrue5)[4][3][0], (*ctrue5)[5][3][0], (*ctrue5)[6][3][0], (*ctrue5)[7][3][0], (*ctrue5)[0][4][0], (*ctrue5)[1][4][0], (*ctrue5)[2][4][0], (*ctrue5)[3][4][0], (*ctrue5)[4][4][0], (*ctrue5)[5][4][0], (*ctrue5)[6][4][0], (*ctrue5)[7][4][0] = (0.1 + (0.1)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (-0.16 + (-0.37)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (-0.17 + (-0.19)*1i), (0.13 + (-0.39)*1i), (5.0 + (6.0)*1i), (5.0 + (6.0)*1i), (5.0 + (6.0)*1i), (5.0 + (6.0)*1i), (5.0 + (6.0)*1i), (5.0 + (6.0)*1i), (0.11 + (-0.03)*1i), (-0.17 + (0.46)*1i), (-0.17 + (-0.19)*1i), (7.0 + (8.0)*1i), (7.0 + (8.0)*1i), (7.0 + (8.0)*1i), (7.0 + (8.0)*1i), (7.0 + (8.0)*1i), (0.19 + (-0.17)*1i), (0.20 + (-0.35)*1i), (0.35 + (0.20)*1i), (0.14 + (0.08)*1i), (2.0 + (3.0)*1i), (2.0 + (3.0)*1i), (2.0 + (3.0)*1i), (2.0 + (3.0)*1i)
	(*ctrue5)[0][0][1], (*ctrue5)[1][0][1], (*ctrue5)[2][0][1], (*ctrue5)[3][0][1], (*ctrue5)[4][0][1], (*ctrue5)[5][0][1], (*ctrue5)[6][0][1], (*ctrue5)[7][0][1], (*ctrue5)[0][1][1], (*ctrue5)[1][1][1], (*ctrue5)[2][1][1], (*ctrue5)[3][1][1], (*ctrue5)[4][1][1], (*ctrue5)[5][1][1], (*ctrue5)[6][1][1], (*ctrue5)[7][1][1], (*ctrue5)[0][2][1], (*ctrue5)[1][2][1], (*ctrue5)[2][2][1], (*ctrue5)[3][2][1], (*ctrue5)[4][2][1], (*ctrue5)[5][2][1], (*ctrue5)[6][2][1], (*ctrue5)[7][2][1], (*ctrue5)[0][3][1], (*ctrue5)[1][3][1], (*ctrue5)[2][3][1], (*ctrue5)[3][3][1], (*ctrue5)[4][3][1], (*ctrue5)[5][3][1], (*ctrue5)[6][3][1], (*ctrue5)[7][3][1], (*ctrue5)[0][4][1], (*ctrue5)[1][4][1], (*ctrue5)[2][4][1], (*ctrue5)[3][4][1], (*ctrue5)[4][4][1], (*ctrue5)[5][4][1], (*ctrue5)[6][4][1], (*ctrue5)[7][4][1] = (0.1 + (0.1)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (-0.16 + (-0.37)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (-0.17 + (-0.19)*1i), (8.0 + (9.0)*1i), (0.13 + (-0.39)*1i), (2.0 + (5.0)*1i), (2.0 + (5.0)*1i), (2.0 + (5.0)*1i), (2.0 + (5.0)*1i), (2.0 + (5.0)*1i), (0.11 + (-0.03)*1i), (3.0 + (6.0)*1i), (-0.17 + (0.46)*1i), (4.0 + (7.0)*1i), (-0.17 + (-0.19)*1i), (7.0 + (2.0)*1i), (7.0 + (2.0)*1i), (7.0 + (2.0)*1i), (0.19 + (-0.17)*1i), (5.0 + (8.0)*1i), (0.20 + (-0.35)*1i), (6.0 + (9.0)*1i), (0.35 + (0.20)*1i), (8.0 + (3.0)*1i), (0.14 + (0.08)*1i), (9.0 + (4.0)*1i)
	(*ctrue6)[0][0][0], (*ctrue6)[1][0][0], (*ctrue6)[2][0][0], (*ctrue6)[3][0][0], (*ctrue6)[4][0][0], (*ctrue6)[5][0][0], (*ctrue6)[6][0][0], (*ctrue6)[7][0][0], (*ctrue6)[0][1][0], (*ctrue6)[1][1][0], (*ctrue6)[2][1][0], (*ctrue6)[3][1][0], (*ctrue6)[4][1][0], (*ctrue6)[5][1][0], (*ctrue6)[6][1][0], (*ctrue6)[7][1][0], (*ctrue6)[0][2][0], (*ctrue6)[1][2][0], (*ctrue6)[2][2][0], (*ctrue6)[3][2][0], (*ctrue6)[4][2][0], (*ctrue6)[5][2][0], (*ctrue6)[6][2][0], (*ctrue6)[7][2][0], (*ctrue6)[0][3][0], (*ctrue6)[1][3][0], (*ctrue6)[2][3][0], (*ctrue6)[3][3][0], (*ctrue6)[4][3][0], (*ctrue6)[5][3][0], (*ctrue6)[6][3][0], (*ctrue6)[7][3][0], (*ctrue6)[0][4][0], (*ctrue6)[1][4][0], (*ctrue6)[2][4][0], (*ctrue6)[3][4][0], (*ctrue6)[4][4][0], (*ctrue6)[5][4][0], (*ctrue6)[6][4][0], (*ctrue6)[7][4][0] = (0.1 + (0.1)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (1.0 + (2.0)*1i), (0.09 + (-0.12)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (3.0 + (4.0)*1i), (0.03 + (-0.09)*1i), (0.15 + (-0.03)*1i), (5.0 + (6.0)*1i), (5.0 + (6.0)*1i), (5.0 + (6.0)*1i), (5.0 + (6.0)*1i), (5.0 + (6.0)*1i), (5.0 + (6.0)*1i), (0.03 + (0.03)*1i), (-0.18 + (0.03)*1i), (0.03 + (-0.09)*1i), (7.0 + (8.0)*1i), (7.0 + (8.0)*1i), (7.0 + (8.0)*1i), (7.0 + (8.0)*1i), (7.0 + (8.0)*1i), (0.09 + (0.03)*1i), (0.15 + (0.00)*1i), (0.00 + (0.15)*1i), (0.00 + (0.06)*1i), (2.0 + (3.0)*1i), (2.0 + (3.0)*1i), (2.0 + (3.0)*1i), (2.0 + (3.0)*1i)
	(*ctrue6)[0][0][1], (*ctrue6)[1][0][1], (*ctrue6)[2][0][1], (*ctrue6)[3][0][1], (*ctrue6)[4][0][1], (*ctrue6)[5][0][1], (*ctrue6)[6][0][1], (*ctrue6)[7][0][1], (*ctrue6)[0][1][1], (*ctrue6)[1][1][1], (*ctrue6)[2][1][1], (*ctrue6)[3][1][1], (*ctrue6)[4][1][1], (*ctrue6)[5][1][1], (*ctrue6)[6][1][1], (*ctrue6)[7][1][1], (*ctrue6)[0][2][1], (*ctrue6)[1][2][1], (*ctrue6)[2][2][1], (*ctrue6)[3][2][1], (*ctrue6)[4][2][1], (*ctrue6)[5][2][1], (*ctrue6)[6][2][1], (*ctrue6)[7][2][1], (*ctrue6)[0][3][1], (*ctrue6)[1][3][1], (*ctrue6)[2][3][1], (*ctrue6)[3][3][1], (*ctrue6)[4][3][1], (*ctrue6)[5][3][1], (*ctrue6)[6][3][1], (*ctrue6)[7][3][1], (*ctrue6)[0][4][1], (*ctrue6)[1][4][1], (*ctrue6)[2][4][1], (*ctrue6)[3][4][1], (*ctrue6)[4][4][1], (*ctrue6)[5][4][1], (*ctrue6)[6][4][1], (*ctrue6)[7][4][1] = (0.1 + (0.1)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (4.0 + (5.0)*1i), (0.09 + (-0.12)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (6.0 + (7.0)*1i), (0.03 + (-0.09)*1i), (8.0 + (9.0)*1i), (0.15 + (-0.03)*1i), (2.0 + (5.0)*1i), (2.0 + (5.0)*1i), (2.0 + (5.0)*1i), (2.0 + (5.0)*1i), (2.0 + (5.0)*1i), (0.03 + (0.03)*1i), (3.0 + (6.0)*1i), (-0.18 + (0.03)*1i), (4.0 + (7.0)*1i), (0.03 + (-0.09)*1i), (7.0 + (2.0)*1i), (7.0 + (2.0)*1i), (7.0 + (2.0)*1i), (0.09 + (0.03)*1i), (5.0 + (8.0)*1i), (0.15 + (0.00)*1i), (6.0 + (9.0)*1i), (0.00 + (0.15)*1i), (8.0 + (3.0)*1i), (0.00 + (0.06)*1i), (9.0 + (4.0)*1i)
	(*itrue3)[0], (*itrue3)[1], (*itrue3)[2], (*itrue3)[3], (*itrue3)[4] = 0, 1, 2, 2, 2
	//*     .. Executable Statements ..
	for (*incx) = 1; (*incx) <= 2; (*incx)++ {
		for (*np1) = 1; (*np1) <= 5; (*np1)++ {
			(*n) = (*np1) - 1
			(*len) = 2 * MAX((*n), 1)
			//*           .. Set vector arguments ..
			for (*i) = 1; (*i) <= (*len); (*i)++ {
				(*cx)[(*i)-(1)] = (*cv)[(*i)-(1)][(*np1)-(1)][(*incx)-(1)]
			//Label20:
			}
			if (*icase) == 6 {
				//*              .. Dznrm2 ..
				Stest1(Dznrm2(n, cx, incx), &((*strue2)[(*np1)-(1)]), &((*strue2)[(*np1)-(1)]), sfac)
			} else if (*icase) == 7 {
				//*              .. Dzasum ..
				Stest1(Dzasum(n, cx, incx), &((*strue4)[(*np1)-(1)]), &((*strue4)[(*np1)-(1)]), sfac)
			} else if (*icase) == 8 {
				//*              .. Zscal ..
				Zscal(n, ca, cx, incx)
				Ctest(len, cx, &((*ctrue5)[0][(*np1)-(1)][(*incx)-(1)]), &((*ctrue5)[0][(*np1)-(1)][(*incx)-(1)]), sfac)
			} else if (*icase) == 9 {
				//*              .. Zdscal ..
				Zdscal(n, sa, cx, incx)
				Ctest(len, cx, &((*ctrue6)[0][(*np1)-(1)][(*incx)-(1)]), &((*ctrue6)[0][(*np1)-(1)][(*incx)-(1)]), sfac)
			} else if (*icase) == 10 {
				//*              .. Izamax ..
				Itest1(Izamax(n, cx, incx), &((*itrue3)[(*np1)-(1)]))
			} else {
				WRITE((*nout), *func() *[]byte{y := []byte(" %v\n"); return &y }(), *func() *[]byte{y := []byte(" shouldn't be here in check1"); return &y }())
				panic("")
			}
			//*
		//Label40:
		}
	//Label60:
	}
	//*
	(*incx) = 1
	if (*icase) == 8 {
		//*        Zscal
		//*        Add a test for alpha equal to zero.
		(*ca) = (0.0 + (0.0)*1i)
		for (*i) = 1; (*i) <= 5; (*i)++ {
			(*mwpct)[(*i)-(1)] = (0.0 + (0.0)*1i)
			(*mwpcs)[(*i)-(1)] = (1.0 + (1.0)*1i)
		//Label80:
		}
		Zscal(func() *int{y := 5; return &y }(), ca, cx, incx)
		Ctest(func() *int{y := 5; return &y }(), cx, mwpct, mwpcs, sfac)
	} else if (*icase) == 9 {
		//*        Zdscal
		//*        Add a test for alpha equal to zero.
		(*sa) = 0.0
		for (*i) = 1; (*i) <= 5; (*i)++ {
			(*mwpct)[(*i)-(1)] = (0.0 + (0.0)*1i)
			(*mwpcs)[(*i)-(1)] = (1.0 + (1.0)*1i)
		//Label100:
		}
		Zdscal(func() *int{y := 5; return &y }(), sa, cx, incx)
		Ctest(func() *int{y := 5; return &y }(), cx, mwpct, mwpcs, sfac)
		//*        Add a test for alpha equal to one.
		(*sa) = 1.0
		for (*i) = 1; (*i) <= 5; (*i)++ {
			(*mwpct)[(*i)-(1)] = (*cx)[(*i)-(1)]
			(*mwpcs)[(*i)-(1)] = (*cx)[(*i)-(1)]
		//Label120:
		}
		Zdscal(func() *int{y := 5; return &y }(), sa, cx, incx)
		Ctest(func() *int{y := 5; return &y }(), cx, mwpct, mwpcs, sfac)
		//*        Add a test for alpha equal to minus one.
		(*sa) = -1.0
		for (*i) = 1; (*i) <= 5; (*i)++ {
			(*mwpct)[(*i)-(1)] = -(*cx)[(*i)-(1)]
			(*mwpcs)[(*i)-(1)] = -(*cx)[(*i)-(1)]
		//Label140:
		}
		Zdscal(func() *int{y := 5; return &y }(), sa, cx, incx)
		Ctest(func() *int{y := 5; return &y }(), cx, mwpct, mwpcs, sfac)
	}
	return
}

func Check2(sfac *float64) {
	nout := new(int)
	icase := new(int)
	incx := new(int)
	incy := new(int)
	mode := new(int)
	n := new(int)
	pass := new(bool)
	ca := new(complex128)
	i := new(int)
	j := new(int)
	ki := new(int)
	kn := new(int)
	ksize := new(int)
	lenx := new(int)
	leny := new(int)
	mx := new(int)
	my := new(int)
	cdot := func() *[]complex128 {
		arr := make([]complex128, 1)
		return &arr
	}()
	csize1 := func() *[]complex128 {
		arr := make([]complex128, 4)
		return &arr
	}()
	csize2 := func() *[][]complex128 {
		arr := make([][]complex128, 7)
		for u := 0; u < 7; u++ {
			arr[u] = make([]complex128, 2)
		}
		return &arr
	}()
	csize3 := func() *[]complex128 {
		arr := make([]complex128, 14)
		return &arr
	}()
	ct10x := func() *[][][]complex128 {
		arr := make([][][]complex128, 7)
		for u := 0; u < 7; u++ {
			arr[u] = make([][]complex128, 4)
			for w := 0; w < 4; w++ {
				arr[u][w] = make([]complex128, 4)
			}
		}
		return &arr
	}()
	ct10y := func() *[][][]complex128 {
		arr := make([][][]complex128, 7)
		for u := 0; u < 7; u++ {
			arr[u] = make([][]complex128, 4)
			for w := 0; w < 4; w++ {
				arr[u][w] = make([]complex128, 4)
			}
		}
		return &arr
	}()
	ct6 := func() *[][]complex128 {
		arr := make([][]complex128, 4)
		for u := 0; u < 4; u++ {
			arr[u] = make([]complex128, 4)
		}
		return &arr
	}()
	ct7 := func() *[][]complex128 {
		arr := make([][]complex128, 4)
		for u := 0; u < 4; u++ {
			arr[u] = make([]complex128, 4)
		}
		return &arr
	}()
	ct8 := func() *[][][]complex128 {
		arr := make([][][]complex128, 7)
		for u := 0; u < 7; u++ {
			arr[u] = make([][]complex128, 4)
			for w := 0; w < 4; w++ {
				arr[u][w] = make([]complex128, 4)
			}
		}
		return &arr
	}()
	cx := func() *[]complex128 {
		arr := make([]complex128, 7)
		return &arr
	}()
	cx1 := func() *[]complex128 {
		arr := make([]complex128, 7)
		return &arr
	}()
	cy := func() *[]complex128 {
		arr := make([]complex128, 7)
		return &arr
	}()
	cy1 := func() *[]complex128 {
		arr := make([]complex128, 7)
		return &arr
	}()
	incxs := func() *[]int {
		arr := make([]int, 4)
		return &arr
	}()
	incys := func() *[]int {
		arr := make([]int, 4)
		return &arr
	}()
	lens := func() *[][]int {
		arr := make([][]int, 4)
		for u := 0; u < 4; u++ {
			arr[u] = make([]int, 2)
		}
		return &arr
	}()
	ns := func() *[]int {
		arr := make([]int, 4)
		return &arr
	}()
	common.combla.pass = new(bool)
	common.combla.mode = new(int)
	common.combla.incy = new(int)
	common.combla.incx = new(int)
	common.combla.n = new(int)
	common.combla.icase = new(int)
	//*     .. Parameters ..
	(*nout) = 6
	//*     .. Scalar Arguments ..
	//*     .. Scalars in Common ..
	//*     .. Local Scalars ..
	//*     .. Local Arrays ..
	//*     .. External Functions ..
	//*     .. External Subroutines ..
	//*     .. Intrinsic Functions ..
	//*     .. Common blocks ..
	icase = common.combla.icase
	n = common.combla.n
	incx = common.combla.incx
	incy = common.combla.incy
	mode = common.combla.mode
	pass = common.combla.pass
	//*     .. Data statements ..
	(*ca) = (0.4 + (-0.7)*1i)
	(*incxs)[0], (*incxs)[1], (*incxs)[2], (*incxs)[3] = 1, 2, -2, -1
	(*incys)[0], (*incys)[1], (*incys)[2], (*incys)[3] = 1, -2, 1, -2
	(*lens)[0][0], (*lens)[1][0], (*lens)[2][0], (*lens)[3][0], (*lens)[0][1], (*lens)[1][1], (*lens)[2][1], (*lens)[3][1] = 1, 1, 2, 4, 1, 1, 3, 7
	(*ns)[0], (*ns)[1], (*ns)[2], (*ns)[3] = 0, 1, 2, 4
	(*cx1)[0], (*cx1)[1], (*cx1)[2], (*cx1)[3], (*cx1)[4], (*cx1)[5], (*cx1)[6] = (0.7 + (-0.8)*1i), (-0.4 + (-0.7)*1i), (-0.1 + (-0.9)*1i), (0.2 + (-0.8)*1i), (-0.9 + (-0.4)*1i), (0.1 + (0.4)*1i), (-0.6 + (0.6)*1i)
	(*cy1)[0], (*cy1)[1], (*cy1)[2], (*cy1)[3], (*cy1)[4], (*cy1)[5], (*cy1)[6] = (0.6 + (-0.6)*1i), (-0.9 + (0.5)*1i), (0.7 + (-0.6)*1i), (0.1 + (-0.5)*1i), (-0.1 + (-0.2)*1i), (-0.5 + (-0.3)*1i), (0.8 + (-0.7)*1i)
	(*ct8)[0][0][0], (*ct8)[1][0][0], (*ct8)[2][0][0], (*ct8)[3][0][0], (*ct8)[4][0][0], (*ct8)[5][0][0], (*ct8)[6][0][0], (*ct8)[0][1][0], (*ct8)[1][1][0], (*ct8)[2][1][0], (*ct8)[3][1][0], (*ct8)[4][1][0], (*ct8)[5][1][0], (*ct8)[6][1][0], (*ct8)[0][2][0], (*ct8)[1][2][0], (*ct8)[2][2][0], (*ct8)[3][2][0], (*ct8)[4][2][0], (*ct8)[5][2][0], (*ct8)[6][2][0], (*ct8)[0][3][0], (*ct8)[1][3][0], (*ct8)[2][3][0], (*ct8)[3][3][0], (*ct8)[4][3][0], (*ct8)[5][3][0], (*ct8)[6][3][0] = (0.6 + (-0.6)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.32 + (-1.41)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.32 + (-1.41)*1i), (-1.55 + (0.5)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.32 + (-1.41)*1i), (-1.55 + (0.5)*1i), (0.03 + (-0.89)*1i), (-0.38 + (-0.96)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i)
	(*ct8)[0][0][1], (*ct8)[1][0][1], (*ct8)[2][0][1], (*ct8)[3][0][1], (*ct8)[4][0][1], (*ct8)[5][0][1], (*ct8)[6][0][1], (*ct8)[0][1][1], (*ct8)[1][1][1], (*ct8)[2][1][1], (*ct8)[3][1][1], (*ct8)[4][1][1], (*ct8)[5][1][1], (*ct8)[6][1][1], (*ct8)[0][2][1], (*ct8)[1][2][1], (*ct8)[2][2][1], (*ct8)[3][2][1], (*ct8)[4][2][1], (*ct8)[5][2][1], (*ct8)[6][2][1], (*ct8)[0][3][1], (*ct8)[1][3][1], (*ct8)[2][3][1], (*ct8)[3][3][1], (*ct8)[4][3][1], (*ct8)[5][3][1], (*ct8)[6][3][1] = (0.6 + (-0.6)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.32 + (-1.41)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (-0.07 + (-0.89)*1i), (-0.9 + (0.5)*1i), (0.42 + (-1.41)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.78 + (0.06)*1i), (-0.9 + (0.5)*1i), (0.06 + (-0.13)*1i), (0.1 + (-0.5)*1i), (-0.77 + (-0.49)*1i), (-0.5 + (-0.3)*1i), (0.52 + (-1.51)*1i)
	(*ct8)[0][0][2], (*ct8)[1][0][2], (*ct8)[2][0][2], (*ct8)[3][0][2], (*ct8)[4][0][2], (*ct8)[5][0][2], (*ct8)[6][0][2], (*ct8)[0][1][2], (*ct8)[1][1][2], (*ct8)[2][1][2], (*ct8)[3][1][2], (*ct8)[4][1][2], (*ct8)[5][1][2], (*ct8)[6][1][2], (*ct8)[0][2][2], (*ct8)[1][2][2], (*ct8)[2][2][2], (*ct8)[3][2][2], (*ct8)[4][2][2], (*ct8)[5][2][2], (*ct8)[6][2][2], (*ct8)[0][3][2], (*ct8)[1][3][2], (*ct8)[2][3][2], (*ct8)[3][3][2], (*ct8)[4][3][2], (*ct8)[5][3][2], (*ct8)[6][3][2] = (0.6 + (-0.6)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.32 + (-1.41)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (-0.07 + (-0.89)*1i), (-1.18 + (-0.31)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.78 + (0.06)*1i), (-1.54 + (0.97)*1i), (0.03 + (-0.89)*1i), (-0.18 + (-1.31)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i)
	(*ct8)[0][0][3], (*ct8)[1][0][3], (*ct8)[2][0][3], (*ct8)[3][0][3], (*ct8)[4][0][3], (*ct8)[5][0][3], (*ct8)[6][0][3], (*ct8)[0][1][3], (*ct8)[1][1][3], (*ct8)[2][1][3], (*ct8)[3][1][3], (*ct8)[4][1][3], (*ct8)[5][1][3], (*ct8)[6][1][3], (*ct8)[0][2][3], (*ct8)[1][2][3], (*ct8)[2][2][3], (*ct8)[3][2][3], (*ct8)[4][2][3], (*ct8)[5][2][3], (*ct8)[6][2][3], (*ct8)[0][3][3], (*ct8)[1][3][3], (*ct8)[2][3][3], (*ct8)[3][3][3], (*ct8)[4][3][3], (*ct8)[5][3][3], (*ct8)[6][3][3] = (0.6 + (-0.6)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.32 + (-1.41)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.32 + (-1.41)*1i), (-0.9 + (0.5)*1i), (0.05 + (-0.6)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.32 + (-1.41)*1i), (-0.9 + (0.5)*1i), (0.05 + (-0.6)*1i), (0.1 + (-0.5)*1i), (-0.77 + (-0.49)*1i), (-0.5 + (-0.3)*1i), (0.32 + (-1.16)*1i)
	(*ct7)[0][0], (*ct7)[1][0], (*ct7)[2][0], (*ct7)[3][0], (*ct7)[0][1], (*ct7)[1][1], (*ct7)[2][1], (*ct7)[3][1], (*ct7)[0][2], (*ct7)[1][2], (*ct7)[2][2], (*ct7)[3][2], (*ct7)[0][3], (*ct7)[1][3], (*ct7)[2][3], (*ct7)[3][3] = (0.0 + (0.0)*1i), (-0.06 + (-0.90)*1i), (0.65 + (-0.47)*1i), (-0.34 + (-1.22)*1i), (0.0 + (0.0)*1i), (-0.06 + (-0.90)*1i), (-0.59 + (-1.46)*1i), (-1.04 + (-0.04)*1i), (0.0 + (0.0)*1i), (-0.06 + (-0.90)*1i), (-0.83 + (0.59)*1i), (0.07 + (-0.37)*1i), (0.0 + (0.0)*1i), (-0.06 + (-0.90)*1i), (-0.76 + (-1.15)*1i), (-1.33 + (-1.82)*1i)
	(*ct6)[0][0], (*ct6)[1][0], (*ct6)[2][0], (*ct6)[3][0], (*ct6)[0][1], (*ct6)[1][1], (*ct6)[2][1], (*ct6)[3][1], (*ct6)[0][2], (*ct6)[1][2], (*ct6)[2][2], (*ct6)[3][2], (*ct6)[0][3], (*ct6)[1][3], (*ct6)[2][3], (*ct6)[3][3] = (0.0 + (0.0)*1i), (0.90 + (0.06)*1i), (0.91 + (-0.77)*1i), (1.80 + (-0.10)*1i), (0.0 + (0.0)*1i), (0.90 + (0.06)*1i), (1.45 + (0.74)*1i), (0.20 + (0.90)*1i), (0.0 + (0.0)*1i), (0.90 + (0.06)*1i), (-0.55 + (0.23)*1i), (0.83 + (-0.39)*1i), (0.0 + (0.0)*1i), (0.90 + (0.06)*1i), (1.04 + (0.79)*1i), (1.95 + (1.22)*1i)
	(*ct10x)[0][0][0], (*ct10x)[1][0][0], (*ct10x)[2][0][0], (*ct10x)[3][0][0], (*ct10x)[4][0][0], (*ct10x)[5][0][0], (*ct10x)[6][0][0], (*ct10x)[0][1][0], (*ct10x)[1][1][0], (*ct10x)[2][1][0], (*ct10x)[3][1][0], (*ct10x)[4][1][0], (*ct10x)[5][1][0], (*ct10x)[6][1][0], (*ct10x)[0][2][0], (*ct10x)[1][2][0], (*ct10x)[2][2][0], (*ct10x)[3][2][0], (*ct10x)[4][2][0], (*ct10x)[5][2][0], (*ct10x)[6][2][0], (*ct10x)[0][3][0], (*ct10x)[1][3][0], (*ct10x)[2][3][0], (*ct10x)[3][3][0], (*ct10x)[4][3][0], (*ct10x)[5][3][0], (*ct10x)[6][3][0] = (0.7 + (-0.8)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.6 + (-0.6)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.6 + (-0.6)*1i), (-0.9 + (0.5)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.6 + (-0.6)*1i), (-0.9 + (0.5)*1i), (0.7 + (-0.6)*1i), (0.1 + (-0.5)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i)
	(*ct10x)[0][0][1], (*ct10x)[1][0][1], (*ct10x)[2][0][1], (*ct10x)[3][0][1], (*ct10x)[4][0][1], (*ct10x)[5][0][1], (*ct10x)[6][0][1], (*ct10x)[0][1][1], (*ct10x)[1][1][1], (*ct10x)[2][1][1], (*ct10x)[3][1][1], (*ct10x)[4][1][1], (*ct10x)[5][1][1], (*ct10x)[6][1][1], (*ct10x)[0][2][1], (*ct10x)[1][2][1], (*ct10x)[2][2][1], (*ct10x)[3][2][1], (*ct10x)[4][2][1], (*ct10x)[5][2][1], (*ct10x)[6][2][1], (*ct10x)[0][3][1], (*ct10x)[1][3][1], (*ct10x)[2][3][1], (*ct10x)[3][3][1], (*ct10x)[4][3][1], (*ct10x)[5][3][1], (*ct10x)[6][3][1] = (0.7 + (-0.8)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.6 + (-0.6)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.7 + (-0.6)*1i), (-0.4 + (-0.7)*1i), (0.6 + (-0.6)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.8 + (-0.7)*1i), (-0.4 + (-0.7)*1i), (-0.1 + (-0.2)*1i), (0.2 + (-0.8)*1i), (0.7 + (-0.6)*1i), (0.1 + (0.4)*1i), (0.6 + (-0.6)*1i)
	(*ct10x)[0][0][2], (*ct10x)[1][0][2], (*ct10x)[2][0][2], (*ct10x)[3][0][2], (*ct10x)[4][0][2], (*ct10x)[5][0][2], (*ct10x)[6][0][2], (*ct10x)[0][1][2], (*ct10x)[1][1][2], (*ct10x)[2][1][2], (*ct10x)[3][1][2], (*ct10x)[4][1][2], (*ct10x)[5][1][2], (*ct10x)[6][1][2], (*ct10x)[0][2][2], (*ct10x)[1][2][2], (*ct10x)[2][2][2], (*ct10x)[3][2][2], (*ct10x)[4][2][2], (*ct10x)[5][2][2], (*ct10x)[6][2][2], (*ct10x)[0][3][2], (*ct10x)[1][3][2], (*ct10x)[2][3][2], (*ct10x)[3][3][2], (*ct10x)[4][3][2], (*ct10x)[5][3][2], (*ct10x)[6][3][2] = (0.7 + (-0.8)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.6 + (-0.6)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (-0.9 + (0.5)*1i), (-0.4 + (-0.7)*1i), (0.6 + (-0.6)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.1 + (-0.5)*1i), (-0.4 + (-0.7)*1i), (0.7 + (-0.6)*1i), (0.2 + (-0.8)*1i), (-0.9 + (0.5)*1i), (0.1 + (0.4)*1i), (0.6 + (-0.6)*1i)
	(*ct10x)[0][0][3], (*ct10x)[1][0][3], (*ct10x)[2][0][3], (*ct10x)[3][0][3], (*ct10x)[4][0][3], (*ct10x)[5][0][3], (*ct10x)[6][0][3], (*ct10x)[0][1][3], (*ct10x)[1][1][3], (*ct10x)[2][1][3], (*ct10x)[3][1][3], (*ct10x)[4][1][3], (*ct10x)[5][1][3], (*ct10x)[6][1][3], (*ct10x)[0][2][3], (*ct10x)[1][2][3], (*ct10x)[2][2][3], (*ct10x)[3][2][3], (*ct10x)[4][2][3], (*ct10x)[5][2][3], (*ct10x)[6][2][3], (*ct10x)[0][3][3], (*ct10x)[1][3][3], (*ct10x)[2][3][3], (*ct10x)[3][3][3], (*ct10x)[4][3][3], (*ct10x)[5][3][3], (*ct10x)[6][3][3] = (0.7 + (-0.8)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.6 + (-0.6)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.6 + (-0.6)*1i), (0.7 + (-0.6)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.6 + (-0.6)*1i), (0.7 + (-0.6)*1i), (-0.1 + (-0.2)*1i), (0.8 + (-0.7)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i)
	(*ct10y)[0][0][0], (*ct10y)[1][0][0], (*ct10y)[2][0][0], (*ct10y)[3][0][0], (*ct10y)[4][0][0], (*ct10y)[5][0][0], (*ct10y)[6][0][0], (*ct10y)[0][1][0], (*ct10y)[1][1][0], (*ct10y)[2][1][0], (*ct10y)[3][1][0], (*ct10y)[4][1][0], (*ct10y)[5][1][0], (*ct10y)[6][1][0], (*ct10y)[0][2][0], (*ct10y)[1][2][0], (*ct10y)[2][2][0], (*ct10y)[3][2][0], (*ct10y)[4][2][0], (*ct10y)[5][2][0], (*ct10y)[6][2][0], (*ct10y)[0][3][0], (*ct10y)[1][3][0], (*ct10y)[2][3][0], (*ct10y)[3][3][0], (*ct10y)[4][3][0], (*ct10y)[5][3][0], (*ct10y)[6][3][0] = (0.6 + (-0.6)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.7 + (-0.8)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.7 + (-0.8)*1i), (-0.4 + (-0.7)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.7 + (-0.8)*1i), (-0.4 + (-0.7)*1i), (-0.1 + (-0.9)*1i), (0.2 + (-0.8)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i)
	(*ct10y)[0][0][1], (*ct10y)[1][0][1], (*ct10y)[2][0][1], (*ct10y)[3][0][1], (*ct10y)[4][0][1], (*ct10y)[5][0][1], (*ct10y)[6][0][1], (*ct10y)[0][1][1], (*ct10y)[1][1][1], (*ct10y)[2][1][1], (*ct10y)[3][1][1], (*ct10y)[4][1][1], (*ct10y)[5][1][1], (*ct10y)[6][1][1], (*ct10y)[0][2][1], (*ct10y)[1][2][1], (*ct10y)[2][2][1], (*ct10y)[3][2][1], (*ct10y)[4][2][1], (*ct10y)[5][2][1], (*ct10y)[6][2][1], (*ct10y)[0][3][1], (*ct10y)[1][3][1], (*ct10y)[2][3][1], (*ct10y)[3][3][1], (*ct10y)[4][3][1], (*ct10y)[5][3][1], (*ct10y)[6][3][1] = (0.6 + (-0.6)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.7 + (-0.8)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (-0.1 + (-0.9)*1i), (-0.9 + (0.5)*1i), (0.7 + (-0.8)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (-0.6 + (0.6)*1i), (-0.9 + (0.5)*1i), (-0.9 + (-0.4)*1i), (0.1 + (-0.5)*1i), (-0.1 + (-0.9)*1i), (-0.5 + (-0.3)*1i), (0.7 + (-0.8)*1i)
	(*ct10y)[0][0][2], (*ct10y)[1][0][2], (*ct10y)[2][0][2], (*ct10y)[3][0][2], (*ct10y)[4][0][2], (*ct10y)[5][0][2], (*ct10y)[6][0][2], (*ct10y)[0][1][2], (*ct10y)[1][1][2], (*ct10y)[2][1][2], (*ct10y)[3][1][2], (*ct10y)[4][1][2], (*ct10y)[5][1][2], (*ct10y)[6][1][2], (*ct10y)[0][2][2], (*ct10y)[1][2][2], (*ct10y)[2][2][2], (*ct10y)[3][2][2], (*ct10y)[4][2][2], (*ct10y)[5][2][2], (*ct10y)[6][2][2], (*ct10y)[0][3][2], (*ct10y)[1][3][2], (*ct10y)[2][3][2], (*ct10y)[3][3][2], (*ct10y)[4][3][2], (*ct10y)[5][3][2], (*ct10y)[6][3][2] = (0.6 + (-0.6)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.7 + (-0.8)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (-0.1 + (-0.9)*1i), (0.7 + (-0.8)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (-0.6 + (0.6)*1i), (-0.9 + (-0.4)*1i), (-0.1 + (-0.9)*1i), (0.7 + (-0.8)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i)
	(*ct10y)[0][0][3], (*ct10y)[1][0][3], (*ct10y)[2][0][3], (*ct10y)[3][0][3], (*ct10y)[4][0][3], (*ct10y)[5][0][3], (*ct10y)[6][0][3], (*ct10y)[0][1][3], (*ct10y)[1][1][3], (*ct10y)[2][1][3], (*ct10y)[3][1][3], (*ct10y)[4][1][3], (*ct10y)[5][1][3], (*ct10y)[6][1][3], (*ct10y)[0][2][3], (*ct10y)[1][2][3], (*ct10y)[2][2][3], (*ct10y)[3][2][3], (*ct10y)[4][2][3], (*ct10y)[5][2][3], (*ct10y)[6][2][3], (*ct10y)[0][3][3], (*ct10y)[1][3][3], (*ct10y)[2][3][3], (*ct10y)[3][3][3], (*ct10y)[4][3][3], (*ct10y)[5][3][3], (*ct10y)[6][3][3] = (0.6 + (-0.6)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.7 + (-0.8)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.7 + (-0.8)*1i), (-0.9 + (0.5)*1i), (-0.4 + (-0.7)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.7 + (-0.8)*1i), (-0.9 + (0.5)*1i), (-0.4 + (-0.7)*1i), (0.1 + (-0.5)*1i), (-0.1 + (-0.9)*1i), (-0.5 + (-0.3)*1i), (0.2 + (-0.8)*1i)
	(*csize1)[0], (*csize1)[1], (*csize1)[2], (*csize1)[3] = (0.0 + (0.0)*1i), (0.9 + (0.9)*1i), (1.63 + (1.73)*1i), (2.90 + (2.78)*1i)
	(*csize3)[0], (*csize3)[1], (*csize3)[2], (*csize3)[3], (*csize3)[4], (*csize3)[5], (*csize3)[6], (*csize3)[7], (*csize3)[8], (*csize3)[9], (*csize3)[10], (*csize3)[11], (*csize3)[12], (*csize3)[13] = (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (1.17 + (1.17)*1i), (1.17 + (1.17)*1i), (1.17 + (1.17)*1i), (1.17 + (1.17)*1i), (1.17 + (1.17)*1i), (1.17 + (1.17)*1i), (1.17 + (1.17)*1i)
	(*csize2)[0][0], (*csize2)[1][0], (*csize2)[2][0], (*csize2)[3][0], (*csize2)[4][0], (*csize2)[5][0], (*csize2)[6][0], (*csize2)[0][1], (*csize2)[1][1], (*csize2)[2][1], (*csize2)[3][1], (*csize2)[4][1], (*csize2)[5][1], (*csize2)[6][1] = (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (0.0 + (0.0)*1i), (1.54 + (1.54)*1i), (1.54 + (1.54)*1i), (1.54 + (1.54)*1i), (1.54 + (1.54)*1i), (1.54 + (1.54)*1i), (1.54 + (1.54)*1i), (1.54 + (1.54)*1i)
	//*     .. Executable Statements ..
	for (*ki) = 1; (*ki) <= 4; (*ki)++ {
		(*incx) = (*incxs)[(*ki)-(1)]
		(*incy) = (*incys)[(*ki)-(1)]
		(*mx) = (ABS((*incx)))
		(*my) = (ABS((*incy)))
		//*
		for (*kn) = 1; (*kn) <= 4; (*kn)++ {
			(*n) = (*ns)[(*kn)-(1)]
			(*ksize) = (MIN(int(2), (*kn)))
			(*lenx) = (*lens)[(*kn)-(1)][(*mx)-(1)]
			(*leny) = (*lens)[(*kn)-(1)][(*my)-(1)]
			//*           .. initialize all argument arrays ..
			for (*i) = 1; (*i) <= 7; (*i)++ {
				(*cx)[(*i)-(1)] = (*cx1)[(*i)-(1)]
				(*cy)[(*i)-(1)] = (*cy1)[(*i)-(1)]
			//Label20:
			}
			if (*icase) == 1 {
				//*              .. Zdotc ..
				(*cdot)[0] = (*Zdotc(n, cx, incx, cy, incy))
				Ctest(func() *int{y := 1; return &y }(), cdot, &((*ct6)[(*kn)-(1)][(*ki)-(1)]), &((*csize1)[(*kn)-(1)]), sfac)
			} else if (*icase) == 2 {
				//*              .. Zdotu ..
				(*cdot)[0] = (*Zdotu(n, cx, incx, cy, incy))
				Ctest(func() *int{y := 1; return &y }(), cdot, &((*ct7)[(*kn)-(1)][(*ki)-(1)]), &((*csize1)[(*kn)-(1)]), sfac)
			} else if (*icase) == 3 {
				//*              .. Zaxpy ..
				Zaxpy(n, ca, cx, incx, cy, incy)
				Ctest(leny, cy, &((*ct8)[0][(*kn)-(1)][(*ki)-(1)]), &((*csize2)[0][(*ksize)-(1)]), sfac)
			} else if (*icase) == 4 {
				//*              .. Zcopy ..
				Zcopy(n, cx, incx, cy, incy)
				Ctest(leny, cy, &((*ct10y)[0][(*kn)-(1)][(*ki)-(1)]), csize3, func() *float64{y := 1.0; return &y }())
			} else if (*icase) == 5 {
				//*              .. Zswap ..
				Zswap(n, cx, incx, cy, incy)
				Ctest(lenx, cx, &((*ct10x)[0][(*kn)-(1)][(*ki)-(1)]), csize3, func() *float64{y := 1.0; return &y }())
				Ctest(leny, cy, &((*ct10y)[0][(*kn)-(1)][(*ki)-(1)]), csize3, func() *float64{y := 1.0; return &y }())
			} else {
				WRITE((*nout), *func() *[]byte{y := []byte(" %v\n"); return &y }(), *func() *[]byte{y := []byte(" shouldn't be here in check2"); return &y }())
				panic("")
			}
			//*
		//Label40:
		}
	//Label60:
	}
	return
}

func Stest(_len *int, scomp *[]float64, strue *[]float64, ssize *[]float64, sfac *float64) {
	nout := new(int)
	zero := new(float64)
	len := new(int)
	icase := new(int)
	incx := new(int)
	incy := new(int)
	mode := new(int)
	n := new(int)
	pass := new(bool)
	sd := new(float64)
	i := new(int)
	common.combla.pass = new(bool)
	common.combla.mode = new(int)
	common.combla.incy = new(int)
	common.combla.incx = new(int)
	common.combla.n = new(int)
	common.combla.icase = new(int)
	//*     ********************************* Stest **************************
	//*
	//*     THIS SUBR COMPARES ARRAYS  SCOMP() AND STRUE() OF LENGTH LEN TO
	//*     SEE IF THE TERM BY TERM DIFFERENCES, MULTIPLIED BY SFAC, ARE
	//*     NEGLIGIBLE.
	//*
	//*     C. L. LAWSON, JPL, 1974 DEC 10
	//*
	//*     .. Parameters ..
	(*nout) = 6
	(*zero) = 0.0
	//*     .. Scalar Arguments ..
	//*     .. Array Arguments ..
	//*     .. Scalars in Common ..
	//*     .. Local Scalars ..
	//*     .. External Functions ..
	//*     .. Intrinsic Functions ..
	//*     .. Common blocks ..
	icase = common.combla.icase
	n = common.combla.n
	incx = common.combla.incx
	incy = common.combla.incy
	mode = common.combla.mode
	pass = common.combla.pass
	//*     .. Executable Statements ..
	//*
	for (*i) = 1; (*i) <= (*len); (*i)++ {
		(*sd) = (*scomp)[(*i)-(1)] - (*strue)[(*i)-(1)]
		if (*ABS((*sfac) * (*sd)) <= ABS(&((*ssize)[(*i)-(1)]))) * (EPSILON((*zero))) {
			goto Label40
		}
		//*
		//*                             HERE    SCOMP(I) IS NOT CLOSE TO STRUE(I).
		//*
		if !(*pass) {
			goto Label20
		}
		//*                             PRINT FAIL MESSAGE AND Header.
		(*pass) = false
		WRITE((*nout), *func() *[]byte{y := []byte("                                       fail\n"); return &y }())
		WRITE((*nout), *func() *[]byte{y := []byte("\n case  n incx incy mode  i                             comp(i)                             true(i)  difference     size(i)\n \n"); return &y }())
	Label20:
		;
		WRITE((*nout), *func() *[]byte{y := []byte(" %4d%3d%5d%3d%v%v%v%v\n"); return &y }(), (*icase), (*n), (*incx), (*incy), (*mode), (*i), (*scomp)[(*i)-(1)], (*strue)[(*i)-(1)], (*sd), (*ssize)[(*i)-(1)])
	Label40:
	}
	return
	//*
}

func Stest1(scomp1 *float64, strue1 *float64, ssize *[]float64, sfac *float64) {
	scomp := func() *[]float64 {
		arr := make([]float64, 1)
		return &arr
	}()
	strue := func() *[]float64 {
		arr := make([]float64, 1)
		return &arr
	}()
	//*     ************************* Stest1 *****************************
	//*
	//*     THIS IS AN INTERFACE SUBROUTINE TO ACCOMMODATE THE FORTRAN
	//*     REQUIREMENT THAT WHEN A DUMMY ARGUMENT IS AN ARRAY, THE
	//*     ACTUAL ARGUMENT MUST ALSO BE AN ARRAY OR AN ARRAY ELEMENT.
	//*
	//*     C.L. LAWSON, JPL, 1978 DEC 6
	//*
	//*     .. Scalar Arguments ..
	//*     .. Array Arguments ..
	//*     .. Local Arrays ..
	//*     .. External Subroutines ..
	//*     .. Executable Statements ..
	//*
	(*scomp)[0] = (*scomp1)
	(*strue)[0] = (*strue1)
	Stest(func() *int{y := 1; return &y }(), scomp, strue, ssize, sfac)
	//*
	return
}

func Sdiff(sa *float64, sb *float64) (sdiffReturn *float64) {
	sdiffreturn := new(float64)
	//*     ********************************* SDIFF **************************
	//*     COMPUTES DIFFERENCE OF TWO NUMBERS.  C. L. LAWSON, JPL 1974 FEB 15
	//*
	//*     .. Scalar Arguments ..
	//*     .. Executable Statements ..
	(*sdiff) = (*sa) - (*sb)
	return
}

func Ctest(_len *int, ccomp *[]complex128, ctrue *[]complex128, csize *[]complex128, sfac *float64) {
	len := new(int)
	i := new(int)
	scomp := func() *[]float64 {
		arr := make([]float64, 20)
		return &arr
	}()
	ssize := func() *[]float64 {
		arr := make([]float64, 20)
		return &arr
	}()
	strue := func() *[]float64 {
		arr := make([]float64, 20)
		return &arr
	}()
	//*     **************************** Ctest *****************************
	//*
	//*     C.L. LAWSON, JPL, 1978 DEC 6
	//*
	//*     .. Scalar Arguments ..
	//*     .. Array Arguments ..
	//*     .. Local Scalars ..
	//*     .. Local Arrays ..
	//*     .. External Subroutines ..
	//*     .. Intrinsic Functions ..
	//*     .. Executable Statements ..
	for (*i) = 1; (*i) <= (*len); (*i)++ {
		(*scomp)[2*(*i)-0] = (DBLE(((*ccomp)[(*i)-(1)])))
		(*scomp)[2*(*i)-(1)] = (*DIMAG(&((*ccomp)[(*i)-(1)])))
		(*strue)[2*(*i)-0] = (DBLE(((*ctrue)[(*i)-(1)])))
		(*strue)[2*(*i)-(1)] = (*DIMAG(&((*ctrue)[(*i)-(1)])))
		(*ssize)[2*(*i)-0] = (DBLE(((*csize)[(*i)-(1)])))
		(*ssize)[2*(*i)-(1)] = (*DIMAG(&((*csize)[(*i)-(1)])))
	//Label20:
	}
	//*
	Stest(2*(*len), scomp, strue, ssize, sfac)
	return
}

func Itest1(icomp *int, itrue *int) {
	nout := new(int)
	icase := new(int)
	incx := new(int)
	incy := new(int)
	mode := new(int)
	n := new(int)
	pass := new(bool)
	id := new(int)
	common.combla.pass = new(bool)
	common.combla.mode = new(int)
	common.combla.incy = new(int)
	common.combla.incx = new(int)
	common.combla.n = new(int)
	common.combla.icase = new(int)
	//*     ********************************* Itest1 *************************
	//*
	//*     THIS SUBROUTINE COMPARES THE VARIABLES ICOMP AND ITRUE FOR
	//*     EQUALITY.
	//*     C. L. LAWSON, JPL, 1974 DEC 10
	//*
	//*     .. Parameters ..
	(*nout) = 6
	//*     .. Scalar Arguments ..
	//*     .. Scalars in Common ..
	//*     .. Local Scalars ..
	//*     .. Common blocks ..
	icase = common.combla.icase
	n = common.combla.n
	incx = common.combla.incx
	incy = common.combla.incy
	mode = common.combla.mode
	pass = common.combla.pass
	//*     .. Executable Statements ..
	if (*icomp) == (*itrue) {
		goto Label40
	}
	//*
	//*                            HERE ICOMP IS NOT EQUAL TO ITRUE.
	//*
	if !(*pass) {
		goto Label20
	}
	//*                             PRINT FAIL MESSAGE AND Header.
	(*pass) = false
	WRITE((*nout), *func() *[]byte{y := []byte("                                       fail\n"); return &y }())
	WRITE((*nout), *func() *[]byte{y := []byte("\n case  n incx incy mode                                comp                                true     difference\n \n"); return &y }())
Label20:
	;
	(*id) = (*icomp) - (*itrue)
	WRITE((*nout), *func() *[]byte{y := []byte(" %4d%3d%5d%36d%12d\n"); return &y }(), (*icase), (*n), (*incx), (*incy), (*mode), (*icomp), (*itrue), (*id))
Label40:
	;
	return
	//*
}
