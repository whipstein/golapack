package goblas

import (
	"fmt"
	"math/cmplx"
	"testing"
)

var zglobal complex128

// BLAS Level 1
func TestDznrm2(t *testing.T) {
	tname := "Dznrm2"
	var nc int
	n := new(int)
	incx := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 8); return &y }()
	res := func() *[]float64 { y := make([]float64, 1); return &y }()
	var dznrm2Tests = []struct {
		n      int
		len    int
		sa     complex128
		sx     []complex128
		incx   int
		result []float64
	}{
		{0, 2, 0.3000, []complex128{(0.1000 + 0.1000i), (1.0000 + 2.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []float64{0.0000}},
		{1, 2, 0.3000, []complex128{(0.3000 - 0.4000i), (3.0000 + 4.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []float64{0.5000}},
		{2, 4, 0.3000, []complex128{(0.1000 - 0.3000i), (0.5000 - 0.1000i), (5.0000 + 6.0000i), (5.0000 + 6.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []float64{0.6000}},
		{3, 6, 0.3000, []complex128{(0.1000 + 0.1000i), (-0.6000 + 0.1000i), (0.1000 - 0.3000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []float64{0.7000}},
		{4, 8, 0.3000, []complex128{(0.3000 + 0.1000i), (0.5000 + 0.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 1, []float64{0.8000}},
		{0, 2, 0.3000, []complex128{(0.1000 + 0.1000i), (4.0000 + 5.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []float64{0.0000}},
		{1, 2, 0.3000, []complex128{(0.3000 - 0.4000i), (6.0000 + 7.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []float64{0.5000}},
		{2, 4, 0.3000, []complex128{(0.1000 - 0.3000i), (8.0000 + 9.0000i), (0.5000 - 0.1000i), (2.0000 + 5.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []float64{0.6000}},
		{3, 6, 0.3000, []complex128{(0.1000 + 0.1000i), (3.0000 + 6.0000i), (-0.6000 + 0.1000i), (4.0000 + 7.0000i), (0.1000 - 0.3000i), (7.0000 + 2.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []float64{0.7000}},
		{4, 8, 0.3000, []complex128{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}, 2, []float64{0.8000}},
	}

	for _, test := range dznrm2Tests {
		*n = test.n
		*incx = test.incx
		for j := 0; j < 8; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		(*res)[0] = Dznrm2(n, sx, incx)
		dTest(t, nc, *onei, res, &test.result, &test.result, &dfac, "result")
	}

	printTestsRun(tname, nc)
}

func BenchmarkDznrm2(b *testing.B) {
	var res float64
	n := new(int)
	incx := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 8); return &y }()
	*n = 4
	*incx = 2

	for i := 0; i < b.N; i++ {
		res = Dznrm2(n, sx, incx)
	}
	dglobal = res
}

func BenchmarkDznrm2Fortran(b *testing.B) {
	var res float64
	n := new(int)
	incx := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 8); return &y }()
	*n = 4
	*incx = 2

	for i := 0; i < b.N; i++ {
		res = dznrm2Wrapper(n, sx, incx)
	}
	dglobal = res
}

func TestDzasum(t *testing.T) {
	tname := "Dzasum"
	var nc int
	n := new(int)
	incx := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 8); return &y }()
	res := func() *[]float64 { y := make([]float64, 1); return &y }()
	var dzasumTests = []struct {
		n      int
		len    int
		sx     []complex128
		incx   int
		result []float64
	}{
		{0, 2, []complex128{(0.1000 + 0.1000i), (1.0000 + 2.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []float64{0.0000}},
		{1, 2, []complex128{(0.3000 - 0.4000i), (3.0000 + 4.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []float64{0.7000}},
		{2, 4, []complex128{(0.1000 - 0.3000i), (0.5000 - 0.1000i), (5.0000 + 6.0000i), (5.0000 + 6.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []float64{1.0000}},
		{3, 6, []complex128{(0.1000 + 0.1000i), (-0.6000 + 0.1000i), (0.1000 - 0.3000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []float64{1.3000}},
		{4, 8, []complex128{(0.3000 + 0.1000i), (0.5000 + 0.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 1, []float64{1.6000}},
		{0, 2, []complex128{(0.1000 + 0.1000i), (4.0000 + 5.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []float64{0.0000}},
		{1, 2, []complex128{(0.3000 - 0.4000i), (6.0000 + 7.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []float64{0.7000}},
		{2, 4, []complex128{(0.1000 - 0.3000i), (8.0000 + 9.0000i), (0.5000 - 0.1000i), (2.0000 + 5.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []float64{1.0000}},
		{3, 6, []complex128{(0.1000 + 0.1000i), (3.0000 + 6.0000i), (-0.6000 + 0.1000i), (4.0000 + 7.0000i), (0.1000 - 0.3000i), (7.0000 + 2.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []float64{1.3000}},
		{4, 8, []complex128{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}, 2, []float64{1.6000}},
	}

	for _, test := range dzasumTests {
		*n = test.n
		*incx = test.incx
		for j := 0; j < 8; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		(*res)[0] = Dzasum(n, sx, incx)
		dTest(t, nc, *onei, res, &test.result, &test.result, &dfac, "result")
	}

	printTestsRun(tname, nc)
}

func BenchmarkDzasum(b *testing.B) {
	var res float64
	n := new(int)
	incx := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 8); return &y }()
	*n = 4
	*incx = 2

	for i := 0; i < b.N; i++ {
		res = Dzasum(n, sx, incx)
	}
	dglobal = res
}

func BenchmarkDzasumFortran(b *testing.B) {
	var res float64
	n := new(int)
	incx := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 8); return &y }()
	*n = 4
	*incx = 2

	for i := 0; i < b.N; i++ {
		res = dzasumWrapper(n, sx, incx)
	}
	dglobal = res
}

func TestZscal(t *testing.T) {
	tname := "Zscal"
	var nc int
	n := new(int)
	incx := new(int)
	sa := new(complex128)
	sx := func() *[]complex128 { y := make([]complex128, 8); return &y }()
	var zscalTests = []struct {
		n      int
		len    int
		sa     complex128
		sx     []complex128
		incx   int
		sxtrue []complex128
	}{
		{0, 2, (0.4000 - 0.7000i), []complex128{(0.1000 + 0.1000i), (1.0000 + 2.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []complex128{(0.1000 + 0.1000i), (1.0000 + 2.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{1, 2, (0.4000 - 0.7000i), []complex128{(0.3000 - 0.4000i), (3.0000 + 4.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []complex128{(-0.1600 - 0.3700i), (3.0000 + 4.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{2, 4, (0.4000 - 0.7000i), []complex128{(0.1000 - 0.3000i), (0.5000 - 0.1000i), (5.0000 + 6.0000i), (5.0000 + 6.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []complex128{(-0.1700 - 0.1900i), (0.1300 - 0.3900i), (5.0000 + 6.0000i), (5.0000 + 6.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{3, 6, (0.4000 - 0.7000i), []complex128{(0.1000 + 0.1000i), (-0.6000 + 0.1000i), (0.1000 - 0.3000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []complex128{(0.1100 - 0.0300i), (-0.1700 + 0.4600i), (-0.1700 - 0.1900i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{4, 8, (0.4000 - 0.7000i), []complex128{(0.3000 + 0.1000i), (0.5000 + 0.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 1, []complex128{(0.1900 - 0.1700i), (0.2000 - 0.3500i), (0.3500 + 0.2000i), (0.1400 + 0.0800i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}},
		{0, 2, (0.4000 - 0.7000i), []complex128{(0.1000 + 0.1000i), (4.0000 + 5.0000i), (0.3500 + 0.2000i), (0.1400 + 0.0800i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []complex128{(0.1000 + 0.1000i), (4.0000 + 5.0000i), (0.3500 + 0.2000i), (0.1400 + 0.0800i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}},
		{1, 2, (0.4000 - 0.7000i), []complex128{(0.3000 - 0.4000i), (6.0000 + 7.0000i), (0.3500 + 0.2000i), (0.1400 + 0.0800i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []complex128{(-0.1600 - 0.3700i), (6.0000 + 7.0000i), (0.3500 + 0.2000i), (0.1400 + 0.0800i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}},
		{2, 4, (0.4000 - 0.7000i), []complex128{(0.1000 - 0.3000i), (8.0000 + 9.0000i), (0.5000 - 0.1000i), (2.0000 + 5.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []complex128{(-0.1700 - 0.1900i), (8.0000 + 9.0000i), (0.1300 - 0.3900i), (2.0000 + 5.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}},
		{3, 6, (0.4000 - 0.7000i), []complex128{(0.1000 + 0.1000i), (3.0000 + 6.0000i), (-0.6000 + 0.1000i), (4.0000 + 7.0000i), (0.1000 - 0.3000i), (7.0000 + 2.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []complex128{(0.1100 - 0.0300i), (3.0000 + 6.0000i), (-0.1700 + 0.4600i), (4.0000 + 7.0000i), (-0.1700 - 0.1900i), (7.0000 + 2.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}},
		{4, 8, (0.4000 - 0.7000i), []complex128{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}, 2, []complex128{(0.1900 - 0.1700i), (5.0000 + 8.0000i), (0.2000 - 0.3500i), (6.0000 + 9.0000i), (0.3500 + 0.2000i), (8.0000 + 3.0000i), (0.1400 + 0.0800i), (9.0000 + 4.0000i)}},
	}

	for _, test := range zscalTests {
		*n = test.n
		*incx = test.incx
		*sa = test.sa
		for j := 0; j < 8; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		Zscal(n, sa, sx, incx)
		zTest(t, nc, test.len, sx, &test.sxtrue, &test.sxtrue, &dfac, "sx")
	}

	printTestsRun(tname, nc)
}

func BenchmarkZscal(b *testing.B) {
	n := new(int)
	incx := new(int)
	sa := new(complex128)
	sx := func() *[]complex128 { y := make([]complex128, 8); return &y }()
	*n = 4
	*incx = 2
	*sa = (0.4000 - 0.7000i)

	for i := 0; i < b.N; i++ {
		Zscal(n, sa, sx, incx)
	}
}

func BenchmarkZscalFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	sa := new(complex128)
	sx := func() *[]complex128 { y := make([]complex128, 8); return &y }()
	*n = 4
	*incx = 2
	*sa = (0.4000 - 0.7000i)

	for i := 0; i < b.N; i++ {
		zscalWrapper(n, sa, sx, incx)
	}
}

func TestZdscal(t *testing.T) {
	tname := "Zdscal"
	var nc int
	n := new(int)
	incx := new(int)
	sa := new(float64)
	sx := func() *[]complex128 { y := make([]complex128, 8); return &y }()
	var zdscalTests = []struct {
		n      int
		len    int
		sa     float64
		sx     []complex128
		incx   int
		sxtrue []complex128
		ssize  []complex128
	}{
		{5, 5, 0.0000, []complex128{(0.0900 + 0.0300i), (5.0000 + 8.0000i), (0.1500 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.1500i)}, 1, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(1.0000 + 1.0000i), (1.0000 + 1.0000i), (1.0000 + 1.0000i), (1.0000 + 1.0000i), (1.0000 + 1.0000i)}},
		{5, 5, 1.0000, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{5, 5, -1.0000, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []complex128{(-0.0000 - 0.0000i), (-0.0000 - 0.0000i), (-0.0000 - 0.0000i), (-0.0000 - 0.0000i), (-0.0000 - 0.0000i)}, []complex128{(-0.0000 - 0.0000i), (-0.0000 - 0.0000i), (-0.0000 - 0.0000i), (-0.0000 - 0.0000i), (-0.0000 - 0.0000i)}},
	}

	for _, test := range zdscalTests {
		*n = test.n
		*incx = test.incx
		*sa = test.sa
		for j := 0; j < test.len; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		Zdscal(n, sa, sx, incx)
		zTest(t, nc, test.len, sx, &test.sxtrue, &test.ssize, &dfac, "sx")
	}

	printTestsRun(tname, nc)
}

func BenchmarkZdscal(b *testing.B) {
	n := new(int)
	incx := new(int)
	sa := new(float64)
	sx := func() *[]complex128 { y := make([]complex128, 8); return &y }()
	*n = 5
	*incx = 1
	*sa = -1.0000

	for i := 0; i < b.N; i++ {
		Zdscal(n, sa, sx, incx)
	}
}

func BenchmarkZdscalFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	sa := new(float64)
	sx := func() *[]complex128 { y := make([]complex128, 8); return &y }()
	*n = 5
	*incx = 1
	*sa = -1.0000

	for i := 0; i < b.N; i++ {
		zdscalWrapper(n, sa, sx, incx)
	}
}

func TestIzamax(t *testing.T) {
	tname := "Izamax"
	var nc, res int
	n := new(int)
	incx := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 8); return &y }()
	var izamaxTests = []struct {
		n     int
		len   int
		sx    []complex128
		incx  int
		ntrue int
	}{
		{0, 2, []complex128{(0.1000 + 0.1000i), (1.0000 + 2.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, 0},
		{1, 2, []complex128{(0.3000 - 0.4000i), (3.0000 + 4.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, 1},
		{2, 4, []complex128{(0.1000 - 0.3000i), (0.5000 - 0.1000i), (5.0000 + 6.0000i), (5.0000 + 6.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, 2},
		{3, 6, []complex128{(0.1000 + 0.1000i), (-0.6000 + 0.1000i), (0.1000 - 0.3000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, 2},
		{4, 8, []complex128{(0.3000 + 0.1000i), (0.5000 + 0.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 1, 2},
		{0, 2, []complex128{(0.1000 + 0.1000i), (4.0000 + 5.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, 0},
		{1, 2, []complex128{(0.3000 - 0.4000i), (6.0000 + 7.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, 1},
		{2, 4, []complex128{(0.1000 - 0.3000i), (8.0000 + 9.0000i), (0.5000 - 0.1000i), (2.0000 + 5.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, 2},
		{3, 6, []complex128{(0.1000 + 0.1000i), (3.0000 + 6.0000i), (-0.6000 + 0.1000i), (4.0000 + 7.0000i), (0.1000 - 0.3000i), (7.0000 + 2.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, 2},
		{4, 8, []complex128{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}, 2, 2},
	}

	for _, test := range izamaxTests {
		*n = test.n
		*incx = test.incx
		for j := 0; j < 8; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		res = Izamax(n, sx, incx)
		if res != test.ntrue {
			t.Errorf("Test Failed: result: test %d: {%d} output, {%d} expected", test.n, res, test.ntrue)
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkIzamax(b *testing.B) {
	var res int
	n := new(int)
	incx := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 8); return &y }()
	*n = 4
	*incx = 2

	for i := 0; i < b.N; i++ {
		res = Izamax(n, sx, incx)
	}
	iglobal = res
}

func BenchmarkIzamaxFortran(b *testing.B) {
	var res int
	n := new(int)
	incx := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 8); return &y }()
	*n = 4
	*incx = 2

	for i := 0; i < b.N; i++ {
		res = izamaxWrapper(n, sx, incx)
	}
	iglobal = res
}

func TestZdotc(t *testing.T) {
	tname := "Zdotc"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	sy := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	res := func() *[]complex128 { y := make([]complex128, 1); return &y }()
	var zdotTests = []struct {
		n      int
		lenx   int
		leny   int
		sx     []complex128
		incx   int
		sy     []complex128
		incy   int
		result []complex128
		size   []complex128
	}{
		{0, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{1, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.9000 + 0.0600i)}, []complex128{(0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{2, 2, 2, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.9100 - 0.7700i)}, []complex128{(1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{4, 4, 4, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(1.8000 - 0.1000i)}, []complex128{(2.9000 + 2.7800i)}},
		{0, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{1, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.9000 + 0.0600i)}, []complex128{(0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{2, 3, 3, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(1.4500 + 0.7400i)}, []complex128{(1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{4, 7, 7, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.2000 + 0.9000i)}, []complex128{(2.9000 + 2.7800i)}},
		{0, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{1, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.9000 + 0.0600i)}, []complex128{(0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{2, 3, 2, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(-0.5500 + 0.2300i)}, []complex128{(1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{4, 7, 4, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.8300 - 0.3900i)}, []complex128{(2.9000 + 2.7800i)}},
		{0, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{1, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.9000 + 0.0600i)}, []complex128{(0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{2, 2, 3, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(1.0400 + 0.7900i)}, []complex128{(1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{4, 4, 7, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(1.9500 + 1.2200i)}, []complex128{(2.9000 + 2.7800i)}},
	}

	for _, test := range zdotTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		(*res)[0] = Zdotc(n, sx, incx, sy, incy)
		zTest(t, nc, *onei, res, &test.result, &test.size, &dfac, "result")
	}

	printTestsRun(tname, nc)
}

func BenchmarkZdotc(b *testing.B) {
	var res complex128
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	sy := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	*n = 4
	*incx = 2
	*incy = -2

	for i := 0; i < b.N; i++ {
		res = Zdotc(n, sx, incx, sy, incy)
	}
	zglobal = res
}

func BenchmarkZdotcFortran(b *testing.B) {
	var res complex128
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	sy := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	*n = 4
	*incx = 2
	*incy = -2

	for i := 0; i < b.N; i++ {
		res = zdotcWrapper(n, sx, incx, sy, incy)
	}
	zglobal = res
}

func TestZdotu(t *testing.T) {
	tname := "Zdotu"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	sy := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	res := func() *[]complex128 { y := make([]complex128, 1); return &y }()
	var zdotTests = []struct {
		n      int
		lenx   int
		leny   int
		sx     []complex128
		incx   int
		sy     []complex128
		incy   int
		result []complex128
		size   []complex128
	}{
		{0, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{1, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(-0.0600 - 0.9000i)}, []complex128{(0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{2, 2, 2, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.6500 - 0.4700i)}, []complex128{(1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{4, 4, 4, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(-0.3400 - 1.2200i)}, []complex128{(2.9000 + 2.7800i)}},
		{0, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{1, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(-0.0600 - 0.9000i)}, []complex128{(0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{2, 3, 3, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(-0.5900 - 1.4600i)}, []complex128{(1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{4, 7, 7, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(-1.0400 - 0.0400i)}, []complex128{(2.9000 + 2.7800i)}},
		{0, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{1, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(-0.0600 - 0.9000i)}, []complex128{(0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{2, 3, 2, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(-0.8300 + 0.5900i)}, []complex128{(1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{4, 7, 4, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.0700 - 0.3700i)}, []complex128{(2.9000 + 2.7800i)}},
		{0, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{1, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(-0.0600 - 0.9000i)}, []complex128{(0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{2, 2, 3, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(-0.7600 - 1.1500i)}, []complex128{(1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{4, 4, 7, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(-1.3300 - 1.8200i)}, []complex128{(2.9000 + 2.7800i)}},
	}

	for _, test := range zdotTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		(*res)[0] = Zdotu(n, sx, incx, sy, incy)
		zTest(t, nc, *onei, res, &test.result, &test.size, &dfac, "result")
	}

	printTestsRun(tname, nc)
}

func BenchmarkZdotu(b *testing.B) {
	var res complex128
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	sy := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	*n = 4
	*sx = []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}
	*incx = 2
	*sy = []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}
	*incy = -2

	for i := 0; i < b.N; i++ {
		res = Zdotu(n, sx, incx, sy, incy)
	}
	zglobal = res
}

func BenchmarkZdotuFortran(b *testing.B) {
	var res complex128
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	sy := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	*n = 4
	*sx = []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}
	*incx = 2
	*sy = []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}
	*incy = -2

	for i := 0; i < b.N; i++ {
		res = zdotuWrapper(n, sx, incx, sy, incy)
	}
	zglobal = res
}

func TestZaxpy(t *testing.T) {
	tname := "Zaxpy"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	sa := new(complex128)
	sx := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	sy := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	var zaxpyTests = []struct {
		n     int
		lenx  int
		leny  int
		sa    complex128
		sx    []complex128
		incx  int
		sy    []complex128
		incy  int
		strue []complex128
		size  []complex128
	}{
		{0, 1, 1, (0.4000 - 0.7000i), []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.6000 - 0.6000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{1, 1, 1, (0.4000 - 0.7000i), []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.3200 - 1.4100i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(1.5400 + 1.5400i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{2, 2, 2, (0.4000 - 0.7000i), []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.3200 - 1.4100i), (-1.5500 + 0.5000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{4, 4, 4, (0.4000 - 0.7000i), []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.3200 - 1.4100i), (-1.5500 + 0.5000i), (0.0300 - 0.8900i), (-0.3800 - 0.9600i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{0, 1, 1, (0.4000 - 0.7000i), []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.6000 - 0.6000i), (-1.5500 + 0.5000i), (0.0300 - 0.8900i), (-0.3800 - 0.9600i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{1, 1, 1, (0.4000 - 0.7000i), []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.3200 - 1.4100i), (-1.5500 + 0.5000i), (0.0300 - 0.8900i), (-0.3800 - 0.9600i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{2, 3, 3, (0.4000 - 0.7000i), []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(-0.0700 - 0.8900i), (-0.9000 + 0.5000i), (0.4200 - 1.4100i), (-0.3800 - 0.9600i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{4, 7, 7, (0.4000 - 0.7000i), []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.7800 + 0.0600i), (-0.9000 + 0.5000i), (0.0600 - 0.1300i), (0.1000 - 0.5000i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.5200 - 1.5100i)}, []complex128{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
		{0, 1, 1, (0.4000 - 0.7000i), []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.0600 - 0.1300i), (0.1000 - 0.5000i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.5200 - 1.5100i)}, []complex128{(0.0000 + 0.0000i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
		{1, 1, 1, (0.4000 - 0.7000i), []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.3200 - 1.4100i), (-0.9000 + 0.5000i), (0.0600 - 0.1300i), (0.1000 - 0.5000i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.5200 - 1.5100i)}, []complex128{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
		{2, 3, 2, (0.4000 - 0.7000i), []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(-0.0700 - 0.8900i), (-1.1800 - 0.3100i), (0.0600 - 0.1300i), (0.1000 - 0.5000i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.5200 - 1.5100i)}, []complex128{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
		{4, 7, 4, (0.4000 - 0.7000i), []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.7800 + 0.0600i), (-1.5400 + 0.9700i), (0.0300 - 0.8900i), (-0.1800 - 1.3100i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.5200 - 1.5100i)}, []complex128{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
		{0, 1, 1, (0.4000 - 0.7000i), []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.6000 - 0.6000i), (-1.5400 + 0.9700i), (0.0300 - 0.8900i), (-0.1800 - 1.3100i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.5200 - 1.5100i)}, []complex128{(0.0000 + 0.0000i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
		{1, 1, 1, (0.4000 - 0.7000i), []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.3200 - 1.4100i), (-1.5400 + 0.9700i), (0.0300 - 0.8900i), (-0.1800 - 1.3100i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.5200 - 1.5100i)}, []complex128{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
		{2, 2, 3, (0.4000 - 0.7000i), []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.3200 - 1.4100i), (-0.9000 + 0.5000i), (0.0500 - 0.6000i), (-0.1800 - 1.3100i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.5200 - 1.5100i)}, []complex128{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
		{4, 4, 7, (0.4000 - 0.7000i), []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.3200 - 1.4100i), (-0.9000 + 0.5000i), (0.0500 - 0.6000i), (0.1000 - 0.5000i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.3200 - 1.1600i)}, []complex128{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
	}

	for _, test := range zaxpyTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		*sa = test.sa
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		Zaxpy(n, sa, sx, incx, sy, incy)
		zTest(t, nc, test.leny, sy, &test.strue, &test.size, &dfac, "sy")
	}

	printTestsRun(tname, nc)
}

func BenchmarkZaxpy(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sa := new(complex128)
	sx := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	sy := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	*n = 4
	*sa = (0.4000 - 0.7000i)
	*incx = 2
	*incy = -2

	for i := 0; i < b.N; i++ {
		Zaxpy(n, sa, sx, incx, sy, incy)
	}
}

func BenchmarkZaxpyFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sa := new(complex128)
	sx := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	sy := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	*n = 4
	*sa = (0.4000 - 0.7000i)
	*incx = 2
	*incy = -2

	for i := 0; i < b.N; i++ {
		zaxpyWrapper(n, sa, sx, incx, sy, incy)
	}
}

func TestZcopy(t *testing.T) {
	tname := "Zcopy"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	sy := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	var zcopyTests = []struct {
		n     int
		lenx  int
		leny  int
		sx    []complex128
		incx  int
		sy    []complex128
		incy  int
		strue []complex128
		size  []complex128
	}{
		{0, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.6000 - 0.6000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{1, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.7000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{2, 2, 2, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{4, 4, 4, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{0, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{1, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{2, 3, 3, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(-0.1000 - 0.9000i), (-0.9000 + 0.5000i), (0.7000 - 0.8000i), (0.2000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{4, 7, 7, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(-0.6000 + 0.6000i), (-0.9000 + 0.5000i), (-0.9000 - 0.4000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{0, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (-0.9000 - 0.4000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{1, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.7000 - 0.8000i), (-0.9000 + 0.5000i), (-0.9000 - 0.4000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{2, 3, 2, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(-0.1000 - 0.9000i), (0.7000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{4, 7, 4, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(-0.6000 + 0.6000i), (-0.9000 - 0.4000i), (-0.1000 - 0.9000i), (0.7000 - 0.8000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{0, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 - 0.4000i), (-0.1000 - 0.9000i), (0.7000 - 0.8000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{1, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.7000 - 0.8000i), (-0.9000 - 0.4000i), (-0.1000 - 0.9000i), (0.7000 - 0.8000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{2, 2, 3, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.7000 - 0.8000i), (-0.9000 + 0.5000i), (-0.4000 - 0.7000i), (0.7000 - 0.8000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{4, 4, 7, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.7000 - 0.8000i), (-0.9000 + 0.5000i), (-0.4000 - 0.7000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.2000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
	}

	for _, test := range zcopyTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		Zcopy(n, sx, incx, sy, incy)
		zTest(t, nc, test.leny, sy, &test.strue, &test.size, onef64, "sy")
	}

	printTestsRun(tname, nc)
}

func BenchmarkZcopy(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	sy := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	*n = 4
	*incx = 2
	*incy = -2

	for i := 0; i < b.N; i++ {
		Zcopy(n, sx, incx, sy, incy)
	}
}

func BenchmarkZcopyFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	sy := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	*n = 4
	*incx = 2
	*incy = -2

	for i := 0; i < b.N; i++ {
		zcopyWrapper(n, sx, incx, sy, incy)
	}
}

func TestZswap(t *testing.T) {
	tname := "Zswap"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	sy := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	var zswapTests = []struct {
		n      int
		lenx   int
		leny   int
		sx     []complex128
		incx   int
		sy     []complex128
		incy   int
		sxtrue []complex128
		sytrue []complex128
		size   []complex128
	}{
		{0, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.7000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.6000 - 0.6000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{1, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.6000 - 0.6000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.7000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{2, 2, 2, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{4, 4, 4, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{0, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.7000 - 0.8000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.6000 - 0.6000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{1, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{2, 3, 3, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.7000 - 0.6000i), (-0.4000 - 0.7000i), (0.6000 - 0.6000i), (0.1000 - 0.5000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(-0.1000 - 0.9000i), (-0.9000 + 0.5000i), (0.7000 - 0.8000i), (0.2000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{4, 7, 7, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.8000 - 0.7000i), (-0.4000 - 0.7000i), (-0.1000 - 0.2000i), (0.2000 - 0.8000i), (0.7000 - 0.6000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex128{(-0.6000 + 0.6000i), (-0.9000 + 0.5000i), (-0.9000 - 0.4000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{0, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.2000i), (0.2000 - 0.8000i), (0.7000 - 0.6000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (-0.9000 - 0.4000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{1, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.6000 - 0.6000i), (-0.4000 - 0.7000i), (-0.1000 - 0.2000i), (0.2000 - 0.8000i), (0.7000 - 0.6000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex128{(0.7000 - 0.8000i), (-0.9000 + 0.5000i), (-0.9000 - 0.4000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{2, 3, 2, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(-0.9000 + 0.5000i), (-0.4000 - 0.7000i), (0.6000 - 0.6000i), (0.2000 - 0.8000i), (0.7000 - 0.6000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex128{(-0.1000 - 0.9000i), (0.7000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{4, 7, 4, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex128{(0.1000 - 0.5000i), (-0.4000 - 0.7000i), (0.7000 - 0.6000i), (0.2000 - 0.8000i), (-0.9000 + 0.5000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex128{(-0.6000 + 0.6000i), (-0.9000 - 0.4000i), (-0.1000 - 0.9000i), (0.7000 - 0.8000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{0, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (0.7000 - 0.6000i), (0.2000 - 0.8000i), (-0.9000 + 0.5000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex128{(0.6000 - 0.6000i), (-0.9000 - 0.4000i), (-0.1000 - 0.9000i), (0.7000 - 0.8000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{1, 1, 1, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.6000 - 0.6000i), (-0.4000 - 0.7000i), (0.7000 - 0.6000i), (0.2000 - 0.8000i), (-0.9000 + 0.5000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex128{(0.7000 - 0.8000i), (-0.9000 - 0.4000i), (-0.1000 - 0.9000i), (0.7000 - 0.8000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{2, 2, 3, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.6000 - 0.6000i), (0.7000 - 0.6000i), (0.7000 - 0.6000i), (0.2000 - 0.8000i), (-0.9000 + 0.5000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex128{(0.7000 - 0.8000i), (-0.9000 + 0.5000i), (-0.4000 - 0.7000i), (0.7000 - 0.8000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{4, 4, 7, []complex128{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex128{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex128{(0.6000 - 0.6000i), (0.7000 - 0.6000i), (-0.1000 - 0.2000i), (0.8000 - 0.7000i), (-0.9000 + 0.5000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex128{(0.7000 - 0.8000i), (-0.9000 + 0.5000i), (-0.4000 - 0.7000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.2000 - 0.8000i)}, []complex128{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
	}

	for _, test := range zswapTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		Zswap(n, sx, incx, sy, incy)
		zTest(t, nc, test.lenx, sx, &test.sxtrue, &test.size, onef64, "sx")
		zTest(t, nc, test.leny, sy, &test.sytrue, &test.size, onef64, "sy")
	}

	printTestsRun(tname, nc)
}

func BenchmarkZswap(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	sy := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	*n = 4
	*incx = 2
	*incy = -2

	for i := 0; i < b.N; i++ {
		Zswap(n, sx, incx, sy, incy)
	}
}

func BenchmarkZswapFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	sy := func() *[]complex128 { y := make([]complex128, 7); return &y }()
	*n = 4
	*incx = 2
	*incy = -2

	for i := 0; i < b.N; i++ {
		zswapWrapper(n, sx, incx, sy, incy)
	}
}

// BLAS Level 2
func TestZgemv(t *testing.T) {
	tname := "Zgemv"
	var i, ia, ib, ic, im, in, incxs, incys, ix, iy, j, laa, ldas, lx, ly, ml, ms, nl, ns, nd, nc int
	var als, bls complex128
	var err, erri, epsf64 float64
	var transs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex128)
	beta := new(complex128)
	transl := new(complex128)
	kl := new(int)
	ku := new(int)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_ml := new(int)
	_nl := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xs := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	y := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	ys := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yt := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]
		ns = *n
		nd = (*n)/2 + 1
		for im = 1; im <= 2; im++ {
			if im == 1 {
				*m = max((*n)-nd, 0)
			} else if im == 2 {
				*m = min((*n)+nd, nmax)
			}

			*ku = (*n) - 1
			*kl = (*m) - 1
			ms = *m
			*lda = *m
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			ldas = *lda

			null = *n <= 0 || *m <= 0

			*transl = 0.0
			zmakeGE2L2(m, n, a, aa, lda, kl, ku, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
			for j = 1; j <= *n; j++ {
				for i = 1; i <= *m; i++ {
					(*a)[i-1][j-1] = (*aa)[i+(j-1)*absint(*lda)-1]
				}
			}

			for ic = 1; ic <= len(ichtL2); ic++ {
				*trans = ichtL2[ic-1]

				if *trans == 'T' || *trans == 'C' {
					ml = *n
					nl = *m
				} else {
					ml = *m
					nl = *n
				}

				for ix = 1; ix <= len(incL2); ix++ {
					*incx = incL2[ix-1]
					lx = absint(*incx) * nl

					*transl = 0.5
					*_nl = nl - 1
					zmakeGEL2(onei, &nl, x, xx, incx, zeroi, _nl, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					if nl > 1 {
						(*xx)[1+absint(*incx)*(nl/2-1)-1] = 0.0
					}

					for iy = 1; iy <= len(incL2); iy++ {
						*incy = incL2[iy-1]
						ly = absint(*incy) * ml

						for ia = 1; ia <= len(alfc128L2); ia++ {
							*alpha = alfc128L2[ia-1]

							for ib = 1; ib <= len(betc128L2); ib++ {
								*beta = betc128L2[ib-1]

								*transl = 0.0
								*_ml = ml - 1
								zmakeGEL2(onei, &ml, y, yy, incy, zeroi, _ml, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

								transs = *trans
								incxs = *incx
								incys = *incy
								als = *alpha
								bls = *beta
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lx; i++ {
									(*xs)[i-1] = (*xx)[i-1]
								}
								for i = 1; i <= ly; i++ {
									(*ys)[i-1] = (*yy)[i-1]
								}

								nc++

								_aa := zExpand(aa, n, lda)
								Zgemv(major, trans, m, n, alpha, _aa, lda, xx, incx, beta, yy, incy)
								zReturn(_aa, aa)

								checkByte(t, nc, trans, &transs, "trans")
								checkInt(t, nc, m, &ms, "m")
								checkInt(t, nc, n, &ns, "n")
								checkComplex128(t, nc, &als, alpha, "alpha")
								checkComplex128(t, nc, &bls, beta, "beta")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, incx, &incxs, "incx")
								checkInt(t, nc, incy, &incys, "incy")
								checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
								checkComplex128Array1D(t, nc, &lx, xx, xs, "xx")
								if null {
									checkComplex128Array1D(t, nc, &ly, yy, ys, "guardband yy")
									break
								} else {
									for j := 0; j < ml; j++ {
										for i = 1; i < absint(*incy); i++ {
											if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
												t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
											}
										}
									}
									zmvchTest(trans, m, n, alpha, a, x, incx, beta, y, incy, yt, g)
									err = 0
									for i = 1; i <= ml; i++ {
										erri = abssumf64((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf64
										if (*g)[i-1] != 0.0 {
											erri /= (*g)[i-1]
										}
										err = maxf64(err, erri)
										if err*sqrtf64(epsf64) >= 1.0 {
											t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.8e} error\n\t\ttrans: %c\tm: %d\tn: %d\talpha: %4.2f\tbeta: %4.2f\tlda: %d\tincx: %d\tincy: %d", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf64(epsf64), *trans, *m, *n, *alpha, *beta, *lda, *incx, *incy)
										}
									}
								}
							}

							if null {
								break
							}
						}

						if null {
							break
						}
					}

					if null {
						break
					}
				}

				if null {
					break
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZgemv(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	trans := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*trans = 'C'
	*m = 14
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 15
	*incx = 2
	*beta = (1.30 - 1.10i)
	*incy = 2

	for i := 0; i < b.N; i++ {
		Zgemv(major, trans, m, n, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func BenchmarkZgemvFortran(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	trans := new(byte)

	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*trans = 'C'
	*m = 14
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 15
	*incx = 2
	*beta = (1.30 - 1.10i)
	*incy = 2

	for i := 0; i < b.N; i++ {
		zgemvWrapper(trans, m, n, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func TestZgbmv(t *testing.T) {
	tname := "Zgbmv"
	var i, ia, ib, ic, iku, im, in, incxs, incys, ix, iy, j, kls, kus, laa, ldas, lx, ly, ml, ms, nl, ns, nd, nc int
	var als, bls complex128
	var err, erri float64
	var transs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex128)
	beta := new(complex128)
	transl := new(complex128)
	m := new(int)
	n := new(int)
	kl := new(int)
	ku := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_ml := new(int)
	_nl := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xs := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	y := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	ys := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yt := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	for j = 1; j <= min(32, nmax); j++ {
		for i = 1; i <= min(32, nmax); i++ {
			(*a)[i-1][j-1] = int2c128(max(i-j+1, 0))
		}
		(*xx)[j-1] = int2c128(j)
		(*yy)[j-1] = *zeroc128
	}
	for j = 1; j <= min(32, nmax); j++ {
		(*yy)[j-1] = int2c128(j*((j+1)*j))/2 - int2c128((j+1)*j*(j-1))/3
	}

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]
		nd = (*n)/2 + 1

		for im = 1; im <= 2; im++ {
			if im == 1 {
				*m = max((*n)-nd, 0)
			} else if im == 2 {
				*m = min((*n)+nd, nmax)
			}

			for iku = 1; iku <= len(kbL2); iku++ {
				*ku = kbL2[iku-1]
				*kl = max((*ku)-1, 0)
				*lda = (*kl) + (*ku) + 1
				if *lda < nmax {
					*lda++
				} else if *lda > nmax {
					continue
				}
				laa = (*lda) * (*n)
				null = *n <= 0 || *m <= 0

				*transl = 0.0
				zmakeGBL2(m, n, a, aa, lda, kl, ku, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

				for ic = 1; ic <= len(ichtL2); ic++ {
					*trans = ichtL2[ic-1]

					if *trans == 'T' || *trans == 'C' {
						ml = *n
						nl = *m
					} else {
						ml = *m
						nl = *n
					}

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * nl

						*transl = 0.5
						*_nl = nl - 1
						zmakeGEL2(onei, &nl, x, xx, incx, zeroi, _nl, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
						if nl > 1 {
							(*xx)[absint(*incx)*nl] = 0.0
						}

						for iy = 1; iy <= len(incL2); iy++ {
							*incy = incL2[iy-1]
							ly = absint(*incy) * ml

							for ia = 1; ia <= len(alfc128L2); ia++ {
								*alpha = alfc128L2[ia-1]

								for ib = 1; ib <= len(betc128L2); ib++ {
									*beta = betc128L2[ib-1]

									*transl = 0.0
									*_ml = ml - 1
									zmakeGEL2(onei, &ml, y, yy, incy, zeroi, _ml, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

									transs = *trans
									ms = *m
									ns = *n
									kls = *kl
									kus = *ku
									ldas = *lda
									incxs = *incx
									incys = *incy
									als = *alpha
									bls = *beta
									for i = 1; i <= laa; i++ {
										(*as)[i-1] = (*aa)[i-1]
									}
									for i = 1; i <= lx; i++ {
										(*xs)[i-1] = (*xx)[i-1]
									}
									for i = 1; i <= ly; i++ {
										(*ys)[i-1] = (*yy)[i-1]
									}

									nc++

									_aa := zExpand(aa, n, lda)
									Zgbmv(major, trans, m, n, kl, ku, alpha, _aa, lda, xx, incx, beta, yy, incy)
									zReturn(_aa, aa)

									checkByte(t, nc, trans, &transs, "trans")
									checkInt(t, nc, m, &ms, "m")
									checkInt(t, nc, n, &ns, "n")
									checkInt(t, nc, kl, &kls, "kl")
									checkInt(t, nc, ku, &kus, "ku")
									checkComplex128(t, nc, &als, alpha, "alpha")
									checkComplex128(t, nc, &bls, beta, "beta")
									checkInt(t, nc, lda, &ldas, "lda")
									checkInt(t, nc, incx, &incxs, "incx")
									checkInt(t, nc, incy, &incys, "incy")
									checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
									checkComplex128Array1D(t, nc, &lx, xx, xs, "xx")
									if null {
										checkComplex128Array1D(t, nc, &ly, yy, ys, "guardband yy")
										break
									} else {
										for j := 0; j < ml; j++ {
											for i = 2; i < absint(*incy); i++ {
												if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
													t.Errorf("Test Failed: guardband yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
												}
											}
										}
										zmvchTest(trans, m, n, alpha, a, x, incx, beta, y, incy, yt, g)
										err = 0
										for i = 1; i <= ml; i++ {
											erri = absc128((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf64
											if (*g)[i-1] != 0.0 {
												erri /= (*g)[i-1]
											}
											err = maxf64(err, erri)
											if err*sqrtf64(epsf64) >= 1.0 {
												t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf64(epsf64))
											}
										}
									}
								}
								if null {
									break
								}
							}
							if null {
								break
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZgbmv(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	m := new(int)
	n := new(int)
	kl := new(int)
	ku := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	trans := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*trans = 'C'
	*m = 14
	*n = 9
	*kl = 3
	*ku = 4
	*alpha = (0.70 - 0.90i)
	*lda = 9
	*incx = 2
	*beta = (1.30 - 1.10i)
	*incy = 2

	for i := 0; i < b.N; i++ {
		Zgbmv(major, trans, m, n, kl, ku, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func BenchmarkZgbmvFortran(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	m := new(int)
	n := new(int)
	kl := new(int)
	ku := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	trans := new(byte)

	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*trans = 'C'
	*m = 14
	*n = 9
	*kl = 3
	*ku = 4
	*alpha = (0.70 - 0.90i)
	*lda = 9
	*incx = 2
	*beta = (1.30 - 1.10i)
	*incy = 2

	for i := 0; i < b.N; i++ {
		zgbmvWrapper(trans, m, n, kl, ku, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func TestZhemv(t *testing.T) {
	tname := "Zhemv"
	var i, ia, ib, ic, in, incxs, incys, ix, iy, laa, ldas, lx, ly, ns, nc int
	var als, bls complex128
	var err, erri float64
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex128)
	beta := new(complex128)
	transl := new(complex128)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xs := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	y := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	ys := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yt := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = (*n)
		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			*transl = 0.0
			*_n = (*n) - 1
			zmakeHEL2(uplo, _X, n, n, a, aa, lda, _n, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				zmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				if (*n) > 1 {
					(*xx)[1+absint(*incx)*(*n)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					for ia = 1; ia <= len(alfc128L2); ia++ {
						*alpha = alfc128L2[ia-1]

						for ib = 1; ib <= len(betc128L2); ib++ {
							*beta = betc128L2[ib-1]
							*transl = 0.0
							zmakeGEL2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

							uplos = *uplo
							ns = *n
							ldas = *lda
							incxs = *incx
							incys = *incy
							als = *alpha
							bls = *beta
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lx; i++ {
								(*xs)[i-1] = (*xx)[i-1]
							}
							for i = 1; i <= ly; i++ {
								(*ys)[i-1] = (*yy)[i-1]
							}

							nc++

							_aa := zExpand(aa, n, lda)
							Zhemv(major, uplo, n, alpha, _aa, lda, xx, incx, beta, yy, incy)
							zReturn(_aa, aa)

							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkComplex128(t, nc, &als, alpha, "alpha")
							checkComplex128(t, nc, &bls, beta, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, incx, &incxs, "incx")
							checkInt(t, nc, incy, &incys, "incy")
							checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
							checkComplex128Array1D(t, nc, &lx, xx, xs, "xx")
							if null {
								checkComplex128Array1D(t, nc, &ly, yy, ys, "guardband yy")
								break
							} else {
								for j := 0; j < *n; j++ {
									for i = 1; i < absint(*incy); i++ {
										if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
											t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
										}
									}
								}
								zmvchTest(_N, n, n, alpha, a, x, incx, beta, y, incy, yt, g)
								err = 0
								for i = 1; i <= *n; i++ {
									erri = abssumf64((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf64
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf64(err, erri)
									if err*sqrtf64(epsf64) >= 1.0 {
										t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf64(epsf64))
									}
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZhemv(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*incx = 2
	*beta = (1.30 - 1.10i)
	*incy = 2

	for i := 0; i < b.N; i++ {
		Zhemv(major, uplo, n, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func BenchmarkZhemvFortran(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)

	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*incx = 2
	*beta = (1.30 - 1.10i)
	*incy = 2

	for i := 0; i < b.N; i++ {
		zhemvWrapper(uplo, n, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func TestZhbmv(t *testing.T) {
	tname := "Zhbmv"
	var i, ia, ib, ic, ik, in, incxs, incys, ix, iy, ks, laa, ldas, lx, ly, nc, ns int
	var als, bls complex128
	var err, erri float64
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex128)
	beta := new(complex128)
	transl := new(complex128)
	n := new(int)
	k := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xs := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	y := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	ys := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yt := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		for ik = 1; ik <= len(kbL2); ik++ {
			*k = kbL2[ik-1]
			*lda = (*k) + 1

			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = ((*n) * ((*n) + 1)) / 2
			null = *n <= 0

			for ic = 1; ic <= len(ichuL2); ic++ {
				*uplo = ichuL2[ic-1]

				*transl = 0.0
				zmakeHBL2(uplo, n, n, a, aa, lda, k, k, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

				for ix = 1; ix <= len(incL2); ix++ {
					*incx = incL2[ix-1]
					lx = absint(*incx) * (*n)

					*transl = 0.5
					*_n = (*n) - 1
					zmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					if (*n) > 1 {
						(*xx)[1+absint(*incx)*(*n)-1] = 0.0
					}

					for iy = 1; iy <= len(incL2); iy++ {
						*incy = incL2[iy-1]
						ly = absint(*incy) * (*n)

						for ia = 1; ia <= len(alfc128L2); ia++ {
							*alpha = alfc128L2[ia-1]

							for ib = 1; ib <= len(betc128L2); ib++ {
								*beta = betc128L2[ib-1]

								*transl = 0.0
								zmakeGEL2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

								uplos = *uplo
								ns = *n
								ks = *k
								ldas = *lda
								incxs = *incx
								incys = *incy
								als = *alpha
								bls = *beta
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lx; i++ {
									(*xs)[i-1] = (*xx)[i-1]
								}
								for i = 1; i <= ly; i++ {
									(*ys)[i-1] = (*yy)[i-1]
								}

								nc++

								_aa := zExpand(aa, n, lda)
								Zhbmv(major, uplo, n, k, alpha, _aa, lda, xx, incx, beta, yy, incy)
								zReturn(_aa, aa)

								checkByte(t, nc, uplo, &uplos, "uplo")
								checkInt(t, nc, n, &ns, "n")
								checkInt(t, nc, k, &ks, "k")
								checkComplex128(t, nc, &als, alpha, "alpha")
								checkComplex128(t, nc, &bls, beta, "beta")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, incx, &incxs, "incx")
								checkInt(t, nc, incy, &incys, "incy")
								checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
								checkComplex128Array1D(t, nc, &lx, xx, xs, "xx")
								if null {
									checkComplex128Array1D(t, nc, &ly, yy, ys, "guardband yy")
									break
								} else {
									for j := 0; j < (*n); j++ {
										for i = 1; i < absint(*incy); i++ {
											if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
												t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
											}
										}
									}
									zmvchTest(_N, n, n, alpha, a, x, incx, beta, y, incy, yt, g)
									err = 0
									for i = 1; i <= (*n); i++ {
										erri = abssumf64((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf64
										if (*g)[i-1] != 0.0 {
											erri /= (*g)[i-1]
										}
										err = maxf64(err, erri)
										if err*sqrtf64(epsf64) >= 1.0 {
											t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf64(epsf64))
										}
									}
								}
							}
							if null {
								break
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZhbmv(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	n := new(int)
	k := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*k = 4
	*alpha = (0.70 - 0.90i)
	*lda = 6
	*incx = 2
	*beta = (1.30 - 1.10i)
	*incy = 2

	for i := 0; i < b.N; i++ {
		Zhbmv(major, uplo, n, k, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func BenchmarkZhbmvFortran(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	n := new(int)
	k := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*k = 4
	*alpha = (0.70 - 0.90i)
	*lda = 6
	*incx = 2
	*beta = (1.30 - 1.10i)
	*incy = 2

	for i := 0; i < b.N; i++ {
		zhbmvWrapper(uplo, n, k, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func TestZhpmv(t *testing.T) {
	tname := "Zhpmv"
	var i, ia, ib, ic, in, incxs, incys, ix, iy, laa, lx, ly, nc, ns int
	var als, bls complex128
	var err, erri float64
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex128)
	beta := new(complex128)
	transl := new(complex128)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xs := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	y := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	ys := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yt := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			*transl = 0.0
			*_n = (*n) - 1
			zmakeHPL2(uplo, n, n, a, aa, _n, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				zmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				if (*n) > 1 {
					(*xx)[1+absint(*incx)*(*n)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					for ia = 1; ia <= len(alfc128L2); ia++ {
						*alpha = alfc128L2[ia-1]

						for ib = 1; ib <= len(betc128L2); ib++ {
							*beta = betc128L2[ib-1]

							*transl = 0.0
							zmakeGEL2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

							uplos = *uplo
							ns = *n
							incxs = *incx
							incys = *incy
							als = *alpha
							bls = *beta
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lx; i++ {
								(*xs)[i-1] = (*xx)[i-1]
							}
							for i = 1; i <= ly; i++ {
								(*ys)[i-1] = (*yy)[i-1]
							}

							nc++

							Zhpmv(major, uplo, n, alpha, aa, xx, incx, beta, yy, incy)

							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkComplex128(t, nc, &als, alpha, "alpha")
							checkComplex128(t, nc, &bls, beta, "beta")
							checkInt(t, nc, incx, &incxs, "incx")
							checkInt(t, nc, incy, &incys, "incy")
							checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
							checkComplex128Array1D(t, nc, &lx, xx, xs, "xx")
							if null {
								checkComplex128Array1D(t, nc, &ly, yy, ys, "guardband yy")
								break
							} else {
								for j := 0; j < (*n); j++ {
									for i = 1; i < absint(*incy); i++ {
										if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
											t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
										}
									}
								}
								zmvchTest(_N, n, n, alpha, a, x, incx, beta, y, incy, yt, g)
								err = 0
								for i = 1; i <= (*n); i++ {
									erri = abssumf64((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf64
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf64(err, erri)
									if err*sqrtf64(epsf64) >= 1.0 {
										t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf64(epsf64))
									}
								}
							}
						}

						if null {
							break
						}
					}

					if null {
						break
					}
				}

				if null {
					break
				}
			}

			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZhpmv(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	n := new(int)
	incx := new(int)
	incy := new(int)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*beta = (1.30 - 1.10i)
	*incy = 2
	*alpha = 0.70

	for i := 0; i < b.N; i++ {
		Zhpmv(major, uplo, n, alpha, aa, xx, incx, beta, yy, incy)
	}
}

func BenchmarkZhpmvFortran(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	n := new(int)
	incx := new(int)
	incy := new(int)
	uplo := new(byte)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*beta = (1.30 - 1.10i)
	*incy = 2
	*alpha = 0.70

	for i := 0; i < b.N; i++ {
		zhpmvWrapper(uplo, n, alpha, aa, xx, incx, beta, yy, incy)
	}
}

func TestZtrmv(t *testing.T) {
	tname := "Ztrmv"
	var i, icd, ict, icu, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float64
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(complex128)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xs := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xt := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	z := func() *[]complex128 { y := make([]complex128, nmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*k = (*n) - 1
		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for icu = 1; icu <= len(ichuL2); icu++ {
			*uplo = ichuL2[icu-1]

			for ict = 1; ict <= len(ichtL2); ict++ {
				*trans = ichtL2[ict-1]

				for icd = 1; icd <= len(ichdL2); icd++ {
					*diag = ichdL2[icd-1]

					*transl = 0.0
					zmakeTRL2(uplo, diag, n, n, a, aa, lda, k, k, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * (*n)

						*transl = 0.5
						*_n = (*n) - 1
						zmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
						if (*n) > 1 {
							(*xx)[1+absint(*incx)*(*n)-1] = 0.0
						}

						uplos = *uplo
						transs = *trans
						diags = *diag
						ns = *n
						ldas = *lda
						incxs = *incx
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}

						nc++

						_aa := zExpand(aa, n, lda)
						Ztrmv(major, uplo, trans, diag, n, _aa, lda, xx, incx)
						zReturn(_aa, aa)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkByte(t, nc, trans, &transs, "trans")
						checkByte(t, nc, diag, &diags, "diag")
						checkInt(t, nc, n, &ns, "n")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
						if null {
							checkComplex128Array1D(t, nc, &lx, xx, xs, "guardband xx")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = 1; i < absint(*incx); i++ {
									if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
									}
								}
							}
							zmvchTest(trans, n, n, onec128, a, x, incx, zeroc128, z, incx, xt, g)
							err = 0
							for i = 1; i <= (*n); i++ {
								erri = abssumf64((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf64
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf64(err, erri)
								if err*sqrtf64(epsf64) >= 1.0 {
									t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf64(epsf64))
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZtrmv(b *testing.B) {
	n := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*lda = 10
	*incx = 2

	for i := 0; i < b.N; i++ {
		Ztrmv(major, uplo, trans, diag, n, aa, lda, xx, incx)
	}
}

func BenchmarkZtrmvFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*lda = 10
	*incx = 2

	for i := 0; i < b.N; i++ {
		ztrmvWrapper(uplo, trans, diag, n, aa, lda, xx, incx)
	}
}

func TestZtbmv(t *testing.T) {
	tname := "Ztbmv"
	var i, icd, ict, icu, ik, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float64
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(complex128)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xs := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xt := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		for ik = 1; ik <= len(kbL2); ik++ {
			*k = kbL2[ik-1]

			*lda = (*k) + 1
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = (*lda) * (*n)
			null = *n <= 0

			for icu = 1; icu <= len(ichuL2); icu++ {
				*uplo = ichuL2[icu-1]

				for ict = 1; ict <= len(ichtL2); ict++ {
					*trans = ichtL2[ict-1]

					for icd = 1; icd <= len(ichdL2); icd++ {
						*diag = ichdL2[icd-1]

						*transl = 0.0
						zmakeTBL2(uplo, diag, n, n, a, aa, lda, k, k, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

						for ix = 1; ix <= len(incL2); ix++ {
							*incx = incL2[ix-1]
							lx = absint(*incx) * (*n)

							*transl = 0.5
							*_n = (*n) - 1
							zmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
							if (*n) > 1 {
								(*xx)[1+absint(*incx)*(*n)-1] = 0.0
							}

							uplos = *uplo
							transs = *trans
							diags = *diag
							ns = *n
							ldas = *lda
							incxs = *incx
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lx; i++ {
								(*xs)[i-1] = (*xx)[i-1]
							}

							nc++

							_aa := zExpand(aa, n, lda)
							Ztbmv(major, uplo, trans, diag, n, k, _aa, lda, xx, incx)
							zReturn(_aa, aa)

							checkByte(t, nc, uplo, &uplos, "uplo")
							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, diag, &diags, "diag")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, incx, &incxs, "incx")
							checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
							if null {
								checkComplex128Array1D(t, nc, &lx, xx, xs, "guardband xx")
								break
							} else {
								for j = 0; j < *n; j++ {
									for i = 1; i < absint(*incx); i++ {
										if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
											t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
										}
									}
								}
								zmvchTest(trans, n, n, onec128, a, x, incx, zeroc128, x, incx, xt, g)
								err = 0
								for i = 1; i <= (*n); i++ {
									erri = abssumf64((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf64
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf64(err, erri)
									if err*sqrtf64(epsf64) >= 1.0 {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf64(epsf64))
									}
								}
							}
						}

						if null {
							break
						}
					}

					if null {
						break
					}
				}

				if null {
					break
				}
			}

			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZtbmv(b *testing.B) {
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*k = 4
	*lda = 6
	*incx = 2

	for i := 0; i < b.N; i++ {
		Ztbmv(major, uplo, trans, diag, n, k, aa, lda, xx, incx)
	}
}

func BenchmarkZtbmvFortran(b *testing.B) {
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*k = 4
	*lda = 6
	*incx = 2

	for i := 0; i < b.N; i++ {
		ztbmvWrapper(uplo, trans, diag, n, k, aa, lda, xx, incx)
	}
}

func TestZtpmv(t *testing.T) {
	tname := "Ztpmv"
	var i, icd, ict, icu, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float64
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(complex128)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xs := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xt := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*k = (*n) - 1
		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for icu = 1; icu <= len(ichuL2); icu++ {
			*uplo = ichuL2[icu-1]

			for ict = 1; ict <= len(ichtL2); ict++ {
				*trans = ichtL2[ict-1]

				for icd = 1; icd <= len(ichdL2); icd++ {
					*diag = ichdL2[icd-1]

					*transl = 0.0
					zmakeTPL2(uplo, diag, n, n, a, aa, k, k, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * (*n)

						*transl = 0.5
						*_n = (*n) - 1
						zmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
						if (*n) > 1 {
							(*xx)[1+absint(*incx)*(*n)-1] = 0.0
						}

						uplos = *uplo
						transs = *trans
						diags = *diag
						ns = *n
						ldas = *lda
						incxs = *incx
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}

						nc++

						Ztpmv(major, uplo, trans, diag, n, aa, xx, incx)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkByte(t, nc, trans, &transs, "trans")
						checkByte(t, nc, diag, &diags, "diag")
						checkInt(t, nc, n, &ns, "n")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
						if null {
							checkComplex128Array1D(t, nc, &lx, xx, xs, "guardband xx")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = 1; i < absint(*incx); i++ {
									if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
									}
								}
							}
							zmvchTest(trans, n, n, onec128, a, x, incx, zeroc128, x, incx, xt, g)
							err = 0
							for i = 1; i <= (*n); i++ {
								erri = abssumf64((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf64
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf64(err, erri)
								if err*sqrtf64(epsf64) >= 1.0 {
									t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf64(epsf64))
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZtpmv(b *testing.B) {
	n := new(int)
	incx := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*incx = 2

	for i := 0; i < b.N; i++ {
		Ztpmv(major, uplo, trans, diag, n, aa, xx, incx)
	}
}

func BenchmarkZtpmvFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*incx = 2

	for i := 0; i < b.N; i++ {
		ztpmvWrapper(uplo, trans, diag, n, aa, xx, incx)
	}
}

func TestZtrsv(t *testing.T) {
	tname := "Ztrsv"
	var i, icd, ict, icu, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float64
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(complex128)
	n := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xs := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xt := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	z := func() *[]complex128 { y := make([]complex128, nmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for icu = 1; icu <= len(ichuL2); icu++ {
			*uplo = ichuL2[icu-1]

			for ict = 1; ict <= len(ichtL2); ict++ {
				*trans = ichtL2[ict-1]

				for icd = 1; icd <= len(ichdL2); icd++ {
					*diag = ichdL2[icd-1]

					*transl = 0.0
					zmakeTRL2(uplo, diag, n, n, a, aa, lda, _n, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * (*n)

						*transl = 0.5
						*_n = (*n) - 1
						zmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
						if (*n) > 1 {
							(*xx)[1+absint(*incx)*(*n)-1] = 0.0
						}

						uplos = *uplo
						transs = *trans
						diags = *diag
						ns = *n
						ldas = *lda
						incxs = *incx
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}

						nc++

						_aa := zExpand(aa, n, lda)
						Ztrsv(major, uplo, trans, diag, n, _aa, lda, xx, incx)
						zReturn(_aa, aa)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkByte(t, nc, trans, &transs, "trans")
						checkByte(t, nc, diag, &diags, "diag")
						checkInt(t, nc, n, &ns, "n")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
						if null {
							checkComplex128Array1D(t, nc, &lx, xx, xs, "guardband xx")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = 1; i < absint(*incx); i++ {
									if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
									}
								}
							}
							for i = 1; i <= *n; i++ {
								(*z)[i-1] = (*xx)[(i-1)*absint(*incx)]
								(*xx)[(i-1)*absint(*incx)] = (*x)[i-1]
							}
							zmvchTest(trans, n, n, onec128, a, z, incx, zeroc128, x, incx, xt, g)
							err = 0
							for i = 1; i <= (*n); i++ {
								erri = abssumf64((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf64
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf64(err, erri)
								if err*sqrtf64(epsf64) >= 1.0 {
									t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*z)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf64(epsf64))
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZtrsv(b *testing.B) {
	n := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*lda = 10
	*incx = 2

	for i := 0; i < b.N; i++ {
		Ztrsv(major, uplo, trans, diag, n, aa, lda, xx, incx)
	}
}

func BenchmarkZtrsvFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*lda = 10
	*incx = 2

	for i := 0; i < b.N; i++ {
		ztrsvWrapper(uplo, trans, diag, n, aa, lda, xx, incx)
	}
}

func TestZtbsv(t *testing.T) {
	tname := "Ztbsv"
	var i, icd, ict, icu, ik, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float64
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(complex128)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xs := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xt := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	z := func() *[]complex128 { y := make([]complex128, nmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		for ik = 1; ik <= len(kbL2); ik++ {
			*k = kbL2[ik-1]

			*lda = (*k) + 1
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = (*lda) * (*n)
			null = *n <= 0

			for icu = 1; icu <= len(ichuL2); icu++ {
				*uplo = ichuL2[icu-1]

				for ict = 1; ict <= len(ichtL2); ict++ {
					*trans = ichtL2[ict-1]

					for icd = 1; icd <= len(ichdL2); icd++ {
						*diag = ichdL2[icd-1]

						*transl = 0.0
						zmakeTBL2(uplo, diag, n, n, a, aa, lda, k, k, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

						for ix = 1; ix <= len(incL2); ix++ {
							*incx = incL2[ix-1]
							lx = absint(*incx) * (*n)

							*transl = 0.5
							*_n = (*n) - 1
							zmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
							if (*n) > 1 {
								(*xx)[1+absint(*incx)*(*n)-1] = 0.0
							}

							uplos = *uplo
							transs = *trans
							diags = *diag
							ns = *n
							ldas = *lda
							incxs = *incx
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lx; i++ {
								(*xs)[i-1] = (*xx)[i-1]
							}

							nc++

							_aa := zExpand(aa, n, lda)
							Ztbsv(major, uplo, trans, diag, n, k, _aa, lda, xx, incx)
							zReturn(_aa, aa)

							checkByte(t, nc, uplo, &uplos, "uplo")
							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, diag, &diags, "diag")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, incx, &incxs, "incx")
							checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
							if null {
								checkComplex128Array1D(t, nc, &lx, xx, xs, "guardband xx")
								break
							} else {
								for j = 0; j < *n; j++ {
									for i = 1; i < absint(*incx); i++ {
										if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
											t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
										}
									}
								}
								for i = 1; i <= *n; i++ {
									(*z)[i-1] = (*xx)[(i-1)*absint(*incx)]
									(*xx)[(i-1)*absint(*incx)] = (*x)[i-1]
								}
								zmvchTest(trans, n, n, onec128, a, z, incx, zeroc128, x, incx, xt, g)
								err = 0
								for i = 1; i <= (*n); i++ {
									erri = abssumf64((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf64
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf64(err, erri)
									if err*sqrtf64(epsf64) >= 1.0 {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf64(epsf64))
									}
								}
							}
							if null {
								break
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZtbsv(b *testing.B) {
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*k = 4
	*lda = 6
	*incx = 2

	for i := 0; i < b.N; i++ {
		Ztbsv(major, uplo, trans, diag, n, k, aa, lda, xx, incx)
	}
}

func BenchmarkZtbsvFortran(b *testing.B) {
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*k = 4
	*lda = 6
	*incx = 2

	for i := 0; i < b.N; i++ {
		ztbsvWrapper(uplo, trans, diag, n, k, aa, lda, xx, incx)
	}
}

func TestZtpsv(t *testing.T) {
	tname := "Ztpsv"
	var i, icd, ict, icu, in, incxs, ix, j, laa, lx, nc, ns int
	var err, erri float64
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(complex128)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xs := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xt := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	z := func() *[]complex128 { y := make([]complex128, nmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*k = (*n) - 1
		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for icu = 1; icu <= len(ichuL2); icu++ {
			*uplo = ichuL2[icu-1]

			for ict = 1; ict <= len(ichtL2); ict++ {
				*trans = ichtL2[ict-1]

				for icd = 1; icd <= len(ichdL2); icd++ {
					*diag = ichdL2[icd-1]

					*transl = 0.0
					zmakeTPL2(uplo, diag, n, n, a, aa, k, k, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * (*n)

						*transl = 0.5
						*_n = (*n) - 1
						zmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
						if (*n) > 1 {
							(*xx)[1+absint(*incx)*(*n)-1] = 0.0
						}

						uplos = *uplo
						transs = *trans
						diags = *diag
						ns = *n
						incxs = *incx
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}

						nc++

						Ztpsv(major, uplo, trans, diag, n, aa, xx, incx)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkByte(t, nc, trans, &transs, "trans")
						checkByte(t, nc, diag, &diags, "diag")
						checkInt(t, nc, n, &ns, "n")
						checkInt(t, nc, incx, &incxs, "incx")
						checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
						if null {
							checkComplex128Array1D(t, nc, &lx, xx, xs, "guardband xx")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = 1; i < absint(*incx); i++ {
									if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
									}
								}
							}
							for i = 1; i <= *n; i++ {
								(*z)[i-1] = (*xx)[(i-1)*absint(*incx)]
								(*xx)[(i-1)*absint(*incx)] = (*x)[i-1]
							}
							zmvchTest(trans, n, n, onec128, a, z, incx, zeroc128, x, incx, xt, g)
							err = 0
							for i = 1; i <= *n; i++ {
								erri = abssumf64((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf64
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf64(err, erri)
								if err*sqrtf64(epsf64) >= 1.0 {
									t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf64(epsf64))
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZtpsv(b *testing.B) {
	n := new(int)
	incx := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*incx = 2

	for i := 0; i < b.N; i++ {
		Ztpsv(major, uplo, trans, diag, n, aa, xx, incx)
	}
}

func BenchmarkZtpsvFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*incx = 2

	for i := 0; i < b.N; i++ {
		ztpsvWrapper(uplo, trans, diag, n, aa, xx, incx)
	}
}

func TestZgerc(t *testing.T) {
	tname := "Zgerc"
	var i, ia, im, in, incxs, incys, ix, iy, j, laa, ldas, lx, ly, ms, ns, nd, nc int
	var als complex128
	var err, erri float64
	var transs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex128)
	transl := new(complex128)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_m := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	at := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	ax := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xs := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	y := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	ys := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yt := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	w := func() *[]complex128 { y := make([]complex128, 1); return &y }()
	z := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		nd = (*n)/2 + 1

		for im = 1; im <= 2; im++ {
			if im == 1 {
				*m = max((*n)-nd, 0)
			} else if im == 2 {
				*m = min((*n)+nd, nmax)
			}

			*lda = *m
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = (*lda) * (*n)

			null = *n <= 0 || *m <= 0

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*m)

				*transl = 0.5
				*_m = (*m) - 1
				zmakeGEL2(onei, m, x, xx, incx, zeroi, _m, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				if *m > 1 {
					(*x)[*m] = 0.0
					(*xx)[1+absint(*incx)*(*m)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					*transl = 0.0
					*_n = (*n) - 1
					zmakeGEL2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					if *n > 1 {
						(*y)[*n] = 0.0
						(*yy)[1+absint(*incy)*(*n)-1] = 0.0
					}

					for ia = 1; ia <= len(alfc128L2); ia++ {
						*alpha = alfc128L2[ia-1]

						*transl = 0.0
						zmakeGE2L2(m, n, a, aa, lda, _m, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

						transs = *trans
						ms = *m
						ns = *n
						ldas = *lda
						incxs = *incx
						incys = *incy
						als = *alpha
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}
						for i = 1; i <= ly; i++ {
							(*ys)[i-1] = (*yy)[i-1]
						}

						nc++

						_aa := zExpand(aa, n, lda)
						Zgerc(major, m, n, alpha, xx, incx, yy, incy, _aa, lda)
						zReturn(_aa, aa)

						checkByte(t, nc, trans, &transs, "trans")
						checkInt(t, nc, m, &ms, "m")
						checkInt(t, nc, n, &ns, "n")
						checkComplex128(t, nc, alpha, &als, "alpha")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkInt(t, nc, incy, &incys, "incy")
						checkComplex128Array1D(t, nc, &lx, xx, xs, "xx")
						checkComplex128Array1D(t, nc, &ly, yy, ys, "yy")
						if null {
							checkComplex128Array1D(t, nc, &laa, aa, as, "guardband aa")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = (*m) + 1; i < *lda; i++ {
									if (*aa)[i+j*(*lda)] != (*as)[i+j*(*lda)] {
										t.Errorf("Test Failed: aa[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*lda), nc, (*aa)[i+j*(*lda)], (*as)[i+j*(*lda)])
									}
								}
							}

							if *incx > 0 {
								for i = 1; i <= *m; i++ {
									(*z)[i-1][0] = (*x)[i-1]
								}
							} else {
								for i = 1; i <= *m; i++ {
									(*z)[i-1][0] = (*x)[(*m)-i]
								}
							}
							for j = 1; j <= *n; j++ {
								if *incy > 0 {
									(*w)[0] = (*y)[j-1]
								} else {
									(*w)[0] = (*y)[(*n)-j]
								}
								(*w)[0] = complex128(cmplx.Conj(complex128((*w)[0])))
								for i = range *ax {
									(*ax)[i] = (*a)[i][j-1]
								}

								zmvchTest(_N, m, onei, alpha, z, w, onei, onec128, ax, onei, yt, g)
								_aa := (*aa)[(j-1)*(*lda):]
								err = 0
								for i = 1; i <= *m; i++ {
									erri = abssumf64((*yt)[i-1]-_aa[i-1]) / epsf64
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf64(err, erri)
									if err*sqrtf64(epsf64) >= 1.0 {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.8e} error", i-1, nc, j, (*aa)[i-1], (*at)[i-1], err*sqrtf64(epsf64))
									}
								}
							}
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
		}

	}

	printTestsRun(tname, nc)
}

func BenchmarkZgerc(b *testing.B) {
	alpha := new(complex128)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*m = 14
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*incy = 2
	*lda = 15

	for i := 0; i < b.N; i++ {
		Zgerc(major, m, n, alpha, xx, incx, yy, incy, aa, lda)
	}
}

func BenchmarkZgercFortran(b *testing.B) {
	alpha := new(complex128)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*m = 14
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*incy = 2
	*lda = 15

	for i := 0; i < b.N; i++ {
		zgercWrapper(m, n, alpha, xx, incx, yy, incy, aa, lda)
	}
}

func TestZgeru(t *testing.T) {
	tname := "Zgeru"
	var i, ia, im, in, incxs, incys, ix, iy, j, laa, ldas, lx, ly, ms, ns, nd, nc int
	var als complex128
	var err, erri float64
	var transs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex128)
	transl := new(complex128)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_m := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	at := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	ax := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xs := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	y := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	ys := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yt := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	w := func() *[]complex128 { y := make([]complex128, 1); return &y }()
	z := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		nd = (*n)/2 + 1

		for im = 1; im <= 2; im++ {
			if im == 1 {
				*m = max((*n)-nd, 0)
			} else if im == 2 {
				*m = min((*n)+nd, nmax)
			}

			*lda = *m
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = (*lda) * (*n)

			null = *n <= 0 || *m <= 0

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*m)

				*transl = 0.5
				*_m = (*m) - 1
				zmakeGEL2(onei, m, x, xx, incx, zeroi, _m, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				if *m > 1 {
					(*x)[*m] = 0.0
					(*xx)[1+absint(*incx)*(*m)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					*transl = 0.0
					*_n = (*n) - 1
					zmakeGEL2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					if *n > 1 {
						(*y)[*n] = 0.0
						(*yy)[1+absint(*incy)*(*n)-1] = 0.0
					}

					for ia = 1; ia <= len(alfc128L2); ia++ {
						*alpha = alfc128L2[ia-1]

						*transl = 0.0
						zmakeGE2L2(m, n, a, aa, lda, _m, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

						transs = *trans
						ms = *m
						ns = *n
						ldas = *lda
						incxs = *incx
						incys = *incy
						als = *alpha
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}
						for i = 1; i <= ly; i++ {
							(*ys)[i-1] = (*yy)[i-1]
						}

						nc++

						_aa := zExpand(aa, n, lda)
						Zgeru(major, m, n, alpha, xx, incx, yy, incy, _aa, lda)
						zReturn(_aa, aa)

						checkByte(t, nc, trans, &transs, "trans")
						checkInt(t, nc, m, &ms, "m")
						checkInt(t, nc, n, &ns, "n")
						checkComplex128(t, nc, alpha, &als, "alpha")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkInt(t, nc, incy, &incys, "incy")
						checkComplex128Array1D(t, nc, &lx, xx, xs, "xx")
						checkComplex128Array1D(t, nc, &ly, yy, ys, "yy")
						if null {
							checkComplex128Array1D(t, nc, &laa, aa, as, "guardband aa")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = (*m) + 1; i < *lda; i++ {
									if (*aa)[i+j*(*lda)] != (*as)[i+j*(*lda)] {
										t.Errorf("Test Failed: aa[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*lda), nc, (*aa)[i+j*(*lda)], (*as)[i+j*(*lda)])
									}
								}
							}

							if *incx > 0 {
								for i = 1; i <= *m; i++ {
									(*z)[i-1][0] = (*x)[i-1]
								}
							} else {
								for i = 1; i <= *m; i++ {
									(*z)[i-1][0] = (*x)[(*m)-i]
								}
							}
							for j = 1; j <= *n; j++ {
								if *incy > 0 {
									(*w)[0] = (*y)[j-1]
								} else {
									(*w)[0] = (*y)[(*n)-j]
								}
								for i = range *ax {
									(*ax)[i] = (*a)[i][j-1]
								}

								zmvchTest(_N, m, onei, alpha, z, w, onei, onec128, ax, onei, yt, g)
								_aa := (*aa)[(j-1)*(*lda):]
								err = 0
								for i = 1; i <= *m; i++ {
									erri = abssumf64((*yt)[i-1]-_aa[i-1]) / epsf64
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf64(err, erri)
									if err*sqrtf64(epsf64) >= 1.0 {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.8e} error", i-1, nc, j, (*aa)[i-1], (*at)[i-1], err*sqrtf64(epsf64))
									}
								}
							}
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
		}

	}

	printTestsRun(tname, nc)
}

func BenchmarkZgeru(b *testing.B) {
	alpha := new(complex128)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*m = 14
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*incy = 2
	*lda = 15

	for i := 0; i < b.N; i++ {
		Zgerc(major, m, n, alpha, xx, incx, yy, incy, aa, lda)
	}
}

func BenchmarkZgeruFortran(b *testing.B) {
	alpha := new(complex128)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*m = 14
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*incy = 2
	*lda = 15

	for i := 0; i < b.N; i++ {
		zgercWrapper(m, n, alpha, xx, incx, yy, incy, aa, lda)
	}
}

func TestZher(t *testing.T) {
	tname := "Zher"
	var i, ia, ic, in, incxs, ix, j, ja, jj, laa, ldas, lj, lx, ns, nc int
	var rals, err, erri float64
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	ralpha := new(float64)
	alpha := new(complex128)
	transl := new(complex128)
	n := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	at := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xs := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yt := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	w := func() *[]complex128 { y := make([]complex128, 1); return &y }()
	z := func() *[]complex128 { y := make([]complex128, nmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = *n
		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				*_n = (*n) - 1
				zmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				if *n > 1 {
					(*x)[*n] = 0.0
					(*xx)[1+absint(*incx)*(*n)-1] = 0.0
				}

				for ia = 1; ia <= len(alfc128L2); ia++ {
					*ralpha = real(alfc128L2[ia-1])
					*alpha = complex(*ralpha, 0.0)
					null = *n <= 0 || *ralpha == 0.0

					*transl = 0.0
					zmakeHEL2(uplo, _X, n, n, a, aa, lda, _n, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					uplos = *uplo
					ns = *n
					ldas = *lda
					incxs = *incx
					rals = *ralpha
					for i = 1; i <= laa; i++ {
						(*as)[i-1] = (*aa)[i-1]
					}
					for i = 1; i <= lx; i++ {
						(*xs)[i-1] = (*xx)[i-1]
					}

					nc++

					_aa := zExpand(aa, n, lda)
					Zher(major, uplo, n, ralpha, xx, incx, _aa, lda)
					zReturn(_aa, aa)

					checkByte(t, nc, uplo, &uplos, "uplo")
					checkInt(t, nc, n, &ns, "n")
					checkFloat64(t, nc, ralpha, &rals, "ralpha")
					checkInt(t, nc, lda, &ldas, "lda")
					checkInt(t, nc, incx, &incxs, "incx")
					checkComplex128Array1D(t, nc, &lx, xx, xs, "xx")
					if null {
						checkComplex128Array1D(t, nc, &laa, aa, as, "guardband aa")
						if *n <= 0 {
							break
						}
					} else {
						for j = 0; j < *n; j++ {
							for i = (*n) + 1; i < *lda; i++ {
								if (*aa)[i+j*(*lda)] != (*as)[i+j*(*lda)] {
									t.Errorf("Test Failed: aa[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*lda), nc, (*aa)[i+j*(*lda)], (*as)[i+j*(*lda)])
								}
							}
						}

						if *incx > 0 {
							for i = 1; i <= *n; i++ {
								(*z)[i-1] = (*x)[i-1]
							}
						} else {
							for i = 1; i <= *n; i++ {
								(*z)[i-1] = (*x)[(*n)-i]
							}
						}
						ja = 1
						for j = 1; j <= *n; j++ {
							(*w)[0] = complex128(cmplx.Conj(complex128((*z)[j-1])))
							if *uplo == 'U' {
								jj = 1
								lj = j
							} else {
								jj = j
								lj = (*n) - j + 1
							}
							_z := func() *[][]complex128 {
								arr := make([][]complex128, *n)
								for i := range arr {
									arr[i] = make([]complex128, 1)
									arr[i][0] = (*z)[i+jj-1]
								}
								return &arr
							}()
							_a := func() *[]complex128 { y := make([]complex128, lj); return &y }()
							for i = range *_a {
								(*_a)[i] = (*a)[jj-1+i][j-1]
							}

							zmvchTest(_N, &lj, onei, alpha, _z, w, onei, onec128, _a, onei, yt, g)
							_aa := (*aa)[ja-1:]
							err = 0
							for i = 1; i <= lj; i++ {
								erri = abssumf64((*yt)[i-1]-_aa[i-1]) / epsf64
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf64(err, erri)
								if err*sqrtf64(epsf64) >= 1.0 {
									t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.8e} error", i-1, nc, j, (*aa)[i-1], (*at)[i-1], err*sqrtf64(epsf64))
								}
							}

							if *uplo == 'U' {
								ja += *lda
							} else {
								ja += (*lda) + 1
							}
						}
					}
				}

				if *n <= 0 {
					break
				}
			}

			if *n <= 0 {
				break
			}
		}

	}

	printTestsRun(tname, nc)
}

func BenchmarkZher(b *testing.B) {
	uplo := new(byte)
	ralpha := new(float64)
	n := new(int)
	incx := new(int)
	lda := new(int)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*ralpha = 0.70
	*incx = 2
	*lda = 10

	for i := 0; i < b.N; i++ {
		Zher(major, uplo, n, ralpha, xx, incx, aa, lda)
	}
}

func BenchmarkZherFortran(b *testing.B) {
	uplo := new(byte)
	ralpha := new(float64)
	n := new(int)
	incx := new(int)
	lda := new(int)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*ralpha = 0.70
	*incx = 2
	*lda = 10

	for i := 0; i < b.N; i++ {
		zherWrapper(uplo, n, ralpha, xx, incx, aa, lda)
	}
}

func TestZhpr(t *testing.T) {
	tname := "Zhpr"
	var i, ia, ic, in, incxs, ix, j, ja, jj, laa, lj, lx, ns, nc int
	var rals, err, erri float64
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	ralpha := new(float64)
	alpha := new(complex128)
	transl := new(complex128)
	n := new(int)
	lda := new(int)
	incx := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	at := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xs := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yt := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	w := func() *[]complex128 { y := make([]complex128, 1); return &y }()
	z := func() *[]complex128 { y := make([]complex128, nmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = *n
		if *lda < nmax {
			*lda++
		}
		if *lda > nmax {
			continue
		}
		laa = ((*n) * ((*n) + 1)) / 2

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				*_n = (*n) - 1
				zmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				if *n > 1 {
					(*x)[*n] = 0.0
					(*xx)[1+absint(*incx)*(*n)-1] = 0.0
				}

				for ia = 1; ia <= len(alfc128L2); ia++ {
					*ralpha = real(alfc128L2[ia-1])
					*alpha = complex(*ralpha, 0.0)
					null = *n <= 0 || *ralpha == 0.0

					*transl = 0.0
					zmakeHPL2(uplo, n, n, a, aa, _n, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					uplos = *uplo
					ns = *n
					incxs = *incx
					rals = *ralpha
					for i = 1; i <= laa; i++ {
						(*as)[i-1] = (*aa)[i-1]
					}
					for i = 1; i <= lx; i++ {
						(*xs)[i-1] = (*xx)[i-1]
					}

					nc++

					Zhpr(major, uplo, n, ralpha, xx, incx, aa)

					checkByte(t, nc, uplo, &uplos, "uplo")
					checkInt(t, nc, n, &ns, "n")
					checkFloat64(t, nc, ralpha, &rals, "ralpha")
					checkInt(t, nc, incx, &incxs, "incx")
					checkComplex128Array1D(t, nc, &lx, xx, xs, "xx")
					if null {
						checkComplex128Array1D(t, nc, &laa, aa, as, "guardband aa")
						if *n <= 0 {
							break
						}
					} else {
						for j = 0; j < *n; j++ {
							for i = (*n) + 1; i < *lda; i++ {
								if (*aa)[i+j*(*lda)] != (*as)[i+j*(*lda)] {
									t.Errorf("Test Failed: aa[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*lda), nc, (*aa)[i+j*(*lda)], (*as)[i+j*(*lda)])
								}
							}
						}

						if *incx > 0 {
							for i = 1; i <= *n; i++ {
								(*z)[i-1] = (*x)[i-1]
							}
						} else {
							for i = 1; i <= *n; i++ {
								(*z)[i-1] = (*x)[(*n)-i]
							}
						}
						ja = 1
						for j = 1; j <= *n; j++ {
							(*w)[0] = complex128(cmplx.Conj(complex128((*z)[j-1])))
							if *uplo == 'U' {
								jj = 1
								lj = j
							} else {
								jj = j
								lj = (*n) - j + 1
							}
							_z := func() *[][]complex128 {
								arr := make([][]complex128, *n)
								for i := range arr {
									arr[i] = make([]complex128, 1)
									arr[i][0] = (*z)[i+jj-1]
								}
								return &arr
							}()
							_a := func() *[]complex128 { y := make([]complex128, lj); return &y }()
							for i = range *_a {
								(*_a)[i] = (*a)[jj-1+i][j-1]
							}

							zmvchTest(_N, &lj, onei, alpha, _z, w, onei, onec128, _a, onei, yt, g)
							_aa := (*aa)[ja-1:]
							err = 0
							for i = 1; i <= lj; i++ {
								erri = abssumf64((*yt)[i-1]-_aa[i-1]) / epsf64
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf64(err, erri)
								if err*sqrtf64(epsf64) >= 1.0 {
									t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.8e} error", i-1, nc, j, (*aa)[i-1], (*at)[i-1], err*sqrtf64(epsf64))
								}
							}

							ja += lj
						}
					}
				}

				if *n <= 0 {
					break
				}
			}

			if *n <= 0 {
				break
			}
		}

	}

	printTestsRun(tname, nc)
}

func BenchmarkZhpr(b *testing.B) {
	uplo := new(byte)
	ralpha := new(float64)
	n := new(int)
	incx := new(int)
	major := new(byte)
	*major = 'C'
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*ralpha = 0.70
	*incx = 2

	for i := 0; i < b.N; i++ {
		Zhpr(major, uplo, n, ralpha, xx, incx, aa)
	}
}

func BenchmarkZhprFortran(b *testing.B) {
	uplo := new(byte)
	ralpha := new(float64)
	n := new(int)
	incx := new(int)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*ralpha = 0.70
	*incx = 2

	for i := 0; i < b.N; i++ {
		zhprWrapper(uplo, n, ralpha, xx, incx, aa)
	}
}

func TestZher2(t *testing.T) {
	tname := "Zher2"
	var i, ia, ic, in, incxs, incys, ix, iy, j, ja, jj, laa, ldas, lj, lx, ly, ns, nc int
	var als complex128
	var err, erri float64
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex128)
	transl := new(complex128)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	at := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xs := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	y := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	ys := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yt := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	w := func() *[]complex128 { y := make([]complex128, 2); return &y }()
	z := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, 2)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = *n
		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				*_n = (*n) - 1
				zmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				if *n > 1 {
					(*x)[*n] = 0.0
					(*xx)[1+absint(*incx)*(*n)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					*transl = 0.0
					zmakeGEL2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					if *n > 1 {
						(*y)[*n] = 0.0
						(*yy)[1+absint(*incy)*(*n)-1] = 0.0
					}

					for ia = 1; ia <= len(alfc128L2); ia++ {
						*alpha = alfc128L2[ia-1]
						null = *n <= 0 || *alpha == 0.0

						*transl = 0.0
						zmakeHEL2(uplo, _X, n, n, a, aa, lda, _n, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

						uplos = *uplo
						ns = *n
						ldas = *lda
						incxs = *incx
						incys = *incy
						als = *alpha
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}
						for i = 1; i <= ly; i++ {
							(*ys)[i-1] = (*yy)[i-1]
						}

						nc++

						_aa := zExpand(aa, n, lda)
						Zher2(major, uplo, n, alpha, xx, incx, yy, incy, _aa, lda)
						zReturn(_aa, aa)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkInt(t, nc, n, &ns, "n")
						checkComplex128(t, nc, alpha, &als, "alpha")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkInt(t, nc, incy, &incys, "incy")
						checkComplex128Array1D(t, nc, &lx, xx, xs, "xx")
						checkComplex128Array1D(t, nc, &ly, yy, ys, "yy")
						if null {
							checkComplex128Array1D(t, nc, &laa, aa, as, "guardband aa")
							if *n <= 0 {
								break
							}
						} else {
							for j = 0; j < *n; j++ {
								for i = (*n) + 1; i < *lda; i++ {
									if (*aa)[i+j*(*lda)] != (*as)[i+j*(*lda)] {
										t.Errorf("Test Failed: aa[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*lda), nc, (*aa)[i+j*(*lda)], (*as)[i+j*(*lda)])
									}
								}
							}

							if *incx > 0 {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][0] = (*x)[i-1]
								}
							} else {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][0] = (*x)[(*n)-i]
								}
							}
							if *incy > 0 {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][1] = (*y)[i-1]
								}
							} else {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][1] = (*y)[(*n)-i]
								}
							}
							ja = 1
							for j = 1; j <= *n; j++ {
								(*w)[0] = (*alpha) * complex128(cmplx.Conj(complex128((*z)[j-1][1])))
								(*w)[1] = complex128(cmplx.Conj(complex128(*alpha))) * complex128(cmplx.Conj(complex128((*z)[j-1][0])))
								if *uplo == 'U' {
									jj = 1
									lj = j
								} else {
									jj = j
									lj = (*n) - j + 1
								}
								_z := func() *[][]complex128 {
									arr := make([][]complex128, lj)
									for i := range arr {
										arr[i] = make([]complex128, 2)
										arr[i][0] = (*z)[i+jj-1][0]
										arr[i][1] = (*z)[i+jj-1][1]
									}
									return &arr
								}()
								_a := func() *[]complex128 { y := make([]complex128, lj); return &y }()
								for i = range *_a {
									(*_a)[i] = (*a)[jj-1+i][j-1]
								}

								zmvchTest(_N, &lj, twoi, onec128, _z, w, onei, onec128, _a, onei, yt, g)
								_aa := (*aa)[ja-1:]
								err = 0
								for i = 1; i <= lj; i++ {
									erri = abssumf64((*yt)[i-1]-_aa[i-1]) / epsf64
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf64(err, erri)
									if err*sqrtf64(epsf64) >= 1.0 {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.8e} error", i-1, nc, j, (*aa)[i-1], (*at)[i-1], err*sqrtf64(epsf64))
									}
								}

								if *uplo == 'U' {
									ja += *lda
								} else {
									ja += (*lda) + 1
								}
							}
						}
					}

					if *n <= 0 {
						break
					}
				}

				if *n <= 0 {
					break
				}
			}

			if *n <= 0 {
				break
			}
		}

	}

	printTestsRun(tname, nc)
}

func BenchmarkZher2(b *testing.B) {
	uplo := new(byte)
	alpha := new(complex128)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*incy = 2
	*lda = 10

	for i := 0; i < b.N; i++ {
		Zher2(major, uplo, n, alpha, xx, incx, yy, incy, aa, lda)
	}
}

func BenchmarkZher2Fortran(b *testing.B) {
	uplo := new(byte)
	alpha := new(complex128)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*incy = 2
	*lda = 10

	for i := 0; i < b.N; i++ {
		zher2Wrapper(uplo, n, alpha, xx, incx, yy, incy, aa, lda)
	}
}

func TestZhpr2(t *testing.T) {
	tname := "Zhpr2"
	var i, ia, ic, in, incxs, incys, ix, iy, j, ja, jj, laa, lj, lx, ly, ns, nc int
	var als complex128
	var err, erri float64
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex128)
	transl := new(complex128)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	at := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*incmax); return &y }()
	x := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	xs := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	y := func() *[]complex128 { y := make([]complex128, nmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	ys := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yt := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	w := func() *[]complex128 { y := make([]complex128, 2); return &y }()
	z := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, 2)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = *n
		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = ((*n) * ((*n) + 1)) / 2

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				*_n = (*n) - 1
				zmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				if *n > 1 {
					(*x)[*n] = 0.0
					(*xx)[1+absint(*incx)*(*n)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					*transl = 0.0
					zmakeGEL2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					if *n > 1 {
						(*y)[*n] = 0.0
						(*yy)[1+absint(*incy)*(*n)-1] = 0.0
					}

					for ia = 1; ia <= len(alfc128L2); ia++ {
						*alpha = alfc128L2[ia-1]
						null = *n <= 0 || *alpha == 0.0

						*transl = 0.0
						zmakeHPL2(uplo, n, n, a, aa, lda, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

						uplos = *uplo
						ns = *n
						incxs = *incx
						incys = *incy
						als = *alpha
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}
						for i = 1; i <= ly; i++ {
							(*ys)[i-1] = (*yy)[i-1]
						}

						nc++

						Zhpr2(major, uplo, n, alpha, xx, incx, yy, incy, aa)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkInt(t, nc, n, &ns, "n")
						checkComplex128(t, nc, alpha, &als, "alpha")
						checkInt(t, nc, incx, &incxs, "incx")
						checkInt(t, nc, incy, &incys, "incy")
						checkComplex128Array1D(t, nc, &lx, xx, xs, "xx")
						checkComplex128Array1D(t, nc, &ly, yy, ys, "yy")
						if null {
							checkComplex128Array1D(t, nc, &laa, aa, as, "guardband aa")
							if *n <= 0 {
								break
							}
						} else {
							for j = 0; j < *n; j++ {
								for i = (*n) + 1; i < *lda; i++ {
									if (*aa)[i+j*(*lda)] != (*as)[i+j*(*lda)] {
										t.Errorf("Test Failed: aa[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*lda), nc, (*aa)[i+j*(*lda)], (*as)[i+j*(*lda)])
									}
								}
							}

							if *incx > 0 {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][0] = (*x)[i-1]
								}
							} else {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][0] = (*x)[(*n)-i]
								}
							}
							if *incy > 0 {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][1] = (*y)[i-1]
								}
							} else {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][1] = (*y)[(*n)-i]
								}
							}
							ja = 1
							for j = 1; j <= *n; j++ {
								(*w)[0] = (*alpha) * complex128(cmplx.Conj(complex128((*z)[j-1][1])))
								(*w)[1] = complex128(cmplx.Conj(complex128(*alpha))) * complex128(cmplx.Conj(complex128((*z)[j-1][0])))
								if *uplo == 'U' {
									jj = 1
									lj = j
								} else {
									jj = j
									lj = (*n) - j + 1
								}
								_z := func() *[][]complex128 {
									arr := make([][]complex128, lj)
									for i := range arr {
										arr[i] = make([]complex128, 2)
										arr[i][0] = (*z)[i+jj-1][0]
										arr[i][1] = (*z)[i+jj-1][1]
									}
									return &arr
								}()
								_a := func() *[]complex128 { y := make([]complex128, lj); return &y }()
								for i = range *_a {
									(*_a)[i] = (*a)[jj-1+i][j-1]
								}

								zmvchTest(_N, &lj, twoi, onec128, _z, w, onei, onec128, _a, onei, yt, g)
								_aa := (*aa)[ja-1:]
								err = 0
								for i = 1; i <= lj; i++ {
									erri = abssumf64((*yt)[i-1]-_aa[i-1]) / epsf64
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf64(err, erri)
									if err*sqrtf64(epsf64) >= 1.0 {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.8e} error", i-1, nc, j, (*aa)[i-1], (*at)[i-1], err*sqrtf64(epsf64))
									}
								}

								ja += lj
							}
						}
					}

					if *n <= 0 {
						break
					}
				}

				if *n <= 0 {
					break
				}
			}

			if *n <= 0 {
				break
			}
		}

	}

	printTestsRun(tname, nc)
}

func BenchmarkZhpr2(b *testing.B) {
	uplo := new(byte)
	alpha := new(complex128)
	n := new(int)
	incx := new(int)
	incy := new(int)
	major := new(byte)
	*major = 'C'
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*incy = 2

	for i := 0; i < b.N; i++ {
		Zhpr2(major, uplo, n, alpha, xx, incx, yy, incy, aa)
	}
}

func BenchmarkZhpr2Fortran(b *testing.B) {
	uplo := new(byte)
	alpha := new(complex128)
	n := new(int)
	incx := new(int)
	incy := new(int)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*incy = 2

	for i := 0; i < b.N; i++ {
		zhpr2Wrapper(uplo, n, alpha, xx, incx, yy, incy, aa)
	}
}

// BLAS Level 3
func TestZgemm(t *testing.T) {
	tname := "Zgemm"
	var i, ia, ib, ica, icb, ik, im, in, j, ks, laa, lbb, lcc, ldas, ldbs, ldcs, ms, nc, ns int
	var als, bls complex128
	var tranas, tranbs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex128)
	beta := new(complex128)
	transl := new(complex128)
	k := new(int)
	m := new(int)
	ma := new(int)
	mb := new(int)
	n := new(int)
	na := new(int)
	nb := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	transa := new(byte)
	transb := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	b := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	bb := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	bs := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	c := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	cc := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	cs := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	ct := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldc = *m
			if *ldc < nmax {
				*ldc++
			}
			if *ldc > nmax {
				continue
			}
			lcc = (*ldc) * (*n)

			null = *n <= 0 || *m <= 0

			for ik = 1; ik <= len(idimL3); ik++ {
				*k = idimL3[ik-1]

				for ica = 1; ica <= len(ichtL3); ica++ {
					*transa = ichtL3[ica-1]

					if *transa == 'T' || *transa == 'C' {
						*ma = *k
						*na = *m
					} else {
						*ma = *m
						*na = *k
					}

					*lda = *ma
					if *lda < nmax {
						*lda++
					}
					if *lda > nmax {
						continue
					}
					laa = (*lda) * (*na)

					zmakeGEL3(ma, na, a, aa, lda, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					for icb = 1; icb <= len(ichtL3); icb++ {
						*transb = ichtL3[icb-1]

						if *transb == 'T' || *transb == 'C' {
							*mb = *n
							*nb = *k
						} else {
							*mb = *k
							*nb = *n
						}

						*ldb = *mb
						if *ldb < nmax {
							*ldb++
						}
						if *ldb > nmax {
							continue
						}
						lbb = (*ldb) * (*nb)

						zmakeGEL3(mb, nb, b, bb, ldb, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

						for ia = 1; ia <= len(alfc128L3); ia++ {
							*alpha = alfc128L3[ia-1]

							for ib = 1; ib <= len(betc128L3); ib++ {
								*beta = betc128L3[ib-1]

								zmakeGEL3(m, n, c, cc, ldc, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

								tranas = *transa
								tranbs = *transb
								ms = *m
								ns = *n
								ks = *k
								als = *alpha
								bls = *beta
								ldas = *lda
								ldbs = *ldb
								ldcs = *ldc
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lbb; i++ {
									(*bs)[i-1] = (*bb)[i-1]
								}
								for i = 1; i <= lcc; i++ {
									(*cs)[i-1] = (*cc)[i-1]
								}

								nc++

								_aa := zExpand(aa, na, lda)
								_bb := zExpand(bb, nb, ldb)
								_cc := zExpand(cc, n, ldc)
								Zgemm(major, transa, transb, m, n, k, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
								zReturn(_aa, aa)
								zReturn(_bb, bb)
								zReturn(_cc, cc)

								checkByte(t, nc, transa, &tranas, "transa")
								checkByte(t, nc, transb, &tranbs, "transb")
								checkInt(t, nc, m, &ms, "m")
								checkInt(t, nc, n, &ns, "n")
								checkInt(t, nc, k, &ks, "k")
								checkComplex128(t, nc, alpha, &als, "alpha")
								checkComplex128(t, nc, beta, &bls, "beta")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, ldb, &ldbs, "ldb")
								checkInt(t, nc, ldc, &ldcs, "ldc")
								checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
								checkComplex128Array1D(t, nc, &lbb, bb, bs, "bb")
								if null {
									checkComplex128Array1D(t, nc, &lcc, cc, cs, "guardband cc")
								} else {
									for j = 0; j < *n; j++ {
										for i = (*m) + 1; i <= *ldc; i++ {
											if (*cc)[i+j*(*ldc)-1] != (*cs)[i+j*(*ldc)-1] {
												t.Errorf("Test Failed: cc[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldc), nc, (*cc)[i+j*(*ldc)], (*cs)[i+j*(*ldc)])
											}
										}
									}

									zmmchTest(transa, transb, m, n, k, alpha, a, b, beta, c, ct, g, cc, ldc, nc, "cc", t)
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZgemm(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	k := new(int)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	transa := new(byte)
	transb := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	bb := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	cc := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()

	*transa = 'C'
	*transb = 'C'
	*m = 9
	*n = 9
	*k = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*beta = (1.3 - 1.1i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Zgemm(major, transa, transb, m, n, k, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func BenchmarkZgemmFortran(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	k := new(int)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	transa := new(byte)
	transb := new(byte)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	bb := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	cc := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()

	*transa = 'C'
	*transb = 'C'
	*m = 9
	*n = 9
	*k = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*beta = (1.3 - 1.1i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		zgemmWrapper(transa, transb, m, n, k, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func TestZhemm(t *testing.T) {
	tname := "Zhemm"
	var i, ia, ib, ics, icu, im, in, j, laa, lbb, lcc, ldas, ldbs, ldcs, ms, nc, ns int
	var als, bls complex128
	var sides, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex128)
	beta := new(complex128)
	transl := new(complex128)
	m := new(int)
	n := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	side := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	b := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	bb := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	bs := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	c := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	cc := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	cs := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	ct := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldc = *m
			if *ldc < nmax {
				*ldc++
			}
			if *ldc > nmax {
				continue
			}
			lcc = (*ldc) * (*n)

			null = *n <= 0 || *m <= 0

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			zmakeGEL3(m, n, b, bb, ldb, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

			for ics = 1; ics <= len(ichsL3); ics++ {
				*side = ichsL3[ics-1]

				if *side == 'L' {
					*na = *m
				} else {
					*na = *n
				}

				*lda = *na
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					zmakeHEL3(uplo, na, na, a, aa, lda, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					for ia = 1; ia <= len(alfc128L3); ia++ {
						*alpha = alfc128L3[ia-1]

						for ib = 1; ib <= len(betc128L3); ib++ {
							*beta = betc128L3[ib-1]

							zmakeGEL3(m, n, c, cc, ldc, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

							sides = *side
							uplos = *uplo
							ms = *m
							ns = *n
							als = *alpha
							bls = *beta
							ldas = *lda
							ldbs = *ldb
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lbb; i++ {
								(*bs)[i-1] = (*bb)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := zExpand(aa, na, lda)
							_bb := zExpand(bb, n, ldb)
							_cc := zExpand(cc, n, ldc)
							Zhemm(major, side, uplo, m, n, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
							zReturn(_aa, aa)
							zReturn(_bb, bb)
							zReturn(_cc, cc)

							checkByte(t, nc, side, &sides, "side")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, m, &ms, "m")
							checkInt(t, nc, n, &ns, "n")
							checkComplex128(t, nc, alpha, &als, "alpha")
							checkComplex128(t, nc, beta, &bls, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldb, &ldbs, "ldb")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
							checkComplex128Array1D(t, nc, &lbb, bb, bs, "bb")
							if null {
								checkComplex128Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 0; j < *n; j++ {
									for i = (*m) + 1; i <= *ldc; i++ {
										if (*cc)[i+j*(*ldc)-1] != (*cs)[i+j*(*ldc)-1] {
											t.Errorf("Test Failed: guardband cc[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldc), nc, (*cc)[i+j*(*ldc)], (*cs)[i+j*(*ldc)])
										}
									}
								}

								if *side == 'L' {
									zmmchTest(_N, _N, m, n, m, alpha, a, b, beta, c, ct, g, cc, ldc, nc, "cc", t)
								} else {
									zmmchTest(_N, _N, m, n, n, alpha, b, a, beta, c, ct, g, cc, ldc, nc, "cc", t)
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZhemm(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	side := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	bb := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	cc := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()

	*side = 'R'
	*uplo = 'L'
	*m = 9
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*beta = (1.30 - 1.10i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Zhemm(major, side, uplo, m, n, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func BenchmarkZhemmFortran(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	side := new(byte)
	uplo := new(byte)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	bb := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	cc := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()

	*side = 'R'
	*uplo = 'L'
	*m = 9
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*beta = (1.30 - 1.10i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		zhemmWrapper(side, uplo, m, n, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func TestZsymm(t *testing.T) {
	tname := "Zsymm"
	var i, ia, ib, ics, icu, im, in, j, laa, lbb, lcc, ldas, ldbs, ldcs, ms, nc, ns int
	var als, bls complex128
	var sides, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex128)
	beta := new(complex128)
	transl := new(complex128)
	m := new(int)
	n := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	side := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	b := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	bb := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	bs := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	c := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	cc := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	cs := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	ct := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldc = *m
			if *ldc < nmax {
				*ldc++
			}
			if *ldc > nmax {
				continue
			}
			lcc = (*ldc) * (*n)

			null = *n <= 0 || *m <= 0

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			zmakeGEL3(m, n, b, bb, ldb, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

			for ics = 1; ics <= len(ichsL3); ics++ {
				*side = ichsL3[ics-1]

				if *side == 'L' {
					*na = *m
				} else {
					*na = *n
				}

				*lda = *na
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					zmakeSYL3(uplo, na, na, a, aa, lda, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					for ia = 1; ia <= len(alfc128L3); ia++ {
						*alpha = alfc128L3[ia-1]

						for ib = 1; ib <= len(betc128L3); ib++ {
							*beta = betc128L3[ib-1]

							zmakeGEL3(m, n, c, cc, ldc, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

							sides = *side
							uplos = *uplo
							ms = *m
							ns = *n
							als = *alpha
							bls = *beta
							ldas = *lda
							ldbs = *ldb
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lbb; i++ {
								(*bs)[i-1] = (*bb)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := zExpand(aa, na, lda)
							_bb := zExpand(bb, n, ldb)
							_cc := zExpand(cc, n, ldc)
							Zsymm(major, side, uplo, m, n, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
							zReturn(_aa, aa)
							zReturn(_bb, bb)
							zReturn(_cc, cc)

							checkByte(t, nc, side, &sides, "side")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, m, &ms, "m")
							checkInt(t, nc, n, &ns, "n")
							checkComplex128(t, nc, alpha, &als, "alpha")
							checkComplex128(t, nc, beta, &bls, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldb, &ldbs, "ldb")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
							checkComplex128Array1D(t, nc, &lbb, bb, bs, "bb")
							if null {
								checkComplex128Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 0; j < *n; j++ {
									for i = (*m) + 1; i <= *ldc; i++ {
										if (*cc)[i+j*(*ldc)-1] != (*cs)[i+j*(*ldc)-1] {
											t.Errorf("Test Failed: guardband cc[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldc), nc, (*cc)[i+j*(*ldc)], (*cs)[i+j*(*ldc)])
										}
									}
								}

								if *side == 'L' {
									zmmchTest(_N, _N, m, n, m, alpha, a, b, beta, c, ct, g, cc, ldc, nc, "cc", t)
								} else {
									zmmchTest(_N, _N, m, n, n, alpha, b, a, beta, c, ct, g, cc, ldc, nc, "cc", t)
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZsymm(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	side := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	bb := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	cc := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()

	*side = 'R'
	*uplo = 'L'
	*m = 9
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*beta = (1.30 - 1.10i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Zsymm(major, side, uplo, m, n, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func BenchmarkZsymmFortran(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	side := new(byte)
	uplo := new(byte)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	bb := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	cc := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()

	*side = 'R'
	*uplo = 'L'
	*m = 9
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*beta = (1.30 - 1.10i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		zsymmWrapper(side, uplo, m, n, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func TestZtrmm(t *testing.T) {
	tname := "Ztrmm"
	var i, ia, icd, ics, ict, icu, im, in, j, laa, lbb, ldas, ldbs, ms, nc, ns int
	var als complex128
	var diags, sides, tranas, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex128)
	m := new(int)
	n := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	b := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	bb := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	bs := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	c := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	ct := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			null = *n <= 0 || *m <= 0

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			for ics = 1; ics <= len(ichsL3); ics++ {
				*side = ichsL3[ics-1]

				if *side == 'L' {
					*na = *m
				} else {
					*na = *n
				}

				*lda = *na
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ict = 1; ict <= len(ichtL3); ict++ {
						*transa = ichtL3[ict-1]

						for icd = 1; icd <= len(ichdL3); icd++ {
							*diag = ichdL3[icd-1]

							for ia = 1; ia <= len(alfc128L3); ia++ {
								*alpha = alfc128L3[ia-1]

								zmakeTRL3(uplo, diag, na, na, a, aa, lda, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

								zmakeGEL3(m, n, b, bb, ldb, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

								diags = *diag
								sides = *side
								tranas = *transa
								uplos = *uplo
								ms = *m
								ns = *n
								als = *alpha
								ldas = *lda
								ldbs = *ldb
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lbb; i++ {
									(*bs)[i-1] = (*bb)[i-1]
								}

								nc++

								_aa := zExpand(aa, na, lda)
								_bb := zExpand(bb, n, ldb)
								Ztrmm(major, side, uplo, transa, diag, m, n, alpha, _aa, lda, _bb, ldb)
								zReturn(_aa, aa)
								zReturn(_bb, bb)

								checkByte(t, nc, diag, &diags, "diag")
								checkByte(t, nc, side, &sides, "side")
								checkByte(t, nc, transa, &tranas, "transa")
								checkByte(t, nc, uplo, &uplos, "uplo")
								checkInt(t, nc, m, &ms, "m")
								checkInt(t, nc, n, &ns, "n")
								checkComplex128(t, nc, alpha, &als, "alpha")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, ldb, &ldbs, "ldb")
								checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
								if null {
									checkComplex128Array1D(t, nc, &lbb, bb, bs, "guardband bb")
								} else {
									for j = 0; j < *n; j++ {
										for i = (*m) + 1; i <= *ldb; i++ {
											if (*bb)[i+j*(*ldb)-1] != (*bs)[i+j*(*ldb)-1] {
												t.Errorf("Test Failed: guardband bb[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldb), nc, (*bb)[i+j*(*ldb)], (*bs)[i+j*(*ldb)])
											}
										}
									}

									if *side == 'L' {
										zmmchTest(transa, _N, m, n, m, alpha, a, b, zeroc128, c, ct, g, bb, ldb, nc, "bb", t)
									} else {
										zmmchTest(_N, transa, m, n, n, alpha, b, a, zeroc128, c, ct, g, bb, ldb, nc, "bb", t)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZtrmm(b *testing.B) {
	alpha := new(complex128)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	bb := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()

	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'U'
	*m = 9
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10

	for i := 0; i < b.N; i++ {
		Ztrmm(major, side, uplo, transa, diag, m, n, alpha, aa, lda, bb, ldb)
	}
}

func BenchmarkZtrmmFortran(b *testing.B) {
	alpha := new(complex128)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	bb := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()

	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'U'
	*m = 9
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10

	for i := 0; i < b.N; i++ {
		ztrmmWrapper(side, uplo, transa, diag, m, n, alpha, aa, lda, bb, ldb)
	}
}

func TestZtrsm(t *testing.T) {
	tname := "Ztrsm"
	var i, ia, icd, ics, ict, icu, im, in, j, laa, lbb, ldas, ldbs, ms, nc, ns int
	var als complex128
	var diags, sides, tranas, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex128)
	m := new(int)
	n := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	b := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	bb := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	bs := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	c := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	ct := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			null = *n <= 0 || *m <= 0

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			for ics = 1; ics <= len(ichsL3); ics++ {
				*side = ichsL3[ics-1]

				if *side == 'L' {
					*na = *m
				} else {
					*na = *n
				}

				*lda = *na
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ict = 1; ict <= len(ichtL3); ict++ {
						*transa = ichtL3[ict-1]

						for icd = 1; icd <= len(ichdL3); icd++ {
							*diag = ichdL3[icd-1]

							for ia = 1; ia <= len(alfc128L3); ia++ {
								*alpha = alfc128L3[ia-1]

								zmakeTRL3(uplo, diag, na, na, a, aa, lda, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

								zmakeGEL3(m, n, b, bb, ldb, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

								diags = *diag
								sides = *side
								tranas = *transa
								uplos = *uplo
								ms = *m
								ns = *n
								als = *alpha
								ldas = *lda
								ldbs = *ldb
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lbb; i++ {
									(*bs)[i-1] = (*bb)[i-1]
								}

								nc++

								_aa := zExpand(aa, na, lda)
								_bb := zExpand(bb, n, ldb)
								Ztrsm(major, side, uplo, transa, diag, m, n, alpha, _aa, lda, _bb, ldb)
								zReturn(_aa, aa)
								zReturn(_bb, bb)

								checkByte(t, nc, diag, &diags, "diag")
								checkByte(t, nc, side, &sides, "side")
								checkByte(t, nc, transa, &tranas, "transa")
								checkByte(t, nc, uplo, &uplos, "uplo")
								checkInt(t, nc, m, &ms, "m")
								checkInt(t, nc, n, &ns, "n")
								checkComplex128(t, nc, alpha, &als, "alpha")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, ldb, &ldbs, "ldb")
								checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
								if null {
									checkComplex128Array1D(t, nc, &lbb, bb, bs, "guardband bb")
								} else {
									for j = 0; j < *n; j++ {
										for i = (*m) + 1; i <= *ldb; i++ {
											if (*bb)[i+j*(*ldb)-1] != (*bs)[i+j*(*ldb)-1] {
												t.Errorf("Test Failed: guardband bb[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldb), nc, (*bb)[i+j*(*ldb)], (*bs)[i+j*(*ldb)])
											}
										}
									}

									for j = 1; j <= *n; j++ {
										for i = 1; i <= *m; i++ {
											(*c)[i-1][j-1] = (*bb)[i+(j-1)*(*ldb)-1]
											(*bb)[i+(j-1)*(*ldb)-1] = (*alpha) * (*b)[i-1][j-1]
										}
									}
									if *side == 'L' {
										zmmchTest(transa, _N, m, n, m, onec128, a, c, zeroc128, b, ct, g, bb, ldb, nc, "bb", t)
									} else {
										zmmchTest(_N, transa, m, n, n, onec128, c, a, zeroc128, b, ct, g, bb, ldb, nc, "bb", t)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZtrsm(b *testing.B) {
	alpha := new(complex128)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	bb := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()

	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'U'
	*m = 9
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10

	for i := 0; i < b.N; i++ {
		Ztrsm(major, side, uplo, transa, diag, m, n, alpha, aa, lda, bb, ldb)
	}
}

func BenchmarkZtrsmFortran(b *testing.B) {
	alpha := new(complex128)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	bb := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()

	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'U'
	*m = 9
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10

	for i := 0; i < b.N; i++ {
		ztrsmWrapper(side, uplo, transa, diag, m, n, alpha, aa, lda, bb, ldb)
	}
}

func TestZherk(t *testing.T) {
	tname := "Zherk"
	var i, ia, ib, ibeg, ict, icu, ik, in, iend, j, jc, jj, ks, laa, lcc, ldas, ldcs, nc, ns, x, y int
	var rals, rbls float64
	var transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	ralpha := new(float64)
	rbeta := new(float64)
	alpha := new(complex128)
	beta := new(complex128)
	k := new(int)
	n := new(int)
	lj := new(int)
	ma := new(int)
	na := new(int)
	lda := new(int)
	ldc := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	c := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	cc := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	cs := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	ct := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	for in = 1; in <= len(idimL3); in++ {
		*n = idimL3[in-1]

		*ldc = *n
		if *ldc < nmax {
			*ldc++
		}
		if *ldc > nmax {
			continue
		}
		lcc = (*ldc) * (*n)

		for ik = 1; ik <= len(idimL3); ik++ {
			*k = idimL3[ik-1]

			for ict = 1; ict <= len(ichtL3); ict++ {
				*trans = ichtL3[ict-1]
				if *trans == 'T' {
					continue
				}

				if *trans == 'T' || *trans == 'C' {
					*ma = *k
					*na = *n
				} else {
					*ma = *n
					*na = *k
				}

				*lda = *ma
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				zmakeGEL3(ma, na, a, aa, lda, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ia = 1; ia <= len(alfc128L3); ia++ {
						*alpha = alfc128L3[ia-1]
						*ralpha = real(*alpha)
						*alpha = complex(*ralpha, 0.0)

						for ib = 1; ib <= len(betc128L3); ib++ {
							*beta = betc128L3[ib-1]
							*rbeta = real(*beta)
							*beta = complex(*rbeta, 0.0)

							null = *n <= 0 || ((*k <= 0 || *ralpha == 0.0) && *rbeta == 1.0)

							zmakeHEL3(uplo, n, n, c, cc, ldc, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

							transs = *trans
							uplos = *uplo
							ns = *n
							ks = *k
							rals = *ralpha
							rbls = *rbeta
							ldas = *lda
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := zExpand(aa, na, lda)
							_cc := zExpand(cc, n, ldc)
							Zherk(major, uplo, trans, n, k, ralpha, _aa, lda, rbeta, _cc, ldc)
							zReturn(_aa, aa)
							zReturn(_cc, cc)

							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, k, &ks, "k")
							checkFloat64(t, nc, ralpha, &rals, "ralpha")
							checkFloat64(t, nc, rbeta, &rbls, "rbeta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
							if null {
								checkComplex128Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										ibeg = 1
										iend = j
									} else {
										ibeg = j
										iend = *n
									}
									for i = 1; i <= *ldc; i++ {
										if i < ibeg || i > iend {
											checkComplex128(t, nc, &(*cc)[i+(j-1)*(*ldc)-1], &(*cs)[i+(j-1)*(*ldc)-1], "guardband cc")
										}
									}
								}

								jc = 1
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										jj = 1
										*lj = j
									} else {
										jj = j
										*lj = (*n) - j + 1
									}
									_c := func() *[][]complex128 {
										arr := make([][]complex128, nmax-jj-1)
										for y := 0; y < nmax-jj-1; y++ {
											arr[y] = make([]complex128, 1)
											for x := 0; x < 1; x++ {
												arr[y][x] = (*c)[y+jj-1][x+j-1]
											}
										}
										return &arr
									}()
									_cc := func() *[]complex128 {
										arr := make([]complex128, *ldc)
										for y := 0; y < *ldc; y++ {
											for x := 0; x < 1; x++ {
												arr[y+x*(*ldc)] = (*cc)[y+jc-1+x*(*ldc)]
											}
										}
										return &arr
									}()

									if *trans == 'T' || *trans == 'C' {
										_a := func() *[][]complex128 {
											arr := make([][]complex128, nmax)
											for y = 0; y < nmax; y++ {
												arr[y] = make([]complex128, *n)
												for x = 0; x < *n; x++ {
													arr[y][x] = (*a)[y][x+jj-1]
												}
											}
											return &arr
										}()
										_b := func() *[][]complex128 {
											arr := make([][]complex128, nmax)
											for y = 0; y < nmax; y++ {
												arr[y] = make([]complex128, 1)
												for x = 0; x < 1; x++ {
													arr[y][x] = (*a)[y][x+j-1]
												}
											}
											return &arr
										}()
										zmmchTest(_C, _N, lj, onei, k, alpha, _a, _b, beta, _c, ct, g, _cc, ldc, nc, "cc", t)
									} else {
										_a := func() *[][]complex128 {
											arr := make([][]complex128, nmax-jj-1)
											for y = 0; y < nmax-jj-1; y++ {
												arr[y] = make([]complex128, *k)
												for x = 0; x < *k; x++ {
													arr[y][x] = (*a)[y+jj-1][x]
												}
											}
											return &arr
										}()
										_b := func() *[][]complex128 {
											arr := make([][]complex128, nmax-j-1)
											for y = 0; y < nmax-j-1; y++ {
												arr[y] = make([]complex128, *k)
												for x = 0; x < *k; x++ {
													arr[y][x] = (*a)[y+j-1][x]
												}
											}
											return &arr
										}()
										zmmchTest(_N, _C, lj, onei, k, alpha, _a, _b, beta, _c, ct, g, _cc, ldc, nc, "cc", t)
									}
									if *uplo == 'U' {
										jc += *ldc
									} else {
										jc += (*ldc) + 1
									}
								}
							}
						}
					}
				}
			}

		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZherk(b *testing.B) {
	ralpha := new(float64)
	rbeta := new(float64)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	cc := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()

	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*ralpha = 0.70
	*lda = 10
	*rbeta = 1.30
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Zherk(major, uplo, trans, n, k, ralpha, aa, lda, rbeta, cc, ldc)
	}
}

func BenchmarkZherkFortran(b *testing.B) {
	ralpha := new(float64)
	rbeta := new(float64)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	cc := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*ralpha = 0.70
	*lda = 10
	*rbeta = 1.30
	*ldc = 10

	for i := 0; i < b.N; i++ {
		zherkWrapper(uplo, trans, n, k, ralpha, aa, lda, rbeta, cc, ldc)
	}
}

func TestZsyrk(t *testing.T) {
	tname := "Zsyrk"
	var i, ia, ib, ibeg, ict, icu, ik, in, iend, j, jc, jj, ks, laa, lcc, ldas, ldcs, nc, ns, x, y int
	var als, bls complex128
	var transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex128)
	beta := new(complex128)
	k := new(int)
	n := new(int)
	lj := new(int)
	ma := new(int)
	na := new(int)
	lda := new(int)
	ldc := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	c := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	cc := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	cs := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	ct := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()

	for in = 1; in <= len(idimL3); in++ {
		*n = idimL3[in-1]

		*ldc = *n
		if *ldc < nmax {
			*ldc++
		}
		if *ldc > nmax {
			continue
		}
		lcc = (*ldc) * (*n)

		for ik = 1; ik <= len(idimL3); ik++ {
			*k = idimL3[ik-1]

			for ict = 1; ict <= len(ichtL3); ict++ {
				*trans = ichtL3[ict-1]
				if *trans == 'C' {
					continue
				}

				if *trans == 'T' || *trans == 'C' {
					*ma = *k
					*na = *n
				} else {
					*ma = *n
					*na = *k
				}

				*lda = *ma
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				zmakeGEL3(ma, na, a, aa, lda, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ia = 1; ia <= len(alfc128L3); ia++ {
						*alpha = alfc128L3[ia-1]

						for ib = 1; ib <= len(betc128L3); ib++ {
							*beta = betc128L3[ib-1]

							null = *n <= 0

							zmakeSYL3(uplo, n, n, c, cc, ldc, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

							transs = *trans
							uplos = *uplo
							ns = *n
							ks = *k
							als = *alpha
							bls = *beta
							ldas = *lda
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := zExpand(aa, na, lda)
							_cc := zExpand(cc, n, ldc)
							Zsyrk(major, uplo, trans, n, k, alpha, _aa, lda, beta, _cc, ldc)
							zReturn(_aa, aa)
							zReturn(_cc, cc)

							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, k, &ks, "k")
							checkComplex128(t, nc, alpha, &als, "alpha")
							checkComplex128(t, nc, beta, &bls, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
							if null {
								checkComplex128Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										ibeg = 1
										iend = j
									} else {
										ibeg = j
										iend = *n
									}
									for i = 1; i <= *ldc; i++ {
										if i < ibeg || i > iend {
											checkComplex128(t, nc, &(*cc)[i+(j-1)*(*ldc)-1], &(*cs)[i+(j-1)*(*ldc)-1], "guardband cc")
										}
									}
								}

								jc = 1
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										jj = 1
										*lj = j
									} else {
										jj = j
										*lj = (*n) - j + 1
									}
									_c := func() *[][]complex128 {
										arr := make([][]complex128, nmax-jj-1)
										for y := 0; y < nmax-jj-1; y++ {
											arr[y] = make([]complex128, 1)
											for x := 0; x < 1; x++ {
												arr[y][x] = (*c)[y+jj-1][x+j-1]
											}
										}
										return &arr
									}()
									_cc := func() *[]complex128 {
										arr := make([]complex128, *ldc)
										for y := 0; y < *ldc; y++ {
											for x := 0; x < 1; x++ {
												arr[y+x*(*ldc)] = (*cc)[y+jc-1+x*(*ldc)]
											}
										}
										return &arr
									}()

									if *trans == 'T' || *trans == 'C' {
										_a := func() *[][]complex128 {
											arr := make([][]complex128, nmax)
											for y = 0; y < nmax; y++ {
												arr[y] = make([]complex128, *n)
												for x = 0; x < *n; x++ {
													arr[y][x] = (*a)[y][x+jj-1]
												}
											}
											return &arr
										}()
										_b := func() *[][]complex128 {
											arr := make([][]complex128, nmax)
											for y = 0; y < nmax; y++ {
												arr[y] = make([]complex128, 1)
												for x = 0; x < 1; x++ {
													arr[y][x] = (*a)[y][x+j-1]
												}
											}
											return &arr
										}()
										zmmchTest(_T, _N, lj, onei, k, alpha, _a, _b, beta, _c, ct, g, _cc, ldc, nc, "cc", t)
									} else {
										_a := func() *[][]complex128 {
											arr := make([][]complex128, nmax-jj-1)
											for y = 0; y < nmax-jj-1; y++ {
												arr[y] = make([]complex128, *k)
												for x = 0; x < *k; x++ {
													arr[y][x] = (*a)[y+jj-1][x]
												}
											}
											return &arr
										}()
										_b := func() *[][]complex128 {
											arr := make([][]complex128, nmax-j-1)
											for y = 0; y < nmax-j-1; y++ {
												arr[y] = make([]complex128, *k)
												for x = 0; x < *k; x++ {
													arr[y][x] = (*a)[y+j-1][x]
												}
											}
											return &arr
										}()
										zmmchTest(_N, _T, lj, onei, k, alpha, _a, _b, beta, _c, ct, g, _cc, ldc, nc, "cc", t)
									}
									if *uplo == 'U' {
										jc += *ldc
									} else {
										jc += (*ldc) + 1
									}
								}
							}
						}
					}
				}
			}

		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZsyrk(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	cc := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()

	*uplo = 'L'
	*trans = 'T'
	*n = 9
	*k = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*beta = (1.30 - 1.10i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Zsyrk(major, uplo, trans, n, k, alpha, aa, lda, beta, cc, ldc)
	}
}

func BenchmarkZsyrkFortran(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	cc := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()

	*uplo = 'L'
	*trans = 'T'
	*n = 9
	*k = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*beta = (1.30 - 1.10i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		zsyrkWrapper(uplo, trans, n, k, alpha, aa, lda, beta, cc, ldc)
	}
}

func TestZher2k(t *testing.T) {
	tname := "Zher2k"
	var i, ia, ib, ibeg, ict, icu, ik, in, iend, j, jc, jj, jjab, ks, laa, lbb, lcc, ldas, ldbs, ldcs, nc, ns int
	var rbls float64
	var als complex128
	var transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	rbeta := new(float64)
	alpha := new(complex128)
	beta := new(complex128)
	k := new(int)
	k2 := new(int)
	n := new(int)
	lj := new(int)
	ma := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	nmax2 := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*nmax2 = 2 * nmax
	*reset = true

	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	ab := func() *[]complex128 { y := make([]complex128, 2*nmax*nmax); return &y }()
	bb := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	bs := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	c := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	cc := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	cs := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	ct := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	w := func() *[]complex128 { y := make([]complex128, 2*nmax); return &y }()

	for in = 1; in <= len(idimL3); in++ {
		*n = idimL3[in-1]

		*ldc = *n
		if *ldc < nmax {
			*ldc++
		}
		if *ldc > nmax {
			continue
		}
		lcc = (*ldc) * (*n)

		for ik = 1; ik <= len(idimL3); ik++ {
			*k = idimL3[ik-1]
			*k2 = 2 * (*k)

			for ict = 1; ict <= len(ichtL3); ict++ {
				*trans = ichtL3[ict-1]
				if *trans == 'T' {
					continue
				}

				if *trans == 'C' {
					*ma = *k
					*na = *n
				} else {
					*ma = *n
					*na = *k
				}

				*lda = *ma
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				_ab := func() *[][]complex128 {
					arr := make([][]complex128, nmax)
					for y := range arr {
						arr[y] = make([]complex128, *na)
						for x := range arr[y] {
							arr[y][x] = (*ab)[y+x*nmax]
						}
					}
					return &arr
				}()
				zmakeGEL3(ma, na, _ab, aa, lda, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				for _j := 0; _j < *na; _j++ {
					for _i := 0; _i < *ma; _i++ {
						(*ab)[_i+_j*nmax] = (*_ab)[_i][_j]
					}
				}

				*ldb = *lda
				lbb = laa

				if *trans == 'C' {
					_ab := func() *[][]complex128 {
						arr := make([][]complex128, nmax)
						for y := range arr {
							arr[y] = make([]complex128, *na)
							for x := range arr[y] {
								arr[y][x] = (*ab)[(*k)+y+x*nmax]
							}
						}
						return &arr
					}()
					zmakeGEL3(ma, na, _ab, bb, ldb, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					for _j := 0; _j < *na; _j++ {
						for _i := 0; _i < *ma; _i++ {
							(*ab)[_i+_j*nmax+(*k)] = (*_ab)[_i][_j]
						}
					}
				} else {
					_ab := func() *[][]complex128 {
						arr := make([][]complex128, nmax)
						for y := range arr {
							arr[y] = make([]complex128, *na)
							for x := range arr[y] {
								arr[y][x] = (*ab)[(*k)*nmax+y+x*nmax]
							}
						}
						return &arr
					}()
					zmakeGEL3(ma, na, _ab, bb, ldb, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					for _j := 0; _j < *na; _j++ {
						for _i := 0; _i < *ma; _i++ {
							(*ab)[_i+_j*nmax+(*k)*nmax] = (*_ab)[_i][_j]
						}
					}
				}

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ia = 1; ia <= len(alfc128L3); ia++ {
						*alpha = alfc128L3[ia-1]

						for ib = 1; ib <= len(betc128L3); ib++ {
							*beta = complex(real(betc128L3[ib-1]), 0.0)
							*rbeta = real(*beta)

							null = *n <= 0 || ((*k <= 0 || *alpha == 0.0) && *rbeta == 1.0)

							zmakeHEL3(uplo, n, n, c, cc, ldc, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

							transs = *trans
							uplos = *uplo
							ns = *n
							ks = *k
							als = *alpha
							rbls = *rbeta
							ldas = *lda
							ldbs = *ldb
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lbb; i++ {
								(*bs)[i-1] = (*bb)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := zExpand(aa, na, lda)
							_bb := zExpand(bb, na, lda)
							_cc := zExpand(cc, n, ldc)
							Zher2k(major, uplo, trans, n, k, alpha, _aa, lda, _bb, ldb, rbeta, _cc, ldc)
							zReturn(_aa, aa)
							zReturn(_bb, bb)
							zReturn(_cc, cc)
							// zher2kWrapperTest(uplo, trans, n, k, alpha, aa, lda, bb, ldb, rbeta, cc, ldc)

							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, k, &ks, "k")
							checkComplex128(t, nc, alpha, &als, "alpha")
							checkFloat64(t, nc, rbeta, &rbls, "rbeta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldb, &ldbs, "ldb")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
							checkComplex128Array1D(t, nc, &lbb, bb, bs, "bb")
							if null {
								checkComplex128Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										ibeg = 1
										iend = j
									} else {
										ibeg = j
										iend = *n
									}
									for i = 1; i <= *ldc; i++ {
										if i < ibeg || i > iend {
											checkComplex128(t, nc, &(*cc)[i+(j-1)*(*ldc)-1], &(*cs)[i+(j-1)*(*ldc)-1], "guardband cc")
										}
									}
								}

								jjab = 1
								jc = 1
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										jj = 1
										*lj = j
									} else {
										jj = j
										*lj = (*n) - j + 1
									}
									_c := func() *[][]complex128 {
										arr := make([][]complex128, min(nmax, cap(*c)-(jj-1)))
										for y := range arr {
											arr[y] = make([]complex128, min(1, cap((*c)[0])-(j-1)))
											for x := range arr[y] {
												arr[y][x] = (*c)[y+jj-1][x+j-1]
											}
										}
										return &arr
									}()
									_cc := (*cc)[jc-1:]
									if *trans == 'C' {
										for i = 1; i <= *k; i++ {
											(*w)[i-1] = (*alpha) * (*ab)[(j-1)*nmax+(*k)+i-1]
											(*w)[(*k)+i-1] = complex128(cmplx.Conj(complex128(*alpha))) * (*ab)[(j-1)*nmax+i-1]
										}
										_jjab := (jjab-1)*nmax + 1
										_ab := func() *[][]complex128 {
											_x := (*ab)[_jjab-1:]
											arr := make([][]complex128, nmax)
											for y := range arr {
												arr[y] = make([]complex128, *lj)
												for x := range arr[y] {
													arr[y][x] = _x[y+x*nmax]
												}
											}
											return &arr
										}()
										_w := func() *[][]complex128 {
											arr := make([][]complex128, *nmax2)
											for y := range arr {
												arr[y] = make([]complex128, 1)
												for x := range arr[y] {
													arr[y][x] = (*w)[y+x*(*nmax2)]
												}
											}
											return &arr
										}()
										zmmchTest(trans, _N, lj, onei, k2, onec128, _ab, _w, beta, _c, ct, g, &_cc, ldc, nc, "cc", t)
									} else {
										for i = 1; i <= *k; i++ {
											(*w)[i-1] = (*alpha) * complex128(cmplx.Conj(complex128((*ab)[((*k)+i-1)*nmax+j-1])))
											(*w)[(*k)+i-1] = complex128(cmplx.Conj(complex128((*alpha) * (*ab)[(i-1)*nmax+j-1])))
										}
										_ab := func() *[][]complex128 {
											_x := (*ab)[jj-1:]
											arr := make([][]complex128, nmax)
											for y := range arr {
												arr[y] = make([]complex128, *k2)
												for x := range arr[y] {
													arr[y][x] = _x[y+x*nmax]
												}
											}
											return &arr
										}()
										_w := func() *[][]complex128 {
											arr := make([][]complex128, *nmax2)
											for y := range arr {
												arr[y] = make([]complex128, 1)
												for x := range arr[y] {
													arr[y][x] = (*w)[y+x*(*nmax2)]
												}
											}
											return &arr
										}()
										zmmchTest(_N, _N, lj, onei, k2, onec128, _ab, _w, beta, _c, ct, g, &_cc, ldc, nc, "cc", t)
									}
									if *uplo == 'U' {
										jc += *ldc
									} else {
										jc += (*ldc) + 1
										if *trans == 'C' {
											jjab++
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZher2k(b *testing.B) {
	alpha := new(complex128)
	rbeta := new(float64)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	bb := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	cc := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()

	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*rbeta = 1.30
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Zher2k(major, uplo, trans, n, k, alpha, aa, lda, bb, ldb, rbeta, cc, ldc)
	}
}

func BenchmarkZher2kFortran(b *testing.B) {
	alpha := new(complex128)
	rbeta := new(float64)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	bb := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	cc := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*rbeta = 1.30
	*ldc = 10

	for i := 0; i < b.N; i++ {
		zher2kWrapper(uplo, trans, n, k, alpha, aa, lda, bb, ldb, rbeta, cc, ldc)
	}
}

func TestZsyr2k(t *testing.T) {
	tname := "Zsyr2k"
	var i, ia, ib, ibeg, ict, icu, ik, in, iend, j, jc, jj, jjab, ks, laa, lbb, lcc, ldas, ldbs, ldcs, nc, ns int
	var als, bls complex128
	var transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex128)
	beta := new(complex128)
	k := new(int)
	k2 := new(int)
	n := new(int)
	lj := new(int)
	ma := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	nmax2 := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*nmax2 = 2 * nmax
	*reset = true

	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	as := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	ab := func() *[]complex128 { y := make([]complex128, 2*nmax*nmax); return &y }()
	bb := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	bs := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	c := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	cc := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	cs := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	ct := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	g := func() *[]float64 { y := make([]float64, nmax*nmax); return &y }()
	w := func() *[]complex128 { y := make([]complex128, 2*nmax); return &y }()

	for in = 1; in <= len(idimL3); in++ {
		*n = idimL3[in-1]

		*ldc = *n
		if *ldc < nmax {
			*ldc++
		}
		if *ldc > nmax {
			continue
		}
		lcc = (*ldc) * (*n)

		for ik = 1; ik <= len(idimL3); ik++ {
			*k = idimL3[ik-1]
			*k2 = 2 * (*k)

			for ict = 1; ict <= len(ichtL3); ict++ {
				*trans = ichtL3[ict-1]
				if *trans == 'C' {
					continue
				}

				if *trans == 'T' {
					*ma = *k
					*na = *n
				} else {
					*ma = *n
					*na = *k
				}

				*lda = *ma
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				_ab := func() *[][]complex128 {
					arr := make([][]complex128, nmax)
					for y := range arr {
						arr[y] = make([]complex128, *na)
						for x := range arr[y] {
							arr[y][x] = (*ab)[y+x*nmax]
						}
					}
					return &arr
				}()
				zmakeGEL3(ma, na, _ab, aa, lda, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				for _j := 0; _j < *na; _j++ {
					for _i := 0; _i < *ma; _i++ {
						(*ab)[_i+_j*nmax] = (*_ab)[_i][_j]
					}
				}

				*ldb = *lda
				lbb = laa

				if *trans == 'T' {
					_ab := func() *[][]complex128 {
						arr := make([][]complex128, nmax)
						for y := range arr {
							arr[y] = make([]complex128, *na)
							for x := range arr[y] {
								arr[y][x] = (*ab)[(*k)+y+x*nmax]
							}
						}
						return &arr
					}()
					zmakeGEL3(ma, na, _ab, bb, ldb, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					for _j := 0; _j < *na; _j++ {
						for _i := 0; _i < *ma; _i++ {
							(*ab)[_i+_j*nmax+(*k)] = (*_ab)[_i][_j]
						}
					}
				} else {
					_ab := func() *[][]complex128 {
						arr := make([][]complex128, nmax)
						for y := range arr {
							arr[y] = make([]complex128, *na)
							for x := range arr[y] {
								arr[y][x] = (*ab)[(*k)*nmax+y+x*nmax]
							}
						}
						return &arr
					}()
					zmakeGEL3(ma, na, _ab, bb, ldb, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					for _j := 0; _j < *na; _j++ {
						for _i := 0; _i < *ma; _i++ {
							(*ab)[_i+_j*nmax+(*k)*nmax] = (*_ab)[_i][_j]
						}
					}
				}

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ia = 1; ia <= len(alfc128L3); ia++ {
						*alpha = alfc128L3[ia-1]

						for ib = 1; ib <= len(betc128L3); ib++ {
							*beta = betc128L3[ib-1]

							null = *n <= 0

							zmakeSYL3(uplo, n, n, c, cc, ldc, reset, zeroc128, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

							transs = *trans
							uplos = *uplo
							ns = *n
							ks = *k
							als = *alpha
							bls = *beta
							ldas = *lda
							ldbs = *ldb
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lbb; i++ {
								(*bs)[i-1] = (*bb)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := zExpand(aa, na, lda)
							_bb := zExpand(bb, na, ldb)
							_cc := zExpand(cc, n, ldc)
							Zsyr2k(major, uplo, trans, n, k, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
							zReturn(_aa, aa)
							zReturn(_bb, bb)
							zReturn(_cc, cc)

							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, k, &ks, "k")
							checkComplex128(t, nc, alpha, &als, "alpha")
							checkComplex128(t, nc, beta, &bls, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldb, &ldbs, "ldb")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkComplex128Array1D(t, nc, &laa, aa, as, "aa")
							checkComplex128Array1D(t, nc, &lbb, bb, bs, "bb")
							if null {
								checkComplex128Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										ibeg = 1
										iend = j
									} else {
										ibeg = j
										iend = *n
									}
									for i = 1; i <= *ldc; i++ {
										if i < ibeg || i > iend {
											checkComplex128(t, nc, &(*cc)[i+(j-1)*(*ldc)-1], &(*cs)[i+(j-1)*(*ldc)-1], "guardband cc")
										}
									}
								}

								jjab = 1
								jc = 1
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										jj = 1
										*lj = j
									} else {
										jj = j
										*lj = (*n) - j + 1
									}
									_c := func() *[][]complex128 {
										arr := make([][]complex128, min(nmax, cap(*c)-(jj-1)))
										for y := range arr {
											arr[y] = make([]complex128, min(1, cap((*c)[0])-(j-1)))
											for x := range arr[y] {
												arr[y][x] = (*c)[y+jj-1][x+j-1]
											}
										}
										return &arr
									}()
									_cc := (*cc)[jc-1:]
									if *trans == 'T' {
										for i = 1; i <= *k; i++ {
											(*w)[i-1] = (*alpha) * (*ab)[(j-1)*nmax+(*k)+i-1]
											(*w)[(*k)+i-1] = (*alpha) * (*ab)[(j-1)*nmax+i-1]
										}
										_jjab := (jjab-1)*nmax + 1
										_ab := func() *[][]complex128 {
											_x := (*ab)[_jjab-1:]
											arr := make([][]complex128, nmax)
											for y := range arr {
												arr[y] = make([]complex128, *lj)
												for x := range arr[y] {
													arr[y][x] = _x[y+x*nmax]
												}
											}
											return &arr
										}()
										_w := func() *[][]complex128 {
											arr := make([][]complex128, *nmax2)
											for y := range arr {
												arr[y] = make([]complex128, 1)
												for x := range arr[y] {
													arr[y][x] = (*w)[y+x*(*nmax2)]
												}
											}
											return &arr
										}()
										zmmchTest(trans, _N, lj, onei, k2, onec128, _ab, _w, beta, _c, ct, g, &_cc, ldc, nc, "cc", t)
									} else {
										for i = 1; i <= *k; i++ {
											(*w)[i-1] = (*alpha) * (*ab)[((*k)+i-1)*nmax+j-1]
											(*w)[(*k)+i-1] = (*alpha) * (*ab)[(i-1)*nmax+j-1]
										}
										_ab := func() *[][]complex128 {
											_x := (*ab)[jj-1:]
											arr := make([][]complex128, nmax)
											for y := range arr {
												arr[y] = make([]complex128, *k2)
												for x := range arr[y] {
													arr[y][x] = _x[y+x*nmax]
												}
											}
											return &arr
										}()
										_w := func() *[][]complex128 {
											arr := make([][]complex128, *nmax2)
											for y := range arr {
												arr[y] = make([]complex128, 1)
												for x := range arr[y] {
													arr[y][x] = (*w)[y+x*(*nmax2)]
												}
											}
											return &arr
										}()
										zmmchTest(_N, _N, lj, onei, k2, onec128, _ab, _w, beta, _c, ct, g, &_cc, ldc, nc, "cc", t)
									}
									if *uplo == 'U' {
										jc += *ldc
									} else {
										jc += (*ldc) + 1
										if *trans == 'T' {
											jjab++
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkZsyr2k(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'
	aa := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	bb := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	cc := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()

	*uplo = 'L'
	*trans = 'T'
	*n = 9
	*k = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*beta = (1.30 - 1.10i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Zsyr2k(major, uplo, trans, n, k, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func BenchmarkZsyr2kFortran(b *testing.B) {
	alpha := new(complex128)
	beta := new(complex128)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	bb := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	cc := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()

	*uplo = 'L'
	*trans = 'T'
	*n = 9
	*k = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*beta = (1.30 - 1.10i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		zsyr2kWrapper(uplo, trans, n, k, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func TestZerrors(t *testing.T) {
	var infot *int
	var srnamt *string
	var test *bool

	alpha := new(complex128)
	beta := new(complex128)
	ralpha := new(float64)
	rbeta := new(float64)

	infot = &common.infoc.infot
	srnamt = &common.srnamc.srnamt
	test = &common.infoc.test
	*test = true

	aa := func() *[]complex128 { y := make([]complex128, nmax*nmax); return &y }()
	xx := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	yy := func() *[]complex128 { y := make([]complex128, nmax*incmax); return &y }()
	a := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	b := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()
	c := func() *[][]complex128 {
		arr := make([][]complex128, nmax)
		for u := range arr {
			arr[u] = make([]complex128, nmax)
		}
		return &arr
	}()

	*srnamt = "Zgemv"
	*infot = 1
	Zgemv(_X, _N, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Zgemv(_C, _X, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Zgemv(_C, _N, negonei, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 4
	Zgemv(_C, _N, zeroi, negonei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 7
	Zgemv(_C, _N, twoi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 9
	Zgemv(_C, _N, zeroi, zeroi, alpha, a, onei, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 12
	Zgemv(_C, _N, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Zgbmv"
	*infot = 1
	Zgbmv(_X, _N, zeroi, zeroi, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Zgbmv(_C, _X, zeroi, zeroi, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Zgbmv(_C, _N, negonei, zeroi, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 4
	Zgbmv(_C, _N, zeroi, negonei, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 5
	Zgbmv(_C, _N, zeroi, zeroi, negonei, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 6
	Zgbmv(_C, _N, twoi, zeroi, zeroi, negonei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 9
	Zgbmv(_C, _N, zeroi, zeroi, onei, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 11
	Zgbmv(_C, _N, zeroi, zeroi, zeroi, zeroi, alpha, a, onei, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 14
	Zgbmv(_C, _N, zeroi, zeroi, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Zhemv"
	*infot = 1
	Zhemv(_X, _U, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Zhemv(_C, _X, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Zhemv(_C, _U, negonei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 6
	Zhemv(_C, _U, twoi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 8
	Zhemv(_C, _U, zeroi, alpha, a, onei, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 11
	Zhemv(_C, _U, zeroi, alpha, a, onei, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Zhbmv"
	*infot = 1
	Zhbmv(_X, _U, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Zhbmv(_C, _X, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Zhbmv(_C, _U, negonei, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 4
	Zhbmv(_C, _U, zeroi, negonei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 7
	Zhbmv(_C, _U, zeroi, onei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 9
	Zhbmv(_C, _U, zeroi, zeroi, alpha, a, onei, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 12
	Zhbmv(_C, _U, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Zhpmv"
	*infot = 1
	Zhpmv(_X, _U, zeroi, alpha, aa, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Zhpmv(_C, _X, zeroi, alpha, aa, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Zhpmv(_C, _U, negonei, alpha, aa, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 7
	Zhpmv(_C, _U, zeroi, alpha, aa, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 10
	Zhpmv(_C, _U, zeroi, alpha, aa, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Ztrmv"
	*infot = 1
	Ztrmv(_X, _U, _N, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 2
	Ztrmv(_C, _X, _N, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 3
	Ztrmv(_C, _U, _X, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 4
	Ztrmv(_C, _U, _N, _X, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 5
	Ztrmv(_C, _U, _N, _N, negonei, a, onei, xx, onei)
	chkxer(t)
	*infot = 7
	Ztrmv(_C, _U, _N, _N, twoi, a, onei, xx, onei)
	chkxer(t)
	*infot = 9
	Ztrmv(_C, _U, _N, _N, zeroi, a, onei, xx, zeroi)
	chkxer(t)

	*srnamt = "Ztbmv"
	*infot = 1
	Ztbmv(_X, _U, _N, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 2
	Ztbmv(_C, _X, _N, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 3
	Ztbmv(_C, _U, _X, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 4
	Ztbmv(_C, _U, _N, _X, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 5
	Ztbmv(_C, _U, _N, _N, negonei, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 6
	Ztbmv(_C, _U, _N, _N, zeroi, negonei, a, onei, xx, onei)
	chkxer(t)
	*infot = 8
	Ztbmv(_C, _U, _N, _N, zeroi, onei, a, onei, xx, onei)
	chkxer(t)
	*infot = 10
	Ztbmv(_C, _U, _N, _N, zeroi, zeroi, a, onei, xx, zeroi)
	chkxer(t)

	*srnamt = "Ztpmv"
	*infot = 1
	Ztpmv(_X, _U, _N, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 2
	Ztpmv(_C, _X, _N, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 3
	Ztpmv(_C, _U, _X, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 4
	Ztpmv(_C, _U, _N, _X, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 5
	Ztpmv(_C, _U, _N, _N, negonei, aa, xx, onei)
	chkxer(t)
	*infot = 8
	Ztpmv(_C, _U, _N, _N, zeroi, aa, xx, zeroi)
	chkxer(t)

	*srnamt = "Ztrsv"
	*infot = 1
	Ztrsv(_X, _U, _N, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 2
	Ztrsv(_C, _X, _N, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 3
	Ztrsv(_C, _U, _X, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 4
	Ztrsv(_C, _U, _N, _X, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 5
	Ztrsv(_C, _U, _N, _N, negonei, a, onei, xx, onei)
	chkxer(t)
	*infot = 7
	Ztrsv(_C, _U, _N, _N, twoi, a, onei, xx, onei)
	chkxer(t)
	*infot = 9
	Ztrsv(_C, _U, _N, _N, zeroi, a, onei, xx, zeroi)
	chkxer(t)

	*srnamt = "Ztbsv"
	*infot = 1
	Ztbsv(_X, _U, _N, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 2
	Ztbsv(_C, _X, _N, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 3
	Ztbsv(_C, _U, _X, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 4
	Ztbsv(_C, _U, _N, _X, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 5
	Ztbsv(_C, _U, _N, _N, negonei, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 6
	Ztbsv(_C, _U, _N, _N, zeroi, negonei, a, onei, xx, onei)
	chkxer(t)
	*infot = 8
	Ztbsv(_C, _U, _N, _N, zeroi, onei, a, onei, xx, onei)
	chkxer(t)
	*infot = 10
	Ztbsv(_C, _U, _N, _N, zeroi, zeroi, a, onei, xx, zeroi)
	chkxer(t)

	*srnamt = "Ztpsv"
	*infot = 1
	Ztpsv(_X, _U, _N, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 2
	Ztpsv(_C, _X, _N, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 3
	Ztpsv(_C, _U, _X, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 4
	Ztpsv(_C, _U, _N, _X, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 5
	Ztpsv(_C, _U, _N, _N, negonei, aa, xx, onei)
	chkxer(t)
	*infot = 8
	Ztpsv(_C, _U, _N, _N, zeroi, aa, xx, zeroi)
	chkxer(t)

	*srnamt = "Zgerc"
	*infot = 1
	Zgerc(_X, zeroi, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 2
	Zgerc(_C, negonei, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 3
	Zgerc(_C, zeroi, negonei, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 6
	Zgerc(_C, zeroi, zeroi, alpha, xx, zeroi, yy, onei, a, onei)
	chkxer(t)
	*infot = 8
	Zgerc(_C, zeroi, zeroi, alpha, xx, onei, yy, zeroi, a, onei)
	chkxer(t)
	*infot = 10
	Zgerc(_C, twoi, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)

	*srnamt = "Zgeru"
	*infot = 1
	Zgeru(_X, zeroi, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 2
	Zgeru(_C, negonei, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 3
	Zgeru(_C, zeroi, negonei, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 6
	Zgeru(_C, zeroi, zeroi, alpha, xx, zeroi, yy, onei, a, onei)
	chkxer(t)
	*infot = 8
	Zgeru(_C, zeroi, zeroi, alpha, xx, onei, yy, zeroi, a, onei)
	chkxer(t)
	*infot = 10
	Zgeru(_C, twoi, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)

	*srnamt = "Zher"
	*infot = 1
	Zher(_X, _U, zeroi, ralpha, xx, onei, a, onei)
	chkxer(t)
	*infot = 2
	Zher(_C, _X, zeroi, ralpha, xx, onei, a, onei)
	chkxer(t)
	*infot = 3
	Zher(_C, _U, negonei, ralpha, xx, onei, a, onei)
	chkxer(t)
	*infot = 6
	Zher(_C, _U, zeroi, ralpha, xx, zeroi, a, onei)
	chkxer(t)
	*infot = 8
	Zher(_C, _U, zeroi, ralpha, xx, onei, a, zeroi)
	chkxer(t)

	*srnamt = "Zhpr"
	*infot = 1
	Zhpr(_X, _U, zeroi, ralpha, xx, onei, aa)
	chkxer(t)
	*infot = 2
	Zhpr(_C, _X, zeroi, ralpha, xx, onei, aa)
	chkxer(t)
	*infot = 3
	Zhpr(_C, _U, negonei, ralpha, xx, onei, aa)
	chkxer(t)
	*infot = 6
	Zhpr(_C, _U, zeroi, ralpha, xx, zeroi, aa)
	chkxer(t)

	*srnamt = "Zher2"
	*infot = 1
	Zher2(_X, _U, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 2
	Zher2(_C, _X, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 3
	Zher2(_C, _U, negonei, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 6
	Zher2(_C, _U, zeroi, alpha, xx, zeroi, yy, onei, a, onei)
	chkxer(t)
	*infot = 8
	Zher2(_C, _U, zeroi, alpha, xx, onei, yy, zeroi, a, onei)
	chkxer(t)
	*infot = 10
	Zher2(_C, _U, twoi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)

	*srnamt = "Zhpr2"
	*infot = 1
	Zhpr2(_X, _U, zeroi, alpha, xx, onei, yy, onei, aa)
	chkxer(t)
	*infot = 2
	Zhpr2(_C, _X, zeroi, alpha, xx, onei, yy, onei, aa)
	chkxer(t)
	*infot = 3
	Zhpr2(_C, _U, negonei, alpha, xx, onei, yy, onei, aa)
	chkxer(t)
	*infot = 6
	Zhpr2(_C, _U, zeroi, alpha, xx, zeroi, yy, onei, aa)
	chkxer(t)
	*infot = 8
	Zhpr2(_C, _U, zeroi, alpha, xx, onei, yy, zeroi, aa)
	chkxer(t)

	*srnamt = "Zgemm"
	*infot = 1
	Zgemm(_X, _N, _T, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Zgemm(_C, _X, _N, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Zgemm(_C, _X, _T, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Zgemm(_C, _N, _X, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Zgemm(_C, _T, _X, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Zgemm(_C, _N, _N, negonei, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Zgemm(_C, _N, _T, negonei, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Zgemm(_C, _T, _T, negonei, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Zgemm(_C, _T, _T, negonei, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Zgemm(_C, _N, _N, zeroi, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Zgemm(_C, _N, _T, zeroi, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Zgemm(_C, _T, _N, zeroi, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Zgemm(_C, _T, _T, zeroi, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 6
	Zgemm(_C, _N, _N, zeroi, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 6
	Zgemm(_C, _N, _T, zeroi, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 6
	Zgemm(_C, _T, _N, zeroi, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 6
	Zgemm(_C, _T, _T, zeroi, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 9
	Zgemm(_C, _N, _N, twoi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 9
	Zgemm(_C, _N, _T, twoi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 9
	Zgemm(_C, _T, _N, zeroi, zeroi, twoi, alpha, a, onei, b, twoi, beta, c, onei)
	chkxer(t)
	*infot = 9
	Zgemm(_C, _T, _T, zeroi, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Zgemm(_C, _N, _N, zeroi, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Zgemm(_C, _T, _N, zeroi, zeroi, twoi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Zgemm(_C, _N, _T, zeroi, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Zgemm(_C, _T, _T, zeroi, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 14
	Zgemm(_C, _N, _N, twoi, zeroi, zeroi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 14
	Zgemm(_C, _N, _T, twoi, zeroi, zeroi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 14
	Zgemm(_C, _T, _N, twoi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 14
	Zgemm(_C, _T, _T, twoi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)

	*srnamt = "Zhemm"
	*infot = 1
	Zhemm(_X, _L, _U, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Zhemm(_C, _X, _U, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Zhemm(_C, _L, _X, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Zhemm(_C, _L, _U, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Zhemm(_C, _R, _U, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Zhemm(_C, _L, _L, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Zhemm(_C, _R, _L, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Zhemm(_C, _L, _U, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Zhemm(_C, _R, _U, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Zhemm(_C, _L, _L, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Zhemm(_C, _R, _L, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Zhemm(_C, _L, _U, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Zhemm(_C, _R, _U, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Zhemm(_C, _L, _L, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Zhemm(_C, _R, _L, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 10
	Zhemm(_C, _L, _U, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	Zhemm(_C, _R, _U, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	Zhemm(_C, _L, _L, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	Zhemm(_C, _R, _L, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 13
	Zhemm(_C, _L, _U, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	Zhemm(_C, _R, _U, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, onei)
	chkxer(t)
	Zhemm(_C, _L, _L, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	Zhemm(_C, _R, _L, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, onei)
	chkxer(t)

	*srnamt = "Zsymm"
	*infot = 1
	Zsymm(_X, _L, _U, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Zsymm(_C, _X, _U, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Zsymm(_C, _L, _X, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Zsymm(_C, _L, _U, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Zsymm(_C, _R, _U, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Zsymm(_C, _L, _L, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Zsymm(_C, _R, _L, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Zsymm(_C, _L, _U, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Zsymm(_C, _R, _U, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Zsymm(_C, _L, _L, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Zsymm(_C, _R, _L, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Zsymm(_C, _L, _U, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, twoi)
	chkxer(t)
	*infot = 8
	Zsymm(_C, _R, _U, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Zsymm(_C, _L, _L, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, twoi)
	chkxer(t)
	*infot = 8
	Zsymm(_C, _R, _L, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 10
	Zsymm(_C, _L, _U, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 10
	Zsymm(_C, _R, _U, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 10
	Zsymm(_C, _L, _L, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 10
	Zsymm(_C, _R, _L, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 13
	Zsymm(_C, _L, _U, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	*infot = 13
	Zsymm(_C, _R, _U, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, onei)
	chkxer(t)
	*infot = 13
	Zsymm(_C, _L, _L, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	*infot = 13
	Zsymm(_C, _R, _L, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, onei)
	chkxer(t)

	*srnamt = "Ztrmm"
	*infot = 1
	Ztrmm(_X, _L, _U, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 2
	Ztrmm(_C, _X, _U, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 3
	Ztrmm(_C, _L, _X, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 4
	Ztrmm(_C, _L, _U, _X, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 5
	Ztrmm(_C, _L, _U, _N, _X, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 6
	Ztrmm(_C, _L, _U, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _L, _U, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _R, _U, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _R, _U, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _L, _L, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _L, _L, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _R, _L, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _R, _L, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 7
	Ztrmm(_C, _L, _U, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _L, _U, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _R, _U, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _R, _U, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _L, _L, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _L, _L, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _R, _L, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _R, _L, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 10
	Ztrmm(_C, _L, _U, _N, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Ztrmm(_C, _L, _U, _T, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Ztrmm(_C, _R, _U, _N, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _R, _U, _T, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _L, _L, _N, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Ztrmm(_C, _L, _L, _T, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Ztrmm(_C, _R, _L, _N, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _R, _L, _T, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 12
	Ztrmm(_C, _L, _U, _N, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Ztrmm(_C, _L, _U, _T, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Ztrmm(_C, _R, _U, _N, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _R, _U, _T, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _L, _L, _N, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Ztrmm(_C, _L, _L, _T, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Ztrmm(_C, _R, _L, _N, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrmm(_C, _R, _L, _T, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)

	*srnamt = "Ztrsm"
	*infot = 1
	Ztrsm(_X, _L, _U, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 2
	Ztrsm(_C, _X, _U, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 3
	Ztrsm(_C, _L, _X, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 4
	Ztrsm(_C, _L, _U, _X, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 5
	Ztrsm(_C, _L, _U, _N, _X, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 6
	Ztrsm(_C, _L, _U, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _L, _U, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _R, _U, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _R, _U, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _L, _L, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _L, _L, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _R, _L, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _R, _L, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 7
	Ztrsm(_C, _L, _U, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _L, _U, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _R, _U, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _R, _U, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _L, _L, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _L, _L, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _R, _L, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _R, _L, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 10
	Ztrsm(_C, _L, _U, _N, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Ztrsm(_C, _L, _U, _T, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Ztrsm(_C, _R, _U, _N, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _R, _U, _T, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _L, _L, _N, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Ztrsm(_C, _L, _L, _T, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Ztrsm(_C, _R, _L, _N, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _R, _L, _T, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 12
	Ztrsm(_C, _L, _U, _N, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Ztrsm(_C, _L, _U, _T, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Ztrsm(_C, _R, _U, _N, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _R, _U, _T, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _L, _L, _N, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Ztrsm(_C, _L, _L, _T, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Ztrsm(_C, _R, _L, _N, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ztrsm(_C, _R, _L, _T, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)

	*srnamt = "Zherk"
	*infot = 1
	Zherk(_X, _U, _N, zeroi, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 2
	Zherk(_C, _X, _N, zeroi, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 3
	Zherk(_C, _U, _T, zeroi, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 4
	Zherk(_C, _U, _N, negonei, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	Zherk(_C, _U, _C, negonei, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	Zherk(_C, _L, _N, negonei, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	Zherk(_C, _L, _C, negonei, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 5
	Zherk(_C, _U, _N, zeroi, negonei, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	Zherk(_C, _U, _C, zeroi, negonei, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	Zherk(_C, _L, _N, zeroi, negonei, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	Zherk(_C, _L, _C, zeroi, negonei, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 8
	Zherk(_C, _U, _N, twoi, zeroi, ralpha, a, onei, rbeta, c, twoi)
	chkxer(t)
	Zherk(_C, _U, _C, zeroi, twoi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	Zherk(_C, _L, _N, twoi, zeroi, ralpha, a, onei, rbeta, c, twoi)
	chkxer(t)
	Zherk(_C, _L, _C, zeroi, twoi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 11
	Zherk(_C, _U, _N, twoi, zeroi, ralpha, a, twoi, rbeta, c, onei)
	chkxer(t)
	Zherk(_C, _U, _C, twoi, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	Zherk(_C, _L, _N, twoi, zeroi, ralpha, a, twoi, rbeta, c, onei)
	chkxer(t)
	Zherk(_C, _L, _C, twoi, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)

	*srnamt = "Zsyrk"
	*infot = 1
	Zsyrk(_X, _U, _N, zeroi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Zsyrk(_C, _X, _N, zeroi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Zsyrk(_C, _U, _X, zeroi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Zsyrk(_C, _U, _N, negonei, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Zsyrk(_C, _U, _T, negonei, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Zsyrk(_C, _L, _N, negonei, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Zsyrk(_C, _L, _T, negonei, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Zsyrk(_C, _U, _N, zeroi, negonei, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Zsyrk(_C, _U, _T, zeroi, negonei, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Zsyrk(_C, _L, _N, zeroi, negonei, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Zsyrk(_C, _L, _T, zeroi, negonei, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Zsyrk(_C, _U, _N, twoi, zeroi, alpha, a, onei, beta, c, twoi)
	chkxer(t)
	Zsyrk(_C, _U, _T, zeroi, twoi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Zsyrk(_C, _L, _N, twoi, zeroi, alpha, a, onei, beta, c, twoi)
	chkxer(t)
	Zsyrk(_C, _L, _T, zeroi, twoi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Zsyrk(_C, _U, _N, twoi, zeroi, alpha, a, twoi, beta, c, onei)
	chkxer(t)
	Zsyrk(_C, _U, _T, twoi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Zsyrk(_C, _L, _N, twoi, zeroi, alpha, a, twoi, beta, c, onei)
	chkxer(t)
	Zsyrk(_C, _L, _T, twoi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)

	*srnamt = "Zher2k"
	*infot = 1
	Zher2k(_X, _U, _N, zeroi, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 2
	Zher2k(_C, _X, _N, zeroi, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 3
	Zher2k(_C, _U, _T, zeroi, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 4
	Zher2k(_C, _U, _N, negonei, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	Zher2k(_C, _U, _C, negonei, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	Zher2k(_C, _L, _N, negonei, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	Zher2k(_C, _L, _C, negonei, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 5
	Zher2k(_C, _U, _N, zeroi, negonei, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	Zher2k(_C, _U, _C, zeroi, negonei, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	Zher2k(_C, _L, _N, zeroi, negonei, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	Zher2k(_C, _L, _C, zeroi, negonei, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 8
	Zher2k(_C, _U, _N, twoi, zeroi, alpha, a, onei, b, onei, rbeta, c, twoi)
	chkxer(t)
	Zher2k(_C, _U, _C, zeroi, twoi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	Zher2k(_C, _L, _N, twoi, zeroi, alpha, a, onei, b, onei, rbeta, c, twoi)
	chkxer(t)
	Zher2k(_C, _L, _C, zeroi, twoi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 10
	Zher2k(_C, _U, _N, twoi, zeroi, alpha, a, twoi, b, onei, rbeta, c, twoi)
	chkxer(t)
	Zher2k(_C, _U, _C, zeroi, twoi, alpha, a, twoi, b, onei, rbeta, c, onei)
	chkxer(t)
	Zher2k(_C, _L, _N, twoi, zeroi, alpha, a, twoi, b, onei, rbeta, c, twoi)
	chkxer(t)
	Zher2k(_C, _L, _C, zeroi, twoi, alpha, a, twoi, b, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 13
	Zher2k(_C, _U, _N, twoi, zeroi, alpha, a, twoi, b, twoi, rbeta, c, onei)
	chkxer(t)
	Zher2k(_C, _U, _C, twoi, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	Zher2k(_C, _L, _N, twoi, zeroi, alpha, a, twoi, b, twoi, rbeta, c, onei)
	chkxer(t)
	Zher2k(_C, _L, _C, twoi, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)

	*srnamt = "Zsyr2k"
	*infot = 1
	Zsyr2k(_X, _U, _N, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Zsyr2k(_C, _X, _N, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Zsyr2k(_C, _U, _X, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Zsyr2k(_C, _U, _N, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Zsyr2k(_C, _U, _T, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Zsyr2k(_C, _L, _N, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Zsyr2k(_C, _L, _T, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Zsyr2k(_C, _U, _N, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Zsyr2k(_C, _U, _T, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Zsyr2k(_C, _L, _N, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Zsyr2k(_C, _L, _T, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Zsyr2k(_C, _U, _N, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	Zsyr2k(_C, _U, _T, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Zsyr2k(_C, _L, _N, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	Zsyr2k(_C, _L, _T, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 10
	Zsyr2k(_C, _U, _N, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	Zsyr2k(_C, _U, _T, zeroi, twoi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	Zsyr2k(_C, _L, _N, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	Zsyr2k(_C, _L, _T, zeroi, twoi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 13
	Zsyr2k(_C, _U, _N, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	Zsyr2k(_C, _U, _T, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Zsyr2k(_C, _L, _N, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	Zsyr2k(_C, _L, _T, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)

	*test = false
	fmt.Println("\t\t\tZblas error tests completed")
}
