package goblas

import (
	"fmt"
	"math/cmplx"
	"testing"
)

var cglobal complex64

// BLAS Level 1
func TestScnrm2(t *testing.T) {
	tname := "Scnrm2"
	var nc int
	n := new(int)
	incx := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 8); return &y }()
	res := func() *[]float32 { y := make([]float32, 1); return &y }()
	var snrm2Tests = []struct {
		n      int
		len    int
		sa     complex64
		sx     []complex64
		incx   int
		result []float32
	}{
		{0, 2, 0.3000, []complex64{(0.1000 + 0.1000i), (1.0000 + 2.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []float32{0.0000}},
		{1, 2, 0.3000, []complex64{(0.3000 - 0.4000i), (3.0000 + 4.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []float32{0.5000}},
		{2, 4, 0.3000, []complex64{(0.1000 - 0.3000i), (0.5000 - 0.1000i), (5.0000 + 6.0000i), (5.0000 + 6.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []float32{0.6000}},
		{3, 6, 0.3000, []complex64{(0.1000 + 0.1000i), (-0.6000 + 0.1000i), (0.1000 - 0.3000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []float32{0.7000}},
		{4, 8, 0.3000, []complex64{(0.3000 + 0.1000i), (0.5000 + 0.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 1, []float32{0.8000}},
		{0, 2, 0.3000, []complex64{(0.1000 + 0.1000i), (4.0000 + 5.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []float32{0.0000}},
		{1, 2, 0.3000, []complex64{(0.3000 - 0.4000i), (6.0000 + 7.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []float32{0.5000}},
		{2, 4, 0.3000, []complex64{(0.1000 - 0.3000i), (8.0000 + 9.0000i), (0.5000 - 0.1000i), (2.0000 + 5.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []float32{0.6000}},
		{3, 6, 0.3000, []complex64{(0.1000 + 0.1000i), (3.0000 + 6.0000i), (-0.6000 + 0.1000i), (4.0000 + 7.0000i), (0.1000 - 0.3000i), (7.0000 + 2.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []float32{0.7000}},
		{4, 8, 0.3000, []complex64{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}, 2, []float32{0.8000}},
	}

	for _, test := range snrm2Tests {
		*n = test.n
		*incx = test.incx
		for j := 0; j < 8; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		(*res)[0] = Scnrm2(n, sx, incx)
		sTest(t, nc, *onei, res, &test.result, &test.result, &sfac, "result")
	}

	printTestsRun(tname, nc)
}

func BenchmarkScnrm2(b *testing.B) {
	var res float32
	n := new(int)
	incx := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 8); return &y }()
	*n = 4
	*incx = 2
	*sx = []complex64{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}

	for i := 0; i < b.N; i++ {
		res = Scnrm2(n, sx, incx)
	}
	sglobal = res
}

func BenchmarkScnrm2Fortran(b *testing.B) {
	var res float32
	n := new(int)
	incx := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 8); return &y }()
	*n = 4
	*incx = 2
	*sx = []complex64{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}

	for i := 0; i < b.N; i++ {
		res = scnrm2Wrapper(n, sx, incx)
	}
	sglobal = res
}

func TestScasum(t *testing.T) {
	tname := "Scasum"
	var nc int
	n := new(int)
	incx := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 8); return &y }()
	res := func() *[]float32 { y := make([]float32, 1); return &y }()
	var sasumTests = []struct {
		n      int
		len    int
		sx     []complex64
		incx   int
		result []float32
	}{
		{0, 2, []complex64{(0.1000 + 0.1000i), (1.0000 + 2.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []float32{0.0000}},
		{1, 2, []complex64{(0.3000 - 0.4000i), (3.0000 + 4.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []float32{0.7000}},
		{2, 4, []complex64{(0.1000 - 0.3000i), (0.5000 - 0.1000i), (5.0000 + 6.0000i), (5.0000 + 6.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []float32{1.0000}},
		{3, 6, []complex64{(0.1000 + 0.1000i), (-0.6000 + 0.1000i), (0.1000 - 0.3000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []float32{1.3000}},
		{4, 8, []complex64{(0.3000 + 0.1000i), (0.5000 + 0.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 1, []float32{1.6000}},
		{0, 2, []complex64{(0.1000 + 0.1000i), (4.0000 + 5.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []float32{0.0000}},
		{1, 2, []complex64{(0.3000 - 0.4000i), (6.0000 + 7.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []float32{0.7000}},
		{2, 4, []complex64{(0.1000 - 0.3000i), (8.0000 + 9.0000i), (0.5000 - 0.1000i), (2.0000 + 5.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []float32{1.0000}},
		{3, 6, []complex64{(0.1000 + 0.1000i), (3.0000 + 6.0000i), (-0.6000 + 0.1000i), (4.0000 + 7.0000i), (0.1000 - 0.3000i), (7.0000 + 2.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []float32{1.3000}},
		{4, 8, []complex64{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}, 2, []float32{1.6000}},
	}

	for _, test := range sasumTests {
		*n = test.n
		*incx = test.incx
		for j := 0; j < 8; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		(*res)[0] = Scasum(n, sx, incx)
		sTest(t, nc, *onei, res, &test.result, &test.result, &sfac, "result")
	}

	printTestsRun(tname, nc)
}

func BenchmarkScasum(b *testing.B) {
	var res float32
	n := new(int)
	incx := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 8); return &y }()
	*n = 4
	*incx = 2
	*sx = []complex64{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}

	for i := 0; i < b.N; i++ {
		res = Scasum(n, sx, incx)
	}
	sglobal = res
}

func BenchmarkScasumFortran(b *testing.B) {
	var res float32
	n := new(int)
	incx := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 8); return &y }()
	*n = 4
	*incx = 2
	*sx = []complex64{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}

	for i := 0; i < b.N; i++ {
		res = scasumWrapper(n, sx, incx)
	}
	sglobal = res
}

func TestCscal(t *testing.T) {
	tname := "Cscal"
	var nc int
	n := new(int)
	incx := new(int)
	sa := new(complex64)
	sx := func() *[]complex64 { y := make([]complex64, 8); return &y }()
	var sscalTests = []struct {
		n      int
		len    int
		sa     complex64
		sx     []complex64
		incx   int
		sxtrue []complex64
	}{
		{0, 2, (0.4000 - 0.7000i), []complex64{(0.1000 + 0.1000i), (1.0000 + 2.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []complex64{(0.1000 + 0.1000i), (1.0000 + 2.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{1, 2, (0.4000 - 0.7000i), []complex64{(0.3000 - 0.4000i), (3.0000 + 4.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []complex64{(-0.1600 - 0.3700i), (3.0000 + 4.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{2, 4, (0.4000 - 0.7000i), []complex64{(0.1000 - 0.3000i), (0.5000 - 0.1000i), (5.0000 + 6.0000i), (5.0000 + 6.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []complex64{(-0.1700 - 0.1900i), (0.1300 - 0.3900i), (5.0000 + 6.0000i), (5.0000 + 6.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{3, 6, (0.4000 - 0.7000i), []complex64{(0.1000 + 0.1000i), (-0.6000 + 0.1000i), (0.1000 - 0.3000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []complex64{(0.1100 - 0.0300i), (-0.1700 + 0.4600i), (-0.1700 - 0.1900i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{4, 8, (0.4000 - 0.7000i), []complex64{(0.3000 + 0.1000i), (0.5000 + 0.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 1, []complex64{(0.1900 - 0.1700i), (0.2000 - 0.3500i), (0.3500 + 0.2000i), (0.1400 + 0.0800i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}},
		{0, 2, (0.4000 - 0.7000i), []complex64{(0.1000 + 0.1000i), (4.0000 + 5.0000i), (0.3500 + 0.2000i), (0.1400 + 0.0800i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []complex64{(0.1000 + 0.1000i), (4.0000 + 5.0000i), (0.3500 + 0.2000i), (0.1400 + 0.0800i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}},
		{1, 2, (0.4000 - 0.7000i), []complex64{(0.3000 - 0.4000i), (6.0000 + 7.0000i), (0.3500 + 0.2000i), (0.1400 + 0.0800i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []complex64{(-0.1600 - 0.3700i), (6.0000 + 7.0000i), (0.3500 + 0.2000i), (0.1400 + 0.0800i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}},
		{2, 4, (0.4000 - 0.7000i), []complex64{(0.1000 - 0.3000i), (8.0000 + 9.0000i), (0.5000 - 0.1000i), (2.0000 + 5.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []complex64{(-0.1700 - 0.1900i), (8.0000 + 9.0000i), (0.1300 - 0.3900i), (2.0000 + 5.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}},
		{3, 6, (0.4000 - 0.7000i), []complex64{(0.1000 + 0.1000i), (3.0000 + 6.0000i), (-0.6000 + 0.1000i), (4.0000 + 7.0000i), (0.1000 - 0.3000i), (7.0000 + 2.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []complex64{(0.1100 - 0.0300i), (3.0000 + 6.0000i), (-0.1700 + 0.4600i), (4.0000 + 7.0000i), (-0.1700 - 0.1900i), (7.0000 + 2.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}},
		{4, 8, (0.4000 - 0.7000i), []complex64{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}, 2, []complex64{(0.1900 - 0.1700i), (5.0000 + 8.0000i), (0.2000 - 0.3500i), (6.0000 + 9.0000i), (0.3500 + 0.2000i), (8.0000 + 3.0000i), (0.1400 + 0.0800i), (9.0000 + 4.0000i)}},
	}

	for _, test := range sscalTests {
		*n = test.n
		*incx = test.incx
		*sa = test.sa
		for j := 0; j < 8; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		Cscal(n, sa, sx, incx)
		cTest(t, nc, test.len, sx, &test.sxtrue, &test.sxtrue, &sfac, "sx")
	}

	printTestsRun(tname, nc)
}

func BenchmarkCscal(b *testing.B) {
	n := new(int)
	incx := new(int)
	sa := new(complex64)
	sx := func() *[]complex64 { y := make([]complex64, 8); return &y }()
	*n = 4
	*incx = 2
	*sa = (0.4000 - 0.7000i)
	*sx = []complex64{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}

	for i := 0; i < b.N; i++ {
		Cscal(n, sa, sx, incx)
	}
}

func BenchmarkCscalFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	sa := new(complex64)
	sx := func() *[]complex64 { y := make([]complex64, 8); return &y }()
	*n = 4
	*incx = 2
	*sa = (0.4000 - 0.7000i)
	*sx = []complex64{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}

	for i := 0; i < b.N; i++ {
		cscalWrapper(n, sa, sx, incx)
	}
}

func TestCsscal(t *testing.T) {
	tname := "Cscal"
	var nc int
	n := new(int)
	incx := new(int)
	sa := new(float32)
	sx := func() *[]complex64 { y := make([]complex64, 8); return &y }()
	var sscalTests = []struct {
		n      int
		len    int
		sa     float32
		sx     []complex64
		incx   int
		sxtrue []complex64
	}{
		{0, 2, 0.30, []complex64{(0.1000 + 0.1000i), (1.0000 + 2.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []complex64{(0.1000 + 0.1000i), (1.0000 + 2.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{1, 2, 0.30, []complex64{(0.3000 - 0.4000i), (3.0000 + 4.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []complex64{(0.0900 - 0.1200i), (3.0000 + 4.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{2, 4, 0.30, []complex64{(0.1000 - 0.3000i), (0.5000 - 0.1000i), (5.0000 + 6.0000i), (5.0000 + 6.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []complex64{(0.0300 - 0.0900i), (0.1500 - 0.0300i), (5.0000 + 6.0000i), (5.0000 + 6.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{3, 6, 0.30, []complex64{(0.1000 + 0.1000i), (-0.6000 + 0.1000i), (0.1000 - 0.3000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, []complex64{(0.0300 + 0.0300i), (-0.1800 + 0.0300i), (0.0300 - 0.0900i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{4, 8, 0.30, []complex64{(0.3000 + 0.1000i), (0.5000 + 0.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 1, []complex64{(0.0900 + 0.0300i), (0.1500 + 0.0000i), (0.0000 + 0.1500i), (0.0000 + 0.0600i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}},
		{0, 2, 0.30, []complex64{(0.1000 + 0.1000i), (4.0000 + 5.0000i), (0.0000 + 0.1500i), (0.0000 + 0.0600i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []complex64{(0.1000 + 0.1000i), (4.0000 + 5.0000i), (0.0000 + 0.1500i), (0.0000 + 0.0600i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}},
		{1, 2, 0.30, []complex64{(0.3000 - 0.4000i), (6.0000 + 7.0000i), (0.0000 + 0.1500i), (0.0000 + 0.0600i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []complex64{(0.0900 - 0.1200i), (6.0000 + 7.0000i), (0.0000 + 0.1500i), (0.0000 + 0.0600i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}},
		{2, 4, 0.30, []complex64{(0.1000 - 0.3000i), (8.0000 + 9.0000i), (0.5000 - 0.1000i), (2.0000 + 5.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []complex64{(0.0300 - 0.0900i), (8.0000 + 9.0000i), (0.1500 - 0.0300i), (2.0000 + 5.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}},
		{3, 6, 0.30, []complex64{(0.1000 + 0.1000i), (3.0000 + 6.0000i), (-0.6000 + 0.1000i), (4.0000 + 7.0000i), (0.1000 - 0.3000i), (7.0000 + 2.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, []complex64{(0.0300 + 0.0300i), (3.0000 + 6.0000i), (-0.1800 + 0.0300i), (4.0000 + 7.0000i), (0.0300 - 0.0900i), (7.0000 + 2.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}},
		{4, 8, 0.30, []complex64{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}, 2, []complex64{(0.0900 + 0.0300i), (5.0000 + 8.0000i), (0.1500 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.1500i), (8.0000 + 3.0000i), (0.0000 + 0.0600i), (9.0000 + 4.0000i)}},
	}

	for _, test := range sscalTests {
		*n = test.n
		*incx = test.incx
		*sa = test.sa
		for j := 0; j < 8; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		Csscal(n, sa, sx, incx)
		cTest(t, nc, test.len, sx, &test.sxtrue, &test.sxtrue, &sfac, "sx")
	}

	printTestsRun(tname, nc)
}

func BenchmarkCsscal(b *testing.B) {
	n := new(int)
	incx := new(int)
	sa := new(float32)
	sx := func() *[]complex64 { y := make([]complex64, 8); return &y }()
	*n = 4
	*incx = 2
	*sa = 0.3
	*sx = []complex64{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}

	for i := 0; i < b.N; i++ {
		Csscal(n, sa, sx, incx)
	}
}

func BenchmarkCsscalFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	sa := new(float32)
	sx := func() *[]complex64 { y := make([]complex64, 8); return &y }()
	*n = 4
	*incx = 2
	*sa = 0.3
	*sx = []complex64{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}

	for i := 0; i < b.N; i++ {
		csscalWrapper(n, sa, sx, incx)
	}
}

func TestIcamax(t *testing.T) {
	tname := "Icamax"
	var nc, res int
	n := new(int)
	incx := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 8); return &y }()
	var isamaxTests = []struct {
		n     int
		len   int
		sx    []complex64
		incx  int
		ntrue int
	}{
		{0, 2, []complex64{(0.1000 + 0.1000i), (1.0000 + 2.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, 0},
		{1, 2, []complex64{(0.3000 - 0.4000i), (3.0000 + 4.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, 1},
		{2, 4, []complex64{(0.1000 - 0.3000i), (0.5000 - 0.1000i), (5.0000 + 6.0000i), (5.0000 + 6.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, 2},
		{3, 6, []complex64{(0.1000 + 0.1000i), (-0.6000 + 0.1000i), (0.1000 - 0.3000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (7.0000 + 8.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, 1, 2},
		{4, 8, []complex64{(0.3000 + 0.1000i), (0.5000 + 0.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 1, 2},
		{0, 2, []complex64{(0.1000 + 0.1000i), (4.0000 + 5.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, 0},
		{1, 2, []complex64{(0.3000 - 0.4000i), (6.0000 + 7.0000i), (0.0000 + 0.5000i), (0.0000 + 0.2000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, 1},
		{2, 4, []complex64{(0.1000 - 0.3000i), (8.0000 + 9.0000i), (0.5000 - 0.1000i), (2.0000 + 5.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, 2},
		{3, 6, []complex64{(0.1000 + 0.1000i), (3.0000 + 6.0000i), (-0.6000 + 0.1000i), (4.0000 + 7.0000i), (0.1000 - 0.3000i), (7.0000 + 2.0000i), (2.0000 + 3.0000i), (2.0000 + 3.0000i)}, 2, 2},
		{4, 8, []complex64{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}, 2, 2},
	}

	for _, test := range isamaxTests {
		*n = test.n
		*incx = test.incx
		for j := 0; j < 8; j++ {
			(*sx)[j] = test.sx[j]
		}
		nc++
		res = Icamax(n, sx, incx)
		if res != test.ntrue {
			t.Errorf("Test Failed: result: test %d: {%d} output, {%d} expected", test.n, res, test.ntrue)
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkIcamax(b *testing.B) {
	n := new(int)
	incx := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 8); return &y }()
	*n = 4
	*incx = 2
	*sx = []complex64{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}

	for i := 0; i < b.N; i++ {
		_ = Icamax(n, sx, incx)
	}
}

func BenchmarkIcamaxFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 8); return &y }()
	*n = 4
	*incx = 2
	*sx = []complex64{(0.3000 + 0.1000i), (5.0000 + 8.0000i), (0.5000 + 0.0000i), (6.0000 + 9.0000i), (0.0000 + 0.5000i), (8.0000 + 3.0000i), (0.0000 + 0.2000i), (9.0000 + 4.0000i)}

	for i := 0; i < b.N; i++ {
		_ = icamaxWrapper(n, sx, incx)
	}
}

func TestCdotc(t *testing.T) {
	tname := "Cdotc"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	sy := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	res := func() *[]complex64 { y := make([]complex64, 1); return &y }()
	var sdotTests = []struct {
		n      int
		lenx   int
		leny   int
		sx     []complex64
		incx   int
		sy     []complex64
		incy   int
		result []complex64
		size   []complex64
	}{
		{0, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{1, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.9000 + 0.0600i)}, []complex64{(0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{2, 2, 2, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.9100 - 0.7700i)}, []complex64{(1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{4, 4, 4, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(1.8000 - 0.1000i)}, []complex64{(2.9000 + 2.7800i)}},
		{0, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{1, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.9000 + 0.0600i)}, []complex64{(0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{2, 3, 3, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(1.4500 + 0.7400i)}, []complex64{(1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{4, 7, 7, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.2000 + 0.9000i)}, []complex64{(2.9000 + 2.7800i)}},
		{0, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{1, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.9000 + 0.0600i)}, []complex64{(0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{2, 3, 2, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(-0.5500 + 0.2300i)}, []complex64{(1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{4, 7, 4, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.8300 - 0.3900i)}, []complex64{(2.9000 + 2.7800i)}},
		{0, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{1, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.9000 + 0.0600i)}, []complex64{(0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{2, 2, 3, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(1.0400 + 0.7900i)}, []complex64{(1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{4, 4, 7, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(1.9500 + 1.2200i)}, []complex64{(2.9000 + 2.7800i)}},
	}

	for _, test := range sdotTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		(*res)[0] = Cdotc(n, sx, incx, sy, incy)
		cTest(t, nc, *onei, res, &test.result, &test.size, &sfac, "result")
	}

	printTestsRun(tname, nc)
}

func BenchmarkCdotc(b *testing.B) {
	var res complex64
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	sy := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	*n = 4
	*sx = []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}
	*incx = 2
	*sy = []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}
	*incy = -2

	for i := 0; i < b.N; i++ {
		res = Cdotc(n, sx, incx, sy, incy)
	}
	cglobal = res
}

func BenchmarkCdotcFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	sy := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	*n = 4
	*sx = []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}
	*incx = 2
	*sy = []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}
	*incy = -2

	for i := 0; i < b.N; i++ {
		_ = cdotcWrapper(n, sx, incx, sy, incy)
	}
}

func TestCdotu(t *testing.T) {
	tname := "Cdotu"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	sy := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	res := func() *[]complex64 { y := make([]complex64, 1); return &y }()
	var sdotTests = []struct {
		n      int
		lenx   int
		leny   int
		sx     []complex64
		incx   int
		sy     []complex64
		incy   int
		result []complex64
		size   []complex64
	}{
		{0, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{1, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(-0.0600 - 0.9000i)}, []complex64{(0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{2, 2, 2, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.6500 - 0.4700i)}, []complex64{(1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{4, 4, 4, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(-0.3400 - 1.2200i)}, []complex64{(2.9000 + 2.7800i)}},
		{0, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{1, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(-0.0600 - 0.9000i)}, []complex64{(0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{2, 3, 3, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(-0.5900 - 1.4600i)}, []complex64{(1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{4, 7, 7, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(-1.0400 - 0.0400i)}, []complex64{(2.9000 + 2.7800i)}},
		{0, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{1, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(-0.0600 - 0.9000i)}, []complex64{(0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{2, 3, 2, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(-0.8300 + 0.5900i)}, []complex64{(1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{4, 7, 4, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.0700 - 0.3700i)}, []complex64{(2.9000 + 2.7800i)}},
		{0, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{1, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(-0.0600 - 0.9000i)}, []complex64{(0.9000 + 0.9000i), (1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{2, 2, 3, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(-0.7600 - 1.1500i)}, []complex64{(1.6300 + 1.7300i), (2.9000 + 2.7800i)}},
		{4, 4, 7, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(-1.3300 - 1.8200i)}, []complex64{(2.9000 + 2.7800i)}},
	}

	for _, test := range sdotTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		(*res)[0] = Cdotu(n, sx, incx, sy, incy)
		cTest(t, nc, *onei, res, &test.result, &test.size, &sfac, "result")
	}

	printTestsRun(tname, nc)
}

func BenchmarkCdotu(b *testing.B) {
	var res complex64
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	sy := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	*n = 4
	*sx = []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}
	*incx = 2
	*sy = []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}
	*incy = -2

	for i := 0; i < b.N; i++ {
		res = Cdotu(n, sx, incx, sy, incy)
	}
	cglobal = res
}

func BenchmarkCdotuFortran(b *testing.B) {
	var res complex64
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	sy := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	*n = 4
	*sx = []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}
	*incx = 2
	*sy = []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}
	*incy = -2

	for i := 0; i < b.N; i++ {
		res = cdotuWrapper(n, sx, incx, sy, incy)
	}
	cglobal = res
}

func TestCaxpy(t *testing.T) {
	tname := "Caxpy"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	sa := new(complex64)
	sx := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	sy := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	var saxpyTests = []struct {
		n     int
		lenx  int
		leny  int
		sa    complex64
		sx    []complex64
		incx  int
		sy    []complex64
		incy  int
		strue []complex64
		size  []complex64
	}{
		{0, 1, 1, (0.4000 - 0.7000i), []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.6000 - 0.6000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{1, 1, 1, (0.4000 - 0.7000i), []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.3200 - 1.4100i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(1.5400 + 1.5400i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{2, 2, 2, (0.4000 - 0.7000i), []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.3200 - 1.4100i), (-1.5500 + 0.5000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{4, 4, 4, (0.4000 - 0.7000i), []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.3200 - 1.4100i), (-1.5500 + 0.5000i), (0.0300 - 0.8900i), (-0.3800 - 0.9600i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{0, 1, 1, (0.4000 - 0.7000i), []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.6000 - 0.6000i), (-1.5500 + 0.5000i), (0.0300 - 0.8900i), (-0.3800 - 0.9600i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{1, 1, 1, (0.4000 - 0.7000i), []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.3200 - 1.4100i), (-1.5500 + 0.5000i), (0.0300 - 0.8900i), (-0.3800 - 0.9600i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{2, 3, 3, (0.4000 - 0.7000i), []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(-0.0700 - 0.8900i), (-0.9000 + 0.5000i), (0.4200 - 1.4100i), (-0.3800 - 0.9600i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}},
		{4, 7, 7, (0.4000 - 0.7000i), []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.7800 + 0.0600i), (-0.9000 + 0.5000i), (0.0600 - 0.1300i), (0.1000 - 0.5000i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.5200 - 1.5100i)}, []complex64{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
		{0, 1, 1, (0.4000 - 0.7000i), []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.0600 - 0.1300i), (0.1000 - 0.5000i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.5200 - 1.5100i)}, []complex64{(0.0000 + 0.0000i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
		{1, 1, 1, (0.4000 - 0.7000i), []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.3200 - 1.4100i), (-0.9000 + 0.5000i), (0.0600 - 0.1300i), (0.1000 - 0.5000i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.5200 - 1.5100i)}, []complex64{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
		{2, 3, 2, (0.4000 - 0.7000i), []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(-0.0700 - 0.8900i), (-1.1800 - 0.3100i), (0.0600 - 0.1300i), (0.1000 - 0.5000i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.5200 - 1.5100i)}, []complex64{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
		{4, 7, 4, (0.4000 - 0.7000i), []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.7800 + 0.0600i), (-1.5400 + 0.9700i), (0.0300 - 0.8900i), (-0.1800 - 1.3100i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.5200 - 1.5100i)}, []complex64{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
		{0, 1, 1, (0.4000 - 0.7000i), []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.6000 - 0.6000i), (-1.5400 + 0.9700i), (0.0300 - 0.8900i), (-0.1800 - 1.3100i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.5200 - 1.5100i)}, []complex64{(0.0000 + 0.0000i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
		{1, 1, 1, (0.4000 - 0.7000i), []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.3200 - 1.4100i), (-1.5400 + 0.9700i), (0.0300 - 0.8900i), (-0.1800 - 1.3100i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.5200 - 1.5100i)}, []complex64{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
		{2, 2, 3, (0.4000 - 0.7000i), []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.3200 - 1.4100i), (-0.9000 + 0.5000i), (0.0500 - 0.6000i), (-0.1800 - 1.3100i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.5200 - 1.5100i)}, []complex64{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
		{4, 4, 7, (0.4000 - 0.7000i), []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.3200 - 1.4100i), (-0.9000 + 0.5000i), (0.0500 - 0.6000i), (0.1000 - 0.5000i), (-0.7700 - 0.4900i), (-0.5000 - 0.3000i), (0.3200 - 1.1600i)}, []complex64{(1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i), (1.5400 + 1.5400i)}},
	}

	for _, test := range saxpyTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		*sa = test.sa
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		Caxpy(n, sa, sx, incx, sy, incy)
		cTest(t, nc, test.leny, sy, &test.strue, &test.size, &sfac, "sy")
	}

	printTestsRun(tname, nc)
}

func BenchmarkCaxpy(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sa := new(complex64)
	sx := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	sy := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	*n = 4
	*sa = (0.4000 - 0.7000i)
	*sx = []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}
	*incx = 2
	*sy = []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Caxpy(n, sa, sx, incx, sy, incy)
	}
}

func BenchmarkCaxpyFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sa := new(complex64)
	sx := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	sy := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	*n = 4
	*sa = (0.4000 - 0.7000i)
	*sx = []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}
	*incx = 2
	*sy = []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}
	*incy = -2

	for i := 0; i < b.N; i++ {
		caxpyWrapper(n, sa, sx, incx, sy, incy)
	}
}

func TestCcopy(t *testing.T) {
	tname := "Ccopy"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	sy := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	var scopyTests = []struct {
		n     int
		lenx  int
		leny  int
		sx    []complex64
		incx  int
		sy    []complex64
		incy  int
		strue []complex64
		size  []complex64
	}{
		{0, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.6000 - 0.6000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{1, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.7000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{2, 2, 2, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{4, 4, 4, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{0, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{1, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{2, 3, 3, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(-0.1000 - 0.9000i), (-0.9000 + 0.5000i), (0.7000 - 0.8000i), (0.2000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{4, 7, 7, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(-0.6000 + 0.6000i), (-0.9000 + 0.5000i), (-0.9000 - 0.4000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{0, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (-0.9000 - 0.4000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{1, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.7000 - 0.8000i), (-0.9000 + 0.5000i), (-0.9000 - 0.4000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{2, 3, 2, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(-0.1000 - 0.9000i), (0.7000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{4, 7, 4, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(-0.6000 + 0.6000i), (-0.9000 - 0.4000i), (-0.1000 - 0.9000i), (0.7000 - 0.8000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{0, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 - 0.4000i), (-0.1000 - 0.9000i), (0.7000 - 0.8000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{1, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.7000 - 0.8000i), (-0.9000 - 0.4000i), (-0.1000 - 0.9000i), (0.7000 - 0.8000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{2, 2, 3, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.7000 - 0.8000i), (-0.9000 + 0.5000i), (-0.4000 - 0.7000i), (0.7000 - 0.8000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{4, 4, 7, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.7000 - 0.8000i), (-0.9000 + 0.5000i), (-0.4000 - 0.7000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.2000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
	}

	for _, test := range scopyTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		Ccopy(n, sx, incx, sy, incy)
		cTest(t, nc, test.leny, sy, &test.strue, &test.size, onef32, "sy")
	}

	printTestsRun(tname, nc)
}

func BenchmarkCcopy(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	sy := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	*n = 4
	*sx = []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}
	*incx = 2
	*sy = []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Ccopy(n, sx, incx, sy, incy)
	}
}

func BenchmarkCcopyFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	sy := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	*n = 4
	*sx = []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}
	*incx = 2
	*sy = []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}
	*incy = -2

	for i := 0; i < b.N; i++ {
		ccopyWrapper(n, sx, incx, sy, incy)
	}
}

func TestCswap(t *testing.T) {
	tname := "Cswap"
	var nc int
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	sy := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	var cswapTests = []struct {
		n      int
		lenx   int
		leny   int
		sx     []complex64
		incx   int
		sy     []complex64
		incy   int
		sxtrue []complex64
		sytrue []complex64
		size   []complex64
	}{
		{0, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.7000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.6000 - 0.6000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{1, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.6000 - 0.6000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.7000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{2, 2, 2, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{4, 4, 4, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{0, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.7000 - 0.8000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.6000 - 0.6000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{1, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{2, 3, 3, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.7000 - 0.6000i), (-0.4000 - 0.7000i), (0.6000 - 0.6000i), (0.1000 - 0.5000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(-0.1000 - 0.9000i), (-0.9000 + 0.5000i), (0.7000 - 0.8000i), (0.2000 - 0.8000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{4, 7, 7, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, 2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.8000 - 0.7000i), (-0.4000 - 0.7000i), (-0.1000 - 0.2000i), (0.2000 - 0.8000i), (0.7000 - 0.6000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex64{(-0.6000 + 0.6000i), (-0.9000 + 0.5000i), (-0.9000 - 0.4000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{0, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.2000i), (0.2000 - 0.8000i), (0.7000 - 0.6000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (-0.9000 - 0.4000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{1, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.6000 - 0.6000i), (-0.4000 - 0.7000i), (-0.1000 - 0.2000i), (0.2000 - 0.8000i), (0.7000 - 0.6000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex64{(0.7000 - 0.8000i), (-0.9000 + 0.5000i), (-0.9000 - 0.4000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{2, 3, 2, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(-0.9000 + 0.5000i), (-0.4000 - 0.7000i), (0.6000 - 0.6000i), (0.2000 - 0.8000i), (0.7000 - 0.6000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex64{(-0.1000 - 0.9000i), (0.7000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{4, 7, 4, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, 1, []complex64{(0.1000 - 0.5000i), (-0.4000 - 0.7000i), (0.7000 - 0.6000i), (0.2000 - 0.8000i), (-0.9000 + 0.5000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex64{(-0.6000 + 0.6000i), (-0.9000 - 0.4000i), (-0.1000 - 0.9000i), (0.7000 - 0.8000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{0, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (0.7000 - 0.6000i), (0.2000 - 0.8000i), (-0.9000 + 0.5000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex64{(0.6000 - 0.6000i), (-0.9000 - 0.4000i), (-0.1000 - 0.9000i), (0.7000 - 0.8000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{1, 1, 1, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.6000 - 0.6000i), (-0.4000 - 0.7000i), (0.7000 - 0.6000i), (0.2000 - 0.8000i), (-0.9000 + 0.5000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex64{(0.7000 - 0.8000i), (-0.9000 - 0.4000i), (-0.1000 - 0.9000i), (0.7000 - 0.8000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{2, 2, 3, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.6000 - 0.6000i), (0.7000 - 0.6000i), (0.7000 - 0.6000i), (0.2000 - 0.8000i), (-0.9000 + 0.5000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex64{(0.7000 - 0.8000i), (-0.9000 + 0.5000i), (-0.4000 - 0.7000i), (0.7000 - 0.8000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.7000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
		{4, 4, 7, []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}, -1, []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}, -2, []complex64{(0.6000 - 0.6000i), (0.7000 - 0.6000i), (-0.1000 - 0.2000i), (0.8000 - 0.7000i), (-0.9000 + 0.5000i), (0.1000 + 0.4000i), (0.6000 - 0.6000i)}, []complex64{(0.7000 - 0.8000i), (-0.9000 + 0.5000i), (-0.4000 - 0.7000i), (0.1000 - 0.5000i), (-0.1000 - 0.9000i), (-0.5000 - 0.3000i), (0.2000 - 0.8000i)}, []complex64{(0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i), (1.1700 + 1.1700i)}},
	}

	for _, test := range cswapTests {
		*n = test.n
		*incx = test.incx
		*incy = test.incy
		for j := 0; j < 7; j++ {
			(*sx)[j] = test.sx[j]
			(*sy)[j] = test.sy[j]
		}
		nc++
		Cswap(n, sx, incx, sy, incy)
		cTest(t, nc, test.lenx, sx, &test.sxtrue, &test.size, onef32, "sx")
		cTest(t, nc, test.leny, sy, &test.sytrue, &test.size, onef32, "sy")
	}

	printTestsRun(tname, nc)
}

func BenchmarkCswap(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	sy := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	*n = 4
	*sx = []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}
	*incx = 2
	*sy = []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}
	*incy = -2

	for i := 0; i < b.N; i++ {
		Cswap(n, sx, incx, sy, incy)
	}
}

func BenchmarkCswapFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	incy := new(int)
	sx := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	sy := func() *[]complex64 { y := make([]complex64, 7); return &y }()
	*n = 4
	*sx = []complex64{(0.7000 - 0.8000i), (-0.4000 - 0.7000i), (-0.1000 - 0.9000i), (0.2000 - 0.8000i), (-0.9000 - 0.4000i), (0.1000 + 0.4000i), (-0.6000 + 0.6000i)}
	*incx = 2
	*sy = []complex64{(0.6000 - 0.6000i), (-0.9000 + 0.5000i), (0.7000 - 0.6000i), (0.1000 - 0.5000i), (-0.1000 - 0.2000i), (-0.5000 - 0.3000i), (0.8000 - 0.7000i)}
	*incy = -2

	for i := 0; i < b.N; i++ {
		cswapWrapper(n, sx, incx, sy, incy)
	}
}

// BLAS Level 2
func TestCgemv(t *testing.T) {
	tname := "Cgemv"
	var i, ia, ib, ic, im, in, incxs, incys, ix, iy, j, laa, ldas, lx, ly, ml, ms, nl, ns, nd, nc int
	var als, bls complex64
	var err, erri, epsf32 float32
	var transs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex64)
	beta := new(complex64)
	transl := new(complex64)
	kl := new(int)
	ku := new(int)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_ml := new(int)
	_nl := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xs := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	y := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	ys := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yt := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]
		ns = *n
		nd = (*n)/2 + 1
		for im = 1; im <= 2; im++ {
			if im == 1 {
				*m = max((*n)-nd, 0)
			} else if im == 2 {
				*m = min((*n)+nd, nmax)
			}

			*ku = (*n) - 1
			*kl = (*m) - 1
			ms = *m
			*lda = *m
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			ldas = *lda

			null = *n <= 0 || *m <= 0

			*transl = 0.0
			cmakeGE2L2(m, n, a, aa, lda, kl, ku, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
			for j = 1; j <= *n; j++ {
				for i = 1; i <= *m; i++ {
					(*a)[i-1][j-1] = (*aa)[i+(j-1)*absint(*lda)-1]
				}
			}

			for ic = 1; ic <= len(ichtL2); ic++ {
				*trans = ichtL2[ic-1]

				if *trans == 'T' || *trans == 'C' {
					ml = *n
					nl = *m
				} else {
					ml = *m
					nl = *n
				}

				for ix = 1; ix <= len(incL2); ix++ {
					*incx = incL2[ix-1]
					lx = absint(*incx) * nl

					*transl = 0.5
					*_nl = nl - 1
					cmakeGEL2(onei, &nl, x, xx, incx, zeroi, _nl, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					if nl > 1 {
						(*xx)[1+absint(*incx)*(nl/2-1)-1] = 0.0
					}

					for iy = 1; iy <= len(incL2); iy++ {
						*incy = incL2[iy-1]
						ly = absint(*incy) * ml

						for ia = 1; ia <= len(alfc64L2); ia++ {
							*alpha = alfc64L2[ia-1]

							for ib = 1; ib <= len(betc64L2); ib++ {
								*beta = betc64L2[ib-1]

								*transl = 0.0
								*_ml = ml - 1
								cmakeGEL2(onei, &ml, y, yy, incy, zeroi, _ml, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

								transs = *trans
								incxs = *incx
								incys = *incy
								als = *alpha
								bls = *beta
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lx; i++ {
									(*xs)[i-1] = (*xx)[i-1]
								}
								for i = 1; i <= ly; i++ {
									(*ys)[i-1] = (*yy)[i-1]
								}

								nc++

								_aa := cExpand(aa, n, lda)
								Cgemv(major, trans, m, n, alpha, _aa, lda, xx, incx, beta, yy, incy)
								cReturn(_aa, aa)

								checkByte(t, nc, trans, &transs, "trans")
								checkInt(t, nc, m, &ms, "m")
								checkInt(t, nc, n, &ns, "n")
								checkComplex64(t, nc, &als, alpha, "alpha")
								checkComplex64(t, nc, &bls, beta, "beta")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, incx, &incxs, "incx")
								checkInt(t, nc, incy, &incys, "incy")
								checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
								checkComplex64Array1D(t, nc, &lx, xx, xs, "xx")
								if null {
									checkComplex64Array1D(t, nc, &ly, yy, ys, "guardband yy")
									break
								} else {
									for j := 0; j < ml; j++ {
										for i = 1; i < absint(*incy); i++ {
											if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
												t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
											}
										}
									}
									cmvchTest(trans, m, n, alpha, a, x, incx, beta, y, incy, yt, g)
									err = 0
									for i = 1; i <= ml; i++ {
										erri = abssumf32((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf32
										if (*g)[i-1] != 0.0 {
											erri /= (*g)[i-1]
										}
										err = maxf32(err, erri)
										if err*sqrtf32(epsf32) >= 1.0 {
											t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.8e} error\n\t\ttrans: %c\tm: %d\tn: %d\talpha: %4.2f\tbeta: %4.2f\tlda: %d\tincx: %d\tincy: %d", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf32(epsf32), *trans, *m, *n, *alpha, *beta, *lda, *incx, *incy)
										}
									}
								}
							}

							if null {
								break
							}
						}

						if null {
							break
						}
					}

					if null {
						break
					}
				}

				if null {
					break
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkCgemv(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	trans := new(byte)
	major := new(byte)
	*major = 'C'

	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*trans = 'C'
	*m = 14
	*n = 9
	*alpha = (0.70 - 0.90i)
	*aa = []complex64{(0.3067 - 0.4925i), (-0.4625 - 0.3007i), (0.4665 + 0.4426i), (0.0969 + 0.4505i), (0.4266 + 0.1069i), (0.1868 - 0.1568i), (-0.3826 + 0.2507i), (-0.2527 - 0.2927i), (-0.4226 + 0.0989i), (0.1069 + 0.2428i), (0.2667 + 0.3067i), (-0.1029 + 0.2987i), (0.2268 - 0.3566i), (0.2567 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (-0.0130 - 0.0929i), (-0.4525 + 0.0430i), (0.3766 - 0.3487i), (-0.0929 - 0.4925i), (0.1369 - 0.3007i), (0.0669 + 0.4426i), (0.0270 + 0.1069i), (0.0569 - 0.1009i), (-0.2128 - 0.1568i), (0.2168 + 0.2507i), (0.3467 - 0.2927i), (-0.2927 + 0.2428i), (-0.0629 + 0.0509i), (-0.1329 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (0.4965 + 0.2987i), (-0.1728 - 0.3566i), (-0.4126 - 0.0929i), (0.0170 + 0.4985i), (0.1469 + 0.0430i), (-0.0230 - 0.3487i), (-0.4925 - 0.4925i), (-0.3327 + 0.4426i), (0.2967 + 0.4505i), (-0.3726 + 0.1069i), (-0.3427 - 0.1009i), (0.3866 - 0.1568i), (-0.0529 - 0.2927i), (-0.2228 + 0.0989i), (-10000000000.0000 + 10000000000.0000i), (0.3067 + 0.2428i), (-0.4625 + 0.0509i), (0.4665 + 0.3067i), (0.4266 - 0.3566i), (0.4565 - 0.1489i), (0.1868 - 0.0929i), (-0.3826 + 0.4985i), (-0.2527 + 0.0430i), (0.1069 - 0.4925i), (0.3367 - 0.3007i), (0.2667 + 0.4426i), (-0.1029 + 0.4505i), (0.2268 + 0.1069i), (-0.0130 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (0.4166 + 0.2507i), (-0.4525 - 0.2927i), (0.3766 + 0.0989i), (-0.0929 + 0.2428i), (0.0669 + 0.3067i), (-0.3027 + 0.2987i), (0.0270 - 0.3566i), (0.0569 - 0.1489i), (-0.2128 - 0.0929i), (0.3467 + 0.0430i), (0.1768 - 0.3487i), (-0.2927 - 0.4925i), (-0.0629 - 0.3007i), (-0.1329 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (-0.1728 + 0.1069i), (-0.1429 - 0.1009i), (-0.4126 - 0.1568i), (0.0170 + 0.2507i), (0.1469 - 0.2927i), (-0.4925 + 0.2428i), (-0.2627 + 0.0509i), (-0.3327 + 0.3067i), (0.2967 + 0.2987i), (-0.3726 - 0.3566i), (0.3866 - 0.0929i), (-0.1828 + 0.4985i), (-0.0529 + 0.0430i), (-0.2228 - 0.3487i), (-10000000000.0000 + 10000000000.0000i), (0.3067 - 0.4925i), (0.4665 + 0.4426i), (0.0969 + 0.4505i), (0.4266 + 0.1069i), (0.4565 - 0.1009i), (0.1868 - 0.1568i), (-0.2527 - 0.2927i), (-0.4226 + 0.0989i), (0.1069 + 0.2428i), (0.3367 + 0.0509i), (0.2667 + 0.3067i), (0.2268 - 0.3566i), (0.2567 - 0.1489i), (-0.0130 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.4166 + 0.4985i), (-0.4525 + 0.0430i), (-0.0929 - 0.4925i), (0.1369 - 0.3007i), (0.0669 + 0.4426i), (-0.3027 + 0.4505i), (0.0270 + 0.1069i), (-0.2128 - 0.1568i), (0.2168 + 0.2507i), (0.3467 - 0.2927i), (0.1768 + 0.0989i), (-0.2927 + 0.2428i), (-0.1329 + 0.3067i), (0.4965 + 0.2987i), (-10000000000.0000 + 10000000000.0000i), (-0.1728 - 0.3566i), (-0.1429 - 0.1489i), (-0.4126 - 0.0929i), (0.1469 + 0.0430i), (-0.0230 - 0.3487i), (-0.4925 - 0.4925i), (-0.2627 - 0.3007i), (-0.3327 + 0.4426i), (-0.3726 + 0.1069i), (-0.3427 - 0.1009i), (0.3866 - 0.1568i), (-0.1828 + 0.2507i), (-0.0529 - 0.2927i), (0.3067 + 0.2428i), (-10000000000.0000 + 10000000000.0000i)}
	*lda = 15
	*xx = []complex64{(0.0375 + 0.0509i), (-10000000000.0000 + 10000000000.0000i), (0.9665 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (0.5969 + 0.2987i), (-10000000000.0000 + 10000000000.0000i), (0.9266 - 0.3566i), (-10000000000.0000 + 10000000000.0000i), (0.6868 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.1174 + 0.4985i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0774 - 0.3487i), (-10000000000.0000 + 10000000000.0000i), (0.6069 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (0.7667 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.3971 + 0.4505i), (-10000000000.0000 + 10000000000.0000i), (0.7268 + 0.1069i), (-10000000000.0000 + 10000000000.0000i), (0.7567 - 0.1009i), (-10000000000.0000 + 10000000000.0000i), (0.4870 - 0.1568i), (-10000000000.0000 + 10000000000.0000i)}
	*incx = 2
	*beta = (1.30 - 1.10i)
	*yy = []complex64{(-0.4525 - 0.2927i), (-10000000000.0000 + 10000000000.0000i), (0.3766 + 0.0989i), (-10000000000.0000 + 10000000000.0000i), (-0.0929 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (0.1369 + 0.0509i), (-10000000000.0000 + 10000000000.0000i), (0.0669 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (0.0270 - 0.3566i), (-10000000000.0000 + 10000000000.0000i), (0.0569 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (-0.2128 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.2168 + 0.4985i), (-10000000000.0000 + 10000000000.0000i)}
	*incy = 2
	_aa := cExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Cgemv(major, trans, m, n, alpha, _aa, lda, xx, incx, beta, yy, incy)
	}
}

func BenchmarkCgemvFortran(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	trans := new(byte)

	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*trans = 'C'
	*m = 14
	*n = 9
	*alpha = (0.70 - 0.90i)
	*aa = []complex64{(0.3067 - 0.4925i), (-0.4625 - 0.3007i), (0.4665 + 0.4426i), (0.0969 + 0.4505i), (0.4266 + 0.1069i), (0.1868 - 0.1568i), (-0.3826 + 0.2507i), (-0.2527 - 0.2927i), (-0.4226 + 0.0989i), (0.1069 + 0.2428i), (0.2667 + 0.3067i), (-0.1029 + 0.2987i), (0.2268 - 0.3566i), (0.2567 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (-0.0130 - 0.0929i), (-0.4525 + 0.0430i), (0.3766 - 0.3487i), (-0.0929 - 0.4925i), (0.1369 - 0.3007i), (0.0669 + 0.4426i), (0.0270 + 0.1069i), (0.0569 - 0.1009i), (-0.2128 - 0.1568i), (0.2168 + 0.2507i), (0.3467 - 0.2927i), (-0.2927 + 0.2428i), (-0.0629 + 0.0509i), (-0.1329 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (0.4965 + 0.2987i), (-0.1728 - 0.3566i), (-0.4126 - 0.0929i), (0.0170 + 0.4985i), (0.1469 + 0.0430i), (-0.0230 - 0.3487i), (-0.4925 - 0.4925i), (-0.3327 + 0.4426i), (0.2967 + 0.4505i), (-0.3726 + 0.1069i), (-0.3427 - 0.1009i), (0.3866 - 0.1568i), (-0.0529 - 0.2927i), (-0.2228 + 0.0989i), (-10000000000.0000 + 10000000000.0000i), (0.3067 + 0.2428i), (-0.4625 + 0.0509i), (0.4665 + 0.3067i), (0.4266 - 0.3566i), (0.4565 - 0.1489i), (0.1868 - 0.0929i), (-0.3826 + 0.4985i), (-0.2527 + 0.0430i), (0.1069 - 0.4925i), (0.3367 - 0.3007i), (0.2667 + 0.4426i), (-0.1029 + 0.4505i), (0.2268 + 0.1069i), (-0.0130 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (0.4166 + 0.2507i), (-0.4525 - 0.2927i), (0.3766 + 0.0989i), (-0.0929 + 0.2428i), (0.0669 + 0.3067i), (-0.3027 + 0.2987i), (0.0270 - 0.3566i), (0.0569 - 0.1489i), (-0.2128 - 0.0929i), (0.3467 + 0.0430i), (0.1768 - 0.3487i), (-0.2927 - 0.4925i), (-0.0629 - 0.3007i), (-0.1329 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (-0.1728 + 0.1069i), (-0.1429 - 0.1009i), (-0.4126 - 0.1568i), (0.0170 + 0.2507i), (0.1469 - 0.2927i), (-0.4925 + 0.2428i), (-0.2627 + 0.0509i), (-0.3327 + 0.3067i), (0.2967 + 0.2987i), (-0.3726 - 0.3566i), (0.3866 - 0.0929i), (-0.1828 + 0.4985i), (-0.0529 + 0.0430i), (-0.2228 - 0.3487i), (-10000000000.0000 + 10000000000.0000i), (0.3067 - 0.4925i), (0.4665 + 0.4426i), (0.0969 + 0.4505i), (0.4266 + 0.1069i), (0.4565 - 0.1009i), (0.1868 - 0.1568i), (-0.2527 - 0.2927i), (-0.4226 + 0.0989i), (0.1069 + 0.2428i), (0.3367 + 0.0509i), (0.2667 + 0.3067i), (0.2268 - 0.3566i), (0.2567 - 0.1489i), (-0.0130 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.4166 + 0.4985i), (-0.4525 + 0.0430i), (-0.0929 - 0.4925i), (0.1369 - 0.3007i), (0.0669 + 0.4426i), (-0.3027 + 0.4505i), (0.0270 + 0.1069i), (-0.2128 - 0.1568i), (0.2168 + 0.2507i), (0.3467 - 0.2927i), (0.1768 + 0.0989i), (-0.2927 + 0.2428i), (-0.1329 + 0.3067i), (0.4965 + 0.2987i), (-10000000000.0000 + 10000000000.0000i), (-0.1728 - 0.3566i), (-0.1429 - 0.1489i), (-0.4126 - 0.0929i), (0.1469 + 0.0430i), (-0.0230 - 0.3487i), (-0.4925 - 0.4925i), (-0.2627 - 0.3007i), (-0.3327 + 0.4426i), (-0.3726 + 0.1069i), (-0.3427 - 0.1009i), (0.3866 - 0.1568i), (-0.1828 + 0.2507i), (-0.0529 - 0.2927i), (0.3067 + 0.2428i), (-10000000000.0000 + 10000000000.0000i)}
	*lda = 15
	*xx = []complex64{(0.0375 + 0.0509i), (-10000000000.0000 + 10000000000.0000i), (0.9665 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (0.5969 + 0.2987i), (-10000000000.0000 + 10000000000.0000i), (0.9266 - 0.3566i), (-10000000000.0000 + 10000000000.0000i), (0.6868 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.1174 + 0.4985i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0774 - 0.3487i), (-10000000000.0000 + 10000000000.0000i), (0.6069 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (0.7667 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.3971 + 0.4505i), (-10000000000.0000 + 10000000000.0000i), (0.7268 + 0.1069i), (-10000000000.0000 + 10000000000.0000i), (0.7567 - 0.1009i), (-10000000000.0000 + 10000000000.0000i), (0.4870 - 0.1568i), (-10000000000.0000 + 10000000000.0000i)}
	*incx = 2
	*beta = (1.30 - 1.10i)
	*yy = []complex64{(-0.4525 - 0.2927i), (-10000000000.0000 + 10000000000.0000i), (0.3766 + 0.0989i), (-10000000000.0000 + 10000000000.0000i), (-0.0929 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (0.1369 + 0.0509i), (-10000000000.0000 + 10000000000.0000i), (0.0669 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (0.0270 - 0.3566i), (-10000000000.0000 + 10000000000.0000i), (0.0569 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (-0.2128 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.2168 + 0.4985i), (-10000000000.0000 + 10000000000.0000i)}
	*incy = 2

	for i := 0; i < b.N; i++ {
		cgemvWrapper(trans, m, n, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func TestCgbmv(t *testing.T) {
	tname := "Cgbmv"
	var i, ia, ib, ic, iku, im, in, incxs, incys, ix, iy, j, kls, kus, laa, ldas, lx, ly, ml, ms, nl, ns, nd, nc int
	var als, bls complex64
	var err, erri float32
	var transs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex64)
	beta := new(complex64)
	transl := new(complex64)
	m := new(int)
	n := new(int)
	kl := new(int)
	ku := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_ml := new(int)
	_nl := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xs := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	y := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	ys := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yt := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	for j = 1; j <= min(32, nmax); j++ {
		for i = 1; i <= min(32, nmax); i++ {
			(*a)[i-1][j-1] = int2c64(max(i-j+1, 0))
		}
		(*xx)[j-1] = int2c64(j)
		(*yy)[j-1] = *zeroc64
	}
	for j = 1; j <= min(32, nmax); j++ {
		(*yy)[j-1] = int2c64(j*((j+1)*j))/2 - int2c64((j+1)*j*(j-1))/3
	}

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]
		nd = (*n)/2 + 1

		for im = 1; im <= 2; im++ {
			if im == 1 {
				*m = max((*n)-nd, 0)
			} else if im == 2 {
				*m = min((*n)+nd, nmax)
			}

			for iku = 1; iku <= len(kbL2); iku++ {
				*ku = kbL2[iku-1]
				*kl = max((*ku)-1, 0)
				*lda = (*kl) + (*ku) + 1
				if *lda < nmax {
					*lda++
				} else if *lda > nmax {
					continue
				}
				laa = (*lda) * (*n)
				null = *n <= 0 || *m <= 0

				*transl = 0.0
				cmakeGBL2(m, n, a, aa, lda, kl, ku, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

				for ic = 1; ic <= len(ichtL2); ic++ {
					*trans = ichtL2[ic-1]

					if *trans == 'T' || *trans == 'C' {
						ml = *n
						nl = *m
					} else {
						ml = *m
						nl = *n
					}

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * nl

						*transl = 0.5
						*_nl = nl - 1
						cmakeGEL2(onei, &nl, x, xx, incx, zeroi, _nl, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
						if nl > 1 {
							(*xx)[absint(*incx)*nl] = 0.0
						}

						for iy = 1; iy <= len(incL2); iy++ {
							*incy = incL2[iy-1]
							ly = absint(*incy) * ml

							for ia = 1; ia <= len(alfc64L2); ia++ {
								*alpha = alfc64L2[ia-1]

								for ib = 1; ib <= len(betc64L2); ib++ {
									*beta = betc64L2[ib-1]

									*transl = 0.0
									*_ml = ml - 1
									cmakeGEL2(onei, &ml, y, yy, incy, zeroi, _ml, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

									transs = *trans
									ms = *m
									ns = *n
									kls = *kl
									kus = *ku
									ldas = *lda
									incxs = *incx
									incys = *incy
									als = *alpha
									bls = *beta
									for i = 1; i <= laa; i++ {
										(*as)[i-1] = (*aa)[i-1]
									}
									for i = 1; i <= lx; i++ {
										(*xs)[i-1] = (*xx)[i-1]
									}
									for i = 1; i <= ly; i++ {
										(*ys)[i-1] = (*yy)[i-1]
									}

									nc++

									_aa := cExpand(aa, n, lda)
									Cgbmv(major, trans, m, n, kl, ku, alpha, _aa, lda, xx, incx, beta, yy, incy)
									cReturn(_aa, aa)

									checkByte(t, nc, trans, &transs, "trans")
									checkInt(t, nc, m, &ms, "m")
									checkInt(t, nc, n, &ns, "n")
									checkInt(t, nc, kl, &kls, "kl")
									checkInt(t, nc, ku, &kus, "ku")
									checkComplex64(t, nc, &als, alpha, "alpha")
									checkComplex64(t, nc, &bls, beta, "beta")
									checkInt(t, nc, lda, &ldas, "lda")
									checkInt(t, nc, incx, &incxs, "incx")
									checkInt(t, nc, incy, &incys, "incy")
									checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
									checkComplex64Array1D(t, nc, &lx, xx, xs, "xx")
									if null {
										checkComplex64Array1D(t, nc, &ly, yy, ys, "guardband yy")
										break
									} else {
										for j := 0; j < ml; j++ {
											for i = 2; i < absint(*incy); i++ {
												if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
													t.Errorf("Test Failed: guardband yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
												}
											}
										}
										cmvchTest(trans, m, n, alpha, a, x, incx, beta, y, incy, yt, g)
										err = 0
										for i = 1; i <= ml; i++ {
											erri = absc64((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf32
											if (*g)[i-1] != 0.0 {
												erri /= (*g)[i-1]
											}
											err = maxf32(err, erri)
											if err*sqrtf32(epsf32) >= 1.0 {
												t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf32(epsf32))
											}
										}
									}
								}
								if null {
									break
								}
							}
							if null {
								break
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkCgbmv(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	m := new(int)
	n := new(int)
	kl := new(int)
	ku := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	trans := new(byte)
	major := new(byte)
	*major = 'C'

	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*trans = 'C'
	*m = 14
	*n = 9
	*kl = 3
	*ku = 4
	*alpha = (0.70 - 0.90i)
	*aa = []complex64{(-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.1469 - 0.2927i), (-0.0230 + 0.0989i), (-0.4925 + 0.2428i), (-0.2627 + 0.0509i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3327 + 0.3067i), (-0.3726 - 0.3566i), (-0.3427 - 0.1489i), (0.3866 - 0.0929i), (-0.1828 + 0.4985i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.0529 + 0.0430i), (0.3067 - 0.4925i), (-0.4625 - 0.3007i), (0.4665 + 0.4426i), (0.0969 + 0.4505i), (0.4266 + 0.1069i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.1868 - 0.1568i), (-0.3826 + 0.2507i), (-0.2527 - 0.2927i), (-0.4226 + 0.0989i), (0.1069 + 0.2428i), (0.2667 + 0.3067i), (-0.1029 + 0.2987i), (-10000000000.0000 + 10000000000.0000i), (0.2268 - 0.3566i), (0.2567 - 0.1489i), (-0.0130 - 0.0929i), (-0.4525 + 0.0430i), (0.3766 - 0.3487i), (-0.0929 - 0.4925i), (0.1369 - 0.3007i), (0.0669 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.0270 + 0.1069i), (0.0569 - 0.1009i), (-0.2128 - 0.1568i), (0.2168 + 0.2507i), (0.3467 - 0.2927i), (-0.2927 + 0.2428i), (-0.0629 + 0.0509i), (-0.1329 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (0.4965 + 0.2987i), (-0.1728 - 0.3566i), (-0.4126 - 0.0929i), (0.0170 + 0.4985i), (0.1469 + 0.0430i), (-0.0230 - 0.3487i), (-0.4925 - 0.4925i), (-0.3327 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.2967 + 0.4505i), (-0.3726 + 0.1069i), (-0.3427 - 0.1009i), (0.3866 - 0.1568i), (-0.0529 - 0.2927i), (-0.2228 + 0.0989i), (0.3067 + 0.2428i), (-0.4625 + 0.0509i), (-10000000000.0000 + 10000000000.0000i), (0.4665 + 0.3067i), (0.4266 - 0.3566i), (0.4565 - 0.1489i), (0.1868 - 0.0929i), (-0.3826 + 0.4985i), (-0.2527 + 0.0430i), (0.1069 - 0.4925i), (0.3367 - 0.3007i), (-10000000000.0000 + 10000000000.0000i)}
	*lda = 9
	*xx = []complex64{(0.7667 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.3971 + 0.4505i), (-10000000000.0000 + 10000000000.0000i), (0.7268 + 0.1069i), (-10000000000.0000 + 10000000000.0000i), (0.4870 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (0.9166 + 0.2507i), (-10000000000.0000 + 10000000000.0000i), (0.0475 - 0.2927i), (-10000000000.0000 + 10000000000.0000i), (0.8766 + 0.0989i), (-10000000000.0000 + 10000000000.0000i), (0.4071 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (0.5669 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (0.1973 + 0.2987i), (-10000000000.0000 + 10000000000.0000i), (0.5270 - 0.3566i), (-10000000000.0000 + 10000000000.0000i), (0.5569 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (0.2872 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.8467 + 0.0430i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (30.0000 + 0.0000i), (31.0000 + 0.0000i), (32.0000 + 0.0000i)}
	*incx = 2
	*beta = (1.30 - 1.10i)
	*yy = []complex64{(0.1768 - 0.3487i), (-10000000000.0000 + 10000000000.0000i), (-0.2927 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (-0.0629 - 0.3007i), (-10000000000.0000 + 10000000000.0000i), (-0.1329 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (-0.1728 + 0.1069i), (-10000000000.0000 + 10000000000.0000i), (-0.1429 - 0.1009i), (-10000000000.0000 + 10000000000.0000i), (-0.4126 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (0.0170 + 0.2507i), (-10000000000.0000 + 10000000000.0000i), (0.1469 - 0.2927i), (-10000000000.0000 + 10000000000.0000i), (1330.0000 + 0.0000i), (1540.0000 + 0.0000i), (1771.0000 + 0.0000i), (2024.0000 + 0.0000i), (2300.0000 + 0.0000i), (2600.0000 + 0.0000i), (2925.0000 + 0.0000i), (3276.0000 + 0.0000i), (3654.0000 + 0.0000i), (4060.0000 + 0.0000i), (4495.0000 + 0.0000i), (4960.0000 + 0.0000i), (5456.0000 + 0.0000i), (5984.0000 + 0.0000i)}
	*incy = 2
	_aa := cExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Cgbmv(major, trans, m, n, kl, ku, alpha, _aa, lda, xx, incx, beta, yy, incy)
	}
}

func BenchmarkCgbmvFortran(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	m := new(int)
	n := new(int)
	kl := new(int)
	ku := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	trans := new(byte)

	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*trans = 'C'
	*m = 14
	*n = 9
	*kl = 3
	*ku = 4
	*alpha = (0.70 - 0.90i)
	*aa = []complex64{(-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.1469 - 0.2927i), (-0.0230 + 0.0989i), (-0.4925 + 0.2428i), (-0.2627 + 0.0509i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3327 + 0.3067i), (-0.3726 - 0.3566i), (-0.3427 - 0.1489i), (0.3866 - 0.0929i), (-0.1828 + 0.4985i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.0529 + 0.0430i), (0.3067 - 0.4925i), (-0.4625 - 0.3007i), (0.4665 + 0.4426i), (0.0969 + 0.4505i), (0.4266 + 0.1069i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.1868 - 0.1568i), (-0.3826 + 0.2507i), (-0.2527 - 0.2927i), (-0.4226 + 0.0989i), (0.1069 + 0.2428i), (0.2667 + 0.3067i), (-0.1029 + 0.2987i), (-10000000000.0000 + 10000000000.0000i), (0.2268 - 0.3566i), (0.2567 - 0.1489i), (-0.0130 - 0.0929i), (-0.4525 + 0.0430i), (0.3766 - 0.3487i), (-0.0929 - 0.4925i), (0.1369 - 0.3007i), (0.0669 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.0270 + 0.1069i), (0.0569 - 0.1009i), (-0.2128 - 0.1568i), (0.2168 + 0.2507i), (0.3467 - 0.2927i), (-0.2927 + 0.2428i), (-0.0629 + 0.0509i), (-0.1329 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (0.4965 + 0.2987i), (-0.1728 - 0.3566i), (-0.4126 - 0.0929i), (0.0170 + 0.4985i), (0.1469 + 0.0430i), (-0.0230 - 0.3487i), (-0.4925 - 0.4925i), (-0.3327 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.2967 + 0.4505i), (-0.3726 + 0.1069i), (-0.3427 - 0.1009i), (0.3866 - 0.1568i), (-0.0529 - 0.2927i), (-0.2228 + 0.0989i), (0.3067 + 0.2428i), (-0.4625 + 0.0509i), (-10000000000.0000 + 10000000000.0000i), (0.4665 + 0.3067i), (0.4266 - 0.3566i), (0.4565 - 0.1489i), (0.1868 - 0.0929i), (-0.3826 + 0.4985i), (-0.2527 + 0.0430i), (0.1069 - 0.4925i), (0.3367 - 0.3007i), (-10000000000.0000 + 10000000000.0000i)}
	*lda = 9
	*xx = []complex64{(0.7667 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.3971 + 0.4505i), (-10000000000.0000 + 10000000000.0000i), (0.7268 + 0.1069i), (-10000000000.0000 + 10000000000.0000i), (0.4870 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (0.9166 + 0.2507i), (-10000000000.0000 + 10000000000.0000i), (0.0475 - 0.2927i), (-10000000000.0000 + 10000000000.0000i), (0.8766 + 0.0989i), (-10000000000.0000 + 10000000000.0000i), (0.4071 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (0.5669 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (0.1973 + 0.2987i), (-10000000000.0000 + 10000000000.0000i), (0.5270 - 0.3566i), (-10000000000.0000 + 10000000000.0000i), (0.5569 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (0.2872 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.8467 + 0.0430i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (30.0000 + 0.0000i), (31.0000 + 0.0000i), (32.0000 + 0.0000i)}
	*incx = 2
	*beta = (1.30 - 1.10i)
	*yy = []complex64{(0.1768 - 0.3487i), (-10000000000.0000 + 10000000000.0000i), (-0.2927 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (-0.0629 - 0.3007i), (-10000000000.0000 + 10000000000.0000i), (-0.1329 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (-0.1728 + 0.1069i), (-10000000000.0000 + 10000000000.0000i), (-0.1429 - 0.1009i), (-10000000000.0000 + 10000000000.0000i), (-0.4126 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (0.0170 + 0.2507i), (-10000000000.0000 + 10000000000.0000i), (0.1469 - 0.2927i), (-10000000000.0000 + 10000000000.0000i), (1330.0000 + 0.0000i), (1540.0000 + 0.0000i), (1771.0000 + 0.0000i), (2024.0000 + 0.0000i), (2300.0000 + 0.0000i), (2600.0000 + 0.0000i), (2925.0000 + 0.0000i), (3276.0000 + 0.0000i), (3654.0000 + 0.0000i), (4060.0000 + 0.0000i), (4495.0000 + 0.0000i), (4960.0000 + 0.0000i), (5456.0000 + 0.0000i), (5984.0000 + 0.0000i)}
	*incy = 2

	for i := 0; i < b.N; i++ {
		cgbmvWrapper(trans, m, n, kl, ku, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func TestChemv(t *testing.T) {
	tname := "Chemv"
	var i, ia, ib, ic, in, incxs, incys, ix, iy, laa, ldas, lx, ly, ns, nc int
	var als, bls complex64
	var err, erri float32
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex64)
	beta := new(complex64)
	transl := new(complex64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xs := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	y := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	ys := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yt := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = (*n)
		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			*transl = 0.0
			*_n = (*n) - 1
			cmakeHEL2(uplo, _X, n, n, a, aa, lda, _n, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				cmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				if (*n) > 1 {
					(*xx)[1+absint(*incx)*(*n)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					for ia = 1; ia <= len(alfc64L2); ia++ {
						*alpha = alfc64L2[ia-1]

						for ib = 1; ib <= len(betc64L2); ib++ {
							*beta = betc64L2[ib-1]
							*transl = 0.0
							cmakeGEL2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

							uplos = *uplo
							ns = *n
							ldas = *lda
							incxs = *incx
							incys = *incy
							als = *alpha
							bls = *beta
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lx; i++ {
								(*xs)[i-1] = (*xx)[i-1]
							}
							for i = 1; i <= ly; i++ {
								(*ys)[i-1] = (*yy)[i-1]
							}

							nc++

							_aa := cExpand(aa, n, lda)
							Chemv(major, uplo, n, alpha, _aa, lda, xx, incx, beta, yy, incy)
							cReturn(_aa, aa)

							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkComplex64(t, nc, &als, alpha, "alpha")
							checkComplex64(t, nc, &bls, beta, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, incx, &incxs, "incx")
							checkInt(t, nc, incy, &incys, "incy")
							checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
							checkComplex64Array1D(t, nc, &lx, xx, xs, "xx")
							if null {
								checkComplex64Array1D(t, nc, &ly, yy, ys, "guardband yy")
								break
							} else {
								for j := 0; j < *n; j++ {
									for i = 1; i < absint(*incy); i++ {
										if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
											t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
										}
									}
								}
								cmvchTest(_N, n, n, alpha, a, x, incx, beta, y, incy, yt, g)
								err = 0
								for i = 1; i <= *n; i++ {
									erri = abssumf32((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf32
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf32(err, erri)
									if err*sqrtf32(epsf32) >= 1.0 {
										t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf32(epsf32))
									}
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkChemv(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*alpha = (0.70 - 0.90i)
	*aa = []complex64{(-0.2627 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3327 + 0.4426i), (0.2967 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3726 + 0.1069i), (0.3866 - 0.1568i), (-0.1828 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.0529 - 0.2927i), (-0.2228 + 0.0989i), (0.3067 + 0.2428i), (0.4665 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0969 + 0.2987i), (0.4266 - 0.3566i), (0.4565 - 0.1489i), (0.1868 - 0.0929i), (-0.2527 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.4226 - 0.3487i), (0.1069 - 0.4925i), (0.3367 - 0.3007i), (0.2667 + 0.4426i), (0.2268 + 0.1069i), (0.2567 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.0130 - 0.1568i), (0.4166 + 0.2507i), (-0.4525 - 0.2927i), (-0.0929 + 0.2428i), (0.1369 + 0.0509i), (0.0669 + 0.3067i), (-0.3027 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0270 - 0.3566i), (-0.2128 - 0.0929i), (0.2168 + 0.4985i), (0.3467 + 0.0430i), (0.1768 - 0.3487i), (-0.2927 - 0.4925i), (-0.1329 + 0.4426i), (0.4965 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.1728 + 0.1069i), (-0.1429 - 0.1009i), (-0.4126 - 0.1568i), (0.1469 - 0.2927i), (-0.0230 + 0.0989i), (-0.4925 + 0.2428i), (-0.2627 + 0.0509i), (-0.3327 + 0.3067i), (-0.3726 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i)}
	*lda = 10
	*xx = []complex64{(0.1573 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (0.8866 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.3172 + 0.4985i), (-10000000000.0000 + 10000000000.0000i), (0.4471 + 0.0430i), (-10000000000.0000 + 10000000000.0000i), (0.8067 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (0.0375 - 0.3007i), (-10000000000.0000 + 10000000000.0000i), (0.9665 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.5969 + 0.4505i), (-10000000000.0000 + 10000000000.0000i), (0.9266 + 0.1069i), (-10000000000.0000 + 10000000000.0000i)}
	*incx = 2
	*beta = (1.30 - 1.10i)
	*yy = []complex64{(0.1868 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (-0.3826 + 0.2507i), (-10000000000.0000 + 10000000000.0000i), (-0.2527 - 0.2927i), (-10000000000.0000 + 10000000000.0000i), (-0.4226 + 0.0989i), (-10000000000.0000 + 10000000000.0000i), (0.1069 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (0.2667 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (-0.1029 + 0.2987i), (-10000000000.0000 + 10000000000.0000i), (0.2268 - 0.3566i), (-10000000000.0000 + 10000000000.0000i), (0.2567 - 0.1489i), (-10000000000.0000 + 10000000000.0000i)}
	*incy = 2
	_aa := cExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Chemv(major, uplo, n, alpha, _aa, lda, xx, incx, beta, yy, incy)
	}
}

func BenchmarkChemvFortran(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)

	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*alpha = (0.70 - 0.90i)
	*aa = []complex64{(-0.2627 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3327 + 0.4426i), (0.2967 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3726 + 0.1069i), (0.3866 - 0.1568i), (-0.1828 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.0529 - 0.2927i), (-0.2228 + 0.0989i), (0.3067 + 0.2428i), (0.4665 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0969 + 0.2987i), (0.4266 - 0.3566i), (0.4565 - 0.1489i), (0.1868 - 0.0929i), (-0.2527 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.4226 - 0.3487i), (0.1069 - 0.4925i), (0.3367 - 0.3007i), (0.2667 + 0.4426i), (0.2268 + 0.1069i), (0.2567 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.0130 - 0.1568i), (0.4166 + 0.2507i), (-0.4525 - 0.2927i), (-0.0929 + 0.2428i), (0.1369 + 0.0509i), (0.0669 + 0.3067i), (-0.3027 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0270 - 0.3566i), (-0.2128 - 0.0929i), (0.2168 + 0.4985i), (0.3467 + 0.0430i), (0.1768 - 0.3487i), (-0.2927 - 0.4925i), (-0.1329 + 0.4426i), (0.4965 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.1728 + 0.1069i), (-0.1429 - 0.1009i), (-0.4126 - 0.1568i), (0.1469 - 0.2927i), (-0.0230 + 0.0989i), (-0.4925 + 0.2428i), (-0.2627 + 0.0509i), (-0.3327 + 0.3067i), (-0.3726 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i)}
	*lda = 10
	*xx = []complex64{(0.1573 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (0.8866 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.3172 + 0.4985i), (-10000000000.0000 + 10000000000.0000i), (0.4471 + 0.0430i), (-10000000000.0000 + 10000000000.0000i), (0.8067 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (0.0375 - 0.3007i), (-10000000000.0000 + 10000000000.0000i), (0.9665 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.5969 + 0.4505i), (-10000000000.0000 + 10000000000.0000i), (0.9266 + 0.1069i), (-10000000000.0000 + 10000000000.0000i)}
	*incx = 2
	*beta = (1.30 - 1.10i)
	*yy = []complex64{(0.1868 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (-0.3826 + 0.2507i), (-10000000000.0000 + 10000000000.0000i), (-0.2527 - 0.2927i), (-10000000000.0000 + 10000000000.0000i), (-0.4226 + 0.0989i), (-10000000000.0000 + 10000000000.0000i), (0.1069 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (0.2667 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (-0.1029 + 0.2987i), (-10000000000.0000 + 10000000000.0000i), (0.2268 - 0.3566i), (-10000000000.0000 + 10000000000.0000i), (0.2567 - 0.1489i), (-10000000000.0000 + 10000000000.0000i)}
	*incy = 2

	for i := 0; i < b.N; i++ {
		chemvWrapper(uplo, n, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func TestChbmv(t *testing.T) {
	tname := "Chbmv"
	var i, ia, ib, ic, ik, in, incxs, incys, ix, iy, ks, laa, ldas, lx, ly, nc, ns int
	var als, bls complex64
	var err, erri float32
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex64)
	beta := new(complex64)
	transl := new(complex64)
	n := new(int)
	k := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xs := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	y := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	ys := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yt := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		for ik = 1; ik <= len(kbL2); ik++ {
			*k = kbL2[ik-1]
			*lda = (*k) + 1

			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = ((*n) * ((*n) + 1)) / 2
			null = *n <= 0

			for ic = 1; ic <= len(ichuL2); ic++ {
				*uplo = ichuL2[ic-1]

				*transl = 0.0
				cmakeHBL2(uplo, n, n, a, aa, lda, k, k, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

				for ix = 1; ix <= len(incL2); ix++ {
					*incx = incL2[ix-1]
					lx = absint(*incx) * (*n)

					*transl = 0.5
					*_n = (*n) - 1
					cmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					if (*n) > 1 {
						(*xx)[1+absint(*incx)*(*n)-1] = 0.0
					}

					for iy = 1; iy <= len(incL2); iy++ {
						*incy = incL2[iy-1]
						ly = absint(*incy) * (*n)

						for ia = 1; ia <= len(alfc64L2); ia++ {
							*alpha = alfc64L2[ia-1]

							for ib = 1; ib <= len(betc64L2); ib++ {
								*beta = betc64L2[ib-1]

								*transl = 0.0
								cmakeGEL2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

								uplos = *uplo
								ns = *n
								ks = *k
								ldas = *lda
								incxs = *incx
								incys = *incy
								als = *alpha
								bls = *beta
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lx; i++ {
									(*xs)[i-1] = (*xx)[i-1]
								}
								for i = 1; i <= ly; i++ {
									(*ys)[i-1] = (*yy)[i-1]
								}

								nc++

								_aa := cExpand(aa, n, lda)
								Chbmv(major, uplo, n, k, alpha, _aa, lda, xx, incx, beta, yy, incy)
								cReturn(_aa, aa)

								checkByte(t, nc, uplo, &uplos, "uplo")
								checkInt(t, nc, n, &ns, "n")
								checkInt(t, nc, k, &ks, "k")
								checkComplex64(t, nc, &als, alpha, "alpha")
								checkComplex64(t, nc, &bls, beta, "beta")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, incx, &incxs, "incx")
								checkInt(t, nc, incy, &incys, "incy")
								checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
								checkComplex64Array1D(t, nc, &lx, xx, xs, "xx")
								if null {
									checkComplex64Array1D(t, nc, &ly, yy, ys, "guardband yy")
									break
								} else {
									for j := 0; j < (*n); j++ {
										for i = 1; i < absint(*incy); i++ {
											if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
												t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
											}
										}
									}
									cmvchTest(_N, n, n, alpha, a, x, incx, beta, y, incy, yt, g)
									err = 0
									for i = 1; i <= (*n); i++ {
										erri = abssumf32((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf32
										if (*g)[i-1] != 0.0 {
											erri /= (*g)[i-1]
										}
										err = maxf32(err, erri)
										if err*sqrtf32(epsf32) >= 1.0 {
											t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf32(epsf32))
										}
									}
								}
							}
							if null {
								break
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkChbmv(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	n := new(int)
	k := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	major := new(byte)
	*major = 'C'

	*uplo = 'U'
	*n = 9
	*k = 4
	*alpha = (0.70 - 0.90i)
	*aa = []complex64{(-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.2627 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3327 + 0.4426i), (0.2967 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3726 + 0.1069i), (0.3866 - 0.1568i), (-0.1828 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.0529 - 0.2927i), (-0.2228 + 0.0989i), (0.3067 + 0.2428i), (0.4665 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0969 + 0.2987i), (0.4266 - 0.3566i), (0.4565 - 0.1489i), (0.1868 - 0.0929i), (-0.2527 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.4226 - 0.3487i), (0.1069 - 0.4925i), (0.3367 - 0.3007i), (0.2667 + 0.4426i), (0.2268 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.2567 - 0.1009i), (-0.0130 - 0.1568i), (0.4166 + 0.2507i), (-0.4525 - 0.2927i), (-0.0929 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.1369 + 0.0509i), (0.0669 + 0.3067i), (-0.3027 + 0.2987i), (0.0270 - 0.3566i), (-0.2128 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.2168 + 0.4985i), (0.3467 + 0.0430i), (0.1768 - 0.3487i), (-0.2927 - 0.4925i), (-0.1329 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i)}
	*lda = 6
	*xx = []complex64{(0.9965 + 0.4505i), (-10000000000.0000 + 10000000000.0000i), (0.3272 + 0.1069i), (-10000000000.0000 + 10000000000.0000i), (0.3571 - 0.1009i), (-10000000000.0000 + 10000000000.0000i), (0.0874 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (0.6469 - 0.2927i), (-10000000000.0000 + 10000000000.0000i), (0.4770 + 0.0989i), (-10000000000.0000 + 10000000000.0000i), (0.0075 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (0.2373 + 0.0509i), (-10000000000.0000 + 10000000000.0000i), (0.1673 + 0.3067i), (-10000000000.0000 + 10000000000.0000i)}
	*incx = 2
	*beta = (1.30 - 1.10i)
	*yy = []complex64{(-0.3726 - 0.3566i), (-10000000000.0000 + 10000000000.0000i), (-0.3427 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (0.3866 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (-0.1828 + 0.4985i), (-10000000000.0000 + 10000000000.0000i), (-0.0529 + 0.0430i), (-10000000000.0000 + 10000000000.0000i), (0.3067 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (-0.4625 - 0.3007i), (-10000000000.0000 + 10000000000.0000i), (0.4665 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.0969 + 0.4505i), (-10000000000.0000 + 10000000000.0000i)}
	*incy = 2
	_aa := cExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Chbmv(major, uplo, n, k, alpha, _aa, lda, xx, incx, beta, yy, incy)
	}
}

func BenchmarkChbmvFortran(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	n := new(int)
	k := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*k = 4
	*alpha = (0.70 - 0.90i)
	*aa = []complex64{(-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.2627 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3327 + 0.4426i), (0.2967 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3726 + 0.1069i), (0.3866 - 0.1568i), (-0.1828 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.0529 - 0.2927i), (-0.2228 + 0.0989i), (0.3067 + 0.2428i), (0.4665 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0969 + 0.2987i), (0.4266 - 0.3566i), (0.4565 - 0.1489i), (0.1868 - 0.0929i), (-0.2527 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.4226 - 0.3487i), (0.1069 - 0.4925i), (0.3367 - 0.3007i), (0.2667 + 0.4426i), (0.2268 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.2567 - 0.1009i), (-0.0130 - 0.1568i), (0.4166 + 0.2507i), (-0.4525 - 0.2927i), (-0.0929 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.1369 + 0.0509i), (0.0669 + 0.3067i), (-0.3027 + 0.2987i), (0.0270 - 0.3566i), (-0.2128 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.2168 + 0.4985i), (0.3467 + 0.0430i), (0.1768 - 0.3487i), (-0.2927 - 0.4925i), (-0.1329 - 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i)}
	*lda = 6
	*xx = []complex64{(0.9965 + 0.4505i), (-10000000000.0000 + 10000000000.0000i), (0.3272 + 0.1069i), (-10000000000.0000 + 10000000000.0000i), (0.3571 - 0.1009i), (-10000000000.0000 + 10000000000.0000i), (0.0874 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (0.6469 - 0.2927i), (-10000000000.0000 + 10000000000.0000i), (0.4770 + 0.0989i), (-10000000000.0000 + 10000000000.0000i), (0.0075 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (0.2373 + 0.0509i), (-10000000000.0000 + 10000000000.0000i), (0.1673 + 0.3067i), (-10000000000.0000 + 10000000000.0000i)}
	*incx = 2
	*beta = (1.30 - 1.10i)
	*yy = []complex64{(-0.3726 - 0.3566i), (-10000000000.0000 + 10000000000.0000i), (-0.3427 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (0.3866 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (-0.1828 + 0.4985i), (-10000000000.0000 + 10000000000.0000i), (-0.0529 + 0.0430i), (-10000000000.0000 + 10000000000.0000i), (0.3067 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (-0.4625 - 0.3007i), (-10000000000.0000 + 10000000000.0000i), (0.4665 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.0969 + 0.4505i), (-10000000000.0000 + 10000000000.0000i)}
	*incy = 2

	for i := 0; i < b.N; i++ {
		chbmvWrapper(uplo, n, k, alpha, aa, lda, xx, incx, beta, yy, incy)
	}
}

func TestChpmv(t *testing.T) {
	tname := "Chpmv"
	var i, ia, ib, ic, in, incxs, incys, ix, iy, laa, lx, ly, nc, ns int
	var als, bls complex64
	var err, erri float32
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex64)
	beta := new(complex64)
	transl := new(complex64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xs := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	y := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	ys := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yt := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			*transl = 0.0
			*_n = (*n) - 1
			cmakeHPL2(uplo, n, n, a, aa, _n, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				cmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				if (*n) > 1 {
					(*xx)[1+absint(*incx)*(*n)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					for ia = 1; ia <= len(alfc64L2); ia++ {
						*alpha = alfc64L2[ia-1]

						for ib = 1; ib <= len(betc64L2); ib++ {
							*beta = betc64L2[ib-1]

							*transl = 0.0
							cmakeGEL2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

							uplos = *uplo
							ns = *n
							incxs = *incx
							incys = *incy
							als = *alpha
							bls = *beta
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lx; i++ {
								(*xs)[i-1] = (*xx)[i-1]
							}
							for i = 1; i <= ly; i++ {
								(*ys)[i-1] = (*yy)[i-1]
							}

							nc++

							Chpmv(major, uplo, n, alpha, aa, xx, incx, beta, yy, incy)

							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkComplex64(t, nc, &als, alpha, "alpha")
							checkComplex64(t, nc, &bls, beta, "beta")
							checkInt(t, nc, incx, &incxs, "incx")
							checkInt(t, nc, incy, &incys, "incy")
							checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
							checkComplex64Array1D(t, nc, &lx, xx, xs, "xx")
							if null {
								checkComplex64Array1D(t, nc, &ly, yy, ys, "guardband yy")
								break
							} else {
								for j := 0; j < (*n); j++ {
									for i = 1; i < absint(*incy); i++ {
										if (*yy)[i+j*absint(*incy)] != (*ys)[i+j*absint(*incy)] {
											t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incy), nc, (*yy)[i+j*absint(*incy)], (*ys)[i+j*absint(*incy)])
										}
									}
								}
								cmvchTest(_N, n, n, alpha, a, x, incx, beta, y, incy, yt, g)
								err = 0
								for i = 1; i <= (*n); i++ {
									erri = abssumf32((*yt)[(i-1)]-(*yy)[(i-1)*absint(*incy)]) / epsf32
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf32(err, erri)
									if err*sqrtf32(epsf32) >= 1.0 {
										t.Errorf("Test Failed: yy[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incy), nc, (*yy)[(i-1)*absint(*incy)], (*yt)[(i-1)], err*sqrtf32(epsf32))
									}
								}
							}
						}

						if null {
							break
						}
					}

					if null {
						break
					}
				}

				if null {
					break
				}
			}

			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkChpmv(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	major := new(byte)
	*major = 'C'

	*uplo = 'U'
	*n = 9
	*alpha = (0.70 - 0.90i)
	*aa = []complex64{(-0.2627 - 10000000000.0000i), (-0.3327 + 0.4426i), (0.2967 - 10000000000.0000i), (-0.3726 + 0.1069i), (0.3866 - 0.1568i), (-0.1828 - 10000000000.0000i), (-0.0529 - 0.2927i), (-0.2228 + 0.0989i), (0.3067 + 0.2428i), (0.4665 - 10000000000.0000i), (0.0969 + 0.2987i), (0.4266 - 0.3566i), (0.4565 - 0.1489i), (0.1868 - 0.0929i), (-0.2527 - 10000000000.0000i), (-0.4226 - 0.3487i), (0.1069 - 0.4925i), (0.3367 - 0.3007i), (0.2667 + 0.4426i), (0.2268 + 0.1069i), (0.2567 - 10000000000.0000i), (-0.0130 - 0.1568i), (0.4166 + 0.2507i), (-0.4525 - 0.2927i), (-0.0929 + 0.2428i), (0.1369 + 0.0509i), (0.0669 + 0.3067i), (-0.3027 - 10000000000.0000i), (0.0270 - 0.3566i), (-0.2128 - 0.0929i), (0.2168 + 0.4985i), (0.3467 + 0.0430i), (0.1768 - 0.3487i), (-0.2927 - 0.4925i), (-0.1329 + 0.4426i), (0.4965 - 10000000000.0000i), (-0.1728 + 0.1069i), (-0.1429 - 0.1009i), (-0.4126 - 0.1568i), (0.1469 - 0.2927i), (-0.0230 + 0.0989i), (-0.4925 + 0.2428i), (-0.2627 + 0.0509i), (-0.3327 + 0.3067i), (-0.3726 - 10000000000.0000i)}
	*xx = []complex64{(0.1573 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (0.8866 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.3172 + 0.4985i), (-10000000000.0000 + 10000000000.0000i), (0.4471 + 0.0430i), (-10000000000.0000 + 10000000000.0000i), (0.8067 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (0.0375 - 0.3007i), (-10000000000.0000 + 10000000000.0000i), (0.9665 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.5969 + 0.4505i), (-10000000000.0000 + 10000000000.0000i), (0.9266 + 0.1069i), (-10000000000.0000 + 10000000000.0000i)}
	*incx = 2
	*beta = (1.30 - 1.10i)
	*yy = []complex64{(0.1868 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (-0.3826 + 0.2507i), (-10000000000.0000 + 10000000000.0000i), (-0.2527 - 0.2927i), (-10000000000.0000 + 10000000000.0000i), (-0.4226 + 0.0989i), (-10000000000.0000 + 10000000000.0000i), (0.1069 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (0.2667 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (-0.1029 + 0.2987i), (-10000000000.0000 + 10000000000.0000i), (0.2268 - 0.3566i), (-10000000000.0000 + 10000000000.0000i), (0.2567 - 0.1489i), (-10000000000.0000 + 10000000000.0000i)}
	*incy = 2
	*alpha = 0.70

	for i := 0; i < b.N; i++ {
		Chpmv(major, uplo, n, alpha, aa, xx, incx, beta, yy, incy)
	}
}

func BenchmarkChpmvFortran(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*alpha = (0.70 - 0.90i)
	*aa = []complex64{(-0.2627 - 10000000000.0000i), (-0.3327 + 0.4426i), (0.2967 - 10000000000.0000i), (-0.3726 + 0.1069i), (0.3866 - 0.1568i), (-0.1828 - 10000000000.0000i), (-0.0529 - 0.2927i), (-0.2228 + 0.0989i), (0.3067 + 0.2428i), (0.4665 - 10000000000.0000i), (0.0969 + 0.2987i), (0.4266 - 0.3566i), (0.4565 - 0.1489i), (0.1868 - 0.0929i), (-0.2527 - 10000000000.0000i), (-0.4226 - 0.3487i), (0.1069 - 0.4925i), (0.3367 - 0.3007i), (0.2667 + 0.4426i), (0.2268 + 0.1069i), (0.2567 - 10000000000.0000i), (-0.0130 - 0.1568i), (0.4166 + 0.2507i), (-0.4525 - 0.2927i), (-0.0929 + 0.2428i), (0.1369 + 0.0509i), (0.0669 + 0.3067i), (-0.3027 - 10000000000.0000i), (0.0270 - 0.3566i), (-0.2128 - 0.0929i), (0.2168 + 0.4985i), (0.3467 + 0.0430i), (0.1768 - 0.3487i), (-0.2927 - 0.4925i), (-0.1329 + 0.4426i), (0.4965 - 10000000000.0000i), (-0.1728 + 0.1069i), (-0.1429 - 0.1009i), (-0.4126 - 0.1568i), (0.1469 - 0.2927i), (-0.0230 + 0.0989i), (-0.4925 + 0.2428i), (-0.2627 + 0.0509i), (-0.3327 + 0.3067i), (-0.3726 - 10000000000.0000i)}
	*xx = []complex64{(0.1573 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (0.8866 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.3172 + 0.4985i), (-10000000000.0000 + 10000000000.0000i), (0.4471 + 0.0430i), (-10000000000.0000 + 10000000000.0000i), (0.8067 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (0.0375 - 0.3007i), (-10000000000.0000 + 10000000000.0000i), (0.9665 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.5969 + 0.4505i), (-10000000000.0000 + 10000000000.0000i), (0.9266 + 0.1069i), (-10000000000.0000 + 10000000000.0000i)}
	*incx = 2
	*beta = (1.30 - 1.10i)
	*yy = []complex64{(0.1868 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (-0.3826 + 0.2507i), (-10000000000.0000 + 10000000000.0000i), (-0.2527 - 0.2927i), (-10000000000.0000 + 10000000000.0000i), (-0.4226 + 0.0989i), (-10000000000.0000 + 10000000000.0000i), (0.1069 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (0.2667 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (-0.1029 + 0.2987i), (-10000000000.0000 + 10000000000.0000i), (0.2268 - 0.3566i), (-10000000000.0000 + 10000000000.0000i), (0.2567 - 0.1489i), (-10000000000.0000 + 10000000000.0000i)}
	*incy = 2
	*alpha = 0.70

	for i := 0; i < b.N; i++ {
		chpmvWrapper(uplo, n, alpha, aa, xx, incx, beta, yy, incy)
	}
}

func TestCtrmv(t *testing.T) {
	tname := "Ctrmv"
	var i, icd, ict, icu, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float32
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(complex64)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xs := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xt := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	z := func() *[]complex64 { y := make([]complex64, nmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*k = (*n) - 1
		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for icu = 1; icu <= len(ichuL2); icu++ {
			*uplo = ichuL2[icu-1]

			for ict = 1; ict <= len(ichtL2); ict++ {
				*trans = ichtL2[ict-1]

				for icd = 1; icd <= len(ichdL2); icd++ {
					*diag = ichdL2[icd-1]

					*transl = 0.0
					cmakeTRL2(uplo, diag, n, n, a, aa, lda, k, k, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * (*n)

						*transl = 0.5
						*_n = (*n) - 1
						cmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
						if (*n) > 1 {
							(*xx)[1+absint(*incx)*(*n)-1] = 0.0
						}

						uplos = *uplo
						transs = *trans
						diags = *diag
						ns = *n
						ldas = *lda
						incxs = *incx
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}

						nc++

						_aa := cExpand(aa, n, lda)
						Ctrmv(major, uplo, trans, diag, n, _aa, lda, xx, incx)
						cReturn(_aa, aa)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkByte(t, nc, trans, &transs, "trans")
						checkByte(t, nc, diag, &diags, "diag")
						checkInt(t, nc, n, &ns, "n")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
						if null {
							checkComplex64Array1D(t, nc, &lx, xx, xs, "guardband xx")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = 1; i < absint(*incx); i++ {
									if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
									}
								}
							}
							cmvchTest(trans, n, n, onec64, a, x, incx, zeroc64, z, incx, xt, g)
							err = 0
							for i = 1; i <= (*n); i++ {
								erri = abssumf32((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf32
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf32(err, erri)
								if err*sqrtf32(epsf32) >= 1.0 {
									t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf32(epsf32))
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkCtrmv(b *testing.B) {
	n := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	major := new(byte)
	*major = 'C'

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*aa = []complex64{(-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3327 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3726 + 0.1069i), (0.3866 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.0529 - 0.2927i), (-0.2228 + 0.0989i), (0.3067 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0969 + 0.2987i), (0.4266 - 0.3566i), (0.4565 - 0.1489i), (0.1868 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.4226 - 0.3487i), (0.1069 - 0.4925i), (0.3367 - 0.3007i), (0.2667 + 0.4426i), (0.2268 + 0.1069i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.0130 - 0.1568i), (0.4166 + 0.2507i), (-0.4525 - 0.2927i), (-0.0929 + 0.2428i), (0.1369 + 0.0509i), (0.0669 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0270 - 0.3566i), (-0.2128 - 0.0929i), (0.2168 + 0.4985i), (0.3467 + 0.0430i), (0.1768 - 0.3487i), (-0.2927 - 0.4925i), (-0.1329 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.1728 + 0.1069i), (-0.1429 - 0.1009i), (-0.4126 - 0.1568i), (0.1469 - 0.2927i), (-0.0230 + 0.0989i), (-0.4925 + 0.2428i), (-0.2627 + 0.0509i), (-0.3327 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i)}
	*lda = 10
	*xx = []complex64{(0.1573 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (0.8866 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.3172 + 0.4985i), (-10000000000.0000 + 10000000000.0000i), (0.4471 + 0.0430i), (-10000000000.0000 + 10000000000.0000i), (0.8067 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (0.0375 - 0.3007i), (-10000000000.0000 + 10000000000.0000i), (0.9665 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.5969 + 0.4505i), (-10000000000.0000 + 10000000000.0000i), (0.9266 + 0.1069i), (-10000000000.0000 + 10000000000.0000i)}
	*incx = 2
	_aa := cExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Ctrmv(major, uplo, trans, diag, n, _aa, lda, xx, incx)
	}
}

func BenchmarkCtrmvFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*aa = []complex64{(-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3327 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3726 + 0.1069i), (0.3866 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.0529 - 0.2927i), (-0.2228 + 0.0989i), (0.3067 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0969 + 0.2987i), (0.4266 - 0.3566i), (0.4565 - 0.1489i), (0.1868 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.4226 - 0.3487i), (0.1069 - 0.4925i), (0.3367 - 0.3007i), (0.2667 + 0.4426i), (0.2268 + 0.1069i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.0130 - 0.1568i), (0.4166 + 0.2507i), (-0.4525 - 0.2927i), (-0.0929 + 0.2428i), (0.1369 + 0.0509i), (0.0669 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0270 - 0.3566i), (-0.2128 - 0.0929i), (0.2168 + 0.4985i), (0.3467 + 0.0430i), (0.1768 - 0.3487i), (-0.2927 - 0.4925i), (-0.1329 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.1728 + 0.1069i), (-0.1429 - 0.1009i), (-0.4126 - 0.1568i), (0.1469 - 0.2927i), (-0.0230 + 0.0989i), (-0.4925 + 0.2428i), (-0.2627 + 0.0509i), (-0.3327 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i)}
	*lda = 10
	*xx = []complex64{(0.1573 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (0.8866 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.3172 + 0.4985i), (-10000000000.0000 + 10000000000.0000i), (0.4471 + 0.0430i), (-10000000000.0000 + 10000000000.0000i), (0.8067 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (0.0375 - 0.3007i), (-10000000000.0000 + 10000000000.0000i), (0.9665 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.5969 + 0.4505i), (-10000000000.0000 + 10000000000.0000i), (0.9266 + 0.1069i), (-10000000000.0000 + 10000000000.0000i)}
	*incx = 2

	for i := 0; i < b.N; i++ {
		ctrmvWrapper(uplo, trans, diag, n, aa, lda, xx, incx)
	}
}

func TestCtbmv(t *testing.T) {
	tname := "Ctbmv"
	var i, icd, ict, icu, ik, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float32
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(complex64)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xs := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xt := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		for ik = 1; ik <= len(kbL2); ik++ {
			*k = kbL2[ik-1]

			*lda = (*k) + 1
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = (*lda) * (*n)
			null = *n <= 0

			for icu = 1; icu <= len(ichuL2); icu++ {
				*uplo = ichuL2[icu-1]

				for ict = 1; ict <= len(ichtL2); ict++ {
					*trans = ichtL2[ict-1]

					for icd = 1; icd <= len(ichdL2); icd++ {
						*diag = ichdL2[icd-1]

						*transl = 0.0
						cmakeTBL2(uplo, diag, n, n, a, aa, lda, k, k, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

						for ix = 1; ix <= len(incL2); ix++ {
							*incx = incL2[ix-1]
							lx = absint(*incx) * (*n)

							*transl = 0.5
							*_n = (*n) - 1
							cmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
							if (*n) > 1 {
								(*xx)[1+absint(*incx)*(*n)-1] = 0.0
							}

							uplos = *uplo
							transs = *trans
							diags = *diag
							ns = *n
							ldas = *lda
							incxs = *incx
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lx; i++ {
								(*xs)[i-1] = (*xx)[i-1]
							}

							nc++

							_aa := cExpand(aa, n, lda)
							Ctbmv(major, uplo, trans, diag, n, k, _aa, lda, xx, incx)
							cReturn(_aa, aa)

							checkByte(t, nc, uplo, &uplos, "uplo")
							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, diag, &diags, "diag")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, incx, &incxs, "incx")
							checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
							if null {
								checkComplex64Array1D(t, nc, &lx, xx, xs, "guardband xx")
								break
							} else {
								for j = 0; j < *n; j++ {
									for i = 1; i < absint(*incx); i++ {
										if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
											t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
										}
									}
								}
								cmvchTest(trans, n, n, onec64, a, x, incx, zeroc64, x, incx, xt, g)
								err = 0
								for i = 1; i <= (*n); i++ {
									erri = abssumf32((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf32
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf32(err, erri)
									if err*sqrtf32(epsf32) >= 1.0 {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf32(epsf32))
									}
								}
							}
						}

						if null {
							break
						}
					}

					if null {
						break
					}
				}

				if null {
					break
				}
			}

			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkCtbmv(b *testing.B) {
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	_aa := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	// aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	major := new(byte)
	*major = 'C'

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*k = 4
	// *aa = []complex64{(-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3327 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3726 + 0.1069i), (0.3866 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.0529 - 0.2927i), (-0.2228 + 0.0989i), (0.3067 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0969 + 0.2987i), (0.4266 - 0.3566i), (0.4565 - 0.1489i), (0.1868 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.4226 - 0.3487i), (0.1069 - 0.4925i), (0.3367 - 0.3007i), (0.2667 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.2567 - 0.1009i), (-0.0130 - 0.1568i), (0.4166 + 0.2507i), (-0.4525 - 0.2927i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.1369 + 0.0509i), (0.0669 + 0.3067i), (-0.3027 + 0.2987i), (0.0270 - 0.3566i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.2168 + 0.4985i), (0.3467 + 0.0430i), (0.1768 - 0.3487i), (-0.2927 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i)}
	*lda = 6
	// *xx = []complex64{(0.9965 + 0.4505i), (-10000000000.0000 + 10000000000.0000i), (0.3272 + 0.1069i), (-10000000000.0000 + 10000000000.0000i), (0.3571 - 0.1009i), (-10000000000.0000 + 10000000000.0000i), (0.0874 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (0.6469 - 0.2927i), (-10000000000.0000 + 10000000000.0000i), (0.4770 + 0.0989i), (-10000000000.0000 + 10000000000.0000i), (0.0075 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (0.2373 + 0.0509i), (-10000000000.0000 + 10000000000.0000i), (0.1673 + 0.3067i), (-10000000000.0000 + 10000000000.0000i)}
	*incx = 2
	// _aa := cExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Ctbmv(major, uplo, trans, diag, n, k, _aa, lda, xx, incx)
	}
}

func BenchmarkCtbmvFortran(b *testing.B) {
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*k = 4
	*aa = []complex64{(-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3327 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.3726 + 0.1069i), (0.3866 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.0529 - 0.2927i), (-0.2228 + 0.0989i), (0.3067 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0969 + 0.2987i), (0.4266 - 0.3566i), (0.4565 - 0.1489i), (0.1868 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-0.4226 - 0.3487i), (0.1069 - 0.4925i), (0.3367 - 0.3007i), (0.2667 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.2567 - 0.1009i), (-0.0130 - 0.1568i), (0.4166 + 0.2507i), (-0.4525 - 0.2927i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.1369 + 0.0509i), (0.0669 + 0.3067i), (-0.3027 + 0.2987i), (0.0270 - 0.3566i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.2168 + 0.4985i), (0.3467 + 0.0430i), (0.1768 - 0.3487i), (-0.2927 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i)}
	*lda = 6
	*xx = []complex64{(0.9965 + 0.4505i), (-10000000000.0000 + 10000000000.0000i), (0.3272 + 0.1069i), (-10000000000.0000 + 10000000000.0000i), (0.3571 - 0.1009i), (-10000000000.0000 + 10000000000.0000i), (0.0874 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (0.6469 - 0.2927i), (-10000000000.0000 + 10000000000.0000i), (0.4770 + 0.0989i), (-10000000000.0000 + 10000000000.0000i), (0.0075 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (0.2373 + 0.0509i), (-10000000000.0000 + 10000000000.0000i), (0.1673 + 0.3067i), (-10000000000.0000 + 10000000000.0000i)}
	*incx = 2

	for i := 0; i < b.N; i++ {
		ctbmvWrapper(uplo, trans, diag, n, k, aa, lda, xx, incx)
	}
}

func TestCtpmv(t *testing.T) {
	tname := "Ctpmv"
	var i, icd, ict, icu, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float32
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(complex64)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xs := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xt := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*k = (*n) - 1
		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for icu = 1; icu <= len(ichuL2); icu++ {
			*uplo = ichuL2[icu-1]

			for ict = 1; ict <= len(ichtL2); ict++ {
				*trans = ichtL2[ict-1]

				for icd = 1; icd <= len(ichdL2); icd++ {
					*diag = ichdL2[icd-1]

					*transl = 0.0
					cmakeTPL2(uplo, diag, n, n, a, aa, k, k, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * (*n)

						*transl = 0.5
						*_n = (*n) - 1
						cmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
						if (*n) > 1 {
							(*xx)[1+absint(*incx)*(*n)-1] = 0.0
						}

						uplos = *uplo
						transs = *trans
						diags = *diag
						ns = *n
						ldas = *lda
						incxs = *incx
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}

						nc++

						Ctpmv(major, uplo, trans, diag, n, aa, xx, incx)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkByte(t, nc, trans, &transs, "trans")
						checkByte(t, nc, diag, &diags, "diag")
						checkInt(t, nc, n, &ns, "n")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
						if null {
							checkComplex64Array1D(t, nc, &lx, xx, xs, "guardband xx")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = 1; i < absint(*incx); i++ {
									if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
									}
								}
							}
							cmvchTest(trans, n, n, onec64, a, x, incx, zeroc64, x, incx, xt, g)
							err = 0
							for i = 1; i <= (*n); i++ {
								erri = abssumf32((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf32
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf32(err, erri)
								if err*sqrtf32(epsf32) >= 1.0 {
									t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf32(epsf32))
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkCtpmv(b *testing.B) {
	n := new(int)
	incx := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	major := new(byte)
	*major = 'C'

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	// *aa = []complex64{(-10000000000.0000 + 10000000000.0000i), (-0.3327 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (-0.3726 + 0.1069i), (0.3866 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (-0.0529 - 0.2927i), (-0.2228 + 0.0989i), (0.3067 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (0.0969 + 0.2987i), (0.4266 - 0.3566i), (0.4565 - 0.1489i), (0.1868 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (-0.4226 - 0.3487i), (0.1069 - 0.4925i), (0.3367 - 0.3007i), (0.2667 + 0.4426i), (0.2268 + 0.1069i), (-10000000000.0000 + 10000000000.0000i), (-0.0130 - 0.1568i), (0.4166 + 0.2507i), (-0.4525 - 0.2927i), (-0.0929 + 0.2428i), (0.1369 + 0.0509i), (0.0669 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (0.0270 - 0.3566i), (-0.2128 - 0.0929i), (0.2168 + 0.4985i), (0.3467 + 0.0430i), (0.1768 - 0.3487i), (-0.2927 - 0.4925i), (-0.1329 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (-0.1728 + 0.1069i), (-0.1429 - 0.1009i), (-0.4126 - 0.1568i), (0.1469 - 0.2927i), (-0.0230 + 0.0989i), (-0.4925 + 0.2428i), (-0.2627 + 0.0509i), (-0.3327 + 0.3067i), (-10000000000.0000 + 10000000000.0000i)}
	// *xx = []complex64{(0.1573 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (0.8866 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.3172 + 0.4985i), (-10000000000.0000 + 10000000000.0000i), (0.4471 + 0.0430i), (-10000000000.0000 + 10000000000.0000i), (0.8067 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (0.0375 - 0.3007i), (-10000000000.0000 + 10000000000.0000i), (0.9665 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.5969 + 0.4505i), (-10000000000.0000 + 10000000000.0000i), (0.9266 + 0.1069i), (-10000000000.0000 + 10000000000.0000i)}
	*incx = 2

	for i := 0; i < b.N; i++ {
		Ctpmv(major, uplo, trans, diag, n, aa, xx, incx)
	}
}

func BenchmarkCtpmvFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*aa = []complex64{(-10000000000.0000 + 10000000000.0000i), (-0.3327 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (-0.3726 + 0.1069i), (0.3866 - 0.1568i), (-10000000000.0000 + 10000000000.0000i), (-0.0529 - 0.2927i), (-0.2228 + 0.0989i), (0.3067 + 0.2428i), (-10000000000.0000 + 10000000000.0000i), (0.0969 + 0.2987i), (0.4266 - 0.3566i), (0.4565 - 0.1489i), (0.1868 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (-0.4226 - 0.3487i), (0.1069 - 0.4925i), (0.3367 - 0.3007i), (0.2667 + 0.4426i), (0.2268 + 0.1069i), (-10000000000.0000 + 10000000000.0000i), (-0.0130 - 0.1568i), (0.4166 + 0.2507i), (-0.4525 - 0.2927i), (-0.0929 + 0.2428i), (0.1369 + 0.0509i), (0.0669 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (0.0270 - 0.3566i), (-0.2128 - 0.0929i), (0.2168 + 0.4985i), (0.3467 + 0.0430i), (0.1768 - 0.3487i), (-0.2927 - 0.4925i), (-0.1329 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (-0.1728 + 0.1069i), (-0.1429 - 0.1009i), (-0.4126 - 0.1568i), (0.1469 - 0.2927i), (-0.0230 + 0.0989i), (-0.4925 + 0.2428i), (-0.2627 + 0.0509i), (-0.3327 + 0.3067i), (-10000000000.0000 + 10000000000.0000i)}
	*xx = []complex64{(0.1573 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (0.8866 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.3172 + 0.4985i), (-10000000000.0000 + 10000000000.0000i), (0.4471 + 0.0430i), (-10000000000.0000 + 10000000000.0000i), (0.8067 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (0.0375 - 0.3007i), (-10000000000.0000 + 10000000000.0000i), (0.9665 + 0.4426i), (-10000000000.0000 + 10000000000.0000i), (0.5969 + 0.4505i), (-10000000000.0000 + 10000000000.0000i), (0.9266 + 0.1069i), (-10000000000.0000 + 10000000000.0000i)}
	*incx = 2

	for i := 0; i < b.N; i++ {
		ctpmvWrapper(uplo, trans, diag, n, aa, xx, incx)
	}
}

func TestCtrsv(t *testing.T) {
	tname := "Ctrsv"
	var i, icd, ict, icu, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float32
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(complex64)
	n := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xs := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xt := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	z := func() *[]complex64 { y := make([]complex64, nmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for icu = 1; icu <= len(ichuL2); icu++ {
			*uplo = ichuL2[icu-1]

			for ict = 1; ict <= len(ichtL2); ict++ {
				*trans = ichtL2[ict-1]

				for icd = 1; icd <= len(ichdL2); icd++ {
					*diag = ichdL2[icd-1]

					*transl = 0.0
					cmakeTRL2(uplo, diag, n, n, a, aa, lda, _n, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * (*n)

						*transl = 0.5
						*_n = (*n) - 1
						cmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
						if (*n) > 1 {
							(*xx)[1+absint(*incx)*(*n)-1] = 0.0
						}

						uplos = *uplo
						transs = *trans
						diags = *diag
						ns = *n
						ldas = *lda
						incxs = *incx
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}

						nc++

						_aa := cExpand(aa, n, lda)
						Ctrsv(major, uplo, trans, diag, n, _aa, lda, xx, incx)
						cReturn(_aa, aa)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkByte(t, nc, trans, &transs, "trans")
						checkByte(t, nc, diag, &diags, "diag")
						checkInt(t, nc, n, &ns, "n")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
						if null {
							checkComplex64Array1D(t, nc, &lx, xx, xs, "guardband xx")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = 1; i < absint(*incx); i++ {
									if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
									}
								}
							}
							for i = 1; i <= *n; i++ {
								(*z)[i-1] = (*xx)[(i-1)*absint(*incx)]
								(*xx)[(i-1)*absint(*incx)] = (*x)[i-1]
							}
							cmvchTest(trans, n, n, onec64, a, z, incx, zeroc64, x, incx, xt, g)
							err = 0
							for i = 1; i <= (*n); i++ {
								erri = abssumf32((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf32
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf32(err, erri)
								if err*sqrtf32(epsf32) >= 1.0 {
									t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*z)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf32(epsf32))
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkCtrsv(b *testing.B) {
	n := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	// aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	aa := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	major := new(byte)
	*major = 'C'

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	// *aa = []complex64{(-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i)}
	*lda = 10
	// *xx = []complex64{(0.9665 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (0.5969 + 0.2987i), (-10000000000.0000 + 10000000000.0000i), (0.9266 - 0.3566i), (-10000000000.0000 + 10000000000.0000i), (0.9565 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (0.6868 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.2473 + 0.0430i), (-10000000000.0000 + 10000000000.0000i), (0.0774 - 0.3487i), (-10000000000.0000 + 10000000000.0000i), (0.6069 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (0.8367 - 0.3007i), (-10000000000.0000 + 10000000000.0000i)}
	*incx = 2
	// _aa := cExpand(aa, n, lda)

	for i := 0; i < b.N; i++ {
		Ctrsv(major, uplo, trans, diag, n, aa, lda, xx, incx)
	}
}

func BenchmarkCtrsvFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	// *aa = []complex64{(-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (0.0000 + 0.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i), (-10000000000.0000 + 10000000000.0000i)}
	*lda = 10
	// *xx = []complex64{(0.9665 + 0.3067i), (-10000000000.0000 + 10000000000.0000i), (0.5969 + 0.2987i), (-10000000000.0000 + 10000000000.0000i), (0.9266 - 0.3566i), (-10000000000.0000 + 10000000000.0000i), (0.9565 - 0.1489i), (-10000000000.0000 + 10000000000.0000i), (0.6868 - 0.0929i), (-10000000000.0000 + 10000000000.0000i), (0.2473 + 0.0430i), (-10000000000.0000 + 10000000000.0000i), (0.0774 - 0.3487i), (-10000000000.0000 + 10000000000.0000i), (0.6069 - 0.4925i), (-10000000000.0000 + 10000000000.0000i), (0.8367 - 0.3007i), (-10000000000.0000 + 10000000000.0000i)}
	*incx = 2

	for i := 0; i < b.N; i++ {
		ctrsvWrapper(uplo, trans, diag, n, aa, lda, xx, incx)
	}
}

func TestCtbsv(t *testing.T) {
	tname := "Ctbsv"
	var i, icd, ict, icu, ik, in, incxs, ix, j, laa, ldas, lx, nc, ns int
	var err, erri float32
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(complex64)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xs := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xt := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	z := func() *[]complex64 { y := make([]complex64, nmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		for ik = 1; ik <= len(kbL2); ik++ {
			*k = kbL2[ik-1]

			*lda = (*k) + 1
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = (*lda) * (*n)
			null = *n <= 0

			for icu = 1; icu <= len(ichuL2); icu++ {
				*uplo = ichuL2[icu-1]

				for ict = 1; ict <= len(ichtL2); ict++ {
					*trans = ichtL2[ict-1]

					for icd = 1; icd <= len(ichdL2); icd++ {
						*diag = ichdL2[icd-1]

						*transl = 0.0
						cmakeTBL2(uplo, diag, n, n, a, aa, lda, k, k, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

						for ix = 1; ix <= len(incL2); ix++ {
							*incx = incL2[ix-1]
							lx = absint(*incx) * (*n)

							*transl = 0.5
							*_n = (*n) - 1
							cmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
							if (*n) > 1 {
								(*xx)[1+absint(*incx)*(*n)-1] = 0.0
							}

							uplos = *uplo
							transs = *trans
							diags = *diag
							ns = *n
							ldas = *lda
							incxs = *incx
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lx; i++ {
								(*xs)[i-1] = (*xx)[i-1]
							}

							nc++

							_aa := cExpand(aa, n, lda)
							Ctbsv(major, uplo, trans, diag, n, k, _aa, lda, xx, incx)
							cReturn(_aa, aa)

							checkByte(t, nc, uplo, &uplos, "uplo")
							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, diag, &diags, "diag")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, incx, &incxs, "incx")
							checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
							if null {
								checkComplex64Array1D(t, nc, &lx, xx, xs, "guardband xx")
								break
							} else {
								for j = 0; j < *n; j++ {
									for i = 1; i < absint(*incx); i++ {
										if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
											t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
										}
									}
								}
								for i = 1; i <= *n; i++ {
									(*z)[i-1] = (*xx)[(i-1)*absint(*incx)]
									(*xx)[(i-1)*absint(*incx)] = (*x)[i-1]
								}
								cmvchTest(trans, n, n, onec64, a, z, incx, zeroc64, x, incx, xt, g)
								err = 0
								for i = 1; i <= (*n); i++ {
									erri = abssumf32((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf32
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf32(err, erri)
									if err*sqrtf32(epsf32) >= 1.0 {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf32(epsf32))
									}
								}
							}
							if null {
								break
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkCtbsv(b *testing.B) {
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	major := new(byte)
	*major = 'C'

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*k = 4
	*lda = 6
	*incx = 2

	for i := 0; i < b.N; i++ {
		Ctbsv(major, uplo, trans, diag, n, k, aa, lda, xx, incx)
	}
}

func BenchmarkCtbsvFortran(b *testing.B) {
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*k = 4
	*lda = 6
	*incx = 2

	for i := 0; i < b.N; i++ {
		ctbsvWrapper(uplo, trans, diag, n, k, aa, lda, xx, incx)
	}
}

func TestCtpsv(t *testing.T) {
	tname := "Ctpsv"
	var i, icd, ict, icu, in, incxs, ix, j, laa, lx, nc, ns int
	var err, erri float32
	var diags, transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	transl := new(complex64)
	n := new(int)
	k := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xs := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xt := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	z := func() *[]complex64 { y := make([]complex64, nmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*k = (*n) - 1
		*lda = *n

		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)
		null = *n <= 0

		for icu = 1; icu <= len(ichuL2); icu++ {
			*uplo = ichuL2[icu-1]

			for ict = 1; ict <= len(ichtL2); ict++ {
				*trans = ichtL2[ict-1]

				for icd = 1; icd <= len(ichdL2); icd++ {
					*diag = ichdL2[icd-1]

					*transl = 0.0
					cmakeTPL2(uplo, diag, n, n, a, aa, k, k, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					for ix = 1; ix <= len(incL2); ix++ {
						*incx = incL2[ix-1]
						lx = absint(*incx) * (*n)

						*transl = 0.5
						*_n = (*n) - 1
						cmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
						if (*n) > 1 {
							(*xx)[1+absint(*incx)*(*n)-1] = 0.0
						}

						uplos = *uplo
						transs = *trans
						diags = *diag
						ns = *n
						incxs = *incx
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}

						nc++

						Ctpsv(major, uplo, trans, diag, n, aa, xx, incx)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkByte(t, nc, trans, &transs, "trans")
						checkByte(t, nc, diag, &diags, "diag")
						checkInt(t, nc, n, &ns, "n")
						checkInt(t, nc, incx, &incxs, "incx")
						checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
						if null {
							checkComplex64Array1D(t, nc, &lx, xx, xs, "guardband xx")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = 1; i < absint(*incx); i++ {
									if (*xx)[i+j*absint(*incx)] != (*xs)[i+j*absint(*incx)] {
										t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*absint(*incx), nc, (*xx)[i+j*absint(*incx)], (*xs)[i+j*absint(*incx)])
									}
								}
							}
							for i = 1; i <= *n; i++ {
								(*z)[i-1] = (*xx)[(i-1)*absint(*incx)]
								(*xx)[(i-1)*absint(*incx)] = (*x)[i-1]
							}
							cmvchTest(trans, n, n, onec64, a, z, incx, zeroc64, x, incx, xt, g)
							err = 0
							for i = 1; i <= *n; i++ {
								erri = abssumf32((*xt)[i-1]-(*xx)[(i-1)*absint(*incx)]) / epsf32
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf32(err, erri)
								if err*sqrtf32(epsf32) >= 1.0 {
									t.Errorf("Test Failed: xx[%d]: iteration %d: {%10.8f} output, {%10.8f} expected, {%10.5e} error", (i-1)*absint(*incx), nc, (*xx)[(i-1)*absint(*incx)], (*xt)[i-1], err*sqrtf32(epsf32))
								}
							}
						}
						if null {
							break
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
			if null {
				break
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkCtpsv(b *testing.B) {
	n := new(int)
	incx := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	major := new(byte)
	*major = 'C'

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*incx = 2

	for i := 0; i < b.N; i++ {
		Ctpsv(major, uplo, trans, diag, n, aa, xx, incx)
	}
}

func BenchmarkCtpsvFortran(b *testing.B) {
	n := new(int)
	incx := new(int)
	diag := new(byte)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*uplo = 'U'
	*trans = 'C'
	*diag = 'U'
	*n = 9
	*incx = 2

	for i := 0; i < b.N; i++ {
		ctpsvWrapper(uplo, trans, diag, n, aa, xx, incx)
	}
}

func TestCgerc(t *testing.T) {
	tname := "Cgerc"
	var i, ia, im, in, incxs, incys, ix, iy, j, laa, ldas, lx, ly, ms, ns, nd, nc int
	var als complex64
	var err, erri float32
	var transs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex64)
	transl := new(complex64)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_m := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	at := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	ax := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xs := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	y := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	ys := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yt := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	w := func() *[]complex64 { y := make([]complex64, 1); return &y }()
	z := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		nd = (*n)/2 + 1

		for im = 1; im <= 2; im++ {
			if im == 1 {
				*m = max((*n)-nd, 0)
			} else if im == 2 {
				*m = min((*n)+nd, nmax)
			}

			*lda = *m
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = (*lda) * (*n)

			null = *n <= 0 || *m <= 0

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*m)

				*transl = 0.5
				*_m = (*m) - 1
				cmakeGEL2(onei, m, x, xx, incx, zeroi, _m, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				if *m > 1 {
					(*x)[*m] = 0.0
					(*xx)[1+absint(*incx)*(*m)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					*transl = 0.0
					*_n = (*n) - 1
					cmakeGEL2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					if *n > 1 {
						(*y)[*n] = 0.0
						(*yy)[1+absint(*incy)*(*n)-1] = 0.0
					}

					for ia = 1; ia <= len(alfc64L2); ia++ {
						*alpha = alfc64L2[ia-1]

						*transl = 0.0
						cmakeGE2L2(m, n, a, aa, lda, _m, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

						transs = *trans
						ms = *m
						ns = *n
						ldas = *lda
						incxs = *incx
						incys = *incy
						als = *alpha
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}
						for i = 1; i <= ly; i++ {
							(*ys)[i-1] = (*yy)[i-1]
						}

						nc++

						_aa := cExpand(aa, n, lda)
						Cgerc(major, m, n, alpha, xx, incx, yy, incy, _aa, lda)
						cReturn(_aa, aa)

						checkByte(t, nc, trans, &transs, "trans")
						checkInt(t, nc, m, &ms, "m")
						checkInt(t, nc, n, &ns, "n")
						checkComplex64(t, nc, alpha, &als, "alpha")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkInt(t, nc, incy, &incys, "incy")
						checkComplex64Array1D(t, nc, &lx, xx, xs, "xx")
						checkComplex64Array1D(t, nc, &ly, yy, ys, "yy")
						if null {
							checkComplex64Array1D(t, nc, &laa, aa, as, "guardband aa")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = (*m) + 1; i < *lda; i++ {
									if (*aa)[i+j*(*lda)] != (*as)[i+j*(*lda)] {
										t.Errorf("Test Failed: aa[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*lda), nc, (*aa)[i+j*(*lda)], (*as)[i+j*(*lda)])
									}
								}
							}

							if *incx > 0 {
								for i = 1; i <= *m; i++ {
									(*z)[i-1][0] = (*x)[i-1]
								}
							} else {
								for i = 1; i <= *m; i++ {
									(*z)[i-1][0] = (*x)[(*m)-i]
								}
							}
							for j = 1; j <= *n; j++ {
								if *incy > 0 {
									(*w)[0] = (*y)[j-1]
								} else {
									(*w)[0] = (*y)[(*n)-j]
								}
								(*w)[0] = complex64(cmplx.Conj(complex128((*w)[0])))
								for i = range *ax {
									(*ax)[i] = (*a)[i][j-1]
								}

								cmvchTest(_N, m, onei, alpha, z, w, onei, onec64, ax, onei, yt, g)
								_aa := (*aa)[(j-1)*(*lda):]
								err = 0
								for i = 1; i <= *m; i++ {
									erri = abssumf32((*yt)[i-1]-_aa[i-1]) / epsf32
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf32(err, erri)
									if err*sqrtf32(epsf32) >= 1.0 {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.8e} error", i-1, nc, j, (*aa)[i-1], (*at)[i-1], err*sqrtf32(epsf32))
									}
								}
							}
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
		}

	}

	printTestsRun(tname, nc)
}

func BenchmarkCgerc(b *testing.B) {
	alpha := new(complex64)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	aa := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	major := new(byte)
	*major = 'C'

	*m = 14
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*incy = 2
	*lda = 15

	for i := 0; i < b.N; i++ {
		Cgerc(major, m, n, alpha, xx, incx, yy, incy, aa, lda)
	}
}

func BenchmarkCgercFortran(b *testing.B) {
	alpha := new(complex64)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*m = 14
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*incy = 2
	*lda = 15

	for i := 0; i < b.N; i++ {
		cgercWrapper(m, n, alpha, xx, incx, yy, incy, aa, lda)
	}
}

func TestCgeru(t *testing.T) {
	tname := "Cgeru"
	var i, ia, im, in, incxs, incys, ix, iy, j, laa, ldas, lx, ly, ms, ns, nd, nc int
	var als complex64
	var err, erri float32
	var transs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex64)
	transl := new(complex64)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_m := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	at := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	ax := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xs := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	y := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	ys := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yt := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	w := func() *[]complex64 { y := make([]complex64, 1); return &y }()
	z := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		nd = (*n)/2 + 1

		for im = 1; im <= 2; im++ {
			if im == 1 {
				*m = max((*n)-nd, 0)
			} else if im == 2 {
				*m = min((*n)+nd, nmax)
			}

			*lda = *m
			if *lda < nmax {
				*lda++
			} else if *lda > nmax {
				continue
			}
			laa = (*lda) * (*n)

			null = *n <= 0 || *m <= 0

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*m)

				*transl = 0.5
				*_m = (*m) - 1
				cmakeGEL2(onei, m, x, xx, incx, zeroi, _m, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				if *m > 1 {
					(*x)[*m] = 0.0
					(*xx)[1+absint(*incx)*(*m)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					*transl = 0.0
					*_n = (*n) - 1
					cmakeGEL2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					if *n > 1 {
						(*y)[*n] = 0.0
						(*yy)[1+absint(*incy)*(*n)-1] = 0.0
					}

					for ia = 1; ia <= len(alfc64L2); ia++ {
						*alpha = alfc64L2[ia-1]

						*transl = 0.0
						cmakeGE2L2(m, n, a, aa, lda, _m, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

						transs = *trans
						ms = *m
						ns = *n
						ldas = *lda
						incxs = *incx
						incys = *incy
						als = *alpha
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}
						for i = 1; i <= ly; i++ {
							(*ys)[i-1] = (*yy)[i-1]
						}

						nc++

						_aa := cExpand(aa, n, lda)
						Cgeru(major, m, n, alpha, xx, incx, yy, incy, _aa, lda)
						cReturn(_aa, aa)

						checkByte(t, nc, trans, &transs, "trans")
						checkInt(t, nc, m, &ms, "m")
						checkInt(t, nc, n, &ns, "n")
						checkComplex64(t, nc, alpha, &als, "alpha")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkInt(t, nc, incy, &incys, "incy")
						checkComplex64Array1D(t, nc, &lx, xx, xs, "xx")
						checkComplex64Array1D(t, nc, &ly, yy, ys, "yy")
						if null {
							checkComplex64Array1D(t, nc, &laa, aa, as, "guardband aa")
							break
						} else {
							for j = 0; j < *n; j++ {
								for i = (*m) + 1; i < *lda; i++ {
									if (*aa)[i+j*(*lda)] != (*as)[i+j*(*lda)] {
										t.Errorf("Test Failed: aa[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*lda), nc, (*aa)[i+j*(*lda)], (*as)[i+j*(*lda)])
									}
								}
							}

							if *incx > 0 {
								for i = 1; i <= *m; i++ {
									(*z)[i-1][0] = (*x)[i-1]
								}
							} else {
								for i = 1; i <= *m; i++ {
									(*z)[i-1][0] = (*x)[(*m)-i]
								}
							}
							for j = 1; j <= *n; j++ {
								if *incy > 0 {
									(*w)[0] = (*y)[j-1]
								} else {
									(*w)[0] = (*y)[(*n)-j]
								}
								for i = range *ax {
									(*ax)[i] = (*a)[i][j-1]
								}

								cmvchTest(_N, m, onei, alpha, z, w, onei, onec64, ax, onei, yt, g)
								_aa := (*aa)[(j-1)*(*lda):]
								err = 0
								for i = 1; i <= *m; i++ {
									erri = abssumf32((*yt)[i-1]-_aa[i-1]) / epsf32
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf32(err, erri)
									if err*sqrtf32(epsf32) >= 1.0 {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.8e} error", i-1, nc, j, (*aa)[i-1], (*at)[i-1], err*sqrtf32(epsf32))
									}
								}
							}
						}
					}
					if null {
						break
					}
				}
				if null {
					break
				}
			}
		}

	}

	printTestsRun(tname, nc)
}

func BenchmarkCgeru(b *testing.B) {
	alpha := new(complex64)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	aa := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	major := new(byte)
	*major = 'C'

	*m = 14
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*incy = 2
	*lda = 15

	for i := 0; i < b.N; i++ {
		Cgerc(major, m, n, alpha, xx, incx, yy, incy, aa, lda)
	}
}

func BenchmarkCgeruFortran(b *testing.B) {
	alpha := new(complex64)
	m := new(int)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*m = 14
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*incy = 2
	*lda = 15

	for i := 0; i < b.N; i++ {
		cgercWrapper(m, n, alpha, xx, incx, yy, incy, aa, lda)
	}
}

func TestCher(t *testing.T) {
	tname := "Cher"
	var i, ia, ic, in, incxs, ix, j, ja, jj, laa, ldas, lj, lx, ns, nc int
	var rals, err, erri float32
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	ralpha := new(float32)
	alpha := new(complex64)
	transl := new(complex64)
	n := new(int)
	incx := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	at := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xs := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yt := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	w := func() *[]complex64 { y := make([]complex64, 1); return &y }()
	z := func() *[]complex64 { y := make([]complex64, nmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = *n
		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				*_n = (*n) - 1
				cmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				if *n > 1 {
					(*x)[*n] = 0.0
					(*xx)[1+absint(*incx)*(*n)-1] = 0.0
				}

				for ia = 1; ia <= len(alfc64L2); ia++ {
					*ralpha = real(alfc64L2[ia-1])
					*alpha = complex(*ralpha, 0.0)
					null = *n <= 0 || *ralpha == 0.0

					*transl = 0.0
					cmakeHEL2(uplo, _X, n, n, a, aa, lda, _n, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					uplos = *uplo
					ns = *n
					ldas = *lda
					incxs = *incx
					rals = *ralpha
					for i = 1; i <= laa; i++ {
						(*as)[i-1] = (*aa)[i-1]
					}
					for i = 1; i <= lx; i++ {
						(*xs)[i-1] = (*xx)[i-1]
					}

					nc++

					_aa := cExpand(aa, n, lda)
					Cher(major, uplo, n, ralpha, xx, incx, _aa, lda)
					cReturn(_aa, aa)

					checkByte(t, nc, uplo, &uplos, "uplo")
					checkInt(t, nc, n, &ns, "n")
					checkFloat32(t, nc, ralpha, &rals, "ralpha")
					checkInt(t, nc, lda, &ldas, "lda")
					checkInt(t, nc, incx, &incxs, "incx")
					checkComplex64Array1D(t, nc, &lx, xx, xs, "xx")
					if null {
						checkComplex64Array1D(t, nc, &laa, aa, as, "guardband aa")
						if *n <= 0 {
							break
						}
					} else {
						for j = 0; j < *n; j++ {
							for i = (*n) + 1; i < *lda; i++ {
								if (*aa)[i+j*(*lda)] != (*as)[i+j*(*lda)] {
									t.Errorf("Test Failed: aa[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*lda), nc, (*aa)[i+j*(*lda)], (*as)[i+j*(*lda)])
								}
							}
						}

						if *incx > 0 {
							for i = 1; i <= *n; i++ {
								(*z)[i-1] = (*x)[i-1]
							}
						} else {
							for i = 1; i <= *n; i++ {
								(*z)[i-1] = (*x)[(*n)-i]
							}
						}
						ja = 1
						for j = 1; j <= *n; j++ {
							(*w)[0] = complex64(cmplx.Conj(complex128((*z)[j-1])))
							if *uplo == 'U' {
								jj = 1
								lj = j
							} else {
								jj = j
								lj = (*n) - j + 1
							}
							_z := func() *[][]complex64 {
								arr := make([][]complex64, *n)
								for i := range arr {
									arr[i] = make([]complex64, 1)
									arr[i][0] = (*z)[i+jj-1]
								}
								return &arr
							}()
							_a := func() *[]complex64 { y := make([]complex64, lj); return &y }()
							for i = range *_a {
								(*_a)[i] = (*a)[jj-1+i][j-1]
							}

							cmvchTest(_N, &lj, onei, alpha, _z, w, onei, onec64, _a, onei, yt, g)
							_aa := (*aa)[ja-1:]
							err = 0
							for i = 1; i <= lj; i++ {
								erri = abssumf32((*yt)[i-1]-_aa[i-1]) / epsf32
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf32(err, erri)
								if err*sqrtf32(epsf32) >= 1.0 {
									t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.8e} error", i-1, nc, j, (*aa)[i-1], (*at)[i-1], err*sqrtf32(epsf32))
								}
							}

							if *uplo == 'U' {
								ja += *lda
							} else {
								ja += (*lda) + 1
							}
						}
					}
				}

				if *n <= 0 {
					break
				}
			}

			if *n <= 0 {
				break
			}
		}

	}

	printTestsRun(tname, nc)
}

func BenchmarkCher(b *testing.B) {
	uplo := new(byte)
	ralpha := new(float32)
	n := new(int)
	incx := new(int)
	lda := new(int)
	aa := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	major := new(byte)
	*major = 'C'

	*uplo = 'U'
	*n = 9
	*ralpha = 0.70
	*incx = 2
	*lda = 10

	for i := 0; i < b.N; i++ {
		Cher(major, uplo, n, ralpha, xx, incx, aa, lda)
	}
}

func BenchmarkCherFortran(b *testing.B) {
	uplo := new(byte)
	ralpha := new(float32)
	n := new(int)
	incx := new(int)
	lda := new(int)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*ralpha = 0.70
	*incx = 2
	*lda = 10

	for i := 0; i < b.N; i++ {
		cherWrapper(uplo, n, ralpha, xx, incx, aa, lda)
	}
}

func TestChpr(t *testing.T) {
	tname := "Chpr"
	var i, ia, ic, in, incxs, ix, j, ja, jj, laa, lj, lx, ns, nc int
	var rals, err, erri float32
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	ralpha := new(float32)
	alpha := new(complex64)
	transl := new(complex64)
	n := new(int)
	lda := new(int)
	incx := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	at := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xs := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yt := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	w := func() *[]complex64 { y := make([]complex64, 1); return &y }()
	z := func() *[]complex64 { y := make([]complex64, nmax); return &y }()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = *n
		if *lda < nmax {
			*lda++
		}
		if *lda > nmax {
			continue
		}
		laa = ((*n) * ((*n) + 1)) / 2

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				*_n = (*n) - 1
				cmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				if *n > 1 {
					(*x)[*n] = 0.0
					(*xx)[1+absint(*incx)*(*n)-1] = 0.0
				}

				for ia = 1; ia <= len(alfc64L2); ia++ {
					*ralpha = real(alfc64L2[ia-1])
					*alpha = complex(*ralpha, 0.0)
					null = *n <= 0 || *ralpha == 0.0

					*transl = 0.0
					cmakeHPL2(uplo, n, n, a, aa, _n, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					uplos = *uplo
					ns = *n
					incxs = *incx
					rals = *ralpha
					for i = 1; i <= laa; i++ {
						(*as)[i-1] = (*aa)[i-1]
					}
					for i = 1; i <= lx; i++ {
						(*xs)[i-1] = (*xx)[i-1]
					}

					nc++

					Chpr(major, uplo, n, ralpha, xx, incx, aa)

					checkByte(t, nc, uplo, &uplos, "uplo")
					checkInt(t, nc, n, &ns, "n")
					checkFloat32(t, nc, ralpha, &rals, "ralpha")
					checkInt(t, nc, incx, &incxs, "incx")
					checkComplex64Array1D(t, nc, &lx, xx, xs, "xx")
					if null {
						checkComplex64Array1D(t, nc, &laa, aa, as, "guardband aa")
						if *n <= 0 {
							break
						}
					} else {
						for j = 0; j < *n; j++ {
							for i = (*n) + 1; i < *lda; i++ {
								if (*aa)[i+j*(*lda)] != (*as)[i+j*(*lda)] {
									t.Errorf("Test Failed: aa[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*lda), nc, (*aa)[i+j*(*lda)], (*as)[i+j*(*lda)])
								}
							}
						}

						if *incx > 0 {
							for i = 1; i <= *n; i++ {
								(*z)[i-1] = (*x)[i-1]
							}
						} else {
							for i = 1; i <= *n; i++ {
								(*z)[i-1] = (*x)[(*n)-i]
							}
						}
						ja = 1
						for j = 1; j <= *n; j++ {
							(*w)[0] = complex64(cmplx.Conj(complex128((*z)[j-1])))
							if *uplo == 'U' {
								jj = 1
								lj = j
							} else {
								jj = j
								lj = (*n) - j + 1
							}
							_z := func() *[][]complex64 {
								arr := make([][]complex64, *n)
								for i := range arr {
									arr[i] = make([]complex64, 1)
									arr[i][0] = (*z)[i+jj-1]
								}
								return &arr
							}()
							_a := func() *[]complex64 { y := make([]complex64, lj); return &y }()
							for i = range *_a {
								(*_a)[i] = (*a)[jj-1+i][j-1]
							}

							cmvchTest(_N, &lj, onei, alpha, _z, w, onei, onec64, _a, onei, yt, g)
							_aa := (*aa)[ja-1:]
							err = 0
							for i = 1; i <= lj; i++ {
								erri = abssumf32((*yt)[i-1]-_aa[i-1]) / epsf32
								if (*g)[i-1] != 0.0 {
									erri /= (*g)[i-1]
								}
								err = maxf32(err, erri)
								if err*sqrtf32(epsf32) >= 1.0 {
									t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.8e} error", i-1, nc, j, (*aa)[i-1], (*at)[i-1], err*sqrtf32(epsf32))
								}
							}

							ja += lj
						}
					}
				}

				if *n <= 0 {
					break
				}
			}

			if *n <= 0 {
				break
			}
		}

	}

	printTestsRun(tname, nc)
}

func BenchmarkChpr(b *testing.B) {
	uplo := new(byte)
	ralpha := new(float32)
	n := new(int)
	incx := new(int)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	major := new(byte)
	*major = 'C'

	*uplo = 'U'
	*n = 9
	*ralpha = 0.70
	*incx = 2

	for i := 0; i < b.N; i++ {
		chprWrapper(uplo, n, ralpha, xx, incx, aa)
	}
}

func BenchmarkChprFortran(b *testing.B) {
	uplo := new(byte)
	ralpha := new(float32)
	n := new(int)
	incx := new(int)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*ralpha = 0.70
	*incx = 2

	for i := 0; i < b.N; i++ {
		chprWrapper(uplo, n, ralpha, xx, incx, aa)
	}
}

func TestCher2(t *testing.T) {
	tname := "Cher2"
	var i, ia, ic, in, incxs, incys, ix, iy, j, ja, jj, laa, ldas, lj, lx, ly, ns, nc int
	var als complex64
	var err, erri float32
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex64)
	transl := new(complex64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	at := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xs := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	y := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	ys := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yt := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	w := func() *[]complex64 { y := make([]complex64, 2); return &y }()
	z := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, 2)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = *n
		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = (*lda) * (*n)

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				*_n = (*n) - 1
				cmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				if *n > 1 {
					(*x)[*n] = 0.0
					(*xx)[1+absint(*incx)*(*n)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					*transl = 0.0
					cmakeGEL2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					if *n > 1 {
						(*y)[*n] = 0.0
						(*yy)[1+absint(*incy)*(*n)-1] = 0.0
					}

					for ia = 1; ia <= len(alfc64L2); ia++ {
						*alpha = alfc64L2[ia-1]
						null = *n <= 0 || *alpha == 0.0

						*transl = 0.0
						cmakeHEL2(uplo, _X, n, n, a, aa, lda, _n, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

						uplos = *uplo
						ns = *n
						ldas = *lda
						incxs = *incx
						incys = *incy
						als = *alpha
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}
						for i = 1; i <= ly; i++ {
							(*ys)[i-1] = (*yy)[i-1]
						}

						nc++

						_aa := cExpand(aa, n, lda)
						Cher2(major, uplo, n, alpha, xx, incx, yy, incy, _aa, lda)
						cReturn(_aa, aa)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkInt(t, nc, n, &ns, "n")
						checkComplex64(t, nc, alpha, &als, "alpha")
						checkInt(t, nc, lda, &ldas, "lda")
						checkInt(t, nc, incx, &incxs, "incx")
						checkInt(t, nc, incy, &incys, "incy")
						checkComplex64Array1D(t, nc, &lx, xx, xs, "xx")
						checkComplex64Array1D(t, nc, &ly, yy, ys, "yy")
						if null {
							checkComplex64Array1D(t, nc, &laa, aa, as, "guardband aa")
							if *n <= 0 {
								break
							}
						} else {
							for j = 0; j < *n; j++ {
								for i = (*n) + 1; i < *lda; i++ {
									if (*aa)[i+j*(*lda)] != (*as)[i+j*(*lda)] {
										t.Errorf("Test Failed: aa[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*lda), nc, (*aa)[i+j*(*lda)], (*as)[i+j*(*lda)])
									}
								}
							}

							if *incx > 0 {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][0] = (*x)[i-1]
								}
							} else {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][0] = (*x)[(*n)-i]
								}
							}
							if *incy > 0 {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][1] = (*y)[i-1]
								}
							} else {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][1] = (*y)[(*n)-i]
								}
							}
							ja = 1
							for j = 1; j <= *n; j++ {
								(*w)[0] = (*alpha) * complex64(cmplx.Conj(complex128((*z)[j-1][1])))
								(*w)[1] = complex64(cmplx.Conj(complex128(*alpha))) * complex64(cmplx.Conj(complex128((*z)[j-1][0])))
								if *uplo == 'U' {
									jj = 1
									lj = j
								} else {
									jj = j
									lj = (*n) - j + 1
								}
								_z := func() *[][]complex64 {
									arr := make([][]complex64, lj)
									for i := range arr {
										arr[i] = make([]complex64, 2)
										arr[i][0] = (*z)[i+jj-1][0]
										arr[i][1] = (*z)[i+jj-1][1]
									}
									return &arr
								}()
								_a := func() *[]complex64 { y := make([]complex64, lj); return &y }()
								for i = range *_a {
									(*_a)[i] = (*a)[jj-1+i][j-1]
								}

								cmvchTest(_N, &lj, twoi, onec64, _z, w, onei, onec64, _a, onei, yt, g)
								_aa := (*aa)[ja-1:]
								err = 0
								for i = 1; i <= lj; i++ {
									erri = abssumf32((*yt)[i-1]-_aa[i-1]) / epsf32
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf32(err, erri)
									if err*sqrtf32(epsf32) >= 1.0 {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.8e} error", i-1, nc, j, (*aa)[i-1], (*at)[i-1], err*sqrtf32(epsf32))
									}
								}

								if *uplo == 'U' {
									ja += *lda
								} else {
									ja += (*lda) + 1
								}
							}
						}
					}

					if *n <= 0 {
						break
					}
				}

				if *n <= 0 {
					break
				}
			}

			if *n <= 0 {
				break
			}
		}

	}

	printTestsRun(tname, nc)
}

func BenchmarkCher2(b *testing.B) {
	uplo := new(byte)
	alpha := new(complex64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	aa := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	major := new(byte)
	*major = 'C'

	*uplo = 'U'
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*incy = 2
	*lda = 10

	for i := 0; i < b.N; i++ {
		Cher2(major, uplo, n, alpha, xx, incx, yy, incy, aa, lda)
	}
}

func BenchmarkCher2Fortran(b *testing.B) {
	uplo := new(byte)
	alpha := new(complex64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*incy = 2
	*lda = 10

	for i := 0; i < b.N; i++ {
		cher2Wrapper(uplo, n, alpha, xx, incx, yy, incy, aa, lda)
	}
}

func TestChpr2(t *testing.T) {
	tname := "Chpr2"
	var i, ia, ic, in, incxs, incys, ix, iy, j, ja, jj, laa, lj, lx, ly, ns, nc int
	var als complex64
	var err, erri float32
	var uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex64)
	transl := new(complex64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	lda := new(int)
	_n := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	at := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*incmax); return &y }()
	x := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	xs := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	y := func() *[]complex64 { y := make([]complex64, nmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	ys := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yt := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	w := func() *[]complex64 { y := make([]complex64, 2); return &y }()
	z := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, 2)
		}
		return &arr
	}()

	for in = 1; in <= len(idimL2); in++ {
		*n = idimL2[in-1]

		*lda = *n
		if *lda < nmax {
			*lda++
		} else if *lda > nmax {
			continue
		}
		laa = ((*n) * ((*n) + 1)) / 2

		for ic = 1; ic <= len(ichuL2); ic++ {
			*uplo = ichuL2[ic-1]

			for ix = 1; ix <= len(incL2); ix++ {
				*incx = incL2[ix-1]
				lx = absint(*incx) * (*n)

				*transl = 0.5
				*_n = (*n) - 1
				cmakeGEL2(onei, n, x, xx, incx, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				if *n > 1 {
					(*x)[*n] = 0.0
					(*xx)[1+absint(*incx)*(*n)-1] = 0.0
				}

				for iy = 1; iy <= len(incL2); iy++ {
					*incy = incL2[iy-1]
					ly = absint(*incy) * (*n)

					*transl = 0.0
					cmakeGEL2(onei, n, y, yy, incy, zeroi, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					if *n > 1 {
						(*y)[*n] = 0.0
						(*yy)[1+absint(*incy)*(*n)-1] = 0.0
					}

					for ia = 1; ia <= len(alfc64L2); ia++ {
						*alpha = alfc64L2[ia-1]
						null = *n <= 0 || *alpha == 0.0

						*transl = 0.0
						cmakeHPL2(uplo, n, n, a, aa, lda, _n, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

						uplos = *uplo
						ns = *n
						incxs = *incx
						incys = *incy
						als = *alpha
						for i = 1; i <= laa; i++ {
							(*as)[i-1] = (*aa)[i-1]
						}
						for i = 1; i <= lx; i++ {
							(*xs)[i-1] = (*xx)[i-1]
						}
						for i = 1; i <= ly; i++ {
							(*ys)[i-1] = (*yy)[i-1]
						}

						nc++

						Chpr2(major, uplo, n, alpha, xx, incx, yy, incy, aa)

						checkByte(t, nc, uplo, &uplos, "uplo")
						checkInt(t, nc, n, &ns, "n")
						checkComplex64(t, nc, alpha, &als, "alpha")
						checkInt(t, nc, incx, &incxs, "incx")
						checkInt(t, nc, incy, &incys, "incy")
						checkComplex64Array1D(t, nc, &lx, xx, xs, "xx")
						checkComplex64Array1D(t, nc, &ly, yy, ys, "yy")
						if null {
							checkComplex64Array1D(t, nc, &laa, aa, as, "guardband aa")
							if *n <= 0 {
								break
							}
						} else {
							for j = 0; j < *n; j++ {
								for i = (*n) + 1; i < *lda; i++ {
									if (*aa)[i+j*(*lda)] != (*as)[i+j*(*lda)] {
										t.Errorf("Test Failed: aa[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*lda), nc, (*aa)[i+j*(*lda)], (*as)[i+j*(*lda)])
									}
								}
							}

							if *incx > 0 {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][0] = (*x)[i-1]
								}
							} else {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][0] = (*x)[(*n)-i]
								}
							}
							if *incy > 0 {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][1] = (*y)[i-1]
								}
							} else {
								for i = 1; i <= *n; i++ {
									(*z)[i-1][1] = (*y)[(*n)-i]
								}
							}
							ja = 1
							for j = 1; j <= *n; j++ {
								(*w)[0] = (*alpha) * complex64(cmplx.Conj(complex128((*z)[j-1][1])))
								(*w)[1] = complex64(cmplx.Conj(complex128(*alpha))) * complex64(cmplx.Conj(complex128((*z)[j-1][0])))
								if *uplo == 'U' {
									jj = 1
									lj = j
								} else {
									jj = j
									lj = (*n) - j + 1
								}
								_z := func() *[][]complex64 {
									arr := make([][]complex64, lj)
									for i := range arr {
										arr[i] = make([]complex64, 2)
										arr[i][0] = (*z)[i+jj-1][0]
										arr[i][1] = (*z)[i+jj-1][1]
									}
									return &arr
								}()
								_a := func() *[]complex64 { y := make([]complex64, lj); return &y }()
								for i = range *_a {
									(*_a)[i] = (*a)[jj-1+i][j-1]
								}

								cmvchTest(_N, &lj, twoi, onec64, _z, w, onei, onec64, _a, onei, yt, g)
								_aa := (*aa)[ja-1:]
								err = 0
								for i = 1; i <= lj; i++ {
									erri = abssumf32((*yt)[i-1]-_aa[i-1]) / epsf32
									if (*g)[i-1] != 0.0 {
										erri /= (*g)[i-1]
									}
									err = maxf32(err, erri)
									if err*sqrtf32(epsf32) >= 1.0 {
										t.Errorf("Test Failed: aa[%d]: iteration %d-%d: {%10.8f} output, {%10.8f} expected, {%10.8e} error", i-1, nc, j, (*aa)[i-1], (*at)[i-1], err*sqrtf32(epsf32))
									}
								}

								ja += lj
							}
						}
					}

					if *n <= 0 {
						break
					}
				}

				if *n <= 0 {
					break
				}
			}

			if *n <= 0 {
				break
			}
		}

	}

	printTestsRun(tname, nc)
}

func BenchmarkChpr2(b *testing.B) {
	uplo := new(byte)
	alpha := new(complex64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	major := new(byte)
	*major = 'C'

	*uplo = 'U'
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*incy = 2

	for i := 0; i < b.N; i++ {
		Chpr2(major, uplo, n, alpha, xx, incx, yy, incy, aa)
	}
}

func BenchmarkChpr2Fortran(b *testing.B) {
	uplo := new(byte)
	alpha := new(complex64)
	n := new(int)
	incx := new(int)
	incy := new(int)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()

	*uplo = 'U'
	*n = 9
	*alpha = (0.70 - 0.90i)
	*incx = 2
	*incy = 2

	for i := 0; i < b.N; i++ {
		chpr2Wrapper(uplo, n, alpha, xx, incx, yy, incy, aa)
	}
}

// BLAS Level 3
func TestCgemm(t *testing.T) {
	tname := "Cgemm"
	var i, ia, ib, ica, icb, ik, im, in, j, ks, laa, lbb, lcc, ldas, ldbs, ldcs, ms, nc, ns int
	var als, bls complex64
	var tranas, tranbs byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex64)
	beta := new(complex64)
	transl := new(complex64)
	k := new(int)
	m := new(int)
	ma := new(int)
	mb := new(int)
	n := new(int)
	na := new(int)
	nb := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	transa := new(byte)
	transb := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	b := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	bb := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	bs := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	c := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	cc := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	cs := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	ct := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldc = *m
			if *ldc < nmax {
				*ldc++
			}
			if *ldc > nmax {
				continue
			}
			lcc = (*ldc) * (*n)

			null = *n <= 0 || *m <= 0

			for ik = 1; ik <= len(idimL3); ik++ {
				*k = idimL3[ik-1]

				for ica = 1; ica <= len(ichtL3); ica++ {
					*transa = ichtL3[ica-1]

					if *transa == 'T' || *transa == 'C' {
						*ma = *k
						*na = *m
					} else {
						*ma = *m
						*na = *k
					}

					*lda = *ma
					if *lda < nmax {
						*lda++
					}
					if *lda > nmax {
						continue
					}
					laa = (*lda) * (*na)

					cmakeGEL3(ma, na, a, aa, lda, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					for icb = 1; icb <= len(ichtL3); icb++ {
						*transb = ichtL3[icb-1]

						if *transb == 'T' || *transb == 'C' {
							*mb = *n
							*nb = *k
						} else {
							*mb = *k
							*nb = *n
						}

						*ldb = *mb
						if *ldb < nmax {
							*ldb++
						}
						if *ldb > nmax {
							continue
						}
						lbb = (*ldb) * (*nb)

						cmakeGEL3(mb, nb, b, bb, ldb, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

						for ia = 1; ia <= len(alfc64L3); ia++ {
							*alpha = alfc64L3[ia-1]

							for ib = 1; ib <= len(betc64L3); ib++ {
								*beta = betc64L3[ib-1]

								cmakeGEL3(m, n, c, cc, ldc, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

								tranas = *transa
								tranbs = *transb
								ms = *m
								ns = *n
								ks = *k
								als = *alpha
								bls = *beta
								ldas = *lda
								ldbs = *ldb
								ldcs = *ldc
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lbb; i++ {
									(*bs)[i-1] = (*bb)[i-1]
								}
								for i = 1; i <= lcc; i++ {
									(*cs)[i-1] = (*cc)[i-1]
								}

								nc++

								_aa := cExpand(aa, na, lda)
								_bb := cExpand(bb, nb, ldb)
								_cc := cExpand(cc, n, ldc)
								Cgemm(major, transa, transb, m, n, k, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
								cReturn(_aa, aa)
								cReturn(_bb, bb)
								cReturn(_cc, cc)

								checkByte(t, nc, transa, &tranas, "transa")
								checkByte(t, nc, transb, &tranbs, "transb")
								checkInt(t, nc, m, &ms, "m")
								checkInt(t, nc, n, &ns, "n")
								checkInt(t, nc, k, &ks, "k")
								checkComplex64(t, nc, alpha, &als, "alpha")
								checkComplex64(t, nc, beta, &bls, "beta")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, ldb, &ldbs, "ldb")
								checkInt(t, nc, ldc, &ldcs, "ldc")
								checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
								checkComplex64Array1D(t, nc, &lbb, bb, bs, "bb")
								if null {
									checkComplex64Array1D(t, nc, &lcc, cc, cs, "guardband cc")
								} else {
									for j = 0; j < *n; j++ {
										for i = (*m) + 1; i <= *ldc; i++ {
											if (*cc)[i+j*(*ldc)-1] != (*cs)[i+j*(*ldc)-1] {
												t.Errorf("Test Failed: cc[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldc), nc, (*cc)[i+j*(*ldc)], (*cs)[i+j*(*ldc)])
											}
										}
									}

									cmmchTest(transa, transb, m, n, k, alpha, a, b, beta, c, ct, g, cc, ldc, nc, "cc", t)
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkCgemm(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	k := new(int)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	transa := new(byte)
	transb := new(byte)
	aa := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	bb := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	cc := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	major := new(byte)
	*major = 'C'

	*transa = 'C'
	*transb = 'C'
	*m = 9
	*n = 9
	*k = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*beta = (1.3 - 1.1i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Cgemm(major, transa, transb, m, n, k, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func BenchmarkCgemmFortran(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	k := new(int)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	transa := new(byte)
	transb := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	bb := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	cc := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()

	*transa = 'C'
	*transb = 'C'
	*m = 9
	*n = 9
	*k = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*beta = (1.3 - 1.1i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		cgemmWrapper(transa, transb, m, n, k, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func TestChemm(t *testing.T) {
	tname := "Chemm"
	var i, ia, ib, ics, icu, im, in, j, laa, lbb, lcc, ldas, ldbs, ldcs, ms, nc, ns int
	var als, bls complex64
	var sides, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex64)
	beta := new(complex64)
	transl := new(complex64)
	m := new(int)
	n := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	side := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	b := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	bb := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	bs := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	c := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	cc := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	cs := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	ct := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldc = *m
			if *ldc < nmax {
				*ldc++
			}
			if *ldc > nmax {
				continue
			}
			lcc = (*ldc) * (*n)

			null = *n <= 0 || *m <= 0

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			cmakeGEL3(m, n, b, bb, ldb, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

			for ics = 1; ics <= len(ichsL3); ics++ {
				*side = ichsL3[ics-1]

				if *side == 'L' {
					*na = *m
				} else {
					*na = *n
				}

				*lda = *na
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					cmakeHEL3(uplo, na, na, a, aa, lda, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					for ia = 1; ia <= len(alfc64L3); ia++ {
						*alpha = alfc64L3[ia-1]

						for ib = 1; ib <= len(betc64L3); ib++ {
							*beta = betc64L3[ib-1]

							cmakeGEL3(m, n, c, cc, ldc, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

							sides = *side
							uplos = *uplo
							ms = *m
							ns = *n
							als = *alpha
							bls = *beta
							ldas = *lda
							ldbs = *ldb
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lbb; i++ {
								(*bs)[i-1] = (*bb)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := cExpand(aa, na, lda)
							_bb := cExpand(bb, n, ldb)
							_cc := cExpand(cc, n, ldc)
							Chemm(major, side, uplo, m, n, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
							cReturn(_aa, aa)
							cReturn(_bb, bb)
							cReturn(_cc, cc)

							checkByte(t, nc, side, &sides, "side")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, m, &ms, "m")
							checkInt(t, nc, n, &ns, "n")
							checkComplex64(t, nc, alpha, &als, "alpha")
							checkComplex64(t, nc, beta, &bls, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldb, &ldbs, "ldb")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
							checkComplex64Array1D(t, nc, &lbb, bb, bs, "bb")
							if null {
								checkComplex64Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 0; j < *n; j++ {
									for i = (*m) + 1; i <= *ldc; i++ {
										if (*cc)[i+j*(*ldc)-1] != (*cs)[i+j*(*ldc)-1] {
											t.Errorf("Test Failed: guardband cc[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldc), nc, (*cc)[i+j*(*ldc)], (*cs)[i+j*(*ldc)])
										}
									}
								}

								if *side == 'L' {
									cmmchTest(_N, _N, m, n, m, alpha, a, b, beta, c, ct, g, cc, ldc, nc, "cc", t)
								} else {
									cmmchTest(_N, _N, m, n, n, alpha, b, a, beta, c, ct, g, cc, ldc, nc, "cc", t)
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkChemm(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	side := new(byte)
	uplo := new(byte)
	aa := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	bb := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	cc := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	major := new(byte)
	*major = 'C'

	*side = 'R'
	*uplo = 'L'
	*m = 9
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*beta = (1.30 - 1.10i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Chemm(major, side, uplo, m, n, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func BenchmarkChemmFortran(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	side := new(byte)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	bb := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	cc := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()

	*side = 'R'
	*uplo = 'L'
	*m = 9
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*beta = (1.30 - 1.10i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		chemmWrapper(side, uplo, m, n, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func TestCsymm(t *testing.T) {
	tname := "Csymm"
	var i, ia, ib, ics, icu, im, in, j, laa, lbb, lcc, ldas, ldbs, ldcs, ms, nc, ns int
	var als, bls complex64
	var sides, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex64)
	beta := new(complex64)
	transl := new(complex64)
	m := new(int)
	n := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	side := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	b := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	bb := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	bs := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	c := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	cc := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	cs := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	ct := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldc = *m
			if *ldc < nmax {
				*ldc++
			}
			if *ldc > nmax {
				continue
			}
			lcc = (*ldc) * (*n)

			null = *n <= 0 || *m <= 0

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			cmakeGEL3(m, n, b, bb, ldb, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

			for ics = 1; ics <= len(ichsL3); ics++ {
				*side = ichsL3[ics-1]

				if *side == 'L' {
					*na = *m
				} else {
					*na = *n
				}

				*lda = *na
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					cmakeSYL3(uplo, na, na, a, aa, lda, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

					for ia = 1; ia <= len(alfc64L3); ia++ {
						*alpha = alfc64L3[ia-1]

						for ib = 1; ib <= len(betc64L3); ib++ {
							*beta = betc64L3[ib-1]

							cmakeGEL3(m, n, c, cc, ldc, reset, transl, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

							sides = *side
							uplos = *uplo
							ms = *m
							ns = *n
							als = *alpha
							bls = *beta
							ldas = *lda
							ldbs = *ldb
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lbb; i++ {
								(*bs)[i-1] = (*bb)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := cExpand(aa, na, lda)
							_bb := cExpand(bb, n, ldb)
							_cc := cExpand(cc, n, ldc)
							Csymm(major, side, uplo, m, n, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
							cReturn(_aa, aa)
							cReturn(_bb, bb)
							cReturn(_cc, cc)

							checkByte(t, nc, side, &sides, "side")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, m, &ms, "m")
							checkInt(t, nc, n, &ns, "n")
							checkComplex64(t, nc, alpha, &als, "alpha")
							checkComplex64(t, nc, beta, &bls, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldb, &ldbs, "ldb")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
							checkComplex64Array1D(t, nc, &lbb, bb, bs, "bb")
							if null {
								checkComplex64Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 0; j < *n; j++ {
									for i = (*m) + 1; i <= *ldc; i++ {
										if (*cc)[i+j*(*ldc)-1] != (*cs)[i+j*(*ldc)-1] {
											t.Errorf("Test Failed: guardband cc[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldc), nc, (*cc)[i+j*(*ldc)], (*cs)[i+j*(*ldc)])
										}
									}
								}

								if *side == 'L' {
									cmmchTest(_N, _N, m, n, m, alpha, a, b, beta, c, ct, g, cc, ldc, nc, "cc", t)
								} else {
									cmmchTest(_N, _N, m, n, n, alpha, b, a, beta, c, ct, g, cc, ldc, nc, "cc", t)
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkCsymm(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	side := new(byte)
	uplo := new(byte)
	aa := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	bb := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	cc := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	major := new(byte)
	*major = 'C'

	*side = 'R'
	*uplo = 'L'
	*m = 9
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*beta = (1.30 - 1.10i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Csymm(major, side, uplo, m, n, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func BenchmarkCsymmFortran(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	side := new(byte)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	bb := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	cc := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()

	*side = 'R'
	*uplo = 'L'
	*m = 9
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*beta = (1.30 - 1.10i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		csymmWrapper(side, uplo, m, n, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func TestCtrmm(t *testing.T) {
	tname := "Ctrmm"
	var i, ia, icd, ics, ict, icu, im, in, j, laa, lbb, ldas, ldbs, ms, nc, ns int
	var als complex64
	var diags, sides, tranas, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex64)
	m := new(int)
	n := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	b := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	bb := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	bs := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	c := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	ct := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			null = *n <= 0 || *m <= 0

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			for ics = 1; ics <= len(ichsL3); ics++ {
				*side = ichsL3[ics-1]

				if *side == 'L' {
					*na = *m
				} else {
					*na = *n
				}

				*lda = *na
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ict = 1; ict <= len(ichtL3); ict++ {
						*transa = ichtL3[ict-1]

						for icd = 1; icd <= len(ichdL3); icd++ {
							*diag = ichdL3[icd-1]

							for ia = 1; ia <= len(alfc64L3); ia++ {
								*alpha = alfc64L3[ia-1]

								cmakeTRL3(uplo, diag, na, na, a, aa, lda, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

								cmakeGEL3(m, n, b, bb, ldb, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

								diags = *diag
								sides = *side
								tranas = *transa
								uplos = *uplo
								ms = *m
								ns = *n
								als = *alpha
								ldas = *lda
								ldbs = *ldb
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lbb; i++ {
									(*bs)[i-1] = (*bb)[i-1]
								}

								nc++

								_aa := cExpand(aa, na, lda)
								_bb := cExpand(bb, n, ldb)
								Ctrmm(major, side, uplo, transa, diag, m, n, alpha, _aa, lda, _bb, ldb)
								cReturn(_aa, aa)
								cReturn(_bb, bb)

								checkByte(t, nc, diag, &diags, "diag")
								checkByte(t, nc, side, &sides, "side")
								checkByte(t, nc, transa, &tranas, "transa")
								checkByte(t, nc, uplo, &uplos, "uplo")
								checkInt(t, nc, m, &ms, "m")
								checkInt(t, nc, n, &ns, "n")
								checkComplex64(t, nc, alpha, &als, "alpha")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, ldb, &ldbs, "ldb")
								checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
								if null {
									checkComplex64Array1D(t, nc, &lbb, bb, bs, "guardband bb")
								} else {
									for j = 0; j < *n; j++ {
										for i = (*m) + 1; i <= *ldb; i++ {
											if (*bb)[i+j*(*ldb)-1] != (*bs)[i+j*(*ldb)-1] {
												t.Errorf("Test Failed: guardband bb[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldb), nc, (*bb)[i+j*(*ldb)], (*bs)[i+j*(*ldb)])
											}
										}
									}

									if *side == 'L' {
										cmmchTest(transa, _N, m, n, m, alpha, a, b, zeroc64, c, ct, g, bb, ldb, nc, "bb", t)
									} else {
										cmmchTest(_N, transa, m, n, n, alpha, b, a, zeroc64, c, ct, g, bb, ldb, nc, "bb", t)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkCtrmm(b *testing.B) {
	alpha := new(complex64)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	aa := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	bb := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	major := new(byte)
	*major = 'C'

	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'U'
	*m = 9
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10

	for i := 0; i < b.N; i++ {
		Ctrmm(major, side, uplo, transa, diag, m, n, alpha, aa, lda, bb, ldb)
	}
}

func BenchmarkCtrmmFortran(b *testing.B) {
	alpha := new(complex64)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	bb := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()

	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'U'
	*m = 9
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10

	for i := 0; i < b.N; i++ {
		ctrmmWrapper(side, uplo, transa, diag, m, n, alpha, aa, lda, bb, ldb)
	}
}

func TestCtrsm(t *testing.T) {
	tname := "Ctrsm"
	var i, ia, icd, ics, ict, icu, im, in, j, laa, lbb, ldas, ldbs, ms, nc, ns int
	var als complex64
	var diags, sides, tranas, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex64)
	m := new(int)
	n := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	b := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	bb := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	bs := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	c := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	ct := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	for im = 1; im <= len(idimL3); im++ {
		*m = idimL3[im-1]

		for in = 1; in <= len(idimL3); in++ {
			*n = idimL3[in-1]

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			null = *n <= 0 || *m <= 0

			*ldb = *m
			if *ldb < nmax {
				*ldb++
			}
			if *ldb > nmax {
				continue
			}
			lbb = (*ldb) * (*n)

			for ics = 1; ics <= len(ichsL3); ics++ {
				*side = ichsL3[ics-1]

				if *side == 'L' {
					*na = *m
				} else {
					*na = *n
				}

				*lda = *na
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ict = 1; ict <= len(ichtL3); ict++ {
						*transa = ichtL3[ict-1]

						for icd = 1; icd <= len(ichdL3); icd++ {
							*diag = ichdL3[icd-1]

							for ia = 1; ia <= len(alfc64L3); ia++ {
								*alpha = alfc64L3[ia-1]

								cmakeTRL3(uplo, diag, na, na, a, aa, lda, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

								cmakeGEL3(m, n, b, bb, ldb, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

								diags = *diag
								sides = *side
								tranas = *transa
								uplos = *uplo
								ms = *m
								ns = *n
								als = *alpha
								ldas = *lda
								ldbs = *ldb
								for i = 1; i <= laa; i++ {
									(*as)[i-1] = (*aa)[i-1]
								}
								for i = 1; i <= lbb; i++ {
									(*bs)[i-1] = (*bb)[i-1]
								}

								nc++

								_aa := cExpand(aa, na, lda)
								_bb := cExpand(bb, n, ldb)
								Ctrsm(major, side, uplo, transa, diag, m, n, alpha, _aa, lda, _bb, ldb)
								cReturn(_aa, aa)
								cReturn(_bb, bb)

								checkByte(t, nc, diag, &diags, "diag")
								checkByte(t, nc, side, &sides, "side")
								checkByte(t, nc, transa, &tranas, "transa")
								checkByte(t, nc, uplo, &uplos, "uplo")
								checkInt(t, nc, m, &ms, "m")
								checkInt(t, nc, n, &ns, "n")
								checkComplex64(t, nc, alpha, &als, "alpha")
								checkInt(t, nc, lda, &ldas, "lda")
								checkInt(t, nc, ldb, &ldbs, "ldb")
								checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
								if null {
									checkComplex64Array1D(t, nc, &lbb, bb, bs, "guardband bb")
								} else {
									for j = 0; j < *n; j++ {
										for i = (*m) + 1; i <= *ldb; i++ {
											if (*bb)[i+j*(*ldb)-1] != (*bs)[i+j*(*ldb)-1] {
												t.Errorf("Test Failed: guardband bb[%d]: iteration %d: {%10.8f} output, {%10.8f} expected", i+j*(*ldb), nc, (*bb)[i+j*(*ldb)], (*bs)[i+j*(*ldb)])
											}
										}
									}

									for j = 1; j <= *n; j++ {
										for i = 1; i <= *m; i++ {
											(*c)[i-1][j-1] = (*bb)[i+(j-1)*(*ldb)-1]
											(*bb)[i+(j-1)*(*ldb)-1] = (*alpha) * (*b)[i-1][j-1]
										}
									}
									if *side == 'L' {
										cmmchTest(transa, _N, m, n, m, onec64, a, c, zeroc64, b, ct, g, bb, ldb, nc, "bb", t)
									} else {
										cmmchTest(_N, transa, m, n, n, onec64, c, a, zeroc64, b, ct, g, bb, ldb, nc, "bb", t)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkCtrsm(b *testing.B) {
	alpha := new(complex64)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	aa := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	bb := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	major := new(byte)
	*major = 'C'

	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'U'
	*m = 9
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10

	for i := 0; i < b.N; i++ {
		Ctrsm(major, side, uplo, transa, diag, m, n, alpha, aa, lda, bb, ldb)
	}
}

func BenchmarkCtrsmFortran(b *testing.B) {
	alpha := new(complex64)
	m := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	diag := new(byte)
	side := new(byte)
	transa := new(byte)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	bb := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()

	*side = 'R'
	*uplo = 'L'
	*transa = 'C'
	*diag = 'U'
	*m = 9
	*n = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10

	for i := 0; i < b.N; i++ {
		ctrsmWrapper(side, uplo, transa, diag, m, n, alpha, aa, lda, bb, ldb)
	}
}

func TestCherk(t *testing.T) {
	tname := "Cherk"
	var i, ia, ib, ibeg, ict, icu, ik, in, iend, j, jc, jj, ks, laa, lcc, ldas, ldcs, nc, ns, x, y int
	var rals, rbls float32
	var transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	ralpha := new(float32)
	rbeta := new(float32)
	alpha := new(complex64)
	beta := new(complex64)
	k := new(int)
	n := new(int)
	lj := new(int)
	ma := new(int)
	na := new(int)
	lda := new(int)
	ldc := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	c := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	cc := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	cs := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	ct := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	for in = 1; in <= len(idimL3); in++ {
		*n = idimL3[in-1]

		*ldc = *n
		if *ldc < nmax {
			*ldc++
		}
		if *ldc > nmax {
			continue
		}
		lcc = (*ldc) * (*n)

		for ik = 1; ik <= len(idimL3); ik++ {
			*k = idimL3[ik-1]

			for ict = 1; ict <= len(ichtL3); ict++ {
				*trans = ichtL3[ict-1]
				if *trans == 'T' {
					continue
				}

				if *trans == 'T' || *trans == 'C' {
					*ma = *k
					*na = *n
				} else {
					*ma = *n
					*na = *k
				}

				*lda = *ma
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				cmakeGEL3(ma, na, a, aa, lda, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ia = 1; ia <= len(alfc64L3); ia++ {
						*alpha = alfc64L3[ia-1]
						*ralpha = real(*alpha)
						*alpha = complex(*ralpha, 0.0)

						for ib = 1; ib <= len(betc64L3); ib++ {
							*beta = betc64L3[ib-1]
							*rbeta = real(*beta)
							*beta = complex(*rbeta, 0.0)

							null = *n <= 0 || ((*k <= 0 || *ralpha == 0.0) && *rbeta == 1.0)

							cmakeHEL3(uplo, n, n, c, cc, ldc, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

							transs = *trans
							uplos = *uplo
							ns = *n
							ks = *k
							rals = *ralpha
							rbls = *rbeta
							ldas = *lda
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := cExpand(aa, na, lda)
							_cc := cExpand(cc, n, ldc)
							Cherk(major, uplo, trans, n, k, ralpha, _aa, lda, rbeta, _cc, ldc)
							cReturn(_aa, aa)
							cReturn(_cc, cc)

							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, k, &ks, "k")
							checkFloat32(t, nc, ralpha, &rals, "ralpha")
							checkFloat32(t, nc, rbeta, &rbls, "rbeta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
							if null {
								checkComplex64Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										ibeg = 1
										iend = j
									} else {
										ibeg = j
										iend = *n
									}
									for i = 1; i <= *ldc; i++ {
										if i < ibeg || i > iend {
											checkComplex64(t, nc, &(*cc)[i+(j-1)*(*ldc)-1], &(*cs)[i+(j-1)*(*ldc)-1], "guardband cc")
										}
									}
								}

								jc = 1
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										jj = 1
										*lj = j
									} else {
										jj = j
										*lj = (*n) - j + 1
									}
									_c := func() *[][]complex64 {
										arr := make([][]complex64, nmax-jj-1)
										for y := 0; y < nmax-jj-1; y++ {
											arr[y] = make([]complex64, 1)
											for x := 0; x < 1; x++ {
												arr[y][x] = (*c)[y+jj-1][x+j-1]
											}
										}
										return &arr
									}()
									_cc := func() *[]complex64 {
										arr := make([]complex64, *ldc)
										for y := 0; y < *ldc; y++ {
											for x := 0; x < 1; x++ {
												arr[y+x*(*ldc)] = (*cc)[y+jc-1+x*(*ldc)]
											}
										}
										return &arr
									}()

									if *trans == 'T' || *trans == 'C' {
										_a := func() *[][]complex64 {
											arr := make([][]complex64, nmax)
											for y = 0; y < nmax; y++ {
												arr[y] = make([]complex64, *n)
												for x = 0; x < *n; x++ {
													arr[y][x] = (*a)[y][x+jj-1]
												}
											}
											return &arr
										}()
										_b := func() *[][]complex64 {
											arr := make([][]complex64, nmax)
											for y = 0; y < nmax; y++ {
												arr[y] = make([]complex64, 1)
												for x = 0; x < 1; x++ {
													arr[y][x] = (*a)[y][x+j-1]
												}
											}
											return &arr
										}()
										cmmchTest(_C, _N, lj, onei, k, alpha, _a, _b, beta, _c, ct, g, _cc, ldc, nc, "cc", t)
									} else {
										_a := func() *[][]complex64 {
											arr := make([][]complex64, nmax-jj-1)
											for y = 0; y < nmax-jj-1; y++ {
												arr[y] = make([]complex64, *k)
												for x = 0; x < *k; x++ {
													arr[y][x] = (*a)[y+jj-1][x]
												}
											}
											return &arr
										}()
										_b := func() *[][]complex64 {
											arr := make([][]complex64, nmax-j-1)
											for y = 0; y < nmax-j-1; y++ {
												arr[y] = make([]complex64, *k)
												for x = 0; x < *k; x++ {
													arr[y][x] = (*a)[y+j-1][x]
												}
											}
											return &arr
										}()
										cmmchTest(_N, _C, lj, onei, k, alpha, _a, _b, beta, _c, ct, g, _cc, ldc, nc, "cc", t)
									}
									if *uplo == 'U' {
										jc += *ldc
									} else {
										jc += (*ldc) + 1
									}
								}
							}
						}
					}
				}
			}

		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkCherk(b *testing.B) {
	ralpha := new(float32)
	rbeta := new(float32)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	cc := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	major := new(byte)
	*major = 'C'

	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*ralpha = 0.70
	*lda = 10
	*rbeta = 1.30
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Cherk(major, uplo, trans, n, k, ralpha, aa, lda, rbeta, cc, ldc)
	}
}

func BenchmarkCherkFortran(b *testing.B) {
	ralpha := new(float32)
	rbeta := new(float32)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	cc := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*ralpha = 0.70
	*lda = 10
	*rbeta = 1.30
	*ldc = 10

	for i := 0; i < b.N; i++ {
		cherkWrapper(uplo, trans, n, k, ralpha, aa, lda, rbeta, cc, ldc)
	}
}

func TestCsyrk(t *testing.T) {
	tname := "Csyrk"
	var i, ia, ib, ibeg, ict, icu, ik, in, iend, j, jc, jj, ks, laa, lcc, ldas, ldcs, nc, ns, x, y int
	var als, bls complex64
	var transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex64)
	beta := new(complex64)
	k := new(int)
	n := new(int)
	lj := new(int)
	ma := new(int)
	na := new(int)
	lda := new(int)
	ldc := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*reset = true

	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	c := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	cc := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	cs := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	ct := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()

	for in = 1; in <= len(idimL3); in++ {
		*n = idimL3[in-1]

		*ldc = *n
		if *ldc < nmax {
			*ldc++
		}
		if *ldc > nmax {
			continue
		}
		lcc = (*ldc) * (*n)

		for ik = 1; ik <= len(idimL3); ik++ {
			*k = idimL3[ik-1]

			for ict = 1; ict <= len(ichtL3); ict++ {
				*trans = ichtL3[ict-1]
				if *trans == 'C' {
					continue
				}

				if *trans == 'T' || *trans == 'C' {
					*ma = *k
					*na = *n
				} else {
					*ma = *n
					*na = *k
				}

				*lda = *ma
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				cmakeGEL3(ma, na, a, aa, lda, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ia = 1; ia <= len(alfc64L3); ia++ {
						*alpha = alfc64L3[ia-1]

						for ib = 1; ib <= len(betc64L3); ib++ {
							*beta = betc64L3[ib-1]

							null = *n <= 0

							cmakeSYL3(uplo, n, n, c, cc, ldc, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

							transs = *trans
							uplos = *uplo
							ns = *n
							ks = *k
							als = *alpha
							bls = *beta
							ldas = *lda
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := cExpand(aa, na, lda)
							_cc := cExpand(cc, n, ldc)
							Csyrk(major, uplo, trans, n, k, alpha, _aa, lda, beta, _cc, ldc)
							cReturn(_aa, aa)
							cReturn(_cc, cc)

							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, k, &ks, "k")
							checkComplex64(t, nc, alpha, &als, "alpha")
							checkComplex64(t, nc, beta, &bls, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
							if null {
								checkComplex64Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										ibeg = 1
										iend = j
									} else {
										ibeg = j
										iend = *n
									}
									for i = 1; i <= *ldc; i++ {
										if i < ibeg || i > iend {
											checkComplex64(t, nc, &(*cc)[i+(j-1)*(*ldc)-1], &(*cs)[i+(j-1)*(*ldc)-1], "guardband cc")
										}
									}
								}

								jc = 1
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										jj = 1
										*lj = j
									} else {
										jj = j
										*lj = (*n) - j + 1
									}
									_c := func() *[][]complex64 {
										arr := make([][]complex64, nmax-jj-1)
										for y := 0; y < nmax-jj-1; y++ {
											arr[y] = make([]complex64, 1)
											for x := 0; x < 1; x++ {
												arr[y][x] = (*c)[y+jj-1][x+j-1]
											}
										}
										return &arr
									}()
									_cc := func() *[]complex64 {
										arr := make([]complex64, *ldc)
										for y := 0; y < *ldc; y++ {
											for x := 0; x < 1; x++ {
												arr[y+x*(*ldc)] = (*cc)[y+jc-1+x*(*ldc)]
											}
										}
										return &arr
									}()

									if *trans == 'T' || *trans == 'C' {
										_a := func() *[][]complex64 {
											arr := make([][]complex64, nmax)
											for y = 0; y < nmax; y++ {
												arr[y] = make([]complex64, *n)
												for x = 0; x < *n; x++ {
													arr[y][x] = (*a)[y][x+jj-1]
												}
											}
											return &arr
										}()
										_b := func() *[][]complex64 {
											arr := make([][]complex64, nmax)
											for y = 0; y < nmax; y++ {
												arr[y] = make([]complex64, 1)
												for x = 0; x < 1; x++ {
													arr[y][x] = (*a)[y][x+j-1]
												}
											}
											return &arr
										}()
										cmmchTest(_T, _N, lj, onei, k, alpha, _a, _b, beta, _c, ct, g, _cc, ldc, nc, "cc", t)
									} else {
										_a := func() *[][]complex64 {
											arr := make([][]complex64, nmax-jj-1)
											for y = 0; y < nmax-jj-1; y++ {
												arr[y] = make([]complex64, *k)
												for x = 0; x < *k; x++ {
													arr[y][x] = (*a)[y+jj-1][x]
												}
											}
											return &arr
										}()
										_b := func() *[][]complex64 {
											arr := make([][]complex64, nmax-j-1)
											for y = 0; y < nmax-j-1; y++ {
												arr[y] = make([]complex64, *k)
												for x = 0; x < *k; x++ {
													arr[y][x] = (*a)[y+j-1][x]
												}
											}
											return &arr
										}()
										cmmchTest(_N, _T, lj, onei, k, alpha, _a, _b, beta, _c, ct, g, _cc, ldc, nc, "cc", t)
									}
									if *uplo == 'U' {
										jc += *ldc
									} else {
										jc += (*ldc) + 1
									}
								}
							}
						}
					}
				}
			}

		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkCsyrk(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	cc := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	major := new(byte)
	*major = 'C'

	*uplo = 'L'
	*trans = 'T'
	*n = 9
	*k = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*beta = (1.30 - 1.10i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Csyrk(major, uplo, trans, n, k, alpha, aa, lda, beta, cc, ldc)
	}
}

func BenchmarkCsyrkFortran(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	cc := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()

	*uplo = 'L'
	*trans = 'T'
	*n = 9
	*k = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*beta = (1.30 - 1.10i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		csyrkWrapper(uplo, trans, n, k, alpha, aa, lda, beta, cc, ldc)
	}
}

func TestCher2k(t *testing.T) {
	tname := "Cher2k"
	var i, ia, ib, ibeg, ict, icu, ik, in, iend, j, jc, jj, jjab, ks, laa, lbb, lcc, ldas, ldbs, ldcs, nc, ns int
	var rbls float32
	var als complex64
	var transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	rbeta := new(float32)
	alpha := new(complex64)
	beta := new(complex64)
	k := new(int)
	k2 := new(int)
	n := new(int)
	lj := new(int)
	ma := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	nmax2 := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*nmax2 = 2 * nmax
	*reset = true

	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	ab := func() *[]complex64 { y := make([]complex64, 2*nmax*nmax); return &y }()
	bb := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	bs := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	c := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	cc := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	cs := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	ct := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	w := func() *[]complex64 { y := make([]complex64, 2*nmax); return &y }()

	for in = 1; in <= len(idimL3); in++ {
		*n = idimL3[in-1]

		*ldc = *n
		if *ldc < nmax {
			*ldc++
		}
		if *ldc > nmax {
			continue
		}
		lcc = (*ldc) * (*n)

		for ik = 1; ik <= len(idimL3); ik++ {
			*k = idimL3[ik-1]
			*k2 = 2 * (*k)

			for ict = 1; ict <= len(ichtL3); ict++ {
				*trans = ichtL3[ict-1]
				if *trans == 'T' {
					continue
				}

				if *trans == 'C' {
					*ma = *k
					*na = *n
				} else {
					*ma = *n
					*na = *k
				}

				*lda = *ma
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				_ab := func() *[][]complex64 {
					arr := make([][]complex64, nmax)
					for y := range arr {
						arr[y] = make([]complex64, *na)
						for x := range arr[y] {
							arr[y][x] = (*ab)[y+x*nmax]
						}
					}
					return &arr
				}()
				cmakeGEL3(ma, na, _ab, aa, lda, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				for _j := 0; _j < *na; _j++ {
					for _i := 0; _i < *ma; _i++ {
						(*ab)[_i+_j*nmax] = (*_ab)[_i][_j]
					}
				}

				*ldb = *lda
				lbb = laa

				if *trans == 'C' {
					_ab := func() *[][]complex64 {
						arr := make([][]complex64, nmax)
						for y := range arr {
							arr[y] = make([]complex64, *na)
							for x := range arr[y] {
								arr[y][x] = (*ab)[(*k)+y+x*nmax]
							}
						}
						return &arr
					}()
					cmakeGEL3(ma, na, _ab, bb, ldb, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					for _j := 0; _j < *na; _j++ {
						for _i := 0; _i < *ma; _i++ {
							(*ab)[_i+_j*nmax+(*k)] = (*_ab)[_i][_j]
						}
					}
				} else {
					_ab := func() *[][]complex64 {
						arr := make([][]complex64, nmax)
						for y := range arr {
							arr[y] = make([]complex64, *na)
							for x := range arr[y] {
								arr[y][x] = (*ab)[(*k)*nmax+y+x*nmax]
							}
						}
						return &arr
					}()
					cmakeGEL3(ma, na, _ab, bb, ldb, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					for _j := 0; _j < *na; _j++ {
						for _i := 0; _i < *ma; _i++ {
							(*ab)[_i+_j*nmax+(*k)*nmax] = (*_ab)[_i][_j]
						}
					}
				}

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ia = 1; ia <= len(alfc64L3); ia++ {
						*alpha = alfc64L3[ia-1]

						for ib = 1; ib <= len(betc64L3); ib++ {
							*beta = complex(real(betc64L3[ib-1]), 0.0)
							*rbeta = real(*beta)

							null = *n <= 0 || ((*k <= 0 || *alpha == 0.0) && *rbeta == 1.0)

							cmakeHEL3(uplo, n, n, c, cc, ldc, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

							transs = *trans
							uplos = *uplo
							ns = *n
							ks = *k
							als = *alpha
							rbls = *rbeta
							ldas = *lda
							ldbs = *ldb
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lbb; i++ {
								(*bs)[i-1] = (*bb)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := cExpand(aa, na, lda)
							_bb := cExpand(bb, na, ldb)
							_cc := cExpand(cc, n, ldc)
							Cher2k(major, uplo, trans, n, k, alpha, _aa, lda, _bb, ldb, rbeta, _cc, ldc)
							cReturn(_aa, aa)
							cReturn(_bb, bb)
							cReturn(_cc, cc)

							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, k, &ks, "k")
							checkComplex64(t, nc, alpha, &als, "alpha")
							checkFloat32(t, nc, rbeta, &rbls, "rbeta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldb, &ldbs, "ldb")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
							checkComplex64Array1D(t, nc, &lbb, bb, bs, "bb")
							if null {
								checkComplex64Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										ibeg = 1
										iend = j
									} else {
										ibeg = j
										iend = *n
									}
									for i = 1; i <= *ldc; i++ {
										if i < ibeg || i > iend {
											checkComplex64(t, nc, &(*cc)[i+(j-1)*(*ldc)-1], &(*cs)[i+(j-1)*(*ldc)-1], "guardband cc")
										}
									}
								}

								jjab = 1
								jc = 1
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										jj = 1
										*lj = j
									} else {
										jj = j
										*lj = (*n) - j + 1
									}
									_c := func() *[][]complex64 {
										arr := make([][]complex64, min(nmax, cap(*c)-(jj-1)))
										for y := range arr {
											arr[y] = make([]complex64, min(1, cap((*c)[0])-(j-1)))
											for x := range arr[y] {
												arr[y][x] = (*c)[y+jj-1][x+j-1]
											}
										}
										return &arr
									}()
									_cc := (*cc)[jc-1:]
									if *trans == 'C' {
										for i = 1; i <= *k; i++ {
											(*w)[i-1] = (*alpha) * (*ab)[(j-1)*nmax+(*k)+i-1]
											(*w)[(*k)+i-1] = complex64(cmplx.Conj(complex128(*alpha))) * (*ab)[(j-1)*nmax+i-1]
										}
										_jjab := (jjab-1)*nmax + 1
										_ab := func() *[][]complex64 {
											_x := (*ab)[_jjab-1:]
											arr := make([][]complex64, nmax)
											for y := range arr {
												arr[y] = make([]complex64, *lj)
												for x := range arr[y] {
													arr[y][x] = _x[y+x*nmax]
												}
											}
											return &arr
										}()
										_w := func() *[][]complex64 {
											arr := make([][]complex64, *nmax2)
											for y := range arr {
												arr[y] = make([]complex64, 1)
												for x := range arr[y] {
													arr[y][x] = (*w)[y+x*(*nmax2)]
												}
											}
											return &arr
										}()
										cmmchTest(trans, _N, lj, onei, k2, onec64, _ab, _w, beta, _c, ct, g, &_cc, ldc, nc, "cc", t)
									} else {
										for i = 1; i <= *k; i++ {
											(*w)[i-1] = (*alpha) * complex64(cmplx.Conj(complex128((*ab)[((*k)+i-1)*nmax+j-1])))
											(*w)[(*k)+i-1] = complex64(cmplx.Conj(complex128((*alpha) * (*ab)[(i-1)*nmax+j-1])))
										}
										_ab := func() *[][]complex64 {
											_x := (*ab)[jj-1:]
											arr := make([][]complex64, nmax)
											for y := range arr {
												arr[y] = make([]complex64, *k2)
												for x := range arr[y] {
													arr[y][x] = _x[y+x*nmax]
												}
											}
											return &arr
										}()
										_w := func() *[][]complex64 {
											arr := make([][]complex64, *nmax2)
											for y := range arr {
												arr[y] = make([]complex64, 1)
												for x := range arr[y] {
													arr[y][x] = (*w)[y+x*(*nmax2)]
												}
											}
											return &arr
										}()
										cmmchTest(_N, _N, lj, onei, k2, onec64, _ab, _w, beta, _c, ct, g, &_cc, ldc, nc, "cc", t)
									}
									if *uplo == 'U' {
										jc += *ldc
									} else {
										jc += (*ldc) + 1
										if *trans == 'C' {
											jjab++
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkCher2k(b *testing.B) {
	alpha := new(complex64)
	rbeta := new(float32)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	bb := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	cc := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	major := new(byte)
	*major = 'C'

	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*rbeta = 1.30
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Cher2k(major, uplo, trans, n, k, alpha, aa, lda, bb, ldb, rbeta, cc, ldc)
	}
}

func BenchmarkCher2kFortran(b *testing.B) {
	alpha := new(complex64)
	rbeta := new(float32)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	bb := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	cc := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()

	*uplo = 'L'
	*trans = 'C'
	*n = 9
	*k = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*rbeta = 1.30
	*ldc = 10

	for i := 0; i < b.N; i++ {
		cher2kWrapper(uplo, trans, n, k, alpha, aa, lda, bb, ldb, rbeta, cc, ldc)
	}
}

func TestCsyr2k(t *testing.T) {
	tname := "Csyr2k"
	var i, ia, ib, ibeg, ict, icu, ik, in, iend, j, jc, jj, jjab, ks, laa, lbb, lcc, ldas, ldbs, ldcs, nc, ns int
	var als, bls complex64
	var transs, uplos byte
	var null bool
	var test *bool
	test = &common.infoc.test
	*test = false

	alpha := new(complex64)
	beta := new(complex64)
	k := new(int)
	k2 := new(int)
	n := new(int)
	lj := new(int)
	ma := new(int)
	na := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	nmax2 := new(int)
	miCbeg := new(int)
	mjCbeg := new(int)
	icCbeg := new(int)
	iCbeg := new(int)
	jCbeg := new(int)
	reset := new(bool)
	trans := new(byte)
	uplo := new(byte)
	major := new(byte)
	*major = 'C'

	*nmax2 = 2 * nmax
	*reset = true

	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	as := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	ab := func() *[]complex64 { y := make([]complex64, 2*nmax*nmax); return &y }()
	bb := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	bs := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	c := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	cc := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	cs := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	ct := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	g := func() *[]float32 { y := make([]float32, nmax*nmax); return &y }()
	w := func() *[]complex64 { y := make([]complex64, 2*nmax); return &y }()

	for in = 1; in <= len(idimL3); in++ {
		*n = idimL3[in-1]

		*ldc = *n
		if *ldc < nmax {
			*ldc++
		}
		if *ldc > nmax {
			continue
		}
		lcc = (*ldc) * (*n)

		for ik = 1; ik <= len(idimL3); ik++ {
			*k = idimL3[ik-1]
			*k2 = 2 * (*k)

			for ict = 1; ict <= len(ichtL3); ict++ {
				*trans = ichtL3[ict-1]
				if *trans == 'C' {
					continue
				}

				if *trans == 'T' {
					*ma = *k
					*na = *n
				} else {
					*ma = *n
					*na = *k
				}

				*lda = *ma
				if *lda < nmax {
					*lda++
				}
				if *lda > nmax {
					continue
				}
				laa = (*lda) * (*na)

				_ab := func() *[][]complex64 {
					arr := make([][]complex64, nmax)
					for y := range arr {
						arr[y] = make([]complex64, *na)
						for x := range arr[y] {
							arr[y][x] = (*ab)[y+x*nmax]
						}
					}
					return &arr
				}()
				cmakeGEL3(ma, na, _ab, aa, lda, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
				for _j := 0; _j < *na; _j++ {
					for _i := 0; _i < *ma; _i++ {
						(*ab)[_i+_j*nmax] = (*_ab)[_i][_j]
					}
				}

				*ldb = *lda
				lbb = laa

				if *trans == 'T' {
					_ab := func() *[][]complex64 {
						arr := make([][]complex64, nmax)
						for y := range arr {
							arr[y] = make([]complex64, *na)
							for x := range arr[y] {
								arr[y][x] = (*ab)[(*k)+y+x*nmax]
							}
						}
						return &arr
					}()
					cmakeGEL3(ma, na, _ab, bb, ldb, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					for _j := 0; _j < *na; _j++ {
						for _i := 0; _i < *ma; _i++ {
							(*ab)[_i+_j*nmax+(*k)] = (*_ab)[_i][_j]
						}
					}
				} else {
					_ab := func() *[][]complex64 {
						arr := make([][]complex64, nmax)
						for y := range arr {
							arr[y] = make([]complex64, *na)
							for x := range arr[y] {
								arr[y][x] = (*ab)[(*k)*nmax+y+x*nmax]
							}
						}
						return &arr
					}()
					cmakeGEL3(ma, na, _ab, bb, ldb, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)
					for _j := 0; _j < *na; _j++ {
						for _i := 0; _i < *ma; _i++ {
							(*ab)[_i+_j*nmax+(*k)*nmax] = (*_ab)[_i][_j]
						}
					}
				}

				for icu = 1; icu <= len(ichuL3); icu++ {
					*uplo = ichuL3[icu-1]

					for ia = 1; ia <= len(alfc64L3); ia++ {
						*alpha = alfc64L3[ia-1]

						for ib = 1; ib <= len(betc64L3); ib++ {
							*beta = betc64L3[ib-1]

							null = *n <= 0

							cmakeSYL3(uplo, n, n, c, cc, ldc, reset, zeroc64, miCbeg, mjCbeg, icCbeg, iCbeg, jCbeg)

							transs = *trans
							uplos = *uplo
							ns = *n
							ks = *k
							als = *alpha
							bls = *beta
							ldas = *lda
							ldbs = *ldb
							ldcs = *ldc
							for i = 1; i <= laa; i++ {
								(*as)[i-1] = (*aa)[i-1]
							}
							for i = 1; i <= lbb; i++ {
								(*bs)[i-1] = (*bb)[i-1]
							}
							for i = 1; i <= lcc; i++ {
								(*cs)[i-1] = (*cc)[i-1]
							}

							nc++

							_aa := cExpand(aa, na, lda)
							_bb := cExpand(bb, na, ldb)
							_cc := cExpand(cc, n, ldc)
							Csyr2k(major, uplo, trans, n, k, alpha, _aa, lda, _bb, ldb, beta, _cc, ldc)
							cReturn(_aa, aa)
							cReturn(_bb, bb)
							cReturn(_cc, cc)

							checkByte(t, nc, trans, &transs, "trans")
							checkByte(t, nc, uplo, &uplos, "uplo")
							checkInt(t, nc, n, &ns, "n")
							checkInt(t, nc, k, &ks, "k")
							checkComplex64(t, nc, alpha, &als, "alpha")
							checkComplex64(t, nc, beta, &bls, "beta")
							checkInt(t, nc, lda, &ldas, "lda")
							checkInt(t, nc, ldb, &ldbs, "ldb")
							checkInt(t, nc, ldc, &ldcs, "ldc")
							checkComplex64Array1D(t, nc, &laa, aa, as, "aa")
							checkComplex64Array1D(t, nc, &lbb, bb, bs, "bb")
							if null {
								checkComplex64Array1D(t, nc, &lcc, cc, cs, "guardband cc")
							} else {
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										ibeg = 1
										iend = j
									} else {
										ibeg = j
										iend = *n
									}
									for i = 1; i <= *ldc; i++ {
										if i < ibeg || i > iend {
											checkComplex64(t, nc, &(*cc)[i+(j-1)*(*ldc)-1], &(*cs)[i+(j-1)*(*ldc)-1], "guardband cc")
										}
									}
								}

								jjab = 1
								jc = 1
								for j = 1; j <= *n; j++ {
									if *uplo == 'U' {
										jj = 1
										*lj = j
									} else {
										jj = j
										*lj = (*n) - j + 1
									}
									_c := func() *[][]complex64 {
										arr := make([][]complex64, min(nmax, cap(*c)-(jj-1)))
										for y := range arr {
											arr[y] = make([]complex64, min(1, cap((*c)[0])-(j-1)))
											for x := range arr[y] {
												arr[y][x] = (*c)[y+jj-1][x+j-1]
											}
										}
										return &arr
									}()
									_cc := (*cc)[jc-1:]
									if *trans == 'T' {
										for i = 1; i <= *k; i++ {
											(*w)[i-1] = (*alpha) * (*ab)[(j-1)*nmax+(*k)+i-1]
											(*w)[(*k)+i-1] = (*alpha) * (*ab)[(j-1)*nmax+i-1]
										}
										_jjab := (jjab-1)*nmax + 1
										_ab := func() *[][]complex64 {
											_x := (*ab)[_jjab-1:]
											arr := make([][]complex64, nmax)
											for y := range arr {
												arr[y] = make([]complex64, *lj)
												for x := range arr[y] {
													arr[y][x] = _x[y+x*nmax]
												}
											}
											return &arr
										}()
										_w := func() *[][]complex64 {
											arr := make([][]complex64, *nmax2)
											for y := range arr {
												arr[y] = make([]complex64, 1)
												for x := range arr[y] {
													arr[y][x] = (*w)[y+x*(*nmax2)]
												}
											}
											return &arr
										}()
										cmmchTest(trans, _N, lj, onei, k2, onec64, _ab, _w, beta, _c, ct, g, &_cc, ldc, nc, "cc", t)
									} else {
										for i = 1; i <= *k; i++ {
											(*w)[i-1] = (*alpha) * (*ab)[((*k)+i-1)*nmax+j-1]
											(*w)[(*k)+i-1] = (*alpha) * (*ab)[(i-1)*nmax+j-1]
										}
										_ab := func() *[][]complex64 {
											_x := (*ab)[jj-1:]
											arr := make([][]complex64, nmax)
											for y := range arr {
												arr[y] = make([]complex64, *k2)
												for x := range arr[y] {
													arr[y][x] = _x[y+x*nmax]
												}
											}
											return &arr
										}()
										_w := func() *[][]complex64 {
											arr := make([][]complex64, *nmax2)
											for y := range arr {
												arr[y] = make([]complex64, 1)
												for x := range arr[y] {
													arr[y][x] = (*w)[y+x*(*nmax2)]
												}
											}
											return &arr
										}()
										cmmchTest(_N, _N, lj, onei, k2, onec64, _ab, _w, beta, _c, ct, g, &_cc, ldc, nc, "cc", t)
									}
									if *uplo == 'U' {
										jc += *ldc
									} else {
										jc += (*ldc) + 1
										if *trans == 'T' {
											jjab++
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	printTestsRun(tname, nc)
}

func BenchmarkCsyr2k(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	bb := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	cc := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	major := new(byte)
	*major = 'C'

	*uplo = 'L'
	*trans = 'T'
	*n = 9
	*k = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*beta = (1.30 - 1.10i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		Csyr2k(major, uplo, trans, n, k, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func BenchmarkCsyr2kFortran(b *testing.B) {
	alpha := new(complex64)
	beta := new(complex64)
	k := new(int)
	n := new(int)
	lda := new(int)
	ldb := new(int)
	ldc := new(int)
	trans := new(byte)
	uplo := new(byte)
	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	bb := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	cc := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()

	*uplo = 'L'
	*trans = 'T'
	*n = 9
	*k = 9
	*alpha = (0.70 - 0.90i)
	*lda = 10
	*ldb = 10
	*beta = (1.30 - 1.10i)
	*ldc = 10

	for i := 0; i < b.N; i++ {
		csyr2kWrapper(uplo, trans, n, k, alpha, aa, lda, bb, ldb, beta, cc, ldc)
	}
}

func TestCerrors(t *testing.T) {
	var infot *int
	var srnamt *string
	var test *bool

	alpha := new(complex64)
	beta := new(complex64)
	ralpha := new(float32)
	rbeta := new(float32)

	infot = &common.infoc.infot
	srnamt = &common.srnamc.srnamt
	test = &common.infoc.test
	*test = true

	aa := func() *[]complex64 { y := make([]complex64, nmax*nmax); return &y }()
	xx := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	yy := func() *[]complex64 { y := make([]complex64, nmax*incmax); return &y }()
	a := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	b := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()
	c := func() *[][]complex64 {
		arr := make([][]complex64, nmax)
		for u := range arr {
			arr[u] = make([]complex64, nmax)
		}
		return &arr
	}()

	*srnamt = "Cgemv"
	*infot = 1
	Cgemv(_X, _N, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Cgemv(_C, _X, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Cgemv(_C, _N, negonei, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 4
	Cgemv(_C, _N, zeroi, negonei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 7
	Cgemv(_C, _N, twoi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 9
	Cgemv(_C, _N, zeroi, zeroi, alpha, a, onei, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 12
	Cgemv(_C, _N, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Cgbmv"
	*infot = 1
	Cgbmv(_X, _N, zeroi, zeroi, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Cgbmv(_C, _X, zeroi, zeroi, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Cgbmv(_C, _N, negonei, zeroi, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 4
	Cgbmv(_C, _N, zeroi, negonei, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 5
	Cgbmv(_C, _N, zeroi, zeroi, negonei, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 6
	Cgbmv(_C, _N, twoi, zeroi, zeroi, negonei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 9
	Cgbmv(_C, _N, zeroi, zeroi, onei, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 11
	Cgbmv(_C, _N, zeroi, zeroi, zeroi, zeroi, alpha, a, onei, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 14
	Cgbmv(_C, _N, zeroi, zeroi, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Chemv"
	*infot = 1
	Chemv(_X, _U, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Chemv(_C, _X, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Chemv(_C, _U, negonei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 6
	Chemv(_C, _U, twoi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 8
	Chemv(_C, _U, zeroi, alpha, a, onei, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 11
	Chemv(_C, _U, zeroi, alpha, a, onei, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Chbmv"
	*infot = 1
	Chbmv(_X, _U, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Chbmv(_C, _X, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Chbmv(_C, _U, negonei, zeroi, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 4
	Chbmv(_C, _U, zeroi, negonei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 7
	Chbmv(_C, _U, zeroi, onei, alpha, a, onei, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 9
	Chbmv(_C, _U, zeroi, zeroi, alpha, a, onei, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 12
	Chbmv(_C, _U, zeroi, zeroi, alpha, a, onei, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Chpmv"
	*infot = 1
	Chpmv(_X, _U, zeroi, alpha, aa, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 2
	Chpmv(_C, _X, zeroi, alpha, aa, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 3
	Chpmv(_C, _U, negonei, alpha, aa, xx, onei, beta, yy, onei)
	chkxer(t)
	*infot = 7
	Chpmv(_C, _U, zeroi, alpha, aa, xx, zeroi, beta, yy, onei)
	chkxer(t)
	*infot = 10
	Chpmv(_C, _U, zeroi, alpha, aa, xx, onei, beta, yy, zeroi)
	chkxer(t)

	*srnamt = "Ctrmv"
	*infot = 1
	Ctrmv(_X, _U, _N, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 2
	Ctrmv(_C, _X, _N, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 3
	Ctrmv(_C, _U, _X, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 4
	Ctrmv(_C, _U, _N, _X, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 5
	Ctrmv(_C, _U, _N, _N, negonei, a, onei, xx, onei)
	chkxer(t)
	*infot = 7
	Ctrmv(_C, _U, _N, _N, twoi, a, onei, xx, onei)
	chkxer(t)
	*infot = 9
	Ctrmv(_C, _U, _N, _N, zeroi, a, onei, xx, zeroi)
	chkxer(t)

	*srnamt = "Ctbmv"
	*infot = 1
	Ctbmv(_X, _U, _N, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 2
	Ctbmv(_C, _X, _N, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 3
	Ctbmv(_C, _U, _X, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 4
	Ctbmv(_C, _U, _N, _X, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 5
	Ctbmv(_C, _U, _N, _N, negonei, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 6
	Ctbmv(_C, _U, _N, _N, zeroi, negonei, a, onei, xx, onei)
	chkxer(t)
	*infot = 8
	Ctbmv(_C, _U, _N, _N, zeroi, onei, a, onei, xx, onei)
	chkxer(t)
	*infot = 10
	Ctbmv(_C, _U, _N, _N, zeroi, zeroi, a, onei, xx, zeroi)
	chkxer(t)

	*srnamt = "Ctpmv"
	*infot = 1
	Ctpmv(_X, _U, _N, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 2
	Ctpmv(_C, _X, _N, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 3
	Ctpmv(_C, _U, _X, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 4
	Ctpmv(_C, _U, _N, _X, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 5
	Ctpmv(_C, _U, _N, _N, negonei, aa, xx, onei)
	chkxer(t)
	*infot = 8
	Ctpmv(_C, _U, _N, _N, zeroi, aa, xx, zeroi)
	chkxer(t)

	*srnamt = "Ctrsv"
	*infot = 1
	Ctrsv(_X, _U, _N, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 2
	Ctrsv(_C, _X, _N, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 3
	Ctrsv(_C, _U, _X, _N, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 4
	Ctrsv(_C, _U, _N, _X, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 5
	Ctrsv(_C, _U, _N, _N, negonei, a, onei, xx, onei)
	chkxer(t)
	*infot = 7
	Ctrsv(_C, _U, _N, _N, twoi, a, onei, xx, onei)
	chkxer(t)
	*infot = 9
	Ctrsv(_C, _U, _N, _N, zeroi, a, onei, xx, zeroi)
	chkxer(t)

	*srnamt = "Ctbsv"
	*infot = 1
	Ctbsv(_X, _U, _N, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 2
	Ctbsv(_C, _X, _N, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 3
	Ctbsv(_C, _U, _X, _N, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 4
	Ctbsv(_C, _U, _N, _X, zeroi, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 5
	Ctbsv(_C, _U, _N, _N, negonei, zeroi, a, onei, xx, onei)
	chkxer(t)
	*infot = 6
	Ctbsv(_C, _U, _N, _N, zeroi, negonei, a, onei, xx, onei)
	chkxer(t)
	*infot = 8
	Ctbsv(_C, _U, _N, _N, zeroi, onei, a, onei, xx, onei)
	chkxer(t)
	*infot = 10
	Ctbsv(_C, _U, _N, _N, zeroi, zeroi, a, onei, xx, zeroi)
	chkxer(t)

	*srnamt = "Ctpsv"
	*infot = 1
	Ctpsv(_X, _U, _N, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 2
	Ctpsv(_C, _X, _N, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 3
	Ctpsv(_C, _U, _X, _N, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 4
	Ctpsv(_C, _U, _N, _X, zeroi, aa, xx, onei)
	chkxer(t)
	*infot = 5
	Ctpsv(_C, _U, _N, _N, negonei, aa, xx, onei)
	chkxer(t)
	*infot = 8
	Ctpsv(_C, _U, _N, _N, zeroi, aa, xx, zeroi)
	chkxer(t)

	*srnamt = "Cgerc"
	*infot = 1
	Cgerc(_X, zeroi, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 2
	Cgerc(_C, negonei, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 3
	Cgerc(_C, zeroi, negonei, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 6
	Cgerc(_C, zeroi, zeroi, alpha, xx, zeroi, yy, onei, a, onei)
	chkxer(t)
	*infot = 8
	Cgerc(_C, zeroi, zeroi, alpha, xx, onei, yy, zeroi, a, onei)
	chkxer(t)
	*infot = 10
	Cgerc(_C, twoi, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)

	*srnamt = "Cgeru"
	*infot = 1
	Cgeru(_X, zeroi, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 2
	Cgeru(_C, negonei, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 3
	Cgeru(_C, zeroi, negonei, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 6
	Cgeru(_C, zeroi, zeroi, alpha, xx, zeroi, yy, onei, a, onei)
	chkxer(t)
	*infot = 8
	Cgeru(_C, zeroi, zeroi, alpha, xx, onei, yy, zeroi, a, onei)
	chkxer(t)
	*infot = 10
	Cgeru(_C, twoi, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)

	*srnamt = "Cher"
	*infot = 1
	Cher(_X, _U, zeroi, ralpha, xx, onei, a, onei)
	chkxer(t)
	*infot = 2
	Cher(_C, _X, zeroi, ralpha, xx, onei, a, onei)
	chkxer(t)
	*infot = 3
	Cher(_C, _U, negonei, ralpha, xx, onei, a, onei)
	chkxer(t)
	*infot = 6
	Cher(_C, _U, zeroi, ralpha, xx, zeroi, a, onei)
	chkxer(t)
	*infot = 8
	Cher(_C, _U, zeroi, ralpha, xx, onei, a, zeroi)
	chkxer(t)

	*srnamt = "Chpr"
	*infot = 1
	Chpr(_X, _U, zeroi, ralpha, xx, onei, aa)
	chkxer(t)
	*infot = 2
	Chpr(_C, _X, zeroi, ralpha, xx, onei, aa)
	chkxer(t)
	*infot = 3
	Chpr(_C, _U, negonei, ralpha, xx, onei, aa)
	chkxer(t)
	*infot = 6
	Chpr(_C, _U, zeroi, ralpha, xx, zeroi, aa)
	chkxer(t)

	*srnamt = "Cher2"
	*infot = 1
	Cher2(_X, _U, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 2
	Cher2(_C, _X, zeroi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 3
	Cher2(_C, _U, negonei, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)
	*infot = 6
	Cher2(_C, _U, zeroi, alpha, xx, zeroi, yy, onei, a, onei)
	chkxer(t)
	*infot = 8
	Cher2(_C, _U, zeroi, alpha, xx, onei, yy, zeroi, a, onei)
	chkxer(t)
	*infot = 10
	Cher2(_C, _U, twoi, alpha, xx, onei, yy, onei, a, onei)
	chkxer(t)

	*srnamt = "Chpr2"
	*infot = 1
	Chpr2(_X, _U, zeroi, alpha, xx, onei, yy, onei, aa)
	chkxer(t)
	*infot = 2
	Chpr2(_C, _X, zeroi, alpha, xx, onei, yy, onei, aa)
	chkxer(t)
	*infot = 3
	Chpr2(_C, _U, negonei, alpha, xx, onei, yy, onei, aa)
	chkxer(t)
	*infot = 6
	Chpr2(_C, _U, zeroi, alpha, xx, zeroi, yy, onei, aa)
	chkxer(t)
	*infot = 8
	Chpr2(_C, _U, zeroi, alpha, xx, onei, yy, zeroi, aa)
	chkxer(t)

	*srnamt = "Cgemm"
	*infot = 1
	Cgemm(_X, _N, _T, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Cgemm(_C, _X, _N, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Cgemm(_C, _X, _T, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Cgemm(_C, _N, _X, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Cgemm(_C, _T, _X, zeroi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Cgemm(_C, _N, _N, negonei, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Cgemm(_C, _N, _T, negonei, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Cgemm(_C, _T, _T, negonei, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Cgemm(_C, _T, _T, negonei, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Cgemm(_C, _N, _N, zeroi, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Cgemm(_C, _N, _T, zeroi, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Cgemm(_C, _T, _N, zeroi, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Cgemm(_C, _T, _T, zeroi, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 6
	Cgemm(_C, _N, _N, zeroi, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 6
	Cgemm(_C, _N, _T, zeroi, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 6
	Cgemm(_C, _T, _N, zeroi, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 6
	Cgemm(_C, _T, _T, zeroi, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 9
	Cgemm(_C, _N, _N, twoi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 9
	Cgemm(_C, _N, _T, twoi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 9
	Cgemm(_C, _T, _N, zeroi, zeroi, twoi, alpha, a, onei, b, twoi, beta, c, onei)
	chkxer(t)
	*infot = 9
	Cgemm(_C, _T, _T, zeroi, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Cgemm(_C, _N, _N, zeroi, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Cgemm(_C, _T, _N, zeroi, zeroi, twoi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Cgemm(_C, _N, _T, zeroi, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Cgemm(_C, _T, _T, zeroi, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 14
	Cgemm(_C, _N, _N, twoi, zeroi, zeroi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 14
	Cgemm(_C, _N, _T, twoi, zeroi, zeroi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 14
	Cgemm(_C, _T, _N, twoi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 14
	Cgemm(_C, _T, _T, twoi, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)

	*srnamt = "Chemm"
	*infot = 1
	Chemm(_X, _L, _U, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Chemm(_C, _X, _U, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Chemm(_C, _L, _X, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Chemm(_C, _L, _U, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Chemm(_C, _R, _U, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Chemm(_C, _L, _L, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Chemm(_C, _R, _L, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Chemm(_C, _L, _U, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Chemm(_C, _R, _U, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Chemm(_C, _L, _L, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Chemm(_C, _R, _L, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Chemm(_C, _L, _U, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Chemm(_C, _R, _U, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Chemm(_C, _L, _L, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Chemm(_C, _R, _L, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 10
	Chemm(_C, _L, _U, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	Chemm(_C, _R, _U, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	Chemm(_C, _L, _L, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	Chemm(_C, _R, _L, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 13
	Chemm(_C, _L, _U, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	Chemm(_C, _R, _U, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, onei)
	chkxer(t)
	Chemm(_C, _L, _L, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	Chemm(_C, _R, _L, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, onei)
	chkxer(t)

	*srnamt = "Csymm"
	*infot = 1
	Csymm(_X, _L, _U, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Csymm(_C, _X, _U, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Csymm(_C, _L, _X, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Csymm(_C, _L, _U, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Csymm(_C, _R, _U, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Csymm(_C, _L, _L, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Csymm(_C, _R, _L, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Csymm(_C, _L, _U, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Csymm(_C, _R, _U, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Csymm(_C, _L, _L, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Csymm(_C, _R, _L, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Csymm(_C, _L, _U, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, twoi)
	chkxer(t)
	*infot = 8
	Csymm(_C, _R, _U, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Csymm(_C, _L, _L, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, twoi)
	chkxer(t)
	*infot = 8
	Csymm(_C, _R, _L, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 10
	Csymm(_C, _L, _U, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 10
	Csymm(_C, _R, _U, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 10
	Csymm(_C, _L, _L, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 10
	Csymm(_C, _R, _L, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	*infot = 13
	Csymm(_C, _L, _U, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	*infot = 13
	Csymm(_C, _R, _U, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, onei)
	chkxer(t)
	*infot = 13
	Csymm(_C, _L, _L, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	*infot = 13
	Csymm(_C, _R, _L, twoi, zeroi, alpha, a, onei, b, twoi, beta, c, onei)
	chkxer(t)

	*srnamt = "Ctrmm"
	*infot = 1
	Ctrmm(_X, _L, _U, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 2
	Ctrmm(_C, _X, _U, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 3
	Ctrmm(_C, _L, _X, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 4
	Ctrmm(_C, _L, _U, _X, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 5
	Ctrmm(_C, _L, _U, _N, _X, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 6
	Ctrmm(_C, _L, _U, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _L, _U, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _R, _U, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _R, _U, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _L, _L, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _L, _L, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _R, _L, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _R, _L, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 7
	Ctrmm(_C, _L, _U, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _L, _U, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _R, _U, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _R, _U, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _L, _L, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _L, _L, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _R, _L, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _R, _L, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 10
	Ctrmm(_C, _L, _U, _N, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Ctrmm(_C, _L, _U, _T, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Ctrmm(_C, _R, _U, _N, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _R, _U, _T, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _L, _L, _N, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Ctrmm(_C, _L, _L, _T, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Ctrmm(_C, _R, _L, _N, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _R, _L, _T, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 12
	Ctrmm(_C, _L, _U, _N, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Ctrmm(_C, _L, _U, _T, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Ctrmm(_C, _R, _U, _N, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _R, _U, _T, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _L, _L, _N, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Ctrmm(_C, _L, _L, _T, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Ctrmm(_C, _R, _L, _N, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrmm(_C, _R, _L, _T, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)

	*srnamt = "Ctrsm"
	*infot = 1
	Ctrsm(_X, _L, _U, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 2
	Ctrsm(_C, _X, _U, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 3
	Ctrsm(_C, _L, _X, _N, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 4
	Ctrsm(_C, _L, _U, _X, _N, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 5
	Ctrsm(_C, _L, _U, _N, _X, zeroi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 6
	Ctrsm(_C, _L, _U, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _L, _U, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _R, _U, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _R, _U, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _L, _L, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _L, _L, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _R, _L, _N, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _R, _L, _T, _N, negonei, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 7
	Ctrsm(_C, _L, _U, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _L, _U, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _R, _U, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _R, _U, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _L, _L, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _L, _L, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _R, _L, _N, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _R, _L, _T, _N, zeroi, negonei, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 10
	Ctrsm(_C, _L, _U, _N, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Ctrsm(_C, _L, _U, _T, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Ctrsm(_C, _R, _U, _N, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _R, _U, _T, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _L, _L, _N, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Ctrsm(_C, _L, _L, _T, _N, twoi, zeroi, alpha, a, onei, b, twoi)
	chkxer(t)
	Ctrsm(_C, _R, _L, _N, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _R, _L, _T, _N, zeroi, twoi, alpha, a, onei, b, onei)
	chkxer(t)
	*infot = 12
	Ctrsm(_C, _L, _U, _N, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Ctrsm(_C, _L, _U, _T, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Ctrsm(_C, _R, _U, _N, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _R, _U, _T, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _L, _L, _N, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Ctrsm(_C, _L, _L, _T, _N, twoi, zeroi, alpha, a, twoi, b, onei)
	chkxer(t)
	Ctrsm(_C, _R, _L, _N, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)
	Ctrsm(_C, _R, _L, _T, _N, twoi, zeroi, alpha, a, onei, b, onei)
	chkxer(t)

	*srnamt = "Cherk"
	*infot = 1
	Cherk(_X, _U, _N, zeroi, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 2
	Cherk(_C, _X, _N, zeroi, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 3
	Cherk(_C, _U, _T, zeroi, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 4
	Cherk(_C, _U, _N, negonei, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	Cherk(_C, _U, _C, negonei, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	Cherk(_C, _L, _N, negonei, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	Cherk(_C, _L, _C, negonei, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 5
	Cherk(_C, _U, _N, zeroi, negonei, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	Cherk(_C, _U, _C, zeroi, negonei, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	Cherk(_C, _L, _N, zeroi, negonei, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	Cherk(_C, _L, _C, zeroi, negonei, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 8
	Cherk(_C, _U, _N, twoi, zeroi, ralpha, a, onei, rbeta, c, twoi)
	chkxer(t)
	Cherk(_C, _U, _C, zeroi, twoi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	Cherk(_C, _L, _N, twoi, zeroi, ralpha, a, onei, rbeta, c, twoi)
	chkxer(t)
	Cherk(_C, _L, _C, zeroi, twoi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 11
	Cherk(_C, _U, _N, twoi, zeroi, ralpha, a, twoi, rbeta, c, onei)
	chkxer(t)
	Cherk(_C, _U, _C, twoi, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)
	Cherk(_C, _L, _N, twoi, zeroi, ralpha, a, twoi, rbeta, c, onei)
	chkxer(t)
	Cherk(_C, _L, _C, twoi, zeroi, ralpha, a, onei, rbeta, c, onei)
	chkxer(t)

	*srnamt = "Csyrk"
	*infot = 1
	Csyrk(_X, _U, _N, zeroi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Csyrk(_C, _X, _N, zeroi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Csyrk(_C, _U, _X, zeroi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Csyrk(_C, _U, _N, negonei, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Csyrk(_C, _U, _T, negonei, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Csyrk(_C, _L, _N, negonei, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Csyrk(_C, _L, _T, negonei, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Csyrk(_C, _U, _N, zeroi, negonei, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Csyrk(_C, _U, _T, zeroi, negonei, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Csyrk(_C, _L, _N, zeroi, negonei, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Csyrk(_C, _L, _T, zeroi, negonei, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Csyrk(_C, _U, _N, twoi, zeroi, alpha, a, onei, beta, c, twoi)
	chkxer(t)
	Csyrk(_C, _U, _T, zeroi, twoi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Csyrk(_C, _L, _N, twoi, zeroi, alpha, a, onei, beta, c, twoi)
	chkxer(t)
	Csyrk(_C, _L, _T, zeroi, twoi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	*infot = 11
	Csyrk(_C, _U, _N, twoi, zeroi, alpha, a, twoi, beta, c, onei)
	chkxer(t)
	Csyrk(_C, _U, _T, twoi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)
	Csyrk(_C, _L, _N, twoi, zeroi, alpha, a, twoi, beta, c, onei)
	chkxer(t)
	Csyrk(_C, _L, _T, twoi, zeroi, alpha, a, onei, beta, c, onei)
	chkxer(t)

	*srnamt = "Cher2k"
	*infot = 1
	Cher2k(_X, _U, _N, zeroi, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 2
	Cher2k(_C, _X, _N, zeroi, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 3
	Cher2k(_C, _U, _T, zeroi, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 4
	Cher2k(_C, _U, _N, negonei, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	Cher2k(_C, _U, _C, negonei, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	Cher2k(_C, _L, _N, negonei, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	Cher2k(_C, _L, _C, negonei, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 5
	Cher2k(_C, _U, _N, zeroi, negonei, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	Cher2k(_C, _U, _C, zeroi, negonei, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	Cher2k(_C, _L, _N, zeroi, negonei, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	Cher2k(_C, _L, _C, zeroi, negonei, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 8
	Cher2k(_C, _U, _N, twoi, zeroi, alpha, a, onei, b, onei, rbeta, c, twoi)
	chkxer(t)
	Cher2k(_C, _U, _C, zeroi, twoi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	Cher2k(_C, _L, _N, twoi, zeroi, alpha, a, onei, b, onei, rbeta, c, twoi)
	chkxer(t)
	Cher2k(_C, _L, _C, zeroi, twoi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 10
	Cher2k(_C, _U, _N, twoi, zeroi, alpha, a, twoi, b, onei, rbeta, c, twoi)
	chkxer(t)
	Cher2k(_C, _U, _C, zeroi, twoi, alpha, a, twoi, b, onei, rbeta, c, onei)
	chkxer(t)
	Cher2k(_C, _L, _N, twoi, zeroi, alpha, a, twoi, b, onei, rbeta, c, twoi)
	chkxer(t)
	Cher2k(_C, _L, _C, zeroi, twoi, alpha, a, twoi, b, onei, rbeta, c, onei)
	chkxer(t)
	*infot = 13
	Cher2k(_C, _U, _N, twoi, zeroi, alpha, a, twoi, b, twoi, rbeta, c, onei)
	chkxer(t)
	Cher2k(_C, _U, _C, twoi, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)
	Cher2k(_C, _L, _N, twoi, zeroi, alpha, a, twoi, b, twoi, rbeta, c, onei)
	chkxer(t)
	Cher2k(_C, _L, _C, twoi, zeroi, alpha, a, onei, b, onei, rbeta, c, onei)
	chkxer(t)

	*srnamt = "Csyr2k"
	*infot = 1
	Csyr2k(_X, _U, _N, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 2
	Csyr2k(_C, _X, _N, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 3
	Csyr2k(_C, _U, _X, zeroi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 4
	Csyr2k(_C, _U, _N, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Csyr2k(_C, _U, _T, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Csyr2k(_C, _L, _N, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Csyr2k(_C, _L, _T, negonei, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 5
	Csyr2k(_C, _U, _N, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Csyr2k(_C, _U, _T, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Csyr2k(_C, _L, _N, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Csyr2k(_C, _L, _T, zeroi, negonei, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 8
	Csyr2k(_C, _U, _N, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	Csyr2k(_C, _U, _T, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Csyr2k(_C, _L, _N, twoi, zeroi, alpha, a, onei, b, onei, beta, c, twoi)
	chkxer(t)
	Csyr2k(_C, _L, _T, zeroi, twoi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 10
	Csyr2k(_C, _U, _N, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	Csyr2k(_C, _U, _T, zeroi, twoi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	Csyr2k(_C, _L, _N, twoi, zeroi, alpha, a, twoi, b, onei, beta, c, twoi)
	chkxer(t)
	Csyr2k(_C, _L, _T, zeroi, twoi, alpha, a, twoi, b, onei, beta, c, onei)
	chkxer(t)
	*infot = 13
	Csyr2k(_C, _U, _N, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	Csyr2k(_C, _U, _T, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)
	Csyr2k(_C, _L, _N, twoi, zeroi, alpha, a, twoi, b, twoi, beta, c, onei)
	chkxer(t)
	Csyr2k(_C, _L, _T, twoi, zeroi, alpha, a, onei, b, onei, beta, c, onei)
	chkxer(t)

	*test = false
	fmt.Println("\t\t\tCblas error tests completed")
}
